
TugasAkhir.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000423e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001d0  00802000  0000423e  000042d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000037c  008021d0  008021d0  000044a2  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000044a2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00004500  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005a0  00000000  00000000  00004548  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000ebe2  00000000  00000000  00004ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002b23  00000000  00000000  000136ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000a8a7  00000000  00000000  000161ed  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001248  00000000  00000000  00020a94  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000331c4  00000000  00000000  00021cdc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000070d2  00000000  00000000  00054ea0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000750  00000000  00000000  0005bf72  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00003ef7  00000000  00000000  0005c6c2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	46 c2       	rjmp	.+1164   	; 0x48e <__ctors_end>
       2:	00 00       	nop
       4:	65 c2       	rjmp	.+1226   	; 0x4d0 <__bad_interrupt>
       6:	00 00       	nop
       8:	63 c2       	rjmp	.+1222   	; 0x4d0 <__bad_interrupt>
       a:	00 00       	nop
       c:	61 c2       	rjmp	.+1218   	; 0x4d0 <__bad_interrupt>
       e:	00 00       	nop
      10:	5f c2       	rjmp	.+1214   	; 0x4d0 <__bad_interrupt>
      12:	00 00       	nop
      14:	5d c2       	rjmp	.+1210   	; 0x4d0 <__bad_interrupt>
      16:	00 00       	nop
      18:	5b c2       	rjmp	.+1206   	; 0x4d0 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	59 c2       	rjmp	.+1202   	; 0x4d0 <__bad_interrupt>
      1e:	00 00       	nop
      20:	57 c2       	rjmp	.+1198   	; 0x4d0 <__bad_interrupt>
      22:	00 00       	nop
      24:	55 c2       	rjmp	.+1194   	; 0x4d0 <__bad_interrupt>
      26:	00 00       	nop
      28:	53 c2       	rjmp	.+1190   	; 0x4d0 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	51 c2       	rjmp	.+1186   	; 0x4d0 <__bad_interrupt>
      2e:	00 00       	nop
      30:	4f c2       	rjmp	.+1182   	; 0x4d0 <__bad_interrupt>
      32:	00 00       	nop
      34:	4d c2       	rjmp	.+1178   	; 0x4d0 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 2a 14 	jmp	0x2854	; 0x2854 <__vector_14>
      3c:	49 c2       	rjmp	.+1170   	; 0x4d0 <__bad_interrupt>
      3e:	00 00       	nop
      40:	47 c2       	rjmp	.+1166   	; 0x4d0 <__bad_interrupt>
      42:	00 00       	nop
      44:	45 c2       	rjmp	.+1162   	; 0x4d0 <__bad_interrupt>
      46:	00 00       	nop
      48:	43 c2       	rjmp	.+1158   	; 0x4d0 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	41 c2       	rjmp	.+1154   	; 0x4d0 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3f c2       	rjmp	.+1150   	; 0x4d0 <__bad_interrupt>
      52:	00 00       	nop
      54:	3d c2       	rjmp	.+1146   	; 0x4d0 <__bad_interrupt>
      56:	00 00       	nop
      58:	3b c2       	rjmp	.+1142   	; 0x4d0 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	39 c2       	rjmp	.+1138   	; 0x4d0 <__bad_interrupt>
      5e:	00 00       	nop
      60:	37 c2       	rjmp	.+1134   	; 0x4d0 <__bad_interrupt>
      62:	00 00       	nop
      64:	35 c2       	rjmp	.+1130   	; 0x4d0 <__bad_interrupt>
      66:	00 00       	nop
      68:	33 c2       	rjmp	.+1126   	; 0x4d0 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	31 c2       	rjmp	.+1122   	; 0x4d0 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2f c2       	rjmp	.+1118   	; 0x4d0 <__bad_interrupt>
      72:	00 00       	nop
      74:	2d c2       	rjmp	.+1114   	; 0x4d0 <__bad_interrupt>
      76:	00 00       	nop
      78:	2b c2       	rjmp	.+1110   	; 0x4d0 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	29 c2       	rjmp	.+1106   	; 0x4d0 <__bad_interrupt>
      7e:	00 00       	nop
      80:	27 c2       	rjmp	.+1102   	; 0x4d0 <__bad_interrupt>
      82:	00 00       	nop
      84:	25 c2       	rjmp	.+1098   	; 0x4d0 <__bad_interrupt>
      86:	00 00       	nop
      88:	23 c2       	rjmp	.+1094   	; 0x4d0 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	21 c2       	rjmp	.+1090   	; 0x4d0 <__bad_interrupt>
      8e:	00 00       	nop
      90:	1f c2       	rjmp	.+1086   	; 0x4d0 <__bad_interrupt>
      92:	00 00       	nop
      94:	1d c2       	rjmp	.+1082   	; 0x4d0 <__bad_interrupt>
      96:	00 00       	nop
      98:	1b c2       	rjmp	.+1078   	; 0x4d0 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 f5 0b 	jmp	0x17ea	; 0x17ea <__vector_39>
      a0:	0c 94 27 0c 	jmp	0x184e	; 0x184e <__vector_40>
      a4:	0c 94 59 0c 	jmp	0x18b2	; 0x18b2 <__vector_41>
      a8:	0c 94 8b 0c 	jmp	0x1916	; 0x1916 <__vector_42>
      ac:	11 c2       	rjmp	.+1058   	; 0x4d0 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	0f c2       	rjmp	.+1054   	; 0x4d0 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	0d c2       	rjmp	.+1050   	; 0x4d0 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	0b c2       	rjmp	.+1046   	; 0x4d0 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	09 c2       	rjmp	.+1042   	; 0x4d0 <__bad_interrupt>
      be:	00 00       	nop
      c0:	07 c2       	rjmp	.+1038   	; 0x4d0 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	05 c2       	rjmp	.+1034   	; 0x4d0 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	03 c2       	rjmp	.+1030   	; 0x4d0 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	01 c2       	rjmp	.+1026   	; 0x4d0 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	ff c1       	rjmp	.+1022   	; 0x4d0 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	fd c1       	rjmp	.+1018   	; 0x4d0 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	fb c1       	rjmp	.+1014   	; 0x4d0 <__bad_interrupt>
      da:	00 00       	nop
      dc:	f9 c1       	rjmp	.+1010   	; 0x4d0 <__bad_interrupt>
      de:	00 00       	nop
      e0:	f7 c1       	rjmp	.+1006   	; 0x4d0 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	f5 c1       	rjmp	.+1002   	; 0x4d0 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	f3 c1       	rjmp	.+998    	; 0x4d0 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	f1 c1       	rjmp	.+994    	; 0x4d0 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	ef c1       	rjmp	.+990    	; 0x4d0 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	ed c1       	rjmp	.+986    	; 0x4d0 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	eb c1       	rjmp	.+982    	; 0x4d0 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	e9 c1       	rjmp	.+978    	; 0x4d0 <__bad_interrupt>
      fe:	00 00       	nop
     100:	e7 c1       	rjmp	.+974    	; 0x4d0 <__bad_interrupt>
     102:	00 00       	nop
     104:	e5 c1       	rjmp	.+970    	; 0x4d0 <__bad_interrupt>
     106:	00 00       	nop
     108:	e3 c1       	rjmp	.+966    	; 0x4d0 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	e1 c1       	rjmp	.+962    	; 0x4d0 <__bad_interrupt>
     10e:	00 00       	nop
     110:	df c1       	rjmp	.+958    	; 0x4d0 <__bad_interrupt>
     112:	00 00       	nop
     114:	dd c1       	rjmp	.+954    	; 0x4d0 <__bad_interrupt>
     116:	00 00       	nop
     118:	db c1       	rjmp	.+950    	; 0x4d0 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	0c 94 2d 0b 	jmp	0x165a	; 0x165a <__vector_71>
     120:	0c 94 5f 0b 	jmp	0x16be	; 0x16be <__vector_72>
     124:	0c 94 91 0b 	jmp	0x1722	; 0x1722 <__vector_73>
     128:	0c 94 c3 0b 	jmp	0x1786	; 0x1786 <__vector_74>
     12c:	d1 c1       	rjmp	.+930    	; 0x4d0 <__bad_interrupt>
     12e:	00 00       	nop
     130:	cf c1       	rjmp	.+926    	; 0x4d0 <__bad_interrupt>
     132:	00 00       	nop
     134:	cd c1       	rjmp	.+922    	; 0x4d0 <__bad_interrupt>
     136:	00 00       	nop
     138:	cb c1       	rjmp	.+918    	; 0x4d0 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	c9 c1       	rjmp	.+914    	; 0x4d0 <__bad_interrupt>
     13e:	00 00       	nop
     140:	c7 c1       	rjmp	.+910    	; 0x4d0 <__bad_interrupt>
     142:	00 00       	nop
     144:	c5 c1       	rjmp	.+906    	; 0x4d0 <__bad_interrupt>
     146:	00 00       	nop
     148:	c3 c1       	rjmp	.+902    	; 0x4d0 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	c1 c1       	rjmp	.+898    	; 0x4d0 <__bad_interrupt>
     14e:	00 00       	nop
     150:	bf c1       	rjmp	.+894    	; 0x4d0 <__bad_interrupt>
     152:	00 00       	nop
     154:	bd c1       	rjmp	.+890    	; 0x4d0 <__bad_interrupt>
     156:	00 00       	nop
     158:	bb c1       	rjmp	.+886    	; 0x4d0 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	b9 c1       	rjmp	.+882    	; 0x4d0 <__bad_interrupt>
     15e:	00 00       	nop
     160:	b7 c1       	rjmp	.+878    	; 0x4d0 <__bad_interrupt>
     162:	00 00       	nop
     164:	b5 c1       	rjmp	.+874    	; 0x4d0 <__bad_interrupt>
     166:	00 00       	nop
     168:	b3 c1       	rjmp	.+870    	; 0x4d0 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	b1 c1       	rjmp	.+866    	; 0x4d0 <__bad_interrupt>
     16e:	00 00       	nop
     170:	af c1       	rjmp	.+862    	; 0x4d0 <__bad_interrupt>
     172:	00 00       	nop
     174:	ad c1       	rjmp	.+858    	; 0x4d0 <__bad_interrupt>
     176:	00 00       	nop
     178:	ab c1       	rjmp	.+854    	; 0x4d0 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	a9 c1       	rjmp	.+850    	; 0x4d0 <__bad_interrupt>
     17e:	00 00       	nop
     180:	a7 c1       	rjmp	.+846    	; 0x4d0 <__bad_interrupt>
     182:	00 00       	nop
     184:	a5 c1       	rjmp	.+842    	; 0x4d0 <__bad_interrupt>
     186:	00 00       	nop
     188:	a3 c1       	rjmp	.+838    	; 0x4d0 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	a1 c1       	rjmp	.+834    	; 0x4d0 <__bad_interrupt>
     18e:	00 00       	nop
     190:	9f c1       	rjmp	.+830    	; 0x4d0 <__bad_interrupt>
     192:	00 00       	nop
     194:	9d c1       	rjmp	.+826    	; 0x4d0 <__bad_interrupt>
     196:	00 00       	nop
     198:	9b c1       	rjmp	.+822    	; 0x4d0 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	99 c1       	rjmp	.+818    	; 0x4d0 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	97 c1       	rjmp	.+814    	; 0x4d0 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	95 c1       	rjmp	.+810    	; 0x4d0 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	93 c1       	rjmp	.+806    	; 0x4d0 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	91 c1       	rjmp	.+802    	; 0x4d0 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	8f c1       	rjmp	.+798    	; 0x4d0 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	8d c1       	rjmp	.+794    	; 0x4d0 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	8b c1       	rjmp	.+790    	; 0x4d0 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	89 c1       	rjmp	.+786    	; 0x4d0 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	87 c1       	rjmp	.+782    	; 0x4d0 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	85 c1       	rjmp	.+778    	; 0x4d0 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	83 c1       	rjmp	.+774    	; 0x4d0 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	81 c1       	rjmp	.+770    	; 0x4d0 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	7f c1       	rjmp	.+766    	; 0x4d0 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	7d c1       	rjmp	.+762    	; 0x4d0 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	7b c1       	rjmp	.+758    	; 0x4d0 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	79 c1       	rjmp	.+754    	; 0x4d0 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	77 c1       	rjmp	.+750    	; 0x4d0 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	75 c1       	rjmp	.+746    	; 0x4d0 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	73 c1       	rjmp	.+742    	; 0x4d0 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	71 c1       	rjmp	.+738    	; 0x4d0 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	6f c1       	rjmp	.+734    	; 0x4d0 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	6d c1       	rjmp	.+730    	; 0x4d0 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	6b c1       	rjmp	.+726    	; 0x4d0 <__bad_interrupt>
	...

000001fc <__trampolines_end>:
     1fc:	00 00       	nop
     1fe:	00 00       	nop
     200:	00 00       	nop
     202:	00 20       	and	r0, r0
     204:	20 20       	and	r2, r0
     206:	20 20       	and	r2, r0
     208:	00 20       	and	r0, r0
     20a:	50 50       	subi	r21, 0x00	; 0
     20c:	50 00       	.word	0x0050	; ????
     20e:	00 00       	nop
     210:	00 50       	subi	r16, 0x00	; 0
     212:	50 f8       	bld	r5, 0
     214:	50 f8       	bld	r5, 0
     216:	50 50       	subi	r21, 0x00	; 0
     218:	20 78       	andi	r18, 0x80	; 128
     21a:	a0 70       	andi	r26, 0x00	; 0
     21c:	28 f0       	brcs	.+10     	; 0x228 <__trampolines_end+0x2c>
     21e:	20 c0       	rjmp	.+64     	; 0x260 <__trampolines_end+0x64>
     220:	c8 10       	cpse	r12, r8
     222:	20 40       	sbci	r18, 0x00	; 0
     224:	98 18       	sub	r9, r8
     226:	60 90 a0 40 	lds	r6, 0x40A0
     22a:	a8 90       	.word	0x90a8	; ????
     22c:	68 60       	ori	r22, 0x08	; 8
     22e:	20 40       	sbci	r18, 0x00	; 0
     230:	00 00       	nop
     232:	00 00       	nop
     234:	10 20       	and	r1, r0
     236:	40 40       	sbci	r20, 0x00	; 0
     238:	40 20       	and	r4, r0
     23a:	10 40       	sbci	r17, 0x00	; 0
     23c:	20 10       	cpse	r2, r0
     23e:	10 10       	cpse	r1, r0
     240:	20 40       	sbci	r18, 0x00	; 0
     242:	00 50       	subi	r16, 0x00	; 0
     244:	20 f8       	bld	r2, 0
     246:	20 50       	subi	r18, 0x00	; 0
     248:	00 00       	nop
     24a:	20 20       	and	r2, r0
     24c:	f8 20       	and	r15, r8
     24e:	20 00       	.word	0x0020	; ????
     250:	00 00       	nop
     252:	00 00       	nop
     254:	60 20       	and	r6, r0
     256:	40 00       	.word	0x0040	; ????
     258:	00 00       	nop
     25a:	f8 00       	.word	0x00f8	; ????
     25c:	00 00       	nop
     25e:	00 00       	nop
     260:	00 00       	nop
     262:	00 60       	ori	r16, 0x00	; 0
     264:	60 00       	.word	0x0060	; ????
     266:	08 10       	cpse	r0, r8
     268:	20 40       	sbci	r18, 0x00	; 0
     26a:	80 00       	.word	0x0080	; ????
     26c:	70 88       	ldd	r7, Z+16	; 0x10
     26e:	98 a8       	ldd	r9, Y+48	; 0x30
     270:	c8 88       	ldd	r12, Y+16	; 0x10
     272:	70 20       	and	r7, r0
     274:	60 20       	and	r6, r0
     276:	20 20       	and	r2, r0
     278:	20 70       	andi	r18, 0x00	; 0
     27a:	70 88       	ldd	r7, Z+16	; 0x10
     27c:	08 10       	cpse	r0, r8
     27e:	20 40       	sbci	r18, 0x00	; 0
     280:	f8 f8       	.word	0xf8f8	; ????
     282:	10 20       	and	r1, r0
     284:	10 08       	sbc	r1, r0
     286:	88 70       	andi	r24, 0x08	; 8
     288:	10 30       	cpi	r17, 0x00	; 0
     28a:	50 90 f8 10 	lds	r5, 0x10F8
     28e:	10 f8       	bld	r1, 0
     290:	80 f0       	brcs	.+32     	; 0x2b2 <__trampolines_end+0xb6>
     292:	08 08       	sbc	r0, r8
     294:	88 70       	andi	r24, 0x08	; 8
     296:	30 40       	sbci	r19, 0x00	; 0
     298:	80 f0       	brcs	.+32     	; 0x2ba <__trampolines_end+0xbe>
     29a:	88 88       	ldd	r8, Y+16	; 0x10
     29c:	70 f8       	bld	r7, 0
     29e:	08 10       	cpse	r0, r8
     2a0:	20 40       	sbci	r18, 0x00	; 0
     2a2:	40 40       	sbci	r20, 0x00	; 0
     2a4:	70 88       	ldd	r7, Z+16	; 0x10
     2a6:	88 70       	andi	r24, 0x08	; 8
     2a8:	88 88       	ldd	r8, Y+16	; 0x10
     2aa:	70 70       	andi	r23, 0x00	; 0
     2ac:	88 88       	ldd	r8, Y+16	; 0x10
     2ae:	78 08       	sbc	r7, r8
     2b0:	10 60       	ori	r17, 0x00	; 0
     2b2:	00 60       	ori	r16, 0x00	; 0
     2b4:	60 00       	.word	0x0060	; ????
     2b6:	60 60       	ori	r22, 0x00	; 0
     2b8:	00 00       	nop
     2ba:	60 60       	ori	r22, 0x00	; 0
     2bc:	00 60       	ori	r16, 0x00	; 0
     2be:	20 40       	sbci	r18, 0x00	; 0
     2c0:	08 10       	cpse	r0, r8
     2c2:	20 40       	sbci	r18, 0x00	; 0
     2c4:	20 10       	cpse	r2, r0
     2c6:	08 00       	.word	0x0008	; ????
     2c8:	00 f8       	bld	r0, 0
     2ca:	00 f8       	bld	r0, 0
     2cc:	00 00       	nop
     2ce:	80 40       	sbci	r24, 0x00	; 0
     2d0:	20 10       	cpse	r2, r0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	80 70       	andi	r24, 0x00	; 0
     2d6:	88 08       	sbc	r8, r8
     2d8:	10 20       	and	r1, r0
     2da:	00 20       	and	r0, r0
     2dc:	70 88       	ldd	r7, Z+16	; 0x10
     2de:	08 68       	ori	r16, 0x88	; 136
     2e0:	a8 a8       	ldd	r10, Y+48	; 0x30
     2e2:	70 70       	andi	r23, 0x00	; 0
     2e4:	88 88       	ldd	r8, Y+16	; 0x10
     2e6:	88 f8       	.word	0xf888	; ????
     2e8:	88 88       	ldd	r8, Y+16	; 0x10
     2ea:	f0 88       	ldd	r15, Z+16	; 0x10
     2ec:	88 f0       	brcs	.+34     	; 0x310 <__trampolines_end+0x114>
     2ee:	88 88       	ldd	r8, Y+16	; 0x10
     2f0:	f0 70       	andi	r31, 0x00	; 0
     2f2:	88 80       	ld	r8, Y
     2f4:	80 80       	ld	r8, Z
     2f6:	88 70       	andi	r24, 0x08	; 8
     2f8:	e0 90 88 88 	lds	r14, 0x8888
     2fc:	88 90       	.word	0x9088	; ????
     2fe:	e0 f8       	bld	r14, 0
     300:	80 80       	ld	r8, Z
     302:	f0 80       	ld	r15, Z
     304:	80 f8       	bld	r8, 0
     306:	f8 80       	ld	r15, Y
     308:	80 e0       	ldi	r24, 0x00	; 0
     30a:	80 80       	ld	r8, Z
     30c:	80 70       	andi	r24, 0x00	; 0
     30e:	88 80       	ld	r8, Y
     310:	80 98       	cbi	0x10, 0	; 16
     312:	88 70       	andi	r24, 0x08	; 8
     314:	88 88       	ldd	r8, Y+16	; 0x10
     316:	88 f8       	.word	0xf888	; ????
     318:	88 88       	ldd	r8, Y+16	; 0x10
     31a:	88 70       	andi	r24, 0x08	; 8
     31c:	20 20       	and	r2, r0
     31e:	20 20       	and	r2, r0
     320:	20 70       	andi	r18, 0x00	; 0
     322:	38 10       	cpse	r3, r8
     324:	10 10       	cpse	r1, r0
     326:	10 90 60 88 	lds	r1, 0x8860
     32a:	90 a0       	ldd	r9, Z+32	; 0x20
     32c:	c0 a0       	ldd	r12, Z+32	; 0x20
     32e:	90 88       	ldd	r9, Z+16	; 0x10
     330:	80 80       	ld	r8, Z
     332:	80 80       	ld	r8, Z
     334:	80 80       	ld	r8, Z
     336:	f8 88       	ldd	r15, Y+16	; 0x10
     338:	d8 a8       	ldd	r13, Y+48	; 0x30
     33a:	88 88       	ldd	r8, Y+16	; 0x10
     33c:	88 88       	ldd	r8, Y+16	; 0x10
     33e:	88 88       	ldd	r8, Y+16	; 0x10
     340:	c8 a8       	ldd	r12, Y+48	; 0x30
     342:	98 88       	ldd	r9, Y+16	; 0x10
     344:	88 70       	andi	r24, 0x08	; 8
     346:	88 88       	ldd	r8, Y+16	; 0x10
     348:	88 88       	ldd	r8, Y+16	; 0x10
     34a:	88 70       	andi	r24, 0x08	; 8
     34c:	f0 88       	ldd	r15, Z+16	; 0x10
     34e:	88 f0       	brcs	.+34     	; 0x372 <__trampolines_end+0x176>
     350:	80 80       	ld	r8, Z
     352:	80 70       	andi	r24, 0x00	; 0
     354:	88 88       	ldd	r8, Y+16	; 0x10
     356:	88 a8       	ldd	r8, Y+48	; 0x30
     358:	90 68       	ori	r25, 0x80	; 128
     35a:	f0 88       	ldd	r15, Z+16	; 0x10
     35c:	88 f0       	brcs	.+34     	; 0x380 <__trampolines_end+0x184>
     35e:	a0 90 88 78 	lds	r10, 0x7888
     362:	80 80       	ld	r8, Z
     364:	70 08       	sbc	r7, r0
     366:	08 f0       	brcs	.+2      	; 0x36a <__trampolines_end+0x16e>
     368:	f8 20       	and	r15, r8
     36a:	20 20       	and	r2, r0
     36c:	20 20       	and	r2, r0
     36e:	20 88       	ldd	r2, Z+16	; 0x10
     370:	88 88       	ldd	r8, Y+16	; 0x10
     372:	88 88       	ldd	r8, Y+16	; 0x10
     374:	88 70       	andi	r24, 0x08	; 8
     376:	88 88       	ldd	r8, Y+16	; 0x10
     378:	88 88       	ldd	r8, Y+16	; 0x10
     37a:	88 50       	subi	r24, 0x08	; 8
     37c:	20 88       	ldd	r2, Z+16	; 0x10
     37e:	88 88       	ldd	r8, Y+16	; 0x10
     380:	a8 a8       	ldd	r10, Y+48	; 0x30
     382:	d8 88       	ldd	r13, Y+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	50 20       	and	r5, r0
     388:	50 88       	ldd	r5, Z+16	; 0x10
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 50       	subi	r24, 0x08	; 8
     38e:	20 20       	and	r2, r0
     390:	20 20       	and	r2, r0
     392:	f8 08       	sbc	r15, r8
     394:	10 20       	and	r1, r0
     396:	40 80       	ld	r4, Z
     398:	f8 38       	cpi	r31, 0x88	; 136
     39a:	20 20       	and	r2, r0
     39c:	20 20       	and	r2, r0
     39e:	20 38       	cpi	r18, 0x80	; 128
     3a0:	00 80       	ld	r0, Z
     3a2:	40 20       	and	r4, r0
     3a4:	10 08       	sbc	r1, r0
     3a6:	00 e0       	ldi	r16, 0x00	; 0
     3a8:	20 20       	and	r2, r0
     3aa:	20 20       	and	r2, r0
     3ac:	20 e0       	ldi	r18, 0x00	; 0
     3ae:	20 50       	subi	r18, 0x00	; 0
     3b0:	88 00       	.word	0x0088	; ????
	...
     3ba:	00 f8       	bld	r0, 0
     3bc:	40 20       	and	r4, r0
     3be:	10 00       	.word	0x0010	; ????
     3c0:	00 00       	nop
     3c2:	00 00       	nop
     3c4:	00 70       	andi	r16, 0x00	; 0
     3c6:	08 78       	andi	r16, 0x88	; 136
     3c8:	88 78       	andi	r24, 0x88	; 136
     3ca:	80 80       	ld	r8, Z
     3cc:	b0 c8       	rjmp	.-3744   	; 0xfffff52e <__eeprom_end+0xff7ef52e>
     3ce:	88 88       	ldd	r8, Y+16	; 0x10
     3d0:	f0 00       	.word	0x00f0	; ????
     3d2:	00 70       	andi	r16, 0x00	; 0
     3d4:	80 80       	ld	r8, Z
     3d6:	88 70       	andi	r24, 0x08	; 8
     3d8:	08 08       	sbc	r0, r8
     3da:	68 98       	cbi	0x0d, 0	; 13
     3dc:	88 88       	ldd	r8, Y+16	; 0x10
     3de:	78 00       	.word	0x0078	; ????
     3e0:	00 70       	andi	r16, 0x00	; 0
     3e2:	88 f8       	.word	0xf888	; ????
     3e4:	80 70       	andi	r24, 0x00	; 0
     3e6:	30 48       	sbci	r19, 0x80	; 128
     3e8:	40 e0       	ldi	r20, 0x00	; 0
     3ea:	40 40       	sbci	r20, 0x00	; 0
     3ec:	40 00       	.word	0x0040	; ????
     3ee:	00 78       	andi	r16, 0x80	; 128
     3f0:	88 78       	andi	r24, 0x88	; 136
     3f2:	08 30       	cpi	r16, 0x08	; 8
     3f4:	80 80       	ld	r8, Z
     3f6:	b0 c8       	rjmp	.-3744   	; 0xfffff558 <__eeprom_end+0xff7ef558>
     3f8:	88 88       	ldd	r8, Y+16	; 0x10
     3fa:	88 20       	and	r8, r8
     3fc:	00 60       	ori	r16, 0x00	; 0
     3fe:	20 20       	and	r2, r0
     400:	20 70       	andi	r18, 0x00	; 0
     402:	10 00       	.word	0x0010	; ????
     404:	30 10       	cpse	r3, r0
     406:	10 90 60 40 	lds	r1, 0x4060
     40a:	40 48       	sbci	r20, 0x80	; 128
     40c:	50 60       	ori	r21, 0x00	; 0
     40e:	50 48       	sbci	r21, 0x80	; 128
     410:	60 20       	and	r6, r0
     412:	20 20       	and	r2, r0
     414:	20 20       	and	r2, r0
     416:	70 00       	.word	0x0070	; ????
     418:	00 d0       	rcall	.+0      	; 0x41a <__trampolines_end+0x21e>
     41a:	a8 a8       	ldd	r10, Y+48	; 0x30
     41c:	88 88       	ldd	r8, Y+16	; 0x10
     41e:	00 00       	nop
     420:	b0 c8       	rjmp	.-3744   	; 0xfffff582 <__eeprom_end+0xff7ef582>
     422:	88 88       	ldd	r8, Y+16	; 0x10
     424:	88 00       	.word	0x0088	; ????
     426:	00 70       	andi	r16, 0x00	; 0
     428:	88 88       	ldd	r8, Y+16	; 0x10
     42a:	88 70       	andi	r24, 0x08	; 8
     42c:	00 00       	nop
     42e:	f0 88       	ldd	r15, Z+16	; 0x10
     430:	f0 80       	ld	r15, Z
     432:	80 00       	.word	0x0080	; ????
     434:	00 68       	ori	r16, 0x80	; 128
     436:	98 78       	andi	r25, 0x88	; 136
     438:	08 08       	sbc	r0, r8
     43a:	00 00       	nop
     43c:	b0 c8       	rjmp	.-3744   	; 0xfffff59e <__eeprom_end+0xff7ef59e>
     43e:	80 80       	ld	r8, Z
     440:	80 00       	.word	0x0080	; ????
     442:	00 70       	andi	r16, 0x00	; 0
     444:	80 70       	andi	r24, 0x00	; 0
     446:	08 f0       	brcs	.+2      	; 0x44a <__trampolines_end+0x24e>
     448:	40 40       	sbci	r20, 0x00	; 0
     44a:	e0 40       	sbci	r30, 0x00	; 0
     44c:	40 48       	sbci	r20, 0x80	; 128
     44e:	30 00       	.word	0x0030	; ????
     450:	00 88       	ldd	r0, Z+16	; 0x10
     452:	88 88       	ldd	r8, Y+16	; 0x10
     454:	98 68       	ori	r25, 0x88	; 136
     456:	00 00       	nop
     458:	88 88       	ldd	r8, Y+16	; 0x10
     45a:	88 50       	subi	r24, 0x08	; 8
     45c:	20 00       	.word	0x0020	; ????
     45e:	00 88       	ldd	r0, Z+16	; 0x10
     460:	88 a8       	ldd	r8, Y+48	; 0x30
     462:	a8 50       	subi	r26, 0x08	; 8
     464:	00 00       	nop
     466:	88 50       	subi	r24, 0x08	; 8
     468:	20 50       	subi	r18, 0x00	; 0
     46a:	88 00       	.word	0x0088	; ????
     46c:	00 88       	ldd	r0, Z+16	; 0x10
     46e:	88 78       	andi	r24, 0x88	; 136
     470:	08 70       	andi	r16, 0x08	; 8
     472:	00 00       	nop
     474:	f8 10       	cpse	r15, r8
     476:	20 40       	sbci	r18, 0x00	; 0
     478:	f8 10       	cpse	r15, r8
     47a:	20 20       	and	r2, r0
     47c:	40 20       	and	r4, r0
     47e:	20 10       	cpse	r2, r0
     480:	20 20       	and	r2, r0
     482:	20 20       	and	r2, r0
     484:	20 20       	and	r2, r0
     486:	20 40       	sbci	r18, 0x00	; 0
     488:	20 20       	and	r2, r0
     48a:	10 20       	and	r1, r0
     48c:	20 40       	sbci	r18, 0x00	; 0

0000048e <__ctors_end>:
     48e:	11 24       	eor	r1, r1
     490:	1f be       	out	0x3f, r1	; 63
     492:	cf ef       	ldi	r28, 0xFF	; 255
     494:	cd bf       	out	0x3d, r28	; 61
     496:	df e5       	ldi	r29, 0x5F	; 95
     498:	de bf       	out	0x3e, r29	; 62
     49a:	00 e0       	ldi	r16, 0x00	; 0
     49c:	0c bf       	out	0x3c, r16	; 60

0000049e <__do_copy_data>:
     49e:	11 e2       	ldi	r17, 0x21	; 33
     4a0:	a0 e0       	ldi	r26, 0x00	; 0
     4a2:	b0 e2       	ldi	r27, 0x20	; 32
     4a4:	ee e3       	ldi	r30, 0x3E	; 62
     4a6:	f2 e4       	ldi	r31, 0x42	; 66
     4a8:	00 e0       	ldi	r16, 0x00	; 0
     4aa:	0b bf       	out	0x3b, r16	; 59
     4ac:	02 c0       	rjmp	.+4      	; 0x4b2 <__do_copy_data+0x14>
     4ae:	07 90       	elpm	r0, Z+
     4b0:	0d 92       	st	X+, r0
     4b2:	a0 3d       	cpi	r26, 0xD0	; 208
     4b4:	b1 07       	cpc	r27, r17
     4b6:	d9 f7       	brne	.-10     	; 0x4ae <__do_copy_data+0x10>

000004b8 <__do_clear_bss>:
     4b8:	25 e2       	ldi	r18, 0x25	; 37
     4ba:	a0 ed       	ldi	r26, 0xD0	; 208
     4bc:	b1 e2       	ldi	r27, 0x21	; 33
     4be:	01 c0       	rjmp	.+2      	; 0x4c2 <.do_clear_bss_start>

000004c0 <.do_clear_bss_loop>:
     4c0:	1d 92       	st	X+, r1

000004c2 <.do_clear_bss_start>:
     4c2:	ac 34       	cpi	r26, 0x4C	; 76
     4c4:	b2 07       	cpc	r27, r18
     4c6:	e1 f7       	brne	.-8      	; 0x4c0 <.do_clear_bss_loop>
     4c8:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <main>
     4cc:	0c 94 1d 21 	jmp	0x423a	; 0x423a <_exit>

000004d0 <__bad_interrupt>:
     4d0:	97 cd       	rjmp	.-1234   	; 0x0 <__vectors>

000004d2 <_1101010101_>:

#if ((_STATIC_PORT_PIN_CONF_ == 1) && (QTOUCH_SNS_PORT_COUNT >= 1))

GLOBAL_FUNCTION _1101010101_
_1101010101_:
    sts	CONCAT( PORT, SNS1, _DIRCLR ), p_1
     4d2:	80 93 a2 06 	sts	0x06A2, r24
    sts	CONCAT( PORT, SNSK1, _DIRCLR ), p_2
     4d6:	60 93 a2 06 	sts	0x06A2, r22
    sts	CONCAT( PORT, SNS1, _OUTSET), p_1
     4da:	80 93 a5 06 	sts	0x06A5, r24
    sts	CONCAT( PORT, SNSK1, _OUTCLR), p_2    
     4de:	60 93 a6 06 	sts	0x06A6, r22
    sts	CONCAT( PORT, SNSK1, _DIRSET), p_2   
     4e2:	60 93 a1 06 	sts	0x06A1, r22
    ret
     4e6:	08 95       	ret

000004e8 <_1101010111_>:


GLOBAL_FUNCTION _1101010111_
_1101010111_:
    push r19
     4e8:	3f 93       	push	r19
    sts	CONCAT( PORT, SNSK1, _DIRCLR), p_2
     4ea:	60 93 a2 06 	sts	0x06A2, r22
    sts	CONCAT( PORT, SNS1, _DIRSET), p_1
     4ee:	80 93 a1 06 	sts	0x06A1, r24
    _10100011_
    _01101001_
    _00011001_
    _00011001_
#endif
    sts	CONCAT( PORT, SNS1, _DIRCLR ), p_1
     4f2:	80 93 a2 06 	sts	0x06A2, r24
    sts	CONCAT( PORT, SNSK1, _DIRSET ), p_2 
     4f6:	60 93 a1 06 	sts	0x06A1, r22
    pop  r19
     4fa:	3f 91       	pop	r19
    lds	r_v, CONCAT(PORT, SNS1, _IN )
     4fc:	80 91 a8 06 	lds	r24, 0x06A8
    and	r_v, p_3
     500:	84 23       	and	r24, r20
    ret
     502:	08 95       	ret

00000504 <_1101010110_>:

GLOBAL_FUNCTION _1101010110_
_1101010110_:
    sts	CONCAT( PORT, SNS1, _OUTCLR), p_1
     504:	80 93 a6 06 	sts	0x06A6, r24
    sts	CONCAT( PORT, SNS1, _DIRSET), p_1
     508:	80 93 a1 06 	sts	0x06A1, r24
    ret
     50c:	08 95       	ret

0000050e <burst_1_1_10_0_1>:
     50e:	a1 e0       	ldi	r26, 0x01	; 1
     510:	b0 e0       	ldi	r27, 0x00	; 0
     512:	ed e8       	ldi	r30, 0x8D	; 141
     514:	f2 e0       	ldi	r31, 0x02	; 2
     516:	0c 94 fb 1c 	jmp	0x39f6	; 0x39f6 <__prologue_saves__+0xc>
     51a:	e8 2f       	mov	r30, r24
     51c:	0f b7       	in	r16, 0x3f	; 63
     51e:	00 78       	andi	r16, 0x80	; 128
     520:	19 82       	std	Y+1, r1	; 0x01
     522:	80 91 d1 21 	lds	r24, 0x21D1
     526:	81 30       	cpi	r24, 0x01	; 1
     528:	19 f0       	breq	.+6      	; 0x530 <burst_1_1_10_0_1+0x22>
     52a:	81 e0       	ldi	r24, 0x01	; 1
     52c:	80 93 d1 21 	sts	0x21D1, r24
     530:	ce 2e       	mov	r12, r30
     532:	dd 24       	eor	r13, r13
     534:	f6 01       	movw	r30, r12
     536:	ed 5e       	subi	r30, 0xED	; 237
     538:	fd 4d       	sbci	r31, 0xDD	; 221
     53a:	b0 80       	ld	r11, Z
     53c:	f6 01       	movw	r30, r12
     53e:	e9 5e       	subi	r30, 0xE9	; 233
     540:	fd 4d       	sbci	r31, 0xDD	; 221
     542:	a0 80       	ld	r10, Z
     544:	f8 94       	cli
     546:	bb 20       	and	r11, r11
     548:	09 f4       	brne	.+2      	; 0x54c <burst_1_1_10_0_1+0x3e>
     54a:	aa c0       	rjmp	.+340    	; 0x6a0 <burst_1_1_10_0_1+0x192>
     54c:	8b 2d       	mov	r24, r11
     54e:	da df       	rcall	.-76     	; 0x504 <_1101010110_>
     550:	8b 2d       	mov	r24, r11
     552:	6a 2d       	mov	r22, r10
     554:	be df       	rcall	.-132    	; 0x4d2 <_1101010101_>
     556:	1b 2d       	mov	r17, r11
     558:	ee 24       	eor	r14, r14
     55a:	ff 24       	eor	r15, r15
     55c:	60 e0       	ldi	r22, 0x00	; 0
     55e:	81 2c       	mov	r8, r1
     560:	30 e2       	ldi	r19, 0x20	; 32
     562:	93 2e       	mov	r9, r19
     564:	f5 fe       	sbrs	r15, 5
     566:	07 c0       	rjmp	.+14     	; 0x576 <burst_1_1_10_0_1+0x68>
     568:	90 91 14 22 	lds	r25, 0x2214
     56c:	80 91 13 22 	lds	r24, 0x2213
     570:	98 2b       	or	r25, r24
     572:	19 f5       	brne	.+70     	; 0x5ba <burst_1_1_10_0_1+0xac>
     574:	35 c0       	rjmp	.+106    	; 0x5e0 <burst_1_1_10_0_1+0xd2>
     576:	8f b7       	in	r24, 0x3f	; 63
     578:	80 2b       	or	r24, r16
     57a:	8f bf       	out	0x3f, r24	; 63
     57c:	00 00       	nop
     57e:	f8 94       	cli
     580:	8b 2d       	mov	r24, r11
     582:	6a 2d       	mov	r22, r10
     584:	41 2f       	mov	r20, r17
     586:	b0 df       	rcall	.-160    	; 0x4e8 <_1101010111_>
     588:	68 2f       	mov	r22, r24
     58a:	08 94       	sec
     58c:	e1 1c       	adc	r14, r1
     58e:	f1 1c       	adc	r15, r1
     590:	80 91 00 20 	lds	r24, 0x2000
     594:	8f 5f       	subi	r24, 0xFF	; 255
     596:	80 93 00 20 	sts	0x2000, r24
     59a:	82 30       	cpi	r24, 0x02	; 2
     59c:	30 f0       	brcs	.+12     	; 0x5aa <burst_1_1_10_0_1+0x9c>
     59e:	82 30       	cpi	r24, 0x02	; 2
     5a0:	21 f0       	breq	.+8      	; 0x5aa <burst_1_1_10_0_1+0x9c>
     5a2:	83 30       	cpi	r24, 0x03	; 3
     5a4:	11 f0       	breq	.+4      	; 0x5aa <burst_1_1_10_0_1+0x9c>
     5a6:	10 92 00 20 	sts	0x2000, r1
     5aa:	66 23       	and	r22, r22
     5ac:	d9 f2       	breq	.-74     	; 0x564 <burst_1_1_10_0_1+0x56>
     5ae:	20 91 14 22 	lds	r18, 0x2214
     5b2:	80 91 13 22 	lds	r24, 0x2213
     5b6:	28 2b       	or	r18, r24
     5b8:	15 c0       	rjmp	.+42     	; 0x5e4 <burst_1_1_10_0_1+0xd6>
     5ba:	41 2f       	mov	r20, r17
     5bc:	80 e0       	ldi	r24, 0x00	; 0
     5be:	40 ff       	sbrs	r20, 0
     5c0:	09 c0       	rjmp	.+18     	; 0x5d4 <burst_1_1_10_0_1+0xc6>
     5c2:	e8 2f       	mov	r30, r24
     5c4:	f0 e0       	ldi	r31, 0x00	; 0
     5c6:	ee 0f       	add	r30, r30
     5c8:	ff 1f       	adc	r31, r31
     5ca:	e4 52       	subi	r30, 0x24	; 36
     5cc:	fe 4d       	sbci	r31, 0xDE	; 222
     5ce:	80 82       	st	Z, r8
     5d0:	91 82       	std	Z+1, r9	; 0x01
     5d2:	01 c0       	rjmp	.+2      	; 0x5d6 <burst_1_1_10_0_1+0xc8>
     5d4:	90 fd       	sbrc	r25, 0
     5d6:	8f 5f       	subi	r24, 0xFF	; 255
     5d8:	96 95       	lsr	r25
     5da:	46 95       	lsr	r20
     5dc:	99 23       	and	r25, r25
     5de:	79 f7       	brne	.-34     	; 0x5be <burst_1_1_10_0_1+0xb0>
     5e0:	10 e0       	ldi	r17, 0x00	; 0
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	8f b7       	in	r24, 0x3f	; 63
     5e6:	80 2b       	or	r24, r16
     5e8:	8f bf       	out	0x3f, r24	; 63
     5ea:	10 92 d2 21 	sts	0x21D2, r1
     5ee:	22 23       	and	r18, r18
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <burst_1_1_10_0_1+0xe6>
     5f2:	3f c0       	rjmp	.+126    	; 0x672 <burst_1_1_10_0_1+0x164>
     5f4:	11 23       	and	r17, r17
     5f6:	09 f4       	brne	.+2      	; 0x5fa <burst_1_1_10_0_1+0xec>
     5f8:	3c c0       	rjmp	.+120    	; 0x672 <burst_1_1_10_0_1+0x164>
     5fa:	30 91 18 22 	lds	r19, 0x2218
     5fe:	80 91 17 22 	lds	r24, 0x2217
     602:	38 2b       	or	r19, r24
     604:	56 2f       	mov	r21, r22
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	80 e0       	ldi	r24, 0x00	; 0
     60a:	70 e0       	ldi	r23, 0x00	; 0
     60c:	40 e0       	ldi	r20, 0x00	; 0
     60e:	23 c0       	rjmp	.+70     	; 0x656 <burst_1_1_10_0_1+0x148>
     610:	50 fd       	sbrc	r21, 0
     612:	17 c0       	rjmp	.+46     	; 0x642 <burst_1_1_10_0_1+0x134>
     614:	19 c0       	rjmp	.+50     	; 0x648 <burst_1_1_10_0_1+0x13a>
     616:	30 ff       	sbrs	r19, 0
     618:	13 c0       	rjmp	.+38     	; 0x640 <burst_1_1_10_0_1+0x132>
     61a:	98 17       	cp	r25, r24
     61c:	81 f4       	brne	.+32     	; 0x63e <burst_1_1_10_0_1+0x130>
     61e:	e4 2f       	mov	r30, r20
     620:	f0 e0       	ldi	r31, 0x00	; 0
     622:	ee 0f       	add	r30, r30
     624:	ff 1f       	adc	r31, r31
     626:	e4 52       	subi	r30, 0x24	; 36
     628:	fe 4d       	sbci	r31, 0xDE	; 222
     62a:	e0 82       	st	Z, r14
     62c:	f1 82       	std	Z+1, r15	; 0x01
     62e:	85 2f       	mov	r24, r21
     630:	8e 7f       	andi	r24, 0xFE	; 254
     632:	19 f4       	brne	.+6      	; 0x63a <burst_1_1_10_0_1+0x12c>
     634:	89 2f       	mov	r24, r25
     636:	71 e0       	ldi	r23, 0x01	; 1
     638:	08 c0       	rjmp	.+16     	; 0x64a <burst_1_1_10_0_1+0x13c>
     63a:	89 2f       	mov	r24, r25
     63c:	06 c0       	rjmp	.+12     	; 0x64a <burst_1_1_10_0_1+0x13c>
     63e:	8f 5f       	subi	r24, 0xFF	; 255
     640:	36 95       	lsr	r19
     642:	33 23       	and	r19, r19
     644:	41 f7       	brne	.-48     	; 0x616 <burst_1_1_10_0_1+0x108>
     646:	01 c0       	rjmp	.+2      	; 0x64a <burst_1_1_10_0_1+0x13c>
     648:	20 fd       	sbrc	r18, 0
     64a:	9f 5f       	subi	r25, 0xFF	; 255
     64c:	20 fd       	sbrc	r18, 0
     64e:	4f 5f       	subi	r20, 0xFF	; 255
     650:	56 95       	lsr	r21
     652:	26 95       	lsr	r18
     654:	11 f0       	breq	.+4      	; 0x65a <burst_1_1_10_0_1+0x14c>
     656:	55 23       	and	r21, r21
     658:	d9 f6       	brne	.-74     	; 0x610 <burst_1_1_10_0_1+0x102>
     65a:	40 93 d2 21 	sts	0x21D2, r20
     65e:	60 95       	com	r22
     660:	16 23       	and	r17, r22
     662:	71 30       	cpi	r23, 0x01	; 1
     664:	21 f4       	brne	.+8      	; 0x66e <burst_1_1_10_0_1+0x160>
     666:	11 23       	and	r17, r17
     668:	11 f4       	brne	.+4      	; 0x66e <burst_1_1_10_0_1+0x160>
     66a:	ee 24       	eor	r14, r14
     66c:	ff 24       	eor	r15, r15
     66e:	60 e0       	ldi	r22, 0x00	; 0
     670:	13 c0       	rjmp	.+38     	; 0x698 <burst_1_1_10_0_1+0x18a>
     672:	80 91 14 22 	lds	r24, 0x2214
     676:	90 91 13 22 	lds	r25, 0x2213
     67a:	89 2b       	or	r24, r25
     67c:	89 83       	std	Y+1, r24	; 0x01
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	06 c0       	rjmp	.+12     	; 0x68e <burst_1_1_10_0_1+0x180>
     682:	89 81       	ldd	r24, Y+1	; 0x01
     684:	80 fd       	sbrc	r24, 0
     686:	9f 5f       	subi	r25, 0xFF	; 255
     688:	89 81       	ldd	r24, Y+1	; 0x01
     68a:	86 95       	lsr	r24
     68c:	89 83       	std	Y+1, r24	; 0x01
     68e:	89 81       	ldd	r24, Y+1	; 0x01
     690:	88 23       	and	r24, r24
     692:	b9 f7       	brne	.-18     	; 0x682 <burst_1_1_10_0_1+0x174>
     694:	90 93 d2 21 	sts	0x21D2, r25
     698:	f8 94       	cli
     69a:	11 23       	and	r17, r17
     69c:	09 f0       	breq	.+2      	; 0x6a0 <burst_1_1_10_0_1+0x192>
     69e:	62 cf       	rjmp	.-316    	; 0x564 <burst_1_1_10_0_1+0x56>
     6a0:	83 e1       	ldi	r24, 0x13	; 19
     6a2:	92 e2       	ldi	r25, 0x22	; 34
     6a4:	c8 0e       	add	r12, r24
     6a6:	d9 1e       	adc	r13, r25
     6a8:	f6 01       	movw	r30, r12
     6aa:	80 81       	ld	r24, Z
     6ac:	2b df       	rcall	.-426    	; 0x504 <_1101010110_>
     6ae:	10 92 d0 21 	sts	0x21D0, r1
     6b2:	8f b7       	in	r24, 0x3f	; 63
     6b4:	08 2b       	or	r16, r24
     6b6:	0f bf       	out	0x3f, r16	; 63
     6b8:	21 96       	adiw	r28, 0x01	; 1
     6ba:	ec e0       	ldi	r30, 0x0C	; 12
     6bc:	0c 94 14 1d 	jmp	0x3a28	; 0x3a28 <__epilogue_restores__+0xc>

000006c0 <qt_get_library_sig>:
     6c0:	fc 01       	movw	r30, r24
     6c2:	80 e2       	ldi	r24, 0x20	; 32
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	80 83       	st	Z, r24
     6c8:	91 83       	std	Z+1, r25	; 0x01
     6ca:	12 82       	std	Z+2, r1	; 0x02
     6cc:	13 82       	std	Z+3, r1	; 0x03
     6ce:	80 e4       	ldi	r24, 0x40	; 64
     6d0:	94 e0       	ldi	r25, 0x04	; 4
     6d2:	84 83       	std	Z+4, r24	; 0x04
     6d4:	95 83       	std	Z+5, r25	; 0x05
     6d6:	08 95       	ret

000006d8 <qt_enable_key>:
     6d8:	90 91 0d 22 	lds	r25, 0x220D
     6dc:	a9 2f       	mov	r26, r25
     6de:	b0 e0       	ldi	r27, 0x00	; 0
     6e0:	fd 01       	movw	r30, r26
     6e2:	ee 0f       	add	r30, r30
     6e4:	ff 1f       	adc	r31, r31
     6e6:	ea 0f       	add	r30, r26
     6e8:	fb 1f       	adc	r31, r27
     6ea:	ee 0f       	add	r30, r30
     6ec:	ff 1f       	adc	r31, r31
     6ee:	eb 50       	subi	r30, 0x0B	; 11
     6f0:	fe 4d       	sbci	r31, 0xDE	; 222
     6f2:	43 83       	std	Z+3, r20	; 0x03
     6f4:	67 70       	andi	r22, 0x07	; 7
     6f6:	85 83       	std	Z+5, r24	; 0x05
     6f8:	23 70       	andi	r18, 0x03	; 3
     6fa:	66 0f       	add	r22, r22
     6fc:	66 0f       	add	r22, r22
     6fe:	66 0f       	add	r22, r22
     700:	26 2b       	or	r18, r22
     702:	24 83       	std	Z+4, r18	; 0x04
     704:	9f 5f       	subi	r25, 0xFF	; 255
     706:	90 93 0d 22 	sts	0x220D, r25
     70a:	08 95       	ret

0000070c <qt_get_sensor_delta>:
     70c:	1f 93       	push	r17
     70e:	cf 93       	push	r28
     710:	df 93       	push	r29
     712:	28 2f       	mov	r18, r24
     714:	c8 2f       	mov	r28, r24
     716:	d0 e0       	ldi	r29, 0x00	; 0
     718:	fe 01       	movw	r30, r28
     71a:	ee 0f       	add	r30, r30
     71c:	ff 1f       	adc	r31, r31
     71e:	ec 0f       	add	r30, r28
     720:	fd 1f       	adc	r31, r29
     722:	ee 0f       	add	r30, r30
     724:	ff 1f       	adc	r31, r31
     726:	eb 50       	subi	r30, 0x0B	; 11
     728:	fe 4d       	sbci	r31, 0xDE	; 222
     72a:	35 81       	ldd	r19, Z+5	; 0x05
     72c:	83 81       	ldd	r24, Z+3	; 0x03
     72e:	90 e0       	ldi	r25, 0x00	; 0
     730:	00 90 d5 21 	lds	r0, 0x21D5
     734:	02 c0       	rjmp	.+4      	; 0x73a <qt_get_sensor_delta+0x2e>
     736:	95 95       	asr	r25
     738:	87 95       	ror	r24
     73a:	0a 94       	dec	r0
     73c:	e2 f7       	brpl	.-8      	; 0x736 <qt_get_sensor_delta+0x2a>
     73e:	18 2f       	mov	r17, r24
     740:	84 30       	cpi	r24, 0x04	; 4
     742:	08 f4       	brcc	.+2      	; 0x746 <qt_get_sensor_delta+0x3a>
     744:	14 e0       	ldi	r17, 0x04	; 4
     746:	80 91 0d 22 	lds	r24, 0x220D
     74a:	28 17       	cp	r18, r24
     74c:	18 f0       	brcs	.+6      	; 0x754 <qt_get_sensor_delta+0x48>
     74e:	20 e0       	ldi	r18, 0x00	; 0
     750:	30 e0       	ldi	r19, 0x00	; 0
     752:	2d c0       	rjmp	.+90     	; 0x7ae <qt_get_sensor_delta+0xa2>
     754:	83 2f       	mov	r24, r19
     756:	1d d1       	rcall	.+570    	; 0x992 <get_channel_delta>
     758:	9c 01       	movw	r18, r24
     75a:	41 2f       	mov	r20, r17
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	16 95       	lsr	r17
     760:	16 95       	lsr	r17
     762:	81 2f       	mov	r24, r17
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	84 1b       	sub	r24, r20
     768:	95 0b       	sbc	r25, r21
     76a:	82 17       	cp	r24, r18
     76c:	93 07       	cpc	r25, r19
     76e:	64 f4       	brge	.+24     	; 0x788 <qt_get_sensor_delta+0x7c>
     770:	fe 01       	movw	r30, r28
     772:	ee 0f       	add	r30, r30
     774:	ff 1f       	adc	r31, r31
     776:	ec 0f       	add	r30, r28
     778:	fd 1f       	adc	r31, r29
     77a:	ee 0f       	add	r30, r30
     77c:	ff 1f       	adc	r31, r31
     77e:	eb 50       	subi	r30, 0x0B	; 11
     780:	fe 4d       	sbci	r31, 0xDE	; 222
     782:	84 81       	ldd	r24, Z+4	; 0x04
     784:	8b 7f       	andi	r24, 0xFB	; 251
     786:	84 83       	std	Z+4, r24	; 0x04
     788:	88 27       	eor	r24, r24
     78a:	99 27       	eor	r25, r25
     78c:	84 1b       	sub	r24, r20
     78e:	95 0b       	sbc	r25, r21
     790:	82 17       	cp	r24, r18
     792:	93 07       	cpc	r25, r19
     794:	64 f0       	brlt	.+24     	; 0x7ae <qt_get_sensor_delta+0xa2>
     796:	fe 01       	movw	r30, r28
     798:	ee 0f       	add	r30, r30
     79a:	ff 1f       	adc	r31, r31
     79c:	ec 0f       	add	r30, r28
     79e:	fd 1f       	adc	r31, r29
     7a0:	ee 0f       	add	r30, r30
     7a2:	ff 1f       	adc	r31, r31
     7a4:	eb 50       	subi	r30, 0x0B	; 11
     7a6:	fe 4d       	sbci	r31, 0xDE	; 222
     7a8:	84 81       	ldd	r24, Z+4	; 0x04
     7aa:	84 60       	ori	r24, 0x04	; 4
     7ac:	84 83       	std	Z+4, r24	; 0x04
     7ae:	c9 01       	movw	r24, r18
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	1f 91       	pop	r17
     7b6:	08 95       	ret

000007b8 <qt_measure_sensors>:
     7b8:	ff 92       	push	r15
     7ba:	0f 93       	push	r16
     7bc:	1f 93       	push	r17
     7be:	cf 93       	push	r28
     7c0:	df 93       	push	r29
     7c2:	10 92 ed 21 	sts	0x21ED, r1
     7c6:	10 92 ee 21 	sts	0x21EE, r1
     7ca:	20 91 f1 21 	lds	r18, 0x21F1
     7ce:	30 91 f2 21 	lds	r19, 0x21F2
     7d2:	80 93 f1 21 	sts	0x21F1, r24
     7d6:	90 93 f2 21 	sts	0x21F2, r25
     7da:	40 91 f3 21 	lds	r20, 0x21F3
     7de:	50 91 f4 21 	lds	r21, 0x21F4
     7e2:	42 1b       	sub	r20, r18
     7e4:	53 0b       	sbc	r21, r19
     7e6:	48 0f       	add	r20, r24
     7e8:	59 1f       	adc	r21, r25
     7ea:	ff 24       	eor	r15, r15
     7ec:	03 c0       	rjmp	.+6      	; 0x7f4 <qt_measure_sensors+0x3c>
     7ee:	f3 94       	inc	r15
     7f0:	48 5c       	subi	r20, 0xC8	; 200
     7f2:	50 40       	sbci	r21, 0x00	; 0
     7f4:	48 3c       	cpi	r20, 0xC8	; 200
     7f6:	51 05       	cpc	r21, r1
     7f8:	d0 f7       	brcc	.-12     	; 0x7ee <qt_measure_sensors+0x36>
     7fa:	40 93 f3 21 	sts	0x21F3, r20
     7fe:	50 93 f4 21 	sts	0x21F4, r21
     802:	80 91 0e 22 	lds	r24, 0x220E
     806:	88 23       	and	r24, r24
     808:	41 f0       	breq	.+16     	; 0x81a <qt_measure_sensors+0x62>
     80a:	8f 15       	cp	r24, r15
     80c:	18 f4       	brcc	.+6      	; 0x814 <qt_measure_sensors+0x5c>
     80e:	10 92 0e 22 	sts	0x220E, r1
     812:	03 c0       	rjmp	.+6      	; 0x81a <qt_measure_sensors+0x62>
     814:	8f 19       	sub	r24, r15
     816:	80 93 0e 22 	sts	0x220E, r24
     81a:	c3 d3       	rcall	.+1926   	; 0xfa2 <burst>
     81c:	e0 91 ef 21 	lds	r30, 0x21EF
     820:	f0 91 f0 21 	lds	r31, 0x21F0
     824:	30 97       	sbiw	r30, 0x00	; 0
     826:	09 f0       	breq	.+2      	; 0x82a <qt_measure_sensors+0x72>
     828:	19 95       	eicall
     82a:	10 e0       	ldi	r17, 0x00	; 0
     82c:	00 e0       	ldi	r16, 0x00	; 0
     82e:	05 c0       	rjmp	.+10     	; 0x83a <qt_measure_sensors+0x82>
     830:	81 2f       	mov	r24, r17
     832:	6f 2d       	mov	r22, r15
     834:	c3 d0       	rcall	.+390    	; 0x9bc <process_sensor>
     836:	08 2b       	or	r16, r24
     838:	1f 5f       	subi	r17, 0xFF	; 255
     83a:	60 91 0d 22 	lds	r22, 0x220D
     83e:	16 17       	cp	r17, r22
     840:	b8 f3       	brcs	.-18     	; 0x830 <qt_measure_sensors+0x78>
     842:	00 23       	and	r16, r16
     844:	49 f0       	breq	.+18     	; 0x858 <qt_measure_sensors+0xa0>
     846:	80 91 ed 21 	lds	r24, 0x21ED
     84a:	90 91 ee 21 	lds	r25, 0x21EE
     84e:	91 60       	ori	r25, 0x01	; 1
     850:	80 93 ed 21 	sts	0x21ED, r24
     854:	90 93 ee 21 	sts	0x21EE, r25
     858:	10 92 ec 21 	sts	0x21EC, r1
     85c:	a5 ef       	ldi	r26, 0xF5	; 245
     85e:	b1 e2       	ldi	r27, 0x21	; 33
     860:	30 e0       	ldi	r19, 0x00	; 0
     862:	41 e0       	ldi	r20, 0x01	; 1
     864:	50 e0       	ldi	r21, 0x00	; 0
     866:	17 c0       	rjmp	.+46     	; 0x896 <qt_measure_sensors+0xde>
     868:	8c 91       	ld	r24, X
     86a:	88 71       	andi	r24, 0x18	; 24
     86c:	91 f0       	breq	.+36     	; 0x892 <qt_measure_sensors+0xda>
     86e:	e3 2f       	mov	r30, r19
     870:	e6 95       	lsr	r30
     872:	e6 95       	lsr	r30
     874:	e6 95       	lsr	r30
     876:	f0 e0       	ldi	r31, 0x00	; 0
     878:	e4 52       	subi	r30, 0x24	; 36
     87a:	fe 4d       	sbci	r31, 0xDE	; 222
     87c:	83 2f       	mov	r24, r19
     87e:	87 70       	andi	r24, 0x07	; 7
     880:	ea 01       	movw	r28, r20
     882:	02 c0       	rjmp	.+4      	; 0x888 <qt_measure_sensors+0xd0>
     884:	cc 0f       	add	r28, r28
     886:	dd 1f       	adc	r29, r29
     888:	8a 95       	dec	r24
     88a:	e2 f7       	brpl	.-8      	; 0x884 <qt_measure_sensors+0xcc>
     88c:	20 89       	ldd	r18, Z+16	; 0x10
     88e:	2c 2b       	or	r18, r28
     890:	20 8b       	std	Z+16, r18	; 0x10
     892:	3f 5f       	subi	r19, 0xFF	; 255
     894:	16 96       	adiw	r26, 0x06	; 6
     896:	36 17       	cp	r19, r22
     898:	38 f3       	brcs	.-50     	; 0x868 <qt_measure_sensors+0xb0>
     89a:	80 91 ed 21 	lds	r24, 0x21ED
     89e:	90 91 ee 21 	lds	r25, 0x21EE
     8a2:	cd b7       	in	r28, 0x3d	; 61
     8a4:	de b7       	in	r29, 0x3e	; 62
     8a6:	e5 e0       	ldi	r30, 0x05	; 5
     8a8:	0c 94 1b 1d 	jmp	0x3a36	; 0x3a36 <__epilogue_restores__+0x1a>

000008ac <qt_reset_sensing>:
     8ac:	10 92 0d 22 	sts	0x220D, r1
     8b0:	84 e0       	ldi	r24, 0x04	; 4
     8b2:	80 93 d6 21 	sts	0x21D6, r24
     8b6:	94 e1       	ldi	r25, 0x14	; 20
     8b8:	90 93 d9 21 	sts	0x21D9, r25
     8bc:	85 e0       	ldi	r24, 0x05	; 5
     8be:	80 93 da 21 	sts	0x21DA, r24
     8c2:	10 92 d8 21 	sts	0x21D8, r1
     8c6:	90 93 d7 21 	sts	0x21D7, r25
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	80 93 d5 21 	sts	0x21D5, r24
     8d0:	83 e0       	ldi	r24, 0x03	; 3
     8d2:	80 93 db 21 	sts	0x21DB, r24
     8d6:	54 d3       	rcall	.+1704   	; 0xf80 <burst_reset>
     8d8:	10 92 ef 21 	sts	0x21EF, r1
     8dc:	10 92 f0 21 	sts	0x21F0, r1
     8e0:	08 95       	ret

000008e2 <qt_calibrate_sensing>:
     8e2:	1f 93       	push	r17
     8e4:	10 e0       	ldi	r17, 0x00	; 0
     8e6:	03 c0       	rjmp	.+6      	; 0x8ee <qt_calibrate_sensing+0xc>
     8e8:	81 2f       	mov	r24, r17
     8ea:	27 d0       	rcall	.+78     	; 0x93a <start_cal_sensor>
     8ec:	1f 5f       	subi	r17, 0xFF	; 255
     8ee:	80 91 0d 22 	lds	r24, 0x220D
     8f2:	18 17       	cp	r17, r24
     8f4:	c8 f3       	brcs	.-14     	; 0x8e8 <qt_calibrate_sensing+0x6>
     8f6:	1f 91       	pop	r17
     8f8:	08 95       	ret

000008fa <qt_init_sensing_with_burst>:
     8fa:	ef 92       	push	r14
     8fc:	ff 92       	push	r15
     8fe:	1f 93       	push	r17
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
     904:	ec 01       	movw	r28, r24
     906:	7b 01       	movw	r14, r22
     908:	10 e0       	ldi	r17, 0x00	; 0
     90a:	03 c0       	rjmp	.+6      	; 0x912 <qt_init_sensing_with_burst+0x18>
     90c:	81 2f       	mov	r24, r17
     90e:	15 d0       	rcall	.+42     	; 0x93a <start_cal_sensor>
     910:	1f 5f       	subi	r17, 0xFF	; 255
     912:	80 91 0d 22 	lds	r24, 0x220D
     916:	18 17       	cp	r17, r24
     918:	c8 f3       	brcs	.-14     	; 0x90c <qt_init_sensing_with_burst+0x12>
     91a:	10 92 f1 21 	sts	0x21F1, r1
     91e:	10 92 f2 21 	sts	0x21F2, r1
     922:	c0 93 d3 21 	sts	0x21D3, r28
     926:	d0 93 d4 21 	sts	0x21D4, r29
     92a:	c7 01       	movw	r24, r14
     92c:	24 d3       	rcall	.+1608   	; 0xf76 <burst_init>
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	1f 91       	pop	r17
     934:	ff 90       	pop	r15
     936:	ef 90       	pop	r14
     938:	08 95       	ret

0000093a <start_cal_sensor>:
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	e5 ef       	ldi	r30, 0xF5	; 245
     93e:	f1 e2       	ldi	r31, 0x21	; 33
     940:	9c 01       	movw	r18, r24
     942:	22 0f       	add	r18, r18
     944:	33 1f       	adc	r19, r19
     946:	28 0f       	add	r18, r24
     948:	39 1f       	adc	r19, r25
     94a:	d9 01       	movw	r26, r18
     94c:	aa 0f       	add	r26, r26
     94e:	bb 1f       	adc	r27, r27
     950:	ae 0f       	add	r26, r30
     952:	bf 1f       	adc	r27, r31
     954:	15 96       	adiw	r26, 0x05	; 5
     956:	4c 91       	ld	r20, X
     958:	15 97       	sbiw	r26, 0x05	; 5
     95a:	80 91 ed 21 	lds	r24, 0x21ED
     95e:	90 91 ee 21 	lds	r25, 0x21EE
     962:	82 60       	ori	r24, 0x02	; 2
     964:	80 93 ed 21 	sts	0x21ED, r24
     968:	90 93 ee 21 	sts	0x21EE, r25
     96c:	2f 5f       	subi	r18, 0xFF	; 255
     96e:	3f 4f       	sbci	r19, 0xFF	; 255
     970:	22 0f       	add	r18, r18
     972:	33 1f       	adc	r19, r19
     974:	e2 0f       	add	r30, r18
     976:	f3 1f       	adc	r31, r19
     978:	10 82       	st	Z, r1
     97a:	ef e0       	ldi	r30, 0x0F	; 15
     97c:	f2 e2       	ldi	r31, 0x22	; 34
     97e:	e4 0f       	add	r30, r20
     980:	f1 1d       	adc	r31, r1
     982:	80 e8       	ldi	r24, 0x80	; 128
     984:	80 83       	st	Z, r24
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	8c 93       	st	X, r24
     98a:	8f e0       	ldi	r24, 0x0F	; 15
     98c:	11 96       	adiw	r26, 0x01	; 1
     98e:	8c 93       	st	X, r24
     990:	08 95       	ret

00000992 <get_channel_delta>:
     992:	90 e0       	ldi	r25, 0x00	; 0
     994:	fc 01       	movw	r30, r24
     996:	34 96       	adiw	r30, 0x04	; 4
     998:	ac ed       	ldi	r26, 0xDC	; 220
     99a:	b1 e2       	ldi	r27, 0x21	; 33
     99c:	ee 0f       	add	r30, r30
     99e:	ff 1f       	adc	r31, r31
     9a0:	ea 0f       	add	r30, r26
     9a2:	fb 1f       	adc	r31, r27
     9a4:	88 0f       	add	r24, r24
     9a6:	99 1f       	adc	r25, r25
     9a8:	a8 0f       	add	r26, r24
     9aa:	b9 1f       	adc	r27, r25
     9ac:	20 81       	ld	r18, Z
     9ae:	31 81       	ldd	r19, Z+1	; 0x01
     9b0:	8d 91       	ld	r24, X+
     9b2:	9c 91       	ld	r25, X
     9b4:	28 1b       	sub	r18, r24
     9b6:	39 0b       	sbc	r19, r25
     9b8:	c9 01       	movw	r24, r18
     9ba:	08 95       	ret

000009bc <process_sensor>:
     9bc:	a0 e0       	ldi	r26, 0x00	; 0
     9be:	b0 e0       	ldi	r27, 0x00	; 0
     9c0:	e4 ee       	ldi	r30, 0xE4	; 228
     9c2:	f4 e0       	ldi	r31, 0x04	; 4
     9c4:	0c 94 f9 1c 	jmp	0x39f2	; 0x39f2 <__prologue_saves__+0x8>
     9c8:	78 2e       	mov	r7, r24
     9ca:	f6 2e       	mov	r15, r22
     9cc:	9f de       	rcall	.-706    	; 0x70c <qt_get_sensor_delta>
     9ce:	5c 01       	movw	r10, r24
     9d0:	07 2d       	mov	r16, r7
     9d2:	10 e0       	ldi	r17, 0x00	; 0
     9d4:	f8 01       	movw	r30, r16
     9d6:	ee 0f       	add	r30, r30
     9d8:	ff 1f       	adc	r31, r31
     9da:	e0 0f       	add	r30, r16
     9dc:	f1 1f       	adc	r31, r17
     9de:	ee 0f       	add	r30, r30
     9e0:	ff 1f       	adc	r31, r31
     9e2:	eb 50       	subi	r30, 0x0B	; 11
     9e4:	fe 4d       	sbci	r31, 0xDE	; 222
     9e6:	54 81       	ldd	r21, Z+4	; 0x04
     9e8:	43 81       	ldd	r20, Z+3	; 0x03
     9ea:	24 2f       	mov	r18, r20
     9ec:	30 e0       	ldi	r19, 0x00	; 0
     9ee:	85 2f       	mov	r24, r21
     9f0:	83 70       	andi	r24, 0x03	; 3
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	01 96       	adiw	r24, 0x01	; 1
     9f6:	02 c0       	rjmp	.+4      	; 0x9fc <process_sensor+0x40>
     9f8:	35 95       	asr	r19
     9fa:	27 95       	ror	r18
     9fc:	8a 95       	dec	r24
     9fe:	e2 f7       	brpl	.-8      	; 0x9f8 <process_sensor+0x3c>
     a00:	82 2f       	mov	r24, r18
     a02:	22 30       	cpi	r18, 0x02	; 2
     a04:	08 f4       	brcc	.+2      	; 0xa08 <process_sensor+0x4c>
     a06:	82 e0       	ldi	r24, 0x02	; 2
     a08:	24 2f       	mov	r18, r20
     a0a:	30 e0       	ldi	r19, 0x00	; 0
     a0c:	b9 01       	movw	r22, r18
     a0e:	68 1b       	sub	r22, r24
     a10:	71 09       	sbc	r23, r1
     a12:	f8 01       	movw	r30, r16
     a14:	ee 0f       	add	r30, r30
     a16:	ff 1f       	adc	r31, r31
     a18:	e0 0f       	add	r30, r16
     a1a:	f1 1f       	adc	r31, r17
     a1c:	ef 01       	movw	r28, r30
     a1e:	cc 0f       	add	r28, r28
     a20:	dd 1f       	adc	r29, r29
     a22:	cb 50       	subi	r28, 0x0B	; 11
     a24:	de 4d       	sbci	r29, 0xDE	; 222
     a26:	88 81       	ld	r24, Y
     a28:	84 30       	cpi	r24, 0x04	; 4
     a2a:	09 f4       	brne	.+2      	; 0xa2e <process_sensor+0x72>
     a2c:	fb c0       	rjmp	.+502    	; 0xc24 <process_sensor+0x268>
     a2e:	85 30       	cpi	r24, 0x05	; 5
     a30:	30 f4       	brcc	.+12     	; 0xa3e <process_sensor+0x82>
     a32:	81 30       	cpi	r24, 0x01	; 1
     a34:	71 f0       	breq	.+28     	; 0xa52 <process_sensor+0x96>
     a36:	82 30       	cpi	r24, 0x02	; 2
     a38:	09 f0       	breq	.+2      	; 0xa3c <process_sensor+0x80>
     a3a:	96 c2       	rjmp	.+1324   	; 0xf68 <process_sensor+0x5ac>
     a3c:	6e c0       	rjmp	.+220    	; 0xb1a <process_sensor+0x15e>
     a3e:	80 31       	cpi	r24, 0x10	; 16
     a40:	09 f4       	brne	.+2      	; 0xa44 <process_sensor+0x88>
     a42:	a5 c1       	rjmp	.+842    	; 0xd8e <process_sensor+0x3d2>
     a44:	80 32       	cpi	r24, 0x20	; 32
     a46:	09 f4       	brne	.+2      	; 0xa4a <process_sensor+0x8e>
     a48:	56 c2       	rjmp	.+1196   	; 0xef6 <process_sensor+0x53a>
     a4a:	88 30       	cpi	r24, 0x08	; 8
     a4c:	09 f0       	breq	.+2      	; 0xa50 <process_sensor+0x94>
     a4e:	8c c2       	rjmp	.+1304   	; 0xf68 <process_sensor+0x5ac>
     a50:	02 c2       	rjmp	.+1028   	; 0xe56 <process_sensor+0x49a>
     a52:	40 91 ed 21 	lds	r20, 0x21ED
     a56:	50 91 ee 21 	lds	r21, 0x21EE
     a5a:	ca 01       	movw	r24, r20
     a5c:	92 60       	ori	r25, 0x02	; 2
     a5e:	80 93 ed 21 	sts	0x21ED, r24
     a62:	90 93 ee 21 	sts	0x21EE, r25
     a66:	8d 81       	ldd	r24, Y+5	; 0x05
     a68:	69 81       	ldd	r22, Y+1	; 0x01
     a6a:	a8 2f       	mov	r26, r24
     a6c:	b0 e0       	ldi	r27, 0x00	; 0
     a6e:	6a 30       	cpi	r22, 0x0A	; 10
     a70:	60 f0       	brcs	.+24     	; 0xa8a <process_sensor+0xce>
     a72:	aa 0f       	add	r26, r26
     a74:	bb 1f       	adc	r27, r27
     a76:	fd 01       	movw	r30, r26
     a78:	e4 52       	subi	r30, 0x24	; 36
     a7a:	fe 4d       	sbci	r31, 0xDE	; 222
     a7c:	80 81       	ld	r24, Z
     a7e:	91 81       	ldd	r25, Z+1	; 0x01
     a80:	ac 51       	subi	r26, 0x1C	; 28
     a82:	be 4d       	sbci	r27, 0xDE	; 222
     a84:	8d 93       	st	X+, r24
     a86:	9c 93       	st	X, r25
     a88:	18 c0       	rjmp	.+48     	; 0xaba <process_sensor+0xfe>
     a8a:	aa 0f       	add	r26, r26
     a8c:	bb 1f       	adc	r27, r27
     a8e:	fd 01       	movw	r30, r26
     a90:	ec 51       	subi	r30, 0x1C	; 28
     a92:	fe 4d       	sbci	r31, 0xDE	; 222
     a94:	20 81       	ld	r18, Z
     a96:	31 81       	ldd	r19, Z+1	; 0x01
     a98:	a4 52       	subi	r26, 0x24	; 36
     a9a:	be 4d       	sbci	r27, 0xDE	; 222
     a9c:	8d 91       	ld	r24, X+
     a9e:	9c 91       	ld	r25, X
     aa0:	82 17       	cp	r24, r18
     aa2:	93 07       	cpc	r25, r19
     aa4:	18 f4       	brcc	.+6      	; 0xaac <process_sensor+0xf0>
     aa6:	21 50       	subi	r18, 0x01	; 1
     aa8:	30 40       	sbci	r19, 0x00	; 0
     aaa:	05 c0       	rjmp	.+10     	; 0xab6 <process_sensor+0xfa>
     aac:	28 17       	cp	r18, r24
     aae:	39 07       	cpc	r19, r25
     ab0:	50 f4       	brcc	.+20     	; 0xac6 <process_sensor+0x10a>
     ab2:	2f 5f       	subi	r18, 0xFF	; 255
     ab4:	3f 4f       	sbci	r19, 0xFF	; 255
     ab6:	20 83       	st	Z, r18
     ab8:	31 83       	std	Z+1, r19	; 0x01
     aba:	48 60       	ori	r20, 0x08	; 8
     abc:	52 60       	ori	r21, 0x02	; 2
     abe:	40 93 ed 21 	sts	0x21ED, r20
     ac2:	50 93 ee 21 	sts	0x21EE, r21
     ac6:	86 2f       	mov	r24, r22
     ac8:	81 50       	subi	r24, 0x01	; 1
     aca:	f8 01       	movw	r30, r16
     acc:	ee 0f       	add	r30, r30
     ace:	ff 1f       	adc	r31, r31
     ad0:	e0 0f       	add	r30, r16
     ad2:	f1 1f       	adc	r31, r17
     ad4:	ef 01       	movw	r28, r30
     ad6:	cc 0f       	add	r28, r28
     ad8:	dd 1f       	adc	r29, r29
     ada:	cb 50       	subi	r28, 0x0B	; 11
     adc:	de 4d       	sbci	r29, 0xDE	; 222
     ade:	89 83       	std	Y+1, r24	; 0x01
     ae0:	88 23       	and	r24, r24
     ae2:	b1 f4       	brne	.+44     	; 0xb10 <process_sensor+0x154>
     ae4:	ad 81       	ldd	r26, Y+5	; 0x05
     ae6:	82 e0       	ldi	r24, 0x02	; 2
     ae8:	88 83       	st	Y, r24
     aea:	80 91 ed 21 	lds	r24, 0x21ED
     aee:	90 91 ee 21 	lds	r25, 0x21EE
     af2:	82 60       	ori	r24, 0x02	; 2
     af4:	80 93 ed 21 	sts	0x21ED, r24
     af8:	90 93 ee 21 	sts	0x21EE, r25
     afc:	ee 0f       	add	r30, r30
     afe:	ff 1f       	adc	r31, r31
     b00:	e9 50       	subi	r30, 0x09	; 9
     b02:	fe 4d       	sbci	r31, 0xDE	; 222
     b04:	10 82       	st	Z, r1
     b06:	b0 e0       	ldi	r27, 0x00	; 0
     b08:	a1 5f       	subi	r26, 0xF1	; 241
     b0a:	bd 4d       	sbci	r27, 0xDD	; 221
     b0c:	80 e8       	ldi	r24, 0x80	; 128
     b0e:	8c 93       	st	X, r24
     b10:	80 91 d7 21 	lds	r24, 0x21D7
     b14:	80 93 0e 22 	sts	0x220E, r24
     b18:	25 c2       	rjmp	.+1098   	; 0xf64 <process_sensor+0x5a8>
     b1a:	52 ff       	sbrs	r21, 2
     b1c:	08 c0       	rjmp	.+16     	; 0xb2e <process_sensor+0x172>
     b1e:	ed 81       	ldd	r30, Y+5	; 0x05
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	e1 5f       	subi	r30, 0xF1	; 241
     b24:	fd 4d       	sbci	r31, 0xDD	; 221
     b26:	10 82       	st	Z, r1
     b28:	80 e2       	ldi	r24, 0x20	; 32
     b2a:	88 83       	st	Y, r24
     b2c:	0c c2       	rjmp	.+1048   	; 0xf46 <process_sensor+0x58a>
     b2e:	c5 01       	movw	r24, r10
     b30:	b7 fe       	sbrs	r11, 7
     b32:	02 c0       	rjmp	.+4      	; 0xb38 <process_sensor+0x17c>
     b34:	80 e0       	ldi	r24, 0x00	; 0
     b36:	90 e0       	ldi	r25, 0x00	; 0
     b38:	82 17       	cp	r24, r18
     b3a:	93 07       	cpc	r25, r19
     b3c:	80 f0       	brcs	.+32     	; 0xb5e <process_sensor+0x1a2>
     b3e:	f8 01       	movw	r30, r16
     b40:	ee 0f       	add	r30, r30
     b42:	ff 1f       	adc	r31, r31
     b44:	e0 0f       	add	r30, r16
     b46:	f1 1f       	adc	r31, r17
     b48:	ee 0f       	add	r30, r30
     b4a:	ff 1f       	adc	r31, r31
     b4c:	df 01       	movw	r26, r30
     b4e:	ab 50       	subi	r26, 0x0B	; 11
     b50:	be 4d       	sbci	r27, 0xDE	; 222
     b52:	84 e0       	ldi	r24, 0x04	; 4
     b54:	8c 93       	st	X, r24
     b56:	e9 50       	subi	r30, 0x09	; 9
     b58:	fe 4d       	sbci	r31, 0xDE	; 222
     b5a:	10 82       	st	Z, r1
     b5c:	fa c1       	rjmp	.+1012   	; 0xf52 <process_sensor+0x596>
     b5e:	ff 20       	and	r15, r15
     b60:	09 f4       	brne	.+2      	; 0xb64 <process_sensor+0x1a8>
     b62:	02 c2       	rjmp	.+1028   	; 0xf68 <process_sensor+0x5ac>
     b64:	80 91 0e 22 	lds	r24, 0x220E
     b68:	88 23       	and	r24, r24
     b6a:	09 f0       	breq	.+2      	; 0xb6e <process_sensor+0x1b2>
     b6c:	fd c1       	rjmp	.+1018   	; 0xf68 <process_sensor+0x5ac>
     b6e:	f8 01       	movw	r30, r16
     b70:	ee 0f       	add	r30, r30
     b72:	ff 1f       	adc	r31, r31
     b74:	e0 0f       	add	r30, r16
     b76:	f1 1f       	adc	r31, r17
     b78:	ee 0f       	add	r30, r30
     b7a:	ff 1f       	adc	r31, r31
     b7c:	eb 50       	subi	r30, 0x0B	; 11
     b7e:	fe 4d       	sbci	r31, 0xDE	; 222
     b80:	85 81       	ldd	r24, Z+5	; 0x05
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	ec 01       	movw	r28, r24
     b86:	cc 0f       	add	r28, r28
     b88:	dd 1f       	adc	r29, r29
     b8a:	cc 51       	subi	r28, 0x1C	; 28
     b8c:	de 4d       	sbci	r29, 0xDE	; 222
     b8e:	28 81       	ld	r18, Y
     b90:	39 81       	ldd	r19, Y+1	; 0x01
     b92:	fc 01       	movw	r30, r24
     b94:	ee 0f       	add	r30, r30
     b96:	ff 1f       	adc	r31, r31
     b98:	e4 52       	subi	r30, 0x24	; 36
     b9a:	fe 4d       	sbci	r31, 0xDE	; 222
     b9c:	01 90       	ld	r0, Z+
     b9e:	f0 81       	ld	r31, Z
     ba0:	e0 2d       	mov	r30, r0
     ba2:	2e 17       	cp	r18, r30
     ba4:	3f 07       	cpc	r19, r31
     ba6:	88 f4       	brcc	.+34     	; 0xbca <process_sensor+0x20e>
     ba8:	fc 01       	movw	r30, r24
     baa:	e1 5f       	subi	r30, 0xF1	; 241
     bac:	fd 4d       	sbci	r31, 0xDD	; 221
     bae:	90 81       	ld	r25, Z
     bb0:	9f 0d       	add	r25, r15
     bb2:	90 83       	st	Z, r25
     bb4:	80 91 da 21 	lds	r24, 0x21DA
     bb8:	80 58       	subi	r24, 0x80	; 128
     bba:	98 17       	cp	r25, r24
     bbc:	08 f4       	brcc	.+2      	; 0xbc0 <process_sensor+0x204>
     bbe:	d4 c1       	rjmp	.+936    	; 0xf68 <process_sensor+0x5ac>
     bc0:	80 e8       	ldi	r24, 0x80	; 128
     bc2:	80 83       	st	Z, r24
     bc4:	2f 5f       	subi	r18, 0xFF	; 255
     bc6:	3f 4f       	sbci	r19, 0xFF	; 255
     bc8:	14 c0       	rjmp	.+40     	; 0xbf2 <process_sensor+0x236>
     bca:	dc 01       	movw	r26, r24
     bcc:	a1 5f       	subi	r26, 0xF1	; 241
     bce:	bd 4d       	sbci	r27, 0xDD	; 221
     bd0:	e2 17       	cp	r30, r18
     bd2:	f3 07       	cpc	r31, r19
     bd4:	d0 f4       	brcc	.+52     	; 0xc0a <process_sensor+0x24e>
     bd6:	8c 91       	ld	r24, X
     bd8:	8f 19       	sub	r24, r15
     bda:	8c 93       	st	X, r24
     bdc:	40 e8       	ldi	r20, 0x80	; 128
     bde:	90 91 d9 21 	lds	r25, 0x21D9
     be2:	54 2f       	mov	r21, r20
     be4:	59 1b       	sub	r21, r25
     be6:	58 17       	cp	r21, r24
     be8:	08 f4       	brcc	.+2      	; 0xbec <process_sensor+0x230>
     bea:	be c1       	rjmp	.+892    	; 0xf68 <process_sensor+0x5ac>
     bec:	4c 93       	st	X, r20
     bee:	21 50       	subi	r18, 0x01	; 1
     bf0:	30 40       	sbci	r19, 0x00	; 0
     bf2:	28 83       	st	Y, r18
     bf4:	39 83       	std	Y+1, r19	; 0x01
     bf6:	80 91 ed 21 	lds	r24, 0x21ED
     bfa:	90 91 ee 21 	lds	r25, 0x21EE
     bfe:	88 60       	ori	r24, 0x08	; 8
     c00:	80 93 ed 21 	sts	0x21ED, r24
     c04:	90 93 ee 21 	sts	0x21EE, r25
     c08:	af c1       	rjmp	.+862    	; 0xf68 <process_sensor+0x5ac>
     c0a:	2c 91       	ld	r18, X
     c0c:	21 38       	cpi	r18, 0x81	; 129
     c0e:	10 f0       	brcs	.+4      	; 0xc14 <process_sensor+0x258>
     c10:	21 50       	subi	r18, 0x01	; 1
     c12:	2c 93       	st	X, r18
     c14:	fc 01       	movw	r30, r24
     c16:	e1 5f       	subi	r30, 0xF1	; 241
     c18:	fd 4d       	sbci	r31, 0xDD	; 221
     c1a:	80 81       	ld	r24, Z
     c1c:	87 fd       	sbrc	r24, 7
     c1e:	a4 c1       	rjmp	.+840    	; 0xf68 <process_sensor+0x5ac>
     c20:	8f 5f       	subi	r24, 0xFF	; 255
     c22:	67 c1       	rjmp	.+718    	; 0xef2 <process_sensor+0x536>
     c24:	c5 01       	movw	r24, r10
     c26:	b7 fe       	sbrs	r11, 7
     c28:	02 c0       	rjmp	.+4      	; 0xc2e <process_sensor+0x272>
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	90 e0       	ldi	r25, 0x00	; 0
     c2e:	f8 01       	movw	r30, r16
     c30:	ee 0f       	add	r30, r30
     c32:	ff 1f       	adc	r31, r31
     c34:	82 17       	cp	r24, r18
     c36:	93 07       	cpc	r25, r19
     c38:	08 f4       	brcc	.+2      	; 0xc3c <process_sensor+0x280>
     c3a:	8f c0       	rjmp	.+286    	; 0xd5a <process_sensor+0x39e>
     c3c:	80 91 d7 21 	lds	r24, 0x21D7
     c40:	80 93 0e 22 	sts	0x220E, r24
     c44:	9f 01       	movw	r18, r30
     c46:	20 0f       	add	r18, r16
     c48:	31 1f       	adc	r19, r17
     c4a:	22 0f       	add	r18, r18
     c4c:	33 1f       	adc	r19, r19
     c4e:	d9 01       	movw	r26, r18
     c50:	a9 50       	subi	r26, 0x09	; 9
     c52:	be 4d       	sbci	r27, 0xDE	; 222
     c54:	8c 91       	ld	r24, X
     c56:	8f 5f       	subi	r24, 0xFF	; 255
     c58:	8c 93       	st	X, r24
     c5a:	f9 01       	movw	r30, r18
     c5c:	eb 50       	subi	r30, 0x0B	; 11
     c5e:	fe 4d       	sbci	r31, 0xDE	; 222
     c60:	84 81       	ldd	r24, Z+4	; 0x04
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	88 73       	andi	r24, 0x38	; 56
     c66:	90 70       	andi	r25, 0x00	; 0
     c68:	23 e0       	ldi	r18, 0x03	; 3
     c6a:	96 95       	lsr	r25
     c6c:	87 95       	ror	r24
     c6e:	2a 95       	dec	r18
     c70:	e1 f7       	brne	.-8      	; 0xc6a <process_sensor+0x2ae>
     c72:	68 2e       	mov	r6, r24
     c74:	88 23       	and	r24, r24
     c76:	09 f4       	brne	.+2      	; 0xc7a <process_sensor+0x2be>
     c78:	3e c0       	rjmp	.+124    	; 0xcf6 <process_sensor+0x33a>
     c7a:	cc 24       	eor	r12, r12
     c7c:	dd 24       	eor	r13, r13
     c7e:	7f 01       	movw	r14, r30
     c80:	83 e0       	ldi	r24, 0x03	; 3
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	e8 0e       	add	r14, r24
     c86:	f9 1e       	adc	r15, r25
     c88:	4d 01       	movw	r8, r26
     c8a:	2f c0       	rjmp	.+94     	; 0xcea <process_sensor+0x32e>
     c8c:	d7 14       	cp	r13, r7
     c8e:	61 f1       	breq	.+88     	; 0xce8 <process_sensor+0x32c>
     c90:	8d 2d       	mov	r24, r13
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	ec 01       	movw	r28, r24
     c96:	cc 0f       	add	r28, r28
     c98:	dd 1f       	adc	r29, r29
     c9a:	c8 0f       	add	r28, r24
     c9c:	d9 1f       	adc	r29, r25
     c9e:	cc 0f       	add	r28, r28
     ca0:	dd 1f       	adc	r29, r29
     ca2:	cb 50       	subi	r28, 0x0B	; 11
     ca4:	de 4d       	sbci	r29, 0xDE	; 222
     ca6:	8c 81       	ldd	r24, Y+4	; 0x04
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	88 73       	andi	r24, 0x38	; 56
     cac:	90 70       	andi	r25, 0x00	; 0
     cae:	73 e0       	ldi	r23, 0x03	; 3
     cb0:	96 95       	lsr	r25
     cb2:	87 95       	ror	r24
     cb4:	7a 95       	dec	r23
     cb6:	e1 f7       	brne	.-8      	; 0xcb0 <process_sensor+0x2f4>
     cb8:	68 16       	cp	r6, r24
     cba:	b1 f4       	brne	.+44     	; 0xce8 <process_sensor+0x32c>
     cbc:	8d 2d       	mov	r24, r13
     cbe:	26 dd       	rcall	.-1460   	; 0x70c <qt_get_sensor_delta>
     cc0:	2b 81       	ldd	r18, Y+3	; 0x03
     cc2:	82 1b       	sub	r24, r18
     cc4:	91 09       	sbc	r25, r1
     cc6:	f7 01       	movw	r30, r14
     cc8:	20 81       	ld	r18, Z
     cca:	a5 01       	movw	r20, r10
     ccc:	42 1b       	sub	r20, r18
     cce:	51 09       	sbc	r21, r1
     cd0:	48 17       	cp	r20, r24
     cd2:	59 07       	cpc	r21, r25
     cd4:	2c f0       	brlt	.+10     	; 0xce0 <process_sensor+0x324>
     cd6:	88 81       	ld	r24, Y
     cd8:	80 31       	cpi	r24, 0x10	; 16
     cda:	11 f0       	breq	.+4      	; 0xce0 <process_sensor+0x324>
     cdc:	88 30       	cpi	r24, 0x08	; 8
     cde:	21 f4       	brne	.+8      	; 0xce8 <process_sensor+0x32c>
     ce0:	f4 01       	movw	r30, r8
     ce2:	10 82       	st	Z, r1
     ce4:	cc 24       	eor	r12, r12
     ce6:	c3 94       	inc	r12
     ce8:	d3 94       	inc	r13
     cea:	80 91 0d 22 	lds	r24, 0x220D
     cee:	d8 16       	cp	r13, r24
     cf0:	68 f2       	brcs	.-102    	; 0xc8c <process_sensor+0x2d0>
     cf2:	cc 20       	and	r12, r12
     cf4:	79 f4       	brne	.+30     	; 0xd14 <process_sensor+0x358>
     cf6:	80 91 d6 21 	lds	r24, 0x21D6
     cfa:	88 23       	and	r24, r24
     cfc:	59 f0       	breq	.+22     	; 0xd14 <process_sensor+0x358>
     cfe:	80 91 ed 21 	lds	r24, 0x21ED
     d02:	90 91 ee 21 	lds	r25, 0x21EE
     d06:	98 60       	ori	r25, 0x08	; 8
     d08:	80 93 ed 21 	sts	0x21ED, r24
     d0c:	90 93 ee 21 	sts	0x21EE, r25
     d10:	41 e0       	ldi	r20, 0x01	; 1
     d12:	01 c0       	rjmp	.+2      	; 0xd16 <process_sensor+0x35a>
     d14:	40 e0       	ldi	r20, 0x00	; 0
     d16:	98 01       	movw	r18, r16
     d18:	22 0f       	add	r18, r18
     d1a:	33 1f       	adc	r19, r19
     d1c:	20 0f       	add	r18, r16
     d1e:	31 1f       	adc	r19, r17
     d20:	f9 01       	movw	r30, r18
     d22:	ee 0f       	add	r30, r30
     d24:	ff 1f       	adc	r31, r31
     d26:	e9 50       	subi	r30, 0x09	; 9
     d28:	fe 4d       	sbci	r31, 0xDE	; 222
     d2a:	90 81       	ld	r25, Z
     d2c:	80 91 d6 21 	lds	r24, 0x21D6
     d30:	98 17       	cp	r25, r24
     d32:	08 f4       	brcc	.+2      	; 0xd36 <process_sensor+0x37a>
     d34:	1a c1       	rjmp	.+564    	; 0xf6a <process_sensor+0x5ae>
     d36:	80 91 ed 21 	lds	r24, 0x21ED
     d3a:	90 91 ee 21 	lds	r25, 0x21EE
     d3e:	83 60       	ori	r24, 0x03	; 3
     d40:	80 93 ed 21 	sts	0x21ED, r24
     d44:	90 93 ee 21 	sts	0x21EE, r25
     d48:	f9 01       	movw	r30, r18
     d4a:	ee 0f       	add	r30, r30
     d4c:	ff 1f       	adc	r31, r31
     d4e:	eb 50       	subi	r30, 0x0B	; 11
     d50:	fe 4d       	sbci	r31, 0xDE	; 222
     d52:	80 e1       	ldi	r24, 0x10	; 16
     d54:	80 83       	st	Z, r24
     d56:	11 82       	std	Z+1, r1	; 0x01
     d58:	08 c1       	rjmp	.+528    	; 0xf6a <process_sensor+0x5ae>
     d5a:	e0 0f       	add	r30, r16
     d5c:	f1 1f       	adc	r31, r17
     d5e:	ee 0f       	add	r30, r30
     d60:	ff 1f       	adc	r31, r31
     d62:	df 01       	movw	r26, r30
     d64:	ab 50       	subi	r26, 0x0B	; 11
     d66:	be 4d       	sbci	r27, 0xDE	; 222
     d68:	15 96       	adiw	r26, 0x05	; 5
     d6a:	2c 91       	ld	r18, X
     d6c:	15 97       	sbiw	r26, 0x05	; 5
     d6e:	82 e0       	ldi	r24, 0x02	; 2
     d70:	8c 93       	st	X, r24
     d72:	80 91 ed 21 	lds	r24, 0x21ED
     d76:	90 91 ee 21 	lds	r25, 0x21EE
     d7a:	82 60       	ori	r24, 0x02	; 2
     d7c:	80 93 ed 21 	sts	0x21ED, r24
     d80:	90 93 ee 21 	sts	0x21EE, r25
     d84:	e9 50       	subi	r30, 0x09	; 9
     d86:	fe 4d       	sbci	r31, 0xDE	; 222
     d88:	10 82       	st	Z, r1
     d8a:	e2 2f       	mov	r30, r18
     d8c:	ae c0       	rjmp	.+348    	; 0xeea <process_sensor+0x52e>
     d8e:	52 ff       	sbrs	r21, 2
     d90:	0e c0       	rjmp	.+28     	; 0xdae <process_sensor+0x3f2>
     d92:	ed 81       	ldd	r30, Y+5	; 0x05
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	e1 5f       	subi	r30, 0xF1	; 241
     d98:	fd 4d       	sbci	r31, 0xDD	; 221
     d9a:	80 e8       	ldi	r24, 0x80	; 128
     d9c:	80 83       	st	Z, r24
     d9e:	80 e2       	ldi	r24, 0x20	; 32
     da0:	88 83       	st	Y, r24
     da2:	80 91 ed 21 	lds	r24, 0x21ED
     da6:	90 91 ee 21 	lds	r25, 0x21EE
     daa:	90 61       	ori	r25, 0x10	; 16
     dac:	4a c0       	rjmp	.+148    	; 0xe42 <process_sensor+0x486>
     dae:	c5 01       	movw	r24, r10
     db0:	b7 fe       	sbrs	r11, 7
     db2:	02 c0       	rjmp	.+4      	; 0xdb8 <process_sensor+0x3fc>
     db4:	80 e0       	ldi	r24, 0x00	; 0
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	f8 01       	movw	r30, r16
     dba:	ee 0f       	add	r30, r30
     dbc:	ff 1f       	adc	r31, r31
     dbe:	40 91 ed 21 	lds	r20, 0x21ED
     dc2:	50 91 ee 21 	lds	r21, 0x21EE
     dc6:	86 17       	cp	r24, r22
     dc8:	97 07       	cpc	r25, r23
     dca:	70 f4       	brcc	.+28     	; 0xde8 <process_sensor+0x42c>
     dcc:	e0 0f       	add	r30, r16
     dce:	f1 1f       	adc	r31, r17
     dd0:	ee 0f       	add	r30, r30
     dd2:	ff 1f       	adc	r31, r31
     dd4:	eb 50       	subi	r30, 0x0B	; 11
     dd6:	fe 4d       	sbci	r31, 0xDE	; 222
     dd8:	88 e0       	ldi	r24, 0x08	; 8
     dda:	80 83       	st	Z, r24
     ddc:	54 60       	ori	r21, 0x04	; 4
     dde:	40 93 ed 21 	sts	0x21ED, r20
     de2:	50 93 ee 21 	sts	0x21EE, r21
     de6:	31 c0       	rjmp	.+98     	; 0xe4a <process_sensor+0x48e>
     de8:	41 60       	ori	r20, 0x01	; 1
     dea:	40 93 ed 21 	sts	0x21ED, r20
     dee:	50 93 ee 21 	sts	0x21EE, r21
     df2:	e0 0f       	add	r30, r16
     df4:	f1 1f       	adc	r31, r17
     df6:	ee 0f       	add	r30, r30
     df8:	ff 1f       	adc	r31, r31
     dfa:	e9 50       	subi	r30, 0x09	; 9
     dfc:	fe 4d       	sbci	r31, 0xDE	; 222
     dfe:	90 81       	ld	r25, Z
     e00:	80 91 d6 21 	lds	r24, 0x21D6
     e04:	98 17       	cp	r25, r24
     e06:	10 f4       	brcc	.+4      	; 0xe0c <process_sensor+0x450>
     e08:	9f 5f       	subi	r25, 0xFF	; 255
     e0a:	90 83       	st	Z, r25
     e0c:	90 91 d8 21 	lds	r25, 0x21D8
     e10:	99 23       	and	r25, r25
     e12:	71 f0       	breq	.+28     	; 0xe30 <process_sensor+0x474>
     e14:	f8 01       	movw	r30, r16
     e16:	ee 0f       	add	r30, r30
     e18:	ff 1f       	adc	r31, r31
     e1a:	e0 0f       	add	r30, r16
     e1c:	f1 1f       	adc	r31, r17
     e1e:	ee 0f       	add	r30, r30
     e20:	ff 1f       	adc	r31, r31
     e22:	eb 50       	subi	r30, 0x0B	; 11
     e24:	fe 4d       	sbci	r31, 0xDE	; 222
     e26:	81 81       	ldd	r24, Z+1	; 0x01
     e28:	89 17       	cp	r24, r25
     e2a:	20 f4       	brcc	.+8      	; 0xe34 <process_sensor+0x478>
     e2c:	8f 0d       	add	r24, r15
     e2e:	81 83       	std	Z+1, r24	; 0x01
     e30:	40 e0       	ldi	r20, 0x00	; 0
     e32:	0c c0       	rjmp	.+24     	; 0xe4c <process_sensor+0x490>
     e34:	87 2d       	mov	r24, r7
     e36:	81 dd       	rcall	.-1278   	; 0x93a <start_cal_sensor>
     e38:	80 91 ed 21 	lds	r24, 0x21ED
     e3c:	90 91 ee 21 	lds	r25, 0x21EE
     e40:	92 60       	ori	r25, 0x02	; 2
     e42:	80 93 ed 21 	sts	0x21ED, r24
     e46:	90 93 ee 21 	sts	0x21EE, r25
     e4a:	41 e0       	ldi	r20, 0x01	; 1
     e4c:	80 91 d7 21 	lds	r24, 0x21D7
     e50:	80 93 0e 22 	sts	0x220E, r24
     e54:	8a c0       	rjmp	.+276    	; 0xf6a <process_sensor+0x5ae>
     e56:	80 91 d7 21 	lds	r24, 0x21D7
     e5a:	80 93 0e 22 	sts	0x220E, r24
     e5e:	df 01       	movw	r26, r30
     e60:	aa 0f       	add	r26, r26
     e62:	bb 1f       	adc	r27, r27
     e64:	a9 50       	subi	r26, 0x09	; 9
     e66:	be 4d       	sbci	r27, 0xDE	; 222
     e68:	8c 91       	ld	r24, X
     e6a:	88 23       	and	r24, r24
     e6c:	89 f1       	breq	.+98     	; 0xed0 <process_sensor+0x514>
     e6e:	c5 01       	movw	r24, r10
     e70:	b7 fe       	sbrs	r11, 7
     e72:	02 c0       	rjmp	.+4      	; 0xe78 <process_sensor+0x4bc>
     e74:	80 e0       	ldi	r24, 0x00	; 0
     e76:	90 e0       	ldi	r25, 0x00	; 0
     e78:	40 91 ed 21 	lds	r20, 0x21ED
     e7c:	50 91 ee 21 	lds	r21, 0x21EE
     e80:	68 17       	cp	r22, r24
     e82:	79 07       	cpc	r23, r25
     e84:	90 f4       	brcc	.+36     	; 0xeaa <process_sensor+0x4ee>
     e86:	f8 01       	movw	r30, r16
     e88:	ee 0f       	add	r30, r30
     e8a:	ff 1f       	adc	r31, r31
     e8c:	e0 0f       	add	r30, r16
     e8e:	f1 1f       	adc	r31, r17
     e90:	ee 0f       	add	r30, r30
     e92:	ff 1f       	adc	r31, r31
     e94:	eb 50       	subi	r30, 0x0B	; 11
     e96:	fe 4d       	sbci	r31, 0xDE	; 222
     e98:	80 e1       	ldi	r24, 0x10	; 16
     e9a:	80 83       	st	Z, r24
     e9c:	41 60       	ori	r20, 0x01	; 1
     e9e:	40 93 ed 21 	sts	0x21ED, r20
     ea2:	50 93 ee 21 	sts	0x21EE, r21
     ea6:	40 e0       	ldi	r20, 0x00	; 0
     ea8:	06 c0       	rjmp	.+12     	; 0xeb6 <process_sensor+0x4fa>
     eaa:	54 60       	ori	r21, 0x04	; 4
     eac:	40 93 ed 21 	sts	0x21ED, r20
     eb0:	50 93 ee 21 	sts	0x21EE, r21
     eb4:	41 e0       	ldi	r20, 0x01	; 1
     eb6:	f8 01       	movw	r30, r16
     eb8:	ee 0f       	add	r30, r30
     eba:	ff 1f       	adc	r31, r31
     ebc:	e0 0f       	add	r30, r16
     ebe:	f1 1f       	adc	r31, r17
     ec0:	ee 0f       	add	r30, r30
     ec2:	ff 1f       	adc	r31, r31
     ec4:	e9 50       	subi	r30, 0x09	; 9
     ec6:	fe 4d       	sbci	r31, 0xDE	; 222
     ec8:	80 81       	ld	r24, Z
     eca:	81 50       	subi	r24, 0x01	; 1
     ecc:	80 83       	st	Z, r24
     ece:	4d c0       	rjmp	.+154    	; 0xf6a <process_sensor+0x5ae>
     ed0:	ed 81       	ldd	r30, Y+5	; 0x05
     ed2:	82 e0       	ldi	r24, 0x02	; 2
     ed4:	88 83       	st	Y, r24
     ed6:	80 91 ed 21 	lds	r24, 0x21ED
     eda:	90 91 ee 21 	lds	r25, 0x21EE
     ede:	82 60       	ori	r24, 0x02	; 2
     ee0:	80 93 ed 21 	sts	0x21ED, r24
     ee4:	90 93 ee 21 	sts	0x21EE, r25
     ee8:	1c 92       	st	X, r1
     eea:	f0 e0       	ldi	r31, 0x00	; 0
     eec:	e1 5f       	subi	r30, 0xF1	; 241
     eee:	fd 4d       	sbci	r31, 0xDD	; 221
     ef0:	80 e8       	ldi	r24, 0x80	; 128
     ef2:	80 83       	st	Z, r24
     ef4:	39 c0       	rjmp	.+114    	; 0xf68 <process_sensor+0x5ac>
     ef6:	8d 81       	ldd	r24, Y+5	; 0x05
     ef8:	a8 2f       	mov	r26, r24
     efa:	b0 e0       	ldi	r27, 0x00	; 0
     efc:	a1 5f       	subi	r26, 0xF1	; 241
     efe:	bd 4d       	sbci	r27, 0xDD	; 221
     f00:	9c 91       	ld	r25, X
     f02:	9f 5f       	subi	r25, 0xFF	; 255
     f04:	9c 93       	st	X, r25
     f06:	52 fd       	sbrc	r21, 2
     f08:	18 c0       	rjmp	.+48     	; 0xf3a <process_sensor+0x57e>
     f0a:	97 ff       	sbrs	r25, 7
     f0c:	03 c0       	rjmp	.+6      	; 0xf14 <process_sensor+0x558>
     f0e:	80 e1       	ldi	r24, 0x10	; 16
     f10:	88 83       	st	Y, r24
     f12:	2a c0       	rjmp	.+84     	; 0xf68 <process_sensor+0x5ac>
     f14:	82 e0       	ldi	r24, 0x02	; 2
     f16:	88 83       	st	Y, r24
     f18:	80 91 ed 21 	lds	r24, 0x21ED
     f1c:	90 91 ee 21 	lds	r25, 0x21EE
     f20:	82 60       	ori	r24, 0x02	; 2
     f22:	80 93 ed 21 	sts	0x21ED, r24
     f26:	90 93 ee 21 	sts	0x21EE, r25
     f2a:	ee 0f       	add	r30, r30
     f2c:	ff 1f       	adc	r31, r31
     f2e:	e9 50       	subi	r30, 0x09	; 9
     f30:	fe 4d       	sbci	r31, 0xDE	; 222
     f32:	10 82       	st	Z, r1
     f34:	80 e8       	ldi	r24, 0x80	; 128
     f36:	8c 93       	st	X, r24
     f38:	17 c0       	rjmp	.+46     	; 0xf68 <process_sensor+0x5ac>
     f3a:	80 91 db 21 	lds	r24, 0x21DB
     f3e:	98 17       	cp	r25, r24
     f40:	40 f0       	brcs	.+16     	; 0xf52 <process_sensor+0x596>
     f42:	87 2d       	mov	r24, r7
     f44:	fa dc       	rcall	.-1548   	; 0x93a <start_cal_sensor>
     f46:	80 91 ed 21 	lds	r24, 0x21ED
     f4a:	90 91 ee 21 	lds	r25, 0x21EE
     f4e:	90 61       	ori	r25, 0x10	; 16
     f50:	05 c0       	rjmp	.+10     	; 0xf5c <process_sensor+0x5a0>
     f52:	80 91 ed 21 	lds	r24, 0x21ED
     f56:	90 91 ee 21 	lds	r25, 0x21EE
     f5a:	94 60       	ori	r25, 0x04	; 4
     f5c:	80 93 ed 21 	sts	0x21ED, r24
     f60:	90 93 ee 21 	sts	0x21EE, r25
     f64:	41 e0       	ldi	r20, 0x01	; 1
     f66:	01 c0       	rjmp	.+2      	; 0xf6a <process_sensor+0x5ae>
     f68:	40 e0       	ldi	r20, 0x00	; 0
     f6a:	84 2f       	mov	r24, r20
     f6c:	cd b7       	in	r28, 0x3d	; 61
     f6e:	de b7       	in	r29, 0x3e	; 62
     f70:	ee e0       	ldi	r30, 0x0E	; 14
     f72:	0c 94 12 1d 	jmp	0x3a24	; 0x3a24 <__epilogue_restores__+0x8>

00000f76 <burst_init>:
     f76:	fc 01       	movw	r30, r24
     f78:	00 97       	sbiw	r24, 0x00	; 0
     f7a:	09 f0       	breq	.+2      	; 0xf7e <burst_init+0x8>
     f7c:	19 95       	eicall
     f7e:	08 95       	ret

00000f80 <burst_reset>:
     f80:	10 92 13 22 	sts	0x2213, r1
     f84:	10 92 14 22 	sts	0x2214, r1
     f88:	10 92 17 22 	sts	0x2217, r1
     f8c:	10 92 18 22 	sts	0x2218, r1
     f90:	10 92 15 22 	sts	0x2215, r1
     f94:	10 92 16 22 	sts	0x2216, r1
     f98:	10 92 19 22 	sts	0x2219, r1
     f9c:	10 92 1a 22 	sts	0x221A, r1
     fa0:	08 95       	ret

00000fa2 <burst>:
     fa2:	80 91 15 22 	lds	r24, 0x2215
     fa6:	90 91 13 22 	lds	r25, 0x2213
     faa:	89 2b       	or	r24, r25
     fac:	41 f0       	breq	.+16     	; 0xfbe <burst+0x1c>
     fae:	e0 91 d3 21 	lds	r30, 0x21D3
     fb2:	f0 91 d4 21 	lds	r31, 0x21D4
     fb6:	30 97       	sbiw	r30, 0x00	; 0
     fb8:	11 f0       	breq	.+4      	; 0xfbe <burst+0x1c>
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	19 95       	eicall
     fbe:	80 91 16 22 	lds	r24, 0x2216
     fc2:	90 91 14 22 	lds	r25, 0x2214
     fc6:	89 2b       	or	r24, r25
     fc8:	41 f0       	breq	.+16     	; 0xfda <burst+0x38>
     fca:	e0 91 d3 21 	lds	r30, 0x21D3
     fce:	f0 91 d4 21 	lds	r31, 0x21D4
     fd2:	30 97       	sbiw	r30, 0x00	; 0
     fd4:	11 f0       	breq	.+4      	; 0xfda <burst+0x38>
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	19 95       	eicall
     fda:	08 95       	ret

00000fdc <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     fdc:	bf 92       	push	r11
     fde:	cf 92       	push	r12
     fe0:	df 92       	push	r13
     fe2:	ef 92       	push	r14
     fe4:	ff 92       	push	r15
     fe6:	0f 93       	push	r16
     fe8:	1f 93       	push	r17
     fea:	cf 93       	push	r28
     fec:	df 93       	push	r29
     fee:	1f 92       	push	r1
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     ff4:	e0 e0       	ldi	r30, 0x00	; 0
     ff6:	f6 e0       	ldi	r31, 0x06	; 6
     ff8:	88 e0       	ldi	r24, 0x08	; 8
     ffa:	86 83       	std	Z+6, r24	; 0x06
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     ffc:	85 83       	std	Z+5, r24	; 0x05
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     ffe:	0f 2e       	mov	r0, r31
    1000:	fb e2       	ldi	r31, 0x2B	; 43
    1002:	bf 2e       	mov	r11, r31
    1004:	f0 2d       	mov	r31, r0
    1006:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
    1008:	80 ea       	ldi	r24, 0xA0	; 160
    100a:	99 e0       	ldi	r25, 0x09	; 9
    100c:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
    1010:	c1 2c       	mov	r12, r1
    1012:	d1 2c       	mov	r13, r1
    1014:	76 01       	movw	r14, r12
    1016:	00 e4       	ldi	r16, 0x40	; 64
    1018:	12 e4       	ldi	r17, 0x42	; 66
    101a:	2f e0       	ldi	r18, 0x0F	; 15
    101c:	30 e0       	ldi	r19, 0x00	; 0
    101e:	43 e0       	ldi	r20, 0x03	; 3
    1020:	be 01       	movw	r22, r28
    1022:	6f 5f       	subi	r22, 0xFF	; 255
    1024:	7f 4f       	sbci	r23, 0xFF	; 255
    1026:	80 ea       	ldi	r24, 0xA0	; 160
    1028:	99 e0       	ldi	r25, 0x09	; 9
    102a:	0e 94 17 11 	call	0x222e	; 0x222e <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    102e:	00 e6       	ldi	r16, 0x60	; 96
    1030:	16 e0       	ldi	r17, 0x06	; 6
    1032:	ff 24       	eor	r15, r15
    1034:	f3 94       	inc	r15
    1036:	f8 01       	movw	r30, r16
    1038:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    103a:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    103c:	be 01       	movw	r22, r28
    103e:	6f 5f       	subi	r22, 0xFF	; 255
    1040:	7f 4f       	sbci	r23, 0xFF	; 255
    1042:	80 ea       	ldi	r24, 0xA0	; 160
    1044:	99 e0       	ldi	r25, 0x09	; 9
    1046:	0e 94 31 11 	call	0x2262	; 0x2262 <usart_spi_select_device>
    104a:	f8 01       	movw	r30, r16
    104c:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    104e:	e0 ea       	ldi	r30, 0xA0	; 160
    1050:	f9 e0       	ldi	r31, 0x09	; 9
    1052:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1054:	85 ff       	sbrs	r24, 5
    1056:	fd cf       	rjmp	.-6      	; 0x1052 <st7565r_init+0x76>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1058:	80 ea       	ldi	r24, 0xA0	; 160
    105a:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    105e:	e0 ea       	ldi	r30, 0xA0	; 160
    1060:	f9 e0       	ldi	r31, 0x09	; 9
    1062:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1064:	86 ff       	sbrs	r24, 6
    1066:	fd cf       	rjmp	.-6      	; 0x1062 <st7565r_init+0x86>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1068:	e0 ea       	ldi	r30, 0xA0	; 160
    106a:	f9 e0       	ldi	r31, 0x09	; 9
    106c:	80 e4       	ldi	r24, 0x40	; 64
    106e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1070:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1072:	be 01       	movw	r22, r28
    1074:	6f 5f       	subi	r22, 0xFF	; 255
    1076:	7f 4f       	sbci	r23, 0xFF	; 255
    1078:	80 ea       	ldi	r24, 0xA0	; 160
    107a:	99 e0       	ldi	r25, 0x09	; 9
    107c:	0e 94 47 11 	call	0x228e	; 0x228e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1080:	8b e2       	ldi	r24, 0x2B	; 43
    1082:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1084:	be 01       	movw	r22, r28
    1086:	6f 5f       	subi	r22, 0xFF	; 255
    1088:	7f 4f       	sbci	r23, 0xFF	; 255
    108a:	80 ea       	ldi	r24, 0xA0	; 160
    108c:	99 e0       	ldi	r25, 0x09	; 9
    108e:	0e 94 31 11 	call	0x2262	; 0x2262 <usart_spi_select_device>
    1092:	81 e0       	ldi	r24, 0x01	; 1
    1094:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1098:	e0 ea       	ldi	r30, 0xA0	; 160
    109a:	f9 e0       	ldi	r31, 0x09	; 9
    109c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    109e:	85 ff       	sbrs	r24, 5
    10a0:	fd cf       	rjmp	.-6      	; 0x109c <st7565r_init+0xc0>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    10a2:	86 ea       	ldi	r24, 0xA6	; 166
    10a4:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    10a8:	e0 ea       	ldi	r30, 0xA0	; 160
    10aa:	f9 e0       	ldi	r31, 0x09	; 9
    10ac:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    10ae:	86 ff       	sbrs	r24, 6
    10b0:	fd cf       	rjmp	.-6      	; 0x10ac <st7565r_init+0xd0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    10b2:	e0 ea       	ldi	r30, 0xA0	; 160
    10b4:	f9 e0       	ldi	r31, 0x09	; 9
    10b6:	80 e4       	ldi	r24, 0x40	; 64
    10b8:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    10ba:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    10bc:	be 01       	movw	r22, r28
    10be:	6f 5f       	subi	r22, 0xFF	; 255
    10c0:	7f 4f       	sbci	r23, 0xFF	; 255
    10c2:	80 ea       	ldi	r24, 0xA0	; 160
    10c4:	99 e0       	ldi	r25, 0x09	; 9
    10c6:	0e 94 47 11 	call	0x228e	; 0x228e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    10ca:	8b e2       	ldi	r24, 0x2B	; 43
    10cc:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    10ce:	be 01       	movw	r22, r28
    10d0:	6f 5f       	subi	r22, 0xFF	; 255
    10d2:	7f 4f       	sbci	r23, 0xFF	; 255
    10d4:	80 ea       	ldi	r24, 0xA0	; 160
    10d6:	99 e0       	ldi	r25, 0x09	; 9
    10d8:	0e 94 31 11 	call	0x2262	; 0x2262 <usart_spi_select_device>
    10dc:	81 e0       	ldi	r24, 0x01	; 1
    10de:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    10e2:	e0 ea       	ldi	r30, 0xA0	; 160
    10e4:	f9 e0       	ldi	r31, 0x09	; 9
    10e6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    10e8:	85 ff       	sbrs	r24, 5
    10ea:	fd cf       	rjmp	.-6      	; 0x10e6 <st7565r_init+0x10a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    10ec:	88 ec       	ldi	r24, 0xC8	; 200
    10ee:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    10f2:	e0 ea       	ldi	r30, 0xA0	; 160
    10f4:	f9 e0       	ldi	r31, 0x09	; 9
    10f6:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    10f8:	86 ff       	sbrs	r24, 6
    10fa:	fd cf       	rjmp	.-6      	; 0x10f6 <st7565r_init+0x11a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    10fc:	e0 ea       	ldi	r30, 0xA0	; 160
    10fe:	f9 e0       	ldi	r31, 0x09	; 9
    1100:	80 e4       	ldi	r24, 0x40	; 64
    1102:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1104:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1106:	be 01       	movw	r22, r28
    1108:	6f 5f       	subi	r22, 0xFF	; 255
    110a:	7f 4f       	sbci	r23, 0xFF	; 255
    110c:	80 ea       	ldi	r24, 0xA0	; 160
    110e:	99 e0       	ldi	r25, 0x09	; 9
    1110:	0e 94 47 11 	call	0x228e	; 0x228e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1114:	8b e2       	ldi	r24, 0x2B	; 43
    1116:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1118:	be 01       	movw	r22, r28
    111a:	6f 5f       	subi	r22, 0xFF	; 255
    111c:	7f 4f       	sbci	r23, 0xFF	; 255
    111e:	80 ea       	ldi	r24, 0xA0	; 160
    1120:	99 e0       	ldi	r25, 0x09	; 9
    1122:	0e 94 31 11 	call	0x2262	; 0x2262 <usart_spi_select_device>
    1126:	81 e0       	ldi	r24, 0x01	; 1
    1128:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    112c:	e0 ea       	ldi	r30, 0xA0	; 160
    112e:	f9 e0       	ldi	r31, 0x09	; 9
    1130:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1132:	85 ff       	sbrs	r24, 5
    1134:	fd cf       	rjmp	.-6      	; 0x1130 <st7565r_init+0x154>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1136:	82 ea       	ldi	r24, 0xA2	; 162
    1138:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    113c:	e0 ea       	ldi	r30, 0xA0	; 160
    113e:	f9 e0       	ldi	r31, 0x09	; 9
    1140:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1142:	86 ff       	sbrs	r24, 6
    1144:	fd cf       	rjmp	.-6      	; 0x1140 <st7565r_init+0x164>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1146:	e0 ea       	ldi	r30, 0xA0	; 160
    1148:	f9 e0       	ldi	r31, 0x09	; 9
    114a:	80 e4       	ldi	r24, 0x40	; 64
    114c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    114e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1150:	be 01       	movw	r22, r28
    1152:	6f 5f       	subi	r22, 0xFF	; 255
    1154:	7f 4f       	sbci	r23, 0xFF	; 255
    1156:	80 ea       	ldi	r24, 0xA0	; 160
    1158:	99 e0       	ldi	r25, 0x09	; 9
    115a:	0e 94 47 11 	call	0x228e	; 0x228e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    115e:	8b e2       	ldi	r24, 0x2B	; 43
    1160:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1162:	be 01       	movw	r22, r28
    1164:	6f 5f       	subi	r22, 0xFF	; 255
    1166:	7f 4f       	sbci	r23, 0xFF	; 255
    1168:	80 ea       	ldi	r24, 0xA0	; 160
    116a:	99 e0       	ldi	r25, 0x09	; 9
    116c:	0e 94 31 11 	call	0x2262	; 0x2262 <usart_spi_select_device>
    1170:	81 e0       	ldi	r24, 0x01	; 1
    1172:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1176:	e0 ea       	ldi	r30, 0xA0	; 160
    1178:	f9 e0       	ldi	r31, 0x09	; 9
    117a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    117c:	85 ff       	sbrs	r24, 5
    117e:	fd cf       	rjmp	.-6      	; 0x117a <st7565r_init+0x19e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1180:	8f e2       	ldi	r24, 0x2F	; 47
    1182:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1186:	e0 ea       	ldi	r30, 0xA0	; 160
    1188:	f9 e0       	ldi	r31, 0x09	; 9
    118a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    118c:	86 ff       	sbrs	r24, 6
    118e:	fd cf       	rjmp	.-6      	; 0x118a <st7565r_init+0x1ae>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1190:	e0 ea       	ldi	r30, 0xA0	; 160
    1192:	f9 e0       	ldi	r31, 0x09	; 9
    1194:	80 e4       	ldi	r24, 0x40	; 64
    1196:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1198:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    119a:	be 01       	movw	r22, r28
    119c:	6f 5f       	subi	r22, 0xFF	; 255
    119e:	7f 4f       	sbci	r23, 0xFF	; 255
    11a0:	80 ea       	ldi	r24, 0xA0	; 160
    11a2:	99 e0       	ldi	r25, 0x09	; 9
    11a4:	0e 94 47 11 	call	0x228e	; 0x228e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    11a8:	8b e2       	ldi	r24, 0x2B	; 43
    11aa:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    11ac:	be 01       	movw	r22, r28
    11ae:	6f 5f       	subi	r22, 0xFF	; 255
    11b0:	7f 4f       	sbci	r23, 0xFF	; 255
    11b2:	80 ea       	ldi	r24, 0xA0	; 160
    11b4:	99 e0       	ldi	r25, 0x09	; 9
    11b6:	0e 94 31 11 	call	0x2262	; 0x2262 <usart_spi_select_device>
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    11c0:	e0 ea       	ldi	r30, 0xA0	; 160
    11c2:	f9 e0       	ldi	r31, 0x09	; 9
    11c4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    11c6:	85 ff       	sbrs	r24, 5
    11c8:	fd cf       	rjmp	.-6      	; 0x11c4 <st7565r_init+0x1e8>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    11ca:	88 ef       	ldi	r24, 0xF8	; 248
    11cc:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    11d0:	e0 ea       	ldi	r30, 0xA0	; 160
    11d2:	f9 e0       	ldi	r31, 0x09	; 9
    11d4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    11d6:	86 ff       	sbrs	r24, 6
    11d8:	fd cf       	rjmp	.-6      	; 0x11d4 <st7565r_init+0x1f8>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    11da:	e0 ea       	ldi	r30, 0xA0	; 160
    11dc:	f9 e0       	ldi	r31, 0x09	; 9
    11de:	80 e4       	ldi	r24, 0x40	; 64
    11e0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    11e2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    11e4:	be 01       	movw	r22, r28
    11e6:	6f 5f       	subi	r22, 0xFF	; 255
    11e8:	7f 4f       	sbci	r23, 0xFF	; 255
    11ea:	80 ea       	ldi	r24, 0xA0	; 160
    11ec:	99 e0       	ldi	r25, 0x09	; 9
    11ee:	0e 94 47 11 	call	0x228e	; 0x228e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    11f2:	8b e2       	ldi	r24, 0x2B	; 43
    11f4:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    11f6:	be 01       	movw	r22, r28
    11f8:	6f 5f       	subi	r22, 0xFF	; 255
    11fa:	7f 4f       	sbci	r23, 0xFF	; 255
    11fc:	80 ea       	ldi	r24, 0xA0	; 160
    11fe:	99 e0       	ldi	r25, 0x09	; 9
    1200:	0e 94 31 11 	call	0x2262	; 0x2262 <usart_spi_select_device>
    1204:	81 e0       	ldi	r24, 0x01	; 1
    1206:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    120a:	e0 ea       	ldi	r30, 0xA0	; 160
    120c:	f9 e0       	ldi	r31, 0x09	; 9
    120e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1210:	85 ff       	sbrs	r24, 5
    1212:	fd cf       	rjmp	.-6      	; 0x120e <st7565r_init+0x232>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1214:	10 92 a0 09 	sts	0x09A0, r1
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1218:	e0 ea       	ldi	r30, 0xA0	; 160
    121a:	f9 e0       	ldi	r31, 0x09	; 9
    121c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    121e:	86 ff       	sbrs	r24, 6
    1220:	fd cf       	rjmp	.-6      	; 0x121c <st7565r_init+0x240>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1222:	e0 ea       	ldi	r30, 0xA0	; 160
    1224:	f9 e0       	ldi	r31, 0x09	; 9
    1226:	80 e4       	ldi	r24, 0x40	; 64
    1228:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    122a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    122c:	be 01       	movw	r22, r28
    122e:	6f 5f       	subi	r22, 0xFF	; 255
    1230:	7f 4f       	sbci	r23, 0xFF	; 255
    1232:	80 ea       	ldi	r24, 0xA0	; 160
    1234:	99 e0       	ldi	r25, 0x09	; 9
    1236:	0e 94 47 11 	call	0x228e	; 0x228e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    123a:	8b e2       	ldi	r24, 0x2B	; 43
    123c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    123e:	be 01       	movw	r22, r28
    1240:	6f 5f       	subi	r22, 0xFF	; 255
    1242:	7f 4f       	sbci	r23, 0xFF	; 255
    1244:	80 ea       	ldi	r24, 0xA0	; 160
    1246:	99 e0       	ldi	r25, 0x09	; 9
    1248:	0e 94 31 11 	call	0x2262	; 0x2262 <usart_spi_select_device>
    124c:	81 e0       	ldi	r24, 0x01	; 1
    124e:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1252:	e0 ea       	ldi	r30, 0xA0	; 160
    1254:	f9 e0       	ldi	r31, 0x09	; 9
    1256:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1258:	85 ff       	sbrs	r24, 5
    125a:	fd cf       	rjmp	.-6      	; 0x1256 <st7565r_init+0x27a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    125c:	81 e2       	ldi	r24, 0x21	; 33
    125e:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1262:	e0 ea       	ldi	r30, 0xA0	; 160
    1264:	f9 e0       	ldi	r31, 0x09	; 9
    1266:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1268:	86 ff       	sbrs	r24, 6
    126a:	fd cf       	rjmp	.-6      	; 0x1266 <st7565r_init+0x28a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    126c:	e0 ea       	ldi	r30, 0xA0	; 160
    126e:	f9 e0       	ldi	r31, 0x09	; 9
    1270:	80 e4       	ldi	r24, 0x40	; 64
    1272:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1274:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1276:	be 01       	movw	r22, r28
    1278:	6f 5f       	subi	r22, 0xFF	; 255
    127a:	7f 4f       	sbci	r23, 0xFF	; 255
    127c:	80 ea       	ldi	r24, 0xA0	; 160
    127e:	99 e0       	ldi	r25, 0x09	; 9
    1280:	0e 94 47 11 	call	0x228e	; 0x228e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1284:	8b e2       	ldi	r24, 0x2B	; 43
    1286:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1288:	be 01       	movw	r22, r28
    128a:	6f 5f       	subi	r22, 0xFF	; 255
    128c:	7f 4f       	sbci	r23, 0xFF	; 255
    128e:	80 ea       	ldi	r24, 0xA0	; 160
    1290:	99 e0       	ldi	r25, 0x09	; 9
    1292:	e7 d7       	rcall	.+4046   	; 0x2262 <usart_spi_select_device>
    1294:	81 e0       	ldi	r24, 0x01	; 1
    1296:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    129a:	e0 ea       	ldi	r30, 0xA0	; 160
    129c:	f9 e0       	ldi	r31, 0x09	; 9
    129e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    12a0:	85 ff       	sbrs	r24, 5
    12a2:	fd cf       	rjmp	.-6      	; 0x129e <st7565r_init+0x2c2>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    12a4:	81 e8       	ldi	r24, 0x81	; 129
    12a6:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    12aa:	e0 ea       	ldi	r30, 0xA0	; 160
    12ac:	f9 e0       	ldi	r31, 0x09	; 9
    12ae:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    12b0:	86 ff       	sbrs	r24, 6
    12b2:	fd cf       	rjmp	.-6      	; 0x12ae <st7565r_init+0x2d2>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    12b4:	e0 ea       	ldi	r30, 0xA0	; 160
    12b6:	f9 e0       	ldi	r31, 0x09	; 9
    12b8:	80 e4       	ldi	r24, 0x40	; 64
    12ba:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    12bc:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    12be:	be 01       	movw	r22, r28
    12c0:	6f 5f       	subi	r22, 0xFF	; 255
    12c2:	7f 4f       	sbci	r23, 0xFF	; 255
    12c4:	80 ea       	ldi	r24, 0xA0	; 160
    12c6:	99 e0       	ldi	r25, 0x09	; 9
    12c8:	e2 d7       	rcall	.+4036   	; 0x228e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    12ca:	8b e2       	ldi	r24, 0x2B	; 43
    12cc:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    12ce:	be 01       	movw	r22, r28
    12d0:	6f 5f       	subi	r22, 0xFF	; 255
    12d2:	7f 4f       	sbci	r23, 0xFF	; 255
    12d4:	80 ea       	ldi	r24, 0xA0	; 160
    12d6:	99 e0       	ldi	r25, 0x09	; 9
    12d8:	c4 d7       	rcall	.+3976   	; 0x2262 <usart_spi_select_device>
    12da:	81 e0       	ldi	r24, 0x01	; 1
    12dc:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    12e0:	e0 ea       	ldi	r30, 0xA0	; 160
    12e2:	f9 e0       	ldi	r31, 0x09	; 9
    12e4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    12e6:	85 ff       	sbrs	r24, 5
    12e8:	fd cf       	rjmp	.-6      	; 0x12e4 <st7565r_init+0x308>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    12ea:	81 e2       	ldi	r24, 0x21	; 33
    12ec:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    12f0:	e0 ea       	ldi	r30, 0xA0	; 160
    12f2:	f9 e0       	ldi	r31, 0x09	; 9
    12f4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    12f6:	86 ff       	sbrs	r24, 6
    12f8:	fd cf       	rjmp	.-6      	; 0x12f4 <st7565r_init+0x318>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    12fa:	e0 ea       	ldi	r30, 0xA0	; 160
    12fc:	f9 e0       	ldi	r31, 0x09	; 9
    12fe:	80 e4       	ldi	r24, 0x40	; 64
    1300:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1302:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1304:	be 01       	movw	r22, r28
    1306:	6f 5f       	subi	r22, 0xFF	; 255
    1308:	7f 4f       	sbci	r23, 0xFF	; 255
    130a:	80 ea       	ldi	r24, 0xA0	; 160
    130c:	99 e0       	ldi	r25, 0x09	; 9
    130e:	bf d7       	rcall	.+3966   	; 0x228e <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1310:	8b e2       	ldi	r24, 0x2B	; 43
    1312:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1314:	be 01       	movw	r22, r28
    1316:	6f 5f       	subi	r22, 0xFF	; 255
    1318:	7f 4f       	sbci	r23, 0xFF	; 255
    131a:	80 ea       	ldi	r24, 0xA0	; 160
    131c:	99 e0       	ldi	r25, 0x09	; 9
    131e:	a1 d7       	rcall	.+3906   	; 0x2262 <usart_spi_select_device>
    1320:	81 e0       	ldi	r24, 0x01	; 1
    1322:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1326:	e0 ea       	ldi	r30, 0xA0	; 160
    1328:	f9 e0       	ldi	r31, 0x09	; 9
    132a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    132c:	85 ff       	sbrs	r24, 5
    132e:	fd cf       	rjmp	.-6      	; 0x132a <st7565r_init+0x34e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1330:	8f ea       	ldi	r24, 0xAF	; 175
    1332:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1336:	e0 ea       	ldi	r30, 0xA0	; 160
    1338:	f9 e0       	ldi	r31, 0x09	; 9
    133a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    133c:	86 ff       	sbrs	r24, 6
    133e:	fd cf       	rjmp	.-6      	; 0x133a <st7565r_init+0x35e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1340:	e0 ea       	ldi	r30, 0xA0	; 160
    1342:	f9 e0       	ldi	r31, 0x09	; 9
    1344:	80 e4       	ldi	r24, 0x40	; 64
    1346:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1348:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    134a:	be 01       	movw	r22, r28
    134c:	6f 5f       	subi	r22, 0xFF	; 255
    134e:	7f 4f       	sbci	r23, 0xFF	; 255
    1350:	80 ea       	ldi	r24, 0xA0	; 160
    1352:	99 e0       	ldi	r25, 0x09	; 9
    1354:	9c d7       	rcall	.+3896   	; 0x228e <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
    1356:	0f 90       	pop	r0
    1358:	df 91       	pop	r29
    135a:	cf 91       	pop	r28
    135c:	1f 91       	pop	r17
    135e:	0f 91       	pop	r16
    1360:	ff 90       	pop	r15
    1362:	ef 90       	pop	r14
    1364:	df 90       	pop	r13
    1366:	cf 90       	pop	r12
    1368:	bf 90       	pop	r11
    136a:	08 95       	ret

0000136c <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
    136c:	ff 92       	push	r15
    136e:	0f 93       	push	r16
    1370:	1f 93       	push	r17
    1372:	cf 93       	push	r28
    1374:	df 93       	push	r29
    1376:	1f 92       	push	r1
    1378:	cd b7       	in	r28, 0x3d	; 61
    137a:	de b7       	in	r29, 0x3e	; 62
    137c:	08 2f       	mov	r16, r24
    137e:	f6 2e       	mov	r15, r22
    1380:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
    1382:	a0 d7       	rcall	.+3904   	; 0x22c4 <gfx_mono_framebuffer_put_byte>
 * \param address the page address
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
    1384:	0f 70       	andi	r16, 0x0F	; 15
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
    1386:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1388:	8b e2       	ldi	r24, 0x2B	; 43
    138a:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    138c:	be 01       	movw	r22, r28
    138e:	6f 5f       	subi	r22, 0xFF	; 255
    1390:	7f 4f       	sbci	r23, 0xFF	; 255
    1392:	80 ea       	ldi	r24, 0xA0	; 160
    1394:	99 e0       	ldi	r25, 0x09	; 9
    1396:	65 d7       	rcall	.+3786   	; 0x2262 <usart_spi_select_device>
    1398:	81 e0       	ldi	r24, 0x01	; 1
    139a:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    139e:	e0 ea       	ldi	r30, 0xA0	; 160
    13a0:	f9 e0       	ldi	r31, 0x09	; 9
    13a2:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    13a4:	95 ff       	sbrs	r25, 5
    13a6:	fd cf       	rjmp	.-6      	; 0x13a2 <gfx_mono_st7565r_put_byte+0x36>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    13a8:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    13ac:	e0 ea       	ldi	r30, 0xA0	; 160
    13ae:	f9 e0       	ldi	r31, 0x09	; 9
    13b0:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    13b2:	86 ff       	sbrs	r24, 6
    13b4:	fd cf       	rjmp	.-6      	; 0x13b0 <gfx_mono_st7565r_put_byte+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    13b6:	e0 ea       	ldi	r30, 0xA0	; 160
    13b8:	f9 e0       	ldi	r31, 0x09	; 9
    13ba:	80 e4       	ldi	r24, 0x40	; 64
    13bc:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    13be:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    13c0:	be 01       	movw	r22, r28
    13c2:	6f 5f       	subi	r22, 0xFF	; 255
    13c4:	7f 4f       	sbci	r23, 0xFF	; 255
    13c6:	80 ea       	ldi	r24, 0xA0	; 160
    13c8:	99 e0       	ldi	r25, 0x09	; 9
    13ca:	61 d7       	rcall	.+3778   	; 0x228e <usart_spi_deselect_device>
 * \param address the column address
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
    13cc:	0f 2d       	mov	r16, r15
    13ce:	0f 77       	andi	r16, 0x7F	; 127
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
    13d0:	02 95       	swap	r16
    13d2:	0f 70       	andi	r16, 0x0F	; 15
    13d4:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    13d6:	8b e2       	ldi	r24, 0x2B	; 43
    13d8:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    13da:	be 01       	movw	r22, r28
    13dc:	6f 5f       	subi	r22, 0xFF	; 255
    13de:	7f 4f       	sbci	r23, 0xFF	; 255
    13e0:	80 ea       	ldi	r24, 0xA0	; 160
    13e2:	99 e0       	ldi	r25, 0x09	; 9
    13e4:	3e d7       	rcall	.+3708   	; 0x2262 <usart_spi_select_device>
    13e6:	81 e0       	ldi	r24, 0x01	; 1
    13e8:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    13ec:	e0 ea       	ldi	r30, 0xA0	; 160
    13ee:	f9 e0       	ldi	r31, 0x09	; 9
    13f0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    13f2:	85 ff       	sbrs	r24, 5
    13f4:	fd cf       	rjmp	.-6      	; 0x13f0 <gfx_mono_st7565r_put_byte+0x84>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    13f6:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    13fa:	e0 ea       	ldi	r30, 0xA0	; 160
    13fc:	f9 e0       	ldi	r31, 0x09	; 9
    13fe:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1400:	86 ff       	sbrs	r24, 6
    1402:	fd cf       	rjmp	.-6      	; 0x13fe <gfx_mono_st7565r_put_byte+0x92>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1404:	e0 ea       	ldi	r30, 0xA0	; 160
    1406:	f9 e0       	ldi	r31, 0x09	; 9
    1408:	80 e4       	ldi	r24, 0x40	; 64
    140a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    140c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    140e:	be 01       	movw	r22, r28
    1410:	6f 5f       	subi	r22, 0xFF	; 255
    1412:	7f 4f       	sbci	r23, 0xFF	; 255
    1414:	80 ea       	ldi	r24, 0xA0	; 160
    1416:	99 e0       	ldi	r25, 0x09	; 9
    1418:	3a d7       	rcall	.+3700   	; 0x228e <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
    141a:	0f 2d       	mov	r16, r15
    141c:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    141e:	8b e2       	ldi	r24, 0x2B	; 43
    1420:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1422:	be 01       	movw	r22, r28
    1424:	6f 5f       	subi	r22, 0xFF	; 255
    1426:	7f 4f       	sbci	r23, 0xFF	; 255
    1428:	80 ea       	ldi	r24, 0xA0	; 160
    142a:	99 e0       	ldi	r25, 0x09	; 9
    142c:	1a d7       	rcall	.+3636   	; 0x2262 <usart_spi_select_device>
    142e:	81 e0       	ldi	r24, 0x01	; 1
    1430:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1434:	e0 ea       	ldi	r30, 0xA0	; 160
    1436:	f9 e0       	ldi	r31, 0x09	; 9
    1438:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    143a:	85 ff       	sbrs	r24, 5
    143c:	fd cf       	rjmp	.-6      	; 0x1438 <gfx_mono_st7565r_put_byte+0xcc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    143e:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1442:	e0 ea       	ldi	r30, 0xA0	; 160
    1444:	f9 e0       	ldi	r31, 0x09	; 9
    1446:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1448:	86 ff       	sbrs	r24, 6
    144a:	fd cf       	rjmp	.-6      	; 0x1446 <gfx_mono_st7565r_put_byte+0xda>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    144c:	e0 ea       	ldi	r30, 0xA0	; 160
    144e:	f9 e0       	ldi	r31, 0x09	; 9
    1450:	80 e4       	ldi	r24, 0x40	; 64
    1452:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1454:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1456:	be 01       	movw	r22, r28
    1458:	6f 5f       	subi	r22, 0xFF	; 255
    145a:	7f 4f       	sbci	r23, 0xFF	; 255
    145c:	80 ea       	ldi	r24, 0xA0	; 160
    145e:	99 e0       	ldi	r25, 0x09	; 9
    1460:	16 d7       	rcall	.+3628   	; 0x228e <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1462:	8b e2       	ldi	r24, 0x2B	; 43
    1464:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1466:	be 01       	movw	r22, r28
    1468:	6f 5f       	subi	r22, 0xFF	; 255
    146a:	7f 4f       	sbci	r23, 0xFF	; 255
    146c:	80 ea       	ldi	r24, 0xA0	; 160
    146e:	99 e0       	ldi	r25, 0x09	; 9
    1470:	f8 d6       	rcall	.+3568   	; 0x2262 <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1472:	81 e0       	ldi	r24, 0x01	; 1
    1474:	80 93 65 06 	sts	0x0665, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1478:	e0 ea       	ldi	r30, 0xA0	; 160
    147a:	f9 e0       	ldi	r31, 0x09	; 9
    147c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    147e:	85 ff       	sbrs	r24, 5
    1480:	fd cf       	rjmp	.-6      	; 0x147c <gfx_mono_st7565r_put_byte+0x110>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1482:	10 93 a0 09 	sts	0x09A0, r17
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1486:	e0 ea       	ldi	r30, 0xA0	; 160
    1488:	f9 e0       	ldi	r31, 0x09	; 9
    148a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    148c:	86 ff       	sbrs	r24, 6
    148e:	fd cf       	rjmp	.-6      	; 0x148a <gfx_mono_st7565r_put_byte+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1490:	e0 ea       	ldi	r30, 0xA0	; 160
    1492:	f9 e0       	ldi	r31, 0x09	; 9
    1494:	80 e4       	ldi	r24, 0x40	; 64
    1496:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1498:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    149a:	81 e0       	ldi	r24, 0x01	; 1
    149c:	80 93 66 06 	sts	0x0666, r24
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    14a0:	be 01       	movw	r22, r28
    14a2:	6f 5f       	subi	r22, 0xFF	; 255
    14a4:	7f 4f       	sbci	r23, 0xFF	; 255
    14a6:	80 ea       	ldi	r24, 0xA0	; 160
    14a8:	99 e0       	ldi	r25, 0x09	; 9
    14aa:	f1 d6       	rcall	.+3554   	; 0x228e <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
    14ac:	0f 90       	pop	r0
    14ae:	df 91       	pop	r29
    14b0:	cf 91       	pop	r28
    14b2:	1f 91       	pop	r17
    14b4:	0f 91       	pop	r16
    14b6:	ff 90       	pop	r15
    14b8:	08 95       	ret

000014ba <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
    14ba:	0f 93       	push	r16
    14bc:	1f 93       	push	r17
    14be:	cf 93       	push	r28
    14c0:	df 93       	push	r29
    14c2:	1f 92       	push	r1
    14c4:	cd b7       	in	r28, 0x3d	; 61
    14c6:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
    14c8:	8b e1       	ldi	r24, 0x1B	; 27
    14ca:	92 e2       	ldi	r25, 0x22	; 34
    14cc:	f6 d6       	rcall	.+3564   	; 0x22ba <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
    14ce:	86 dd       	rcall	.-1268   	; 0xfdc <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    14d0:	8b e2       	ldi	r24, 0x2B	; 43
    14d2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    14d4:	be 01       	movw	r22, r28
    14d6:	6f 5f       	subi	r22, 0xFF	; 255
    14d8:	7f 4f       	sbci	r23, 0xFF	; 255
    14da:	80 ea       	ldi	r24, 0xA0	; 160
    14dc:	99 e0       	ldi	r25, 0x09	; 9
    14de:	c1 d6       	rcall	.+3458   	; 0x2262 <usart_spi_select_device>
    14e0:	81 e0       	ldi	r24, 0x01	; 1
    14e2:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    14e6:	e0 ea       	ldi	r30, 0xA0	; 160
    14e8:	f9 e0       	ldi	r31, 0x09	; 9
    14ea:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    14ec:	85 ff       	sbrs	r24, 5
    14ee:	fd cf       	rjmp	.-6      	; 0x14ea <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    14f0:	80 e4       	ldi	r24, 0x40	; 64
    14f2:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    14f6:	e0 ea       	ldi	r30, 0xA0	; 160
    14f8:	f9 e0       	ldi	r31, 0x09	; 9
    14fa:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    14fc:	86 ff       	sbrs	r24, 6
    14fe:	fd cf       	rjmp	.-6      	; 0x14fa <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1500:	e0 ea       	ldi	r30, 0xA0	; 160
    1502:	f9 e0       	ldi	r31, 0x09	; 9
    1504:	80 e4       	ldi	r24, 0x40	; 64
    1506:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1508:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    150a:	be 01       	movw	r22, r28
    150c:	6f 5f       	subi	r22, 0xFF	; 255
    150e:	7f 4f       	sbci	r23, 0xFF	; 255
    1510:	80 ea       	ldi	r24, 0xA0	; 160
    1512:	99 e0       	ldi	r25, 0x09	; 9
    1514:	bc d6       	rcall	.+3448   	; 0x228e <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    1516:	00 e0       	ldi	r16, 0x00	; 0
    1518:	0a c0       	rjmp	.+20     	; 0x152e <gfx_mono_st7565r_init+0x74>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
    151a:	40 e0       	ldi	r20, 0x00	; 0
    151c:	61 2f       	mov	r22, r17
    151e:	80 2f       	mov	r24, r16
    1520:	25 df       	rcall	.-438    	; 0x136c <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
    1522:	1f 5f       	subi	r17, 0xFF	; 255
    1524:	10 38       	cpi	r17, 0x80	; 128
    1526:	c9 f7       	brne	.-14     	; 0x151a <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    1528:	0f 5f       	subi	r16, 0xFF	; 255
    152a:	04 30       	cpi	r16, 0x04	; 4
    152c:	11 f0       	breq	.+4      	; 0x1532 <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
    152e:	10 e0       	ldi	r17, 0x00	; 0
    1530:	f4 cf       	rjmp	.-24     	; 0x151a <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
    1532:	0f 90       	pop	r0
    1534:	df 91       	pop	r29
    1536:	cf 91       	pop	r28
    1538:	1f 91       	pop	r17
    153a:	0f 91       	pop	r16
    153c:	08 95       	ret

0000153e <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
    153e:	ff 92       	push	r15
    1540:	0f 93       	push	r16
    1542:	1f 93       	push	r17
    1544:	cf 93       	push	r28
    1546:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
    1548:	88 23       	and	r24, r24
    154a:	8c f1       	brlt	.+98     	; 0x15ae <gfx_mono_st7565r_draw_pixel+0x70>
    154c:	60 32       	cpi	r22, 0x20	; 32
    154e:	78 f5       	brcc	.+94     	; 0x15ae <gfx_mono_st7565r_draw_pixel+0x70>
    1550:	d4 2f       	mov	r29, r20
    1552:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
    1554:	f6 2e       	mov	r15, r22
    1556:	f6 94       	lsr	r15
    1558:	f6 94       	lsr	r15
    155a:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
    155c:	2f 2d       	mov	r18, r15
    155e:	30 e0       	ldi	r19, 0x00	; 0
    1560:	31 95       	neg	r19
    1562:	21 95       	neg	r18
    1564:	31 09       	sbc	r19, r1
    1566:	22 0f       	add	r18, r18
    1568:	33 1f       	adc	r19, r19
    156a:	22 0f       	add	r18, r18
    156c:	33 1f       	adc	r19, r19
    156e:	22 0f       	add	r18, r18
    1570:	33 1f       	adc	r19, r19
    1572:	26 0f       	add	r18, r22
    1574:	31 1d       	adc	r19, r1
    1576:	61 e0       	ldi	r22, 0x01	; 1
    1578:	70 e0       	ldi	r23, 0x00	; 0
    157a:	8b 01       	movw	r16, r22
    157c:	02 c0       	rjmp	.+4      	; 0x1582 <gfx_mono_st7565r_draw_pixel+0x44>
    157e:	00 0f       	add	r16, r16
    1580:	11 1f       	adc	r17, r17
    1582:	2a 95       	dec	r18
    1584:	e2 f7       	brpl	.-8      	; 0x157e <gfx_mono_st7565r_draw_pixel+0x40>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
    1586:	68 2f       	mov	r22, r24
    1588:	8f 2d       	mov	r24, r15
    158a:	aa d6       	rcall	.+3412   	; 0x22e0 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
    158c:	d1 30       	cpi	r29, 0x01	; 1
    158e:	21 f0       	breq	.+8      	; 0x1598 <gfx_mono_st7565r_draw_pixel+0x5a>
    1590:	28 f0       	brcs	.+10     	; 0x159c <gfx_mono_st7565r_draw_pixel+0x5e>
    1592:	d2 30       	cpi	r29, 0x02	; 2
    1594:	39 f0       	breq	.+14     	; 0x15a4 <gfx_mono_st7565r_draw_pixel+0x66>
    1596:	07 c0       	rjmp	.+14     	; 0x15a6 <gfx_mono_st7565r_draw_pixel+0x68>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
    1598:	80 2b       	or	r24, r16
		break;
    159a:	05 c0       	rjmp	.+10     	; 0x15a6 <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
    159c:	60 2f       	mov	r22, r16
    159e:	60 95       	com	r22
    15a0:	86 23       	and	r24, r22
		break;
    15a2:	01 c0       	rjmp	.+2      	; 0x15a6 <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
    15a4:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
    15a6:	48 2f       	mov	r20, r24
    15a8:	6c 2f       	mov	r22, r28
    15aa:	8f 2d       	mov	r24, r15
    15ac:	df de       	rcall	.-578    	; 0x136c <gfx_mono_st7565r_put_byte>
}
    15ae:	df 91       	pop	r29
    15b0:	cf 91       	pop	r28
    15b2:	1f 91       	pop	r17
    15b4:	0f 91       	pop	r16
    15b6:	ff 90       	pop	r15
    15b8:	08 95       	ret

000015ba <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
    15ba:	92 c6       	rjmp	.+3364   	; 0x22e0 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
    15bc:	08 95       	ret

000015be <tb_init>:


uint16_t qt_measurement_period_msec = 25;

void tb_init(void) {
	qt_config_data.qt_di				= DEF_QT_DI;
    15be:	e5 ed       	ldi	r30, 0xD5	; 213
    15c0:	f1 e2       	ldi	r31, 0x21	; 33
    15c2:	84 e0       	ldi	r24, 0x04	; 4
    15c4:	81 83       	std	Z+1, r24	; 0x01
	qt_config_data.qt_neg_drift_rate	= DEF_QT_NEG_DRIFT_RATE;
    15c6:	84 e1       	ldi	r24, 0x14	; 20
    15c8:	84 83       	std	Z+4, r24	; 0x04
	qt_config_data.qt_pos_drift_rate	= DEF_QT_POS_DRIFT_RATE;
    15ca:	95 e0       	ldi	r25, 0x05	; 5
    15cc:	95 83       	std	Z+5, r25	; 0x05
	qt_config_data.qt_max_on_duration	= DEF_QT_MAX_ON_DURATION;
    15ce:	13 82       	std	Z+3, r1	; 0x03
	qt_config_data.qt_drift_hold_time	= DEF_QT_DRIFT_HOLD_TIME;
    15d0:	82 83       	std	Z+2, r24	; 0x02
	qt_config_data.qt_recal_threshold	= DEF_QT_RECAL_THRESHOLD;
    15d2:	81 e0       	ldi	r24, 0x01	; 1
    15d4:	80 83       	st	Z, r24
	qt_config_data.qt_pos_recal_delay	= DEF_QT_POS_RECAL_DELAY;
    15d6:	83 e0       	ldi	r24, 0x03	; 3
    15d8:	86 83       	std	Z+6, r24	; 0x06
	qt_filter_callback					= 0;
    15da:	10 92 ef 21 	sts	0x21EF, r1
    15de:	10 92 f0 21 	sts	0x21F0, r1


	#ifdef QTOUCH_STUDIO_MASKS
		SNS_array[0][0] = 0x40;
    15e2:	e3 e1       	ldi	r30, 0x13	; 19
    15e4:	f2 e2       	ldi	r31, 0x22	; 34
    15e6:	80 e4       	ldi	r24, 0x40	; 64
    15e8:	80 83       	st	Z, r24
		SNS_array[0][1] = 0x0;
    15ea:	11 82       	std	Z+1, r1	; 0x01
		SNS_array[1][0] = 0x0;
    15ec:	12 82       	std	Z+2, r1	; 0x02
		SNS_array[1][1] = 0x0;
    15ee:	13 82       	std	Z+3, r1	; 0x03

		SNSK_array[0][0] = 0x80;
    15f0:	e7 e1       	ldi	r30, 0x17	; 23
    15f2:	f2 e2       	ldi	r31, 0x22	; 34
    15f4:	80 e8       	ldi	r24, 0x80	; 128
    15f6:	80 83       	st	Z, r24
		SNSK_array[0][1] = 0x0;
    15f8:	11 82       	std	Z+1, r1	; 0x01
		SNSK_array[1][0] = 0x0;
    15fa:	12 82       	std	Z+2, r1	; 0x02
		SNSK_array[1][1] = 0x0;
    15fc:	13 82       	std	Z+3, r1	; 0x03
	 * When using "pin configurability" this will result in channel 0
	 * because it is the first and only channel that is used.
	 * For the standard qtouch library setup we would need to use
	 * channel 3 since we are using the last two pins on the port.
	 */
	qt_enable_key(CHANNEL_0, NO_AKS_GROUP, 10, HYST_6_25);
    15fe:	23 e0       	ldi	r18, 0x03	; 3
    1600:	4a e0       	ldi	r20, 0x0A	; 10
    1602:	60 e0       	ldi	r22, 0x00	; 0
    1604:	80 e0       	ldi	r24, 0x00	; 0
    1606:	68 d8       	rcall	.-3888   	; 0x6d8 <qt_enable_key>

	qt_init_sensing();
    1608:	60 e0       	ldi	r22, 0x00	; 0
    160a:	70 e0       	ldi	r23, 0x00	; 0
    160c:	87 e8       	ldi	r24, 0x87	; 135
    160e:	92 e0       	ldi	r25, 0x02	; 2
    1610:	74 c9       	rjmp	.-3352   	; 0x8fa <qt_init_sensing_with_burst>
    1612:	08 95       	ret

00001614 <tb_is_touched>:
}


bool tb_is_touched(void) {
    1614:	cf 93       	push	r28
    1616:	df 93       	push	r29
	
	static int16_t last = 0;
	int16_t now = getUptimeMs();
    1618:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <xTaskGetTickCount>
    161c:	ec 01       	movw	r28, r24
    161e:	cc 0f       	add	r28, r28
    1620:	dd 1f       	adc	r29, r29
	
	if(now - last >= 25) {
    1622:	80 91 1b 24 	lds	r24, 0x241B
    1626:	90 91 1c 24 	lds	r25, 0x241C
    162a:	9e 01       	movw	r18, r28
    162c:	28 1b       	sub	r18, r24
    162e:	39 0b       	sbc	r19, r25
    1630:	29 31       	cpi	r18, 0x19	; 25
    1632:	31 05       	cpc	r19, r1
    1634:	5c f0       	brlt	.+22     	; 0x164c <tb_is_touched+0x38>
		while(qt_measure_sensors(getUptimeMs()) & QTLIB_BURST_AGAIN);
    1636:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <xTaskGetTickCount>
    163a:	88 0f       	add	r24, r24
    163c:	99 1f       	adc	r25, r25
    163e:	bc d8       	rcall	.-3720   	; 0x7b8 <qt_measure_sensors>
    1640:	90 fd       	sbrc	r25, 0
    1642:	f9 cf       	rjmp	.-14     	; 0x1636 <tb_is_touched+0x22>
		last = now;
    1644:	c0 93 1b 24 	sts	0x241B, r28
    1648:	d0 93 1c 24 	sts	0x241C, r29
	}
	
	if (GET_SENSOR_STATE(0)) {
    164c:	80 91 ec 21 	lds	r24, 0x21EC
    1650:	80 95       	com	r24
		return 0;
	} else {
		return 1;
	}
    1652:	81 70       	andi	r24, 0x01	; 1
    1654:	df 91       	pop	r29
    1656:	cf 91       	pop	r28
    1658:	08 95       	ret

0000165a <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
    165a:	1f 92       	push	r1
    165c:	0f 92       	push	r0
    165e:	0f b6       	in	r0, 0x3f	; 63
    1660:	0f 92       	push	r0
    1662:	11 24       	eor	r1, r1
    1664:	0b b6       	in	r0, 0x3b	; 59
    1666:	0f 92       	push	r0
    1668:	2f 93       	push	r18
    166a:	3f 93       	push	r19
    166c:	4f 93       	push	r20
    166e:	5f 93       	push	r21
    1670:	6f 93       	push	r22
    1672:	7f 93       	push	r23
    1674:	8f 93       	push	r24
    1676:	9f 93       	push	r25
    1678:	af 93       	push	r26
    167a:	bf 93       	push	r27
    167c:	ef 93       	push	r30
    167e:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
    1680:	40 91 24 02 	lds	r20, 0x0224
    1684:	50 91 25 02 	lds	r21, 0x0225
    1688:	e0 91 46 25 	lds	r30, 0x2546
    168c:	f0 91 47 25 	lds	r31, 0x2547
    1690:	61 e0       	ldi	r22, 0x01	; 1
    1692:	80 e0       	ldi	r24, 0x00	; 0
    1694:	92 e0       	ldi	r25, 0x02	; 2
    1696:	19 95       	eicall
}
    1698:	ff 91       	pop	r31
    169a:	ef 91       	pop	r30
    169c:	bf 91       	pop	r27
    169e:	af 91       	pop	r26
    16a0:	9f 91       	pop	r25
    16a2:	8f 91       	pop	r24
    16a4:	7f 91       	pop	r23
    16a6:	6f 91       	pop	r22
    16a8:	5f 91       	pop	r21
    16aa:	4f 91       	pop	r20
    16ac:	3f 91       	pop	r19
    16ae:	2f 91       	pop	r18
    16b0:	0f 90       	pop	r0
    16b2:	0b be       	out	0x3b, r0	; 59
    16b4:	0f 90       	pop	r0
    16b6:	0f be       	out	0x3f, r0	; 63
    16b8:	0f 90       	pop	r0
    16ba:	1f 90       	pop	r1
    16bc:	18 95       	reti

000016be <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
    16be:	1f 92       	push	r1
    16c0:	0f 92       	push	r0
    16c2:	0f b6       	in	r0, 0x3f	; 63
    16c4:	0f 92       	push	r0
    16c6:	11 24       	eor	r1, r1
    16c8:	0b b6       	in	r0, 0x3b	; 59
    16ca:	0f 92       	push	r0
    16cc:	2f 93       	push	r18
    16ce:	3f 93       	push	r19
    16d0:	4f 93       	push	r20
    16d2:	5f 93       	push	r21
    16d4:	6f 93       	push	r22
    16d6:	7f 93       	push	r23
    16d8:	8f 93       	push	r24
    16da:	9f 93       	push	r25
    16dc:	af 93       	push	r26
    16de:	bf 93       	push	r27
    16e0:	ef 93       	push	r30
    16e2:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
    16e4:	40 91 2c 02 	lds	r20, 0x022C
    16e8:	50 91 2d 02 	lds	r21, 0x022D
    16ec:	e0 91 46 25 	lds	r30, 0x2546
    16f0:	f0 91 47 25 	lds	r31, 0x2547
    16f4:	62 e0       	ldi	r22, 0x02	; 2
    16f6:	80 e0       	ldi	r24, 0x00	; 0
    16f8:	92 e0       	ldi	r25, 0x02	; 2
    16fa:	19 95       	eicall
}
    16fc:	ff 91       	pop	r31
    16fe:	ef 91       	pop	r30
    1700:	bf 91       	pop	r27
    1702:	af 91       	pop	r26
    1704:	9f 91       	pop	r25
    1706:	8f 91       	pop	r24
    1708:	7f 91       	pop	r23
    170a:	6f 91       	pop	r22
    170c:	5f 91       	pop	r21
    170e:	4f 91       	pop	r20
    1710:	3f 91       	pop	r19
    1712:	2f 91       	pop	r18
    1714:	0f 90       	pop	r0
    1716:	0b be       	out	0x3b, r0	; 59
    1718:	0f 90       	pop	r0
    171a:	0f be       	out	0x3f, r0	; 63
    171c:	0f 90       	pop	r0
    171e:	1f 90       	pop	r1
    1720:	18 95       	reti

00001722 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
    1722:	1f 92       	push	r1
    1724:	0f 92       	push	r0
    1726:	0f b6       	in	r0, 0x3f	; 63
    1728:	0f 92       	push	r0
    172a:	11 24       	eor	r1, r1
    172c:	0b b6       	in	r0, 0x3b	; 59
    172e:	0f 92       	push	r0
    1730:	2f 93       	push	r18
    1732:	3f 93       	push	r19
    1734:	4f 93       	push	r20
    1736:	5f 93       	push	r21
    1738:	6f 93       	push	r22
    173a:	7f 93       	push	r23
    173c:	8f 93       	push	r24
    173e:	9f 93       	push	r25
    1740:	af 93       	push	r26
    1742:	bf 93       	push	r27
    1744:	ef 93       	push	r30
    1746:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
    1748:	40 91 34 02 	lds	r20, 0x0234
    174c:	50 91 35 02 	lds	r21, 0x0235
    1750:	e0 91 46 25 	lds	r30, 0x2546
    1754:	f0 91 47 25 	lds	r31, 0x2547
    1758:	64 e0       	ldi	r22, 0x04	; 4
    175a:	80 e0       	ldi	r24, 0x00	; 0
    175c:	92 e0       	ldi	r25, 0x02	; 2
    175e:	19 95       	eicall
}
    1760:	ff 91       	pop	r31
    1762:	ef 91       	pop	r30
    1764:	bf 91       	pop	r27
    1766:	af 91       	pop	r26
    1768:	9f 91       	pop	r25
    176a:	8f 91       	pop	r24
    176c:	7f 91       	pop	r23
    176e:	6f 91       	pop	r22
    1770:	5f 91       	pop	r21
    1772:	4f 91       	pop	r20
    1774:	3f 91       	pop	r19
    1776:	2f 91       	pop	r18
    1778:	0f 90       	pop	r0
    177a:	0b be       	out	0x3b, r0	; 59
    177c:	0f 90       	pop	r0
    177e:	0f be       	out	0x3f, r0	; 63
    1780:	0f 90       	pop	r0
    1782:	1f 90       	pop	r1
    1784:	18 95       	reti

00001786 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    1786:	1f 92       	push	r1
    1788:	0f 92       	push	r0
    178a:	0f b6       	in	r0, 0x3f	; 63
    178c:	0f 92       	push	r0
    178e:	11 24       	eor	r1, r1
    1790:	0b b6       	in	r0, 0x3b	; 59
    1792:	0f 92       	push	r0
    1794:	2f 93       	push	r18
    1796:	3f 93       	push	r19
    1798:	4f 93       	push	r20
    179a:	5f 93       	push	r21
    179c:	6f 93       	push	r22
    179e:	7f 93       	push	r23
    17a0:	8f 93       	push	r24
    17a2:	9f 93       	push	r25
    17a4:	af 93       	push	r26
    17a6:	bf 93       	push	r27
    17a8:	ef 93       	push	r30
    17aa:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    17ac:	40 91 3c 02 	lds	r20, 0x023C
    17b0:	50 91 3d 02 	lds	r21, 0x023D
    17b4:	e0 91 46 25 	lds	r30, 0x2546
    17b8:	f0 91 47 25 	lds	r31, 0x2547
    17bc:	68 e0       	ldi	r22, 0x08	; 8
    17be:	80 e0       	ldi	r24, 0x00	; 0
    17c0:	92 e0       	ldi	r25, 0x02	; 2
    17c2:	19 95       	eicall
}
    17c4:	ff 91       	pop	r31
    17c6:	ef 91       	pop	r30
    17c8:	bf 91       	pop	r27
    17ca:	af 91       	pop	r26
    17cc:	9f 91       	pop	r25
    17ce:	8f 91       	pop	r24
    17d0:	7f 91       	pop	r23
    17d2:	6f 91       	pop	r22
    17d4:	5f 91       	pop	r21
    17d6:	4f 91       	pop	r20
    17d8:	3f 91       	pop	r19
    17da:	2f 91       	pop	r18
    17dc:	0f 90       	pop	r0
    17de:	0b be       	out	0x3b, r0	; 59
    17e0:	0f 90       	pop	r0
    17e2:	0f be       	out	0x3f, r0	; 63
    17e4:	0f 90       	pop	r0
    17e6:	1f 90       	pop	r1
    17e8:	18 95       	reti

000017ea <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    17ea:	1f 92       	push	r1
    17ec:	0f 92       	push	r0
    17ee:	0f b6       	in	r0, 0x3f	; 63
    17f0:	0f 92       	push	r0
    17f2:	11 24       	eor	r1, r1
    17f4:	0b b6       	in	r0, 0x3b	; 59
    17f6:	0f 92       	push	r0
    17f8:	2f 93       	push	r18
    17fa:	3f 93       	push	r19
    17fc:	4f 93       	push	r20
    17fe:	5f 93       	push	r21
    1800:	6f 93       	push	r22
    1802:	7f 93       	push	r23
    1804:	8f 93       	push	r24
    1806:	9f 93       	push	r25
    1808:	af 93       	push	r26
    180a:	bf 93       	push	r27
    180c:	ef 93       	push	r30
    180e:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1810:	40 91 64 02 	lds	r20, 0x0264
    1814:	50 91 65 02 	lds	r21, 0x0265
    1818:	e0 91 44 25 	lds	r30, 0x2544
    181c:	f0 91 45 25 	lds	r31, 0x2545
    1820:	61 e0       	ldi	r22, 0x01	; 1
    1822:	80 e4       	ldi	r24, 0x40	; 64
    1824:	92 e0       	ldi	r25, 0x02	; 2
    1826:	19 95       	eicall
}
    1828:	ff 91       	pop	r31
    182a:	ef 91       	pop	r30
    182c:	bf 91       	pop	r27
    182e:	af 91       	pop	r26
    1830:	9f 91       	pop	r25
    1832:	8f 91       	pop	r24
    1834:	7f 91       	pop	r23
    1836:	6f 91       	pop	r22
    1838:	5f 91       	pop	r21
    183a:	4f 91       	pop	r20
    183c:	3f 91       	pop	r19
    183e:	2f 91       	pop	r18
    1840:	0f 90       	pop	r0
    1842:	0b be       	out	0x3b, r0	; 59
    1844:	0f 90       	pop	r0
    1846:	0f be       	out	0x3f, r0	; 63
    1848:	0f 90       	pop	r0
    184a:	1f 90       	pop	r1
    184c:	18 95       	reti

0000184e <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    184e:	1f 92       	push	r1
    1850:	0f 92       	push	r0
    1852:	0f b6       	in	r0, 0x3f	; 63
    1854:	0f 92       	push	r0
    1856:	11 24       	eor	r1, r1
    1858:	0b b6       	in	r0, 0x3b	; 59
    185a:	0f 92       	push	r0
    185c:	2f 93       	push	r18
    185e:	3f 93       	push	r19
    1860:	4f 93       	push	r20
    1862:	5f 93       	push	r21
    1864:	6f 93       	push	r22
    1866:	7f 93       	push	r23
    1868:	8f 93       	push	r24
    186a:	9f 93       	push	r25
    186c:	af 93       	push	r26
    186e:	bf 93       	push	r27
    1870:	ef 93       	push	r30
    1872:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    1874:	40 91 6c 02 	lds	r20, 0x026C
    1878:	50 91 6d 02 	lds	r21, 0x026D
    187c:	e0 91 44 25 	lds	r30, 0x2544
    1880:	f0 91 45 25 	lds	r31, 0x2545
    1884:	62 e0       	ldi	r22, 0x02	; 2
    1886:	80 e4       	ldi	r24, 0x40	; 64
    1888:	92 e0       	ldi	r25, 0x02	; 2
    188a:	19 95       	eicall
}
    188c:	ff 91       	pop	r31
    188e:	ef 91       	pop	r30
    1890:	bf 91       	pop	r27
    1892:	af 91       	pop	r26
    1894:	9f 91       	pop	r25
    1896:	8f 91       	pop	r24
    1898:	7f 91       	pop	r23
    189a:	6f 91       	pop	r22
    189c:	5f 91       	pop	r21
    189e:	4f 91       	pop	r20
    18a0:	3f 91       	pop	r19
    18a2:	2f 91       	pop	r18
    18a4:	0f 90       	pop	r0
    18a6:	0b be       	out	0x3b, r0	; 59
    18a8:	0f 90       	pop	r0
    18aa:	0f be       	out	0x3f, r0	; 63
    18ac:	0f 90       	pop	r0
    18ae:	1f 90       	pop	r1
    18b0:	18 95       	reti

000018b2 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    18b2:	1f 92       	push	r1
    18b4:	0f 92       	push	r0
    18b6:	0f b6       	in	r0, 0x3f	; 63
    18b8:	0f 92       	push	r0
    18ba:	11 24       	eor	r1, r1
    18bc:	0b b6       	in	r0, 0x3b	; 59
    18be:	0f 92       	push	r0
    18c0:	2f 93       	push	r18
    18c2:	3f 93       	push	r19
    18c4:	4f 93       	push	r20
    18c6:	5f 93       	push	r21
    18c8:	6f 93       	push	r22
    18ca:	7f 93       	push	r23
    18cc:	8f 93       	push	r24
    18ce:	9f 93       	push	r25
    18d0:	af 93       	push	r26
    18d2:	bf 93       	push	r27
    18d4:	ef 93       	push	r30
    18d6:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    18d8:	40 91 74 02 	lds	r20, 0x0274
    18dc:	50 91 75 02 	lds	r21, 0x0275
    18e0:	e0 91 44 25 	lds	r30, 0x2544
    18e4:	f0 91 45 25 	lds	r31, 0x2545
    18e8:	64 e0       	ldi	r22, 0x04	; 4
    18ea:	80 e4       	ldi	r24, 0x40	; 64
    18ec:	92 e0       	ldi	r25, 0x02	; 2
    18ee:	19 95       	eicall
}
    18f0:	ff 91       	pop	r31
    18f2:	ef 91       	pop	r30
    18f4:	bf 91       	pop	r27
    18f6:	af 91       	pop	r26
    18f8:	9f 91       	pop	r25
    18fa:	8f 91       	pop	r24
    18fc:	7f 91       	pop	r23
    18fe:	6f 91       	pop	r22
    1900:	5f 91       	pop	r21
    1902:	4f 91       	pop	r20
    1904:	3f 91       	pop	r19
    1906:	2f 91       	pop	r18
    1908:	0f 90       	pop	r0
    190a:	0b be       	out	0x3b, r0	; 59
    190c:	0f 90       	pop	r0
    190e:	0f be       	out	0x3f, r0	; 63
    1910:	0f 90       	pop	r0
    1912:	1f 90       	pop	r1
    1914:	18 95       	reti

00001916 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1916:	1f 92       	push	r1
    1918:	0f 92       	push	r0
    191a:	0f b6       	in	r0, 0x3f	; 63
    191c:	0f 92       	push	r0
    191e:	11 24       	eor	r1, r1
    1920:	0b b6       	in	r0, 0x3b	; 59
    1922:	0f 92       	push	r0
    1924:	2f 93       	push	r18
    1926:	3f 93       	push	r19
    1928:	4f 93       	push	r20
    192a:	5f 93       	push	r21
    192c:	6f 93       	push	r22
    192e:	7f 93       	push	r23
    1930:	8f 93       	push	r24
    1932:	9f 93       	push	r25
    1934:	af 93       	push	r26
    1936:	bf 93       	push	r27
    1938:	ef 93       	push	r30
    193a:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    193c:	40 91 7c 02 	lds	r20, 0x027C
    1940:	50 91 7d 02 	lds	r21, 0x027D
    1944:	e0 91 44 25 	lds	r30, 0x2544
    1948:	f0 91 45 25 	lds	r31, 0x2545
    194c:	68 e0       	ldi	r22, 0x08	; 8
    194e:	80 e4       	ldi	r24, 0x40	; 64
    1950:	92 e0       	ldi	r25, 0x02	; 2
    1952:	19 95       	eicall
}
    1954:	ff 91       	pop	r31
    1956:	ef 91       	pop	r30
    1958:	bf 91       	pop	r27
    195a:	af 91       	pop	r26
    195c:	9f 91       	pop	r25
    195e:	8f 91       	pop	r24
    1960:	7f 91       	pop	r23
    1962:	6f 91       	pop	r22
    1964:	5f 91       	pop	r21
    1966:	4f 91       	pop	r20
    1968:	3f 91       	pop	r19
    196a:	2f 91       	pop	r18
    196c:	0f 90       	pop	r0
    196e:	0b be       	out	0x3b, r0	; 59
    1970:	0f 90       	pop	r0
    1972:	0f be       	out	0x3f, r0	; 63
    1974:	0f 90       	pop	r0
    1976:	1f 90       	pop	r1
    1978:	18 95       	reti

0000197a <usart_set_baudrate>:
 * \retval true if the hardware supports the baud rate
 * \retval false if the hardware does not support the baud rate (i.e. it's
 *               either too high or too low.)
 */
bool usart_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    197a:	2f 92       	push	r2
    197c:	3f 92       	push	r3
    197e:	4f 92       	push	r4
    1980:	5f 92       	push	r5
    1982:	6f 92       	push	r6
    1984:	7f 92       	push	r7
    1986:	8f 92       	push	r8
    1988:	9f 92       	push	r9
    198a:	af 92       	push	r10
    198c:	bf 92       	push	r11
    198e:	cf 92       	push	r12
    1990:	df 92       	push	r13
    1992:	ef 92       	push	r14
    1994:	ff 92       	push	r15
    1996:	0f 93       	push	r16
    1998:	1f 93       	push	r17
    199a:	cf 93       	push	r28
    199c:	1c 01       	movw	r2, r24
    199e:	2a 01       	movw	r4, r20
    19a0:	3b 01       	movw	r6, r22
    19a2:	48 01       	movw	r8, r16
    19a4:	59 01       	movw	r10, r18

	/*
	 * Check if the hardware supports the given baud rate
	 */
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
    19a6:	d9 01       	movw	r26, r18
    19a8:	c8 01       	movw	r24, r16
    19aa:	68 94       	set
    19ac:	12 f8       	bld	r1, 2
    19ae:	b6 95       	lsr	r27
    19b0:	a7 95       	ror	r26
    19b2:	97 95       	ror	r25
    19b4:	87 95       	ror	r24
    19b6:	16 94       	lsr	r1
    19b8:	d1 f7       	brne	.-12     	; 0x19ae <usart_set_baudrate+0x34>
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;
    19ba:	b9 01       	movw	r22, r18
    19bc:	a8 01       	movw	r20, r16
    19be:	03 2e       	mov	r0, r19
    19c0:	36 e1       	ldi	r19, 0x16	; 22
    19c2:	76 95       	lsr	r23
    19c4:	67 95       	ror	r22
    19c6:	57 95       	ror	r21
    19c8:	47 95       	ror	r20
    19ca:	3a 95       	dec	r19
    19cc:	d1 f7       	brne	.-12     	; 0x19c2 <usart_set_baudrate+0x48>
    19ce:	30 2d       	mov	r19, r0

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    19d0:	f1 01       	movw	r30, r2
    19d2:	24 81       	ldd	r18, Z+4	; 0x04
    19d4:	22 fd       	sbrc	r18, 2
    19d6:	08 c0       	rjmp	.+16     	; 0x19e8 <usart_set_baudrate+0x6e>
		max_rate /= 2;
    19d8:	b6 95       	lsr	r27
    19da:	a7 95       	ror	r26
    19dc:	97 95       	ror	r25
    19de:	87 95       	ror	r24
		min_rate /= 2;
    19e0:	76 95       	lsr	r23
    19e2:	67 95       	ror	r22
    19e4:	57 95       	ror	r21
    19e6:	47 95       	ror	r20
	}

	if ((baud > max_rate) || (baud < min_rate)) {
    19e8:	84 15       	cp	r24, r4
    19ea:	95 05       	cpc	r25, r5
    19ec:	a6 05       	cpc	r26, r6
    19ee:	b7 05       	cpc	r27, r7
    19f0:	08 f4       	brcc	.+2      	; 0x19f4 <usart_set_baudrate+0x7a>
    19f2:	ae c0       	rjmp	.+348    	; 0x1b50 <usart_set_baudrate+0x1d6>
    19f4:	44 16       	cp	r4, r20
    19f6:	55 06       	cpc	r5, r21
    19f8:	66 06       	cpc	r6, r22
    19fa:	77 06       	cpc	r7, r23
    19fc:	08 f4       	brcc	.+2      	; 0x1a00 <usart_set_baudrate+0x86>
    19fe:	aa c0       	rjmp	.+340    	; 0x1b54 <usart_set_baudrate+0x1da>
		return false;
	}

	/* Check if double speed is enabled. */
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    1a00:	f1 01       	movw	r30, r2
    1a02:	84 81       	ldd	r24, Z+4	; 0x04
    1a04:	82 fd       	sbrc	r24, 2
    1a06:	04 c0       	rjmp	.+8      	; 0x1a10 <usart_set_baudrate+0x96>
		baud *= 2;
    1a08:	44 0c       	add	r4, r4
    1a0a:	55 1c       	adc	r5, r5
    1a0c:	66 1c       	adc	r6, r6
    1a0e:	77 1c       	adc	r7, r7
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;
    1a10:	c5 01       	movw	r24, r10
    1a12:	b4 01       	movw	r22, r8
    1a14:	a3 01       	movw	r20, r6
    1a16:	92 01       	movw	r18, r4
    1a18:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <__udivmodsi4>

	for (exp = -7; exp < 7; exp++) {
		if (ratio < limit) {
    1a1c:	2f 3f       	cpi	r18, 0xFF	; 255
    1a1e:	31 05       	cpc	r19, r1
    1a20:	41 05       	cpc	r20, r1
    1a22:	51 05       	cpc	r21, r1
    1a24:	08 f4       	brcc	.+2      	; 0x1a28 <usart_set_baudrate+0xae>
    1a26:	98 c0       	rjmp	.+304    	; 0x1b58 <usart_set_baudrate+0x1de>
    1a28:	c1 2c       	mov	r12, r1
    1a2a:	d1 2c       	mov	r13, r1
    1a2c:	76 01       	movw	r14, r12
    1a2e:	ca 94       	dec	r12
    1a30:	c9 ef       	ldi	r28, 0xF9	; 249
    1a32:	05 c0       	rjmp	.+10     	; 0x1a3e <usart_set_baudrate+0xc4>
    1a34:	2c 15       	cp	r18, r12
    1a36:	3d 05       	cpc	r19, r13
    1a38:	4e 05       	cpc	r20, r14
    1a3a:	5f 05       	cpc	r21, r15
    1a3c:	68 f0       	brcs	.+26     	; 0x1a58 <usart_set_baudrate+0xde>
			break;
		}

		limit <<= 1;
    1a3e:	cc 0c       	add	r12, r12
    1a40:	dd 1c       	adc	r13, r13
    1a42:	ee 1c       	adc	r14, r14
    1a44:	ff 1c       	adc	r15, r15

		if (exp < -3) {
    1a46:	cd 3f       	cpi	r28, 0xFD	; 253
    1a48:	14 f4       	brge	.+4      	; 0x1a4e <usart_set_baudrate+0xd4>
			limit |= 1;
    1a4a:	68 94       	set
    1a4c:	c0 f8       	bld	r12, 0
    1a4e:	cf 5f       	subi	r28, 0xFF	; 255

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    1a50:	c7 30       	cpi	r28, 0x07	; 7
    1a52:	81 f7       	brne	.-32     	; 0x1a34 <usart_set_baudrate+0xba>
    1a54:	8c 2f       	mov	r24, r28
    1a56:	56 c0       	rjmp	.+172    	; 0x1b04 <usart_set_baudrate+0x18a>
    1a58:	8c 2f       	mov	r24, r28
	 * point.
	 *
	 * The formula for calculating BSEL is slightly different when exp is
	 * negative than it is when exp is positive.
	 */
	if (exp < 0) {
    1a5a:	cc 23       	and	r28, r28
    1a5c:	0c f0       	brlt	.+2      	; 0x1a60 <usart_set_baudrate+0xe6>
    1a5e:	52 c0       	rjmp	.+164    	; 0x1b04 <usart_set_baudrate+0x18a>
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    1a60:	d3 01       	movw	r26, r6
    1a62:	c2 01       	movw	r24, r4
    1a64:	88 0f       	add	r24, r24
    1a66:	99 1f       	adc	r25, r25
    1a68:	aa 1f       	adc	r26, r26
    1a6a:	bb 1f       	adc	r27, r27
    1a6c:	88 0f       	add	r24, r24
    1a6e:	99 1f       	adc	r25, r25
    1a70:	aa 1f       	adc	r26, r26
    1a72:	bb 1f       	adc	r27, r27
    1a74:	88 0f       	add	r24, r24
    1a76:	99 1f       	adc	r25, r25
    1a78:	aa 1f       	adc	r26, r26
    1a7a:	bb 1f       	adc	r27, r27
    1a7c:	85 01       	movw	r16, r10
    1a7e:	74 01       	movw	r14, r8
    1a80:	e8 1a       	sub	r14, r24
    1a82:	f9 0a       	sbc	r15, r25
    1a84:	0a 0b       	sbc	r16, r26
    1a86:	1b 0b       	sbc	r17, r27
    1a88:	d8 01       	movw	r26, r16
    1a8a:	c7 01       	movw	r24, r14
		/* If we end up with a left-shift after taking the final
		 * divide-by-8 into account, do the shift before the divide.
		 * Otherwise, left-shift the denominator instead (effectively
		 * resulting in an overall right shift.)
		 */
		if (exp <= -3) {
    1a8c:	ce 3f       	cpi	r28, 0xFE	; 254
    1a8e:	f4 f4       	brge	.+60     	; 0x1acc <usart_set_baudrate+0x152>
			div = ((cpu_hz << (-exp - 3)) + baud / 2) / baud;
    1a90:	2d ef       	ldi	r18, 0xFD	; 253
    1a92:	3f ef       	ldi	r19, 0xFF	; 255
    1a94:	2c 1b       	sub	r18, r28
    1a96:	31 09       	sbc	r19, r1
    1a98:	c7 fd       	sbrc	r28, 7
    1a9a:	33 95       	inc	r19
    1a9c:	04 c0       	rjmp	.+8      	; 0x1aa6 <usart_set_baudrate+0x12c>
    1a9e:	88 0f       	add	r24, r24
    1aa0:	99 1f       	adc	r25, r25
    1aa2:	aa 1f       	adc	r26, r26
    1aa4:	bb 1f       	adc	r27, r27
    1aa6:	2a 95       	dec	r18
    1aa8:	d2 f7       	brpl	.-12     	; 0x1a9e <usart_set_baudrate+0x124>
    1aaa:	73 01       	movw	r14, r6
    1aac:	62 01       	movw	r12, r4
    1aae:	f6 94       	lsr	r15
    1ab0:	e7 94       	ror	r14
    1ab2:	d7 94       	ror	r13
    1ab4:	c7 94       	ror	r12
    1ab6:	bc 01       	movw	r22, r24
    1ab8:	cd 01       	movw	r24, r26
    1aba:	6c 0d       	add	r22, r12
    1abc:	7d 1d       	adc	r23, r13
    1abe:	8e 1d       	adc	r24, r14
    1ac0:	9f 1d       	adc	r25, r15
    1ac2:	a3 01       	movw	r20, r6
    1ac4:	92 01       	movw	r18, r4
    1ac6:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <__udivmodsi4>
    1aca:	38 c0       	rjmp	.+112    	; 0x1b3c <usart_set_baudrate+0x1c2>
		} else {
			baud <<= exp + 3;
    1acc:	23 e0       	ldi	r18, 0x03	; 3
    1ace:	2c 0f       	add	r18, r28
    1ad0:	83 01       	movw	r16, r6
    1ad2:	72 01       	movw	r14, r4
    1ad4:	04 c0       	rjmp	.+8      	; 0x1ade <usart_set_baudrate+0x164>
    1ad6:	ee 0c       	add	r14, r14
    1ad8:	ff 1c       	adc	r15, r15
    1ada:	00 1f       	adc	r16, r16
    1adc:	11 1f       	adc	r17, r17
    1ade:	2a 95       	dec	r18
    1ae0:	d2 f7       	brpl	.-12     	; 0x1ad6 <usart_set_baudrate+0x15c>
    1ae2:	a8 01       	movw	r20, r16
    1ae4:	97 01       	movw	r18, r14
			div = (cpu_hz + baud / 2) / baud;
    1ae6:	67 01       	movw	r12, r14
    1ae8:	78 01       	movw	r14, r16
    1aea:	f6 94       	lsr	r15
    1aec:	e7 94       	ror	r14
    1aee:	d7 94       	ror	r13
    1af0:	c7 94       	ror	r12
    1af2:	bc 01       	movw	r22, r24
    1af4:	cd 01       	movw	r24, r26
    1af6:	6c 0d       	add	r22, r12
    1af8:	7d 1d       	adc	r23, r13
    1afa:	8e 1d       	adc	r24, r14
    1afc:	9f 1d       	adc	r25, r15
    1afe:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <__udivmodsi4>
    1b02:	1c c0       	rjmp	.+56     	; 0x1b3c <usart_set_baudrate+0x1c2>
		}
	} else {
		/* We will always do a right shift in this case, but we need to
		 * shift three extra positions because of the divide-by-8.
		 */
		baud <<= exp + 3;
    1b04:	8d 5f       	subi	r24, 0xFD	; 253
    1b06:	a3 01       	movw	r20, r6
    1b08:	92 01       	movw	r18, r4
    1b0a:	04 c0       	rjmp	.+8      	; 0x1b14 <usart_set_baudrate+0x19a>
    1b0c:	22 0f       	add	r18, r18
    1b0e:	33 1f       	adc	r19, r19
    1b10:	44 1f       	adc	r20, r20
    1b12:	55 1f       	adc	r21, r21
    1b14:	8a 95       	dec	r24
    1b16:	d2 f7       	brpl	.-12     	; 0x1b0c <usart_set_baudrate+0x192>
		div = (cpu_hz + baud / 2) / baud - 1;
    1b18:	da 01       	movw	r26, r20
    1b1a:	c9 01       	movw	r24, r18
    1b1c:	b6 95       	lsr	r27
    1b1e:	a7 95       	ror	r26
    1b20:	97 95       	ror	r25
    1b22:	87 95       	ror	r24
    1b24:	bc 01       	movw	r22, r24
    1b26:	cd 01       	movw	r24, r26
    1b28:	68 0d       	add	r22, r8
    1b2a:	79 1d       	adc	r23, r9
    1b2c:	8a 1d       	adc	r24, r10
    1b2e:	9b 1d       	adc	r25, r11
    1b30:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <__udivmodsi4>
    1b34:	21 50       	subi	r18, 0x01	; 1
    1b36:	31 09       	sbc	r19, r1
    1b38:	41 09       	sbc	r20, r1
    1b3a:	51 09       	sbc	r21, r1
	}

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
    1b3c:	83 2f       	mov	r24, r19
    1b3e:	8f 70       	andi	r24, 0x0F	; 15
    1b40:	c2 95       	swap	r28
    1b42:	c0 7f       	andi	r28, 0xF0	; 240
    1b44:	c8 2b       	or	r28, r24
    1b46:	f1 01       	movw	r30, r2
    1b48:	c7 83       	std	Z+7, r28	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)div;
    1b4a:	26 83       	std	Z+6, r18	; 0x06

	return true;
    1b4c:	81 e0       	ldi	r24, 0x01	; 1
    1b4e:	1c c0       	rjmp	.+56     	; 0x1b88 <usart_set_baudrate+0x20e>
		max_rate /= 2;
		min_rate /= 2;
	}

	if ((baud > max_rate) || (baud < min_rate)) {
		return false;
    1b50:	80 e0       	ldi	r24, 0x00	; 0
    1b52:	1a c0       	rjmp	.+52     	; 0x1b88 <usart_set_baudrate+0x20e>
    1b54:	80 e0       	ldi	r24, 0x00	; 0
    1b56:	18 c0       	rjmp	.+48     	; 0x1b88 <usart_set_baudrate+0x20e>
	if (exp < 0) {
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    1b58:	d3 01       	movw	r26, r6
    1b5a:	c2 01       	movw	r24, r4
    1b5c:	88 0f       	add	r24, r24
    1b5e:	99 1f       	adc	r25, r25
    1b60:	aa 1f       	adc	r26, r26
    1b62:	bb 1f       	adc	r27, r27
    1b64:	88 0f       	add	r24, r24
    1b66:	99 1f       	adc	r25, r25
    1b68:	aa 1f       	adc	r26, r26
    1b6a:	bb 1f       	adc	r27, r27
    1b6c:	88 0f       	add	r24, r24
    1b6e:	99 1f       	adc	r25, r25
    1b70:	aa 1f       	adc	r26, r26
    1b72:	bb 1f       	adc	r27, r27
    1b74:	85 01       	movw	r16, r10
    1b76:	74 01       	movw	r14, r8
    1b78:	e8 1a       	sub	r14, r24
    1b7a:	f9 0a       	sbc	r15, r25
    1b7c:	0a 0b       	sbc	r16, r26
    1b7e:	1b 0b       	sbc	r17, r27
    1b80:	d8 01       	movw	r26, r16
    1b82:	c7 01       	movw	r24, r14

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    1b84:	c9 ef       	ldi	r28, 0xF9	; 249
    1b86:	84 cf       	rjmp	.-248    	; 0x1a90 <usart_set_baudrate+0x116>

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
	(usart)->BAUDCTRLA = (uint8_t)div;

	return true;
}
    1b88:	cf 91       	pop	r28
    1b8a:	1f 91       	pop	r17
    1b8c:	0f 91       	pop	r16
    1b8e:	ff 90       	pop	r15
    1b90:	ef 90       	pop	r14
    1b92:	df 90       	pop	r13
    1b94:	cf 90       	pop	r12
    1b96:	bf 90       	pop	r11
    1b98:	af 90       	pop	r10
    1b9a:	9f 90       	pop	r9
    1b9c:	8f 90       	pop	r8
    1b9e:	7f 90       	pop	r7
    1ba0:	6f 90       	pop	r6
    1ba2:	5f 90       	pop	r5
    1ba4:	4f 90       	pop	r4
    1ba6:	3f 90       	pop	r3
    1ba8:	2f 90       	pop	r2
    1baa:	08 95       	ret

00001bac <usart_init_rs232>:
 *
 * \retval true if the initialization was successfull
 * \retval false if the initialization failed (error in baud rate calculation)
 */
bool usart_init_rs232(USART_t *usart, const usart_rs232_options_t *opt)
{
    1bac:	0f 93       	push	r16
    1bae:	1f 93       	push	r17
    1bb0:	cf 93       	push	r28
    1bb2:	df 93       	push	r29
    1bb4:	ec 01       	movw	r28, r24
    1bb6:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1bb8:	00 97       	sbiw	r24, 0x00	; 0
    1bba:	09 f4       	brne	.+2      	; 0x1bbe <usart_init_rs232+0x12>
    1bbc:	03 c1       	rjmp	.+518    	; 0x1dc4 <usart_init_rs232+0x218>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1bbe:	80 3c       	cpi	r24, 0xC0	; 192
    1bc0:	91 05       	cpc	r25, r1
    1bc2:	29 f4       	brne	.+10     	; 0x1bce <usart_init_rs232+0x22>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1bc4:	60 e1       	ldi	r22, 0x10	; 16
    1bc6:	80 e0       	ldi	r24, 0x00	; 0
    1bc8:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1bcc:	fb c0       	rjmp	.+502    	; 0x1dc4 <usart_init_rs232+0x218>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1bce:	c0 38       	cpi	r28, 0x80	; 128
    1bd0:	81 e0       	ldi	r24, 0x01	; 1
    1bd2:	d8 07       	cpc	r29, r24
    1bd4:	29 f4       	brne	.+10     	; 0x1be0 <usart_init_rs232+0x34>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1bd6:	62 e0       	ldi	r22, 0x02	; 2
    1bd8:	80 e0       	ldi	r24, 0x00	; 0
    1bda:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1bde:	f2 c0       	rjmp	.+484    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1be0:	c1 15       	cp	r28, r1
    1be2:	e1 e0       	ldi	r30, 0x01	; 1
    1be4:	de 07       	cpc	r29, r30
    1be6:	29 f4       	brne	.+10     	; 0x1bf2 <usart_init_rs232+0x46>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1be8:	61 e0       	ldi	r22, 0x01	; 1
    1bea:	80 e0       	ldi	r24, 0x00	; 0
    1bec:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1bf0:	e9 c0       	rjmp	.+466    	; 0x1dc4 <usart_init_rs232+0x218>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1bf2:	c0 38       	cpi	r28, 0x80	; 128
    1bf4:	f3 e0       	ldi	r31, 0x03	; 3
    1bf6:	df 07       	cpc	r29, r31
    1bf8:	29 f4       	brne	.+10     	; 0x1c04 <usart_init_rs232+0x58>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1bfa:	61 e0       	ldi	r22, 0x01	; 1
    1bfc:	81 e0       	ldi	r24, 0x01	; 1
    1bfe:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1c02:	e0 c0       	rjmp	.+448    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1c04:	c0 39       	cpi	r28, 0x90	; 144
    1c06:	83 e0       	ldi	r24, 0x03	; 3
    1c08:	d8 07       	cpc	r29, r24
    1c0a:	29 f4       	brne	.+10     	; 0x1c16 <usart_init_rs232+0x6a>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1c0c:	61 e0       	ldi	r22, 0x01	; 1
    1c0e:	82 e0       	ldi	r24, 0x02	; 2
    1c10:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1c14:	d7 c0       	rjmp	.+430    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    1c16:	c1 15       	cp	r28, r1
    1c18:	e2 e0       	ldi	r30, 0x02	; 2
    1c1a:	de 07       	cpc	r29, r30
    1c1c:	29 f4       	brne	.+10     	; 0x1c28 <usart_init_rs232+0x7c>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1c1e:	62 e0       	ldi	r22, 0x02	; 2
    1c20:	81 e0       	ldi	r24, 0x01	; 1
    1c22:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1c26:	ce c0       	rjmp	.+412    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    1c28:	c0 34       	cpi	r28, 0x40	; 64
    1c2a:	f2 e0       	ldi	r31, 0x02	; 2
    1c2c:	df 07       	cpc	r29, r31
    1c2e:	29 f4       	brne	.+10     	; 0x1c3a <usart_init_rs232+0x8e>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1c30:	62 e0       	ldi	r22, 0x02	; 2
    1c32:	82 e0       	ldi	r24, 0x02	; 2
    1c34:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1c38:	c5 c0       	rjmp	.+394    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1c3a:	c0 32       	cpi	r28, 0x20	; 32
    1c3c:	83 e0       	ldi	r24, 0x03	; 3
    1c3e:	d8 07       	cpc	r29, r24
    1c40:	29 f4       	brne	.+10     	; 0x1c4c <usart_init_rs232+0xa0>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1c42:	64 e0       	ldi	r22, 0x04	; 4
    1c44:	82 e0       	ldi	r24, 0x02	; 2
    1c46:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1c4a:	bc c0       	rjmp	.+376    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1c4c:	c1 15       	cp	r28, r1
    1c4e:	e8 e0       	ldi	r30, 0x08	; 8
    1c50:	de 07       	cpc	r29, r30
    1c52:	29 f4       	brne	.+10     	; 0x1c5e <usart_init_rs232+0xb2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1c54:	61 e0       	ldi	r22, 0x01	; 1
    1c56:	83 e0       	ldi	r24, 0x03	; 3
    1c58:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1c5c:	b3 c0       	rjmp	.+358    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1c5e:	c1 15       	cp	r28, r1
    1c60:	f9 e0       	ldi	r31, 0x09	; 9
    1c62:	df 07       	cpc	r29, r31
    1c64:	29 f4       	brne	.+10     	; 0x1c70 <usart_init_rs232+0xc4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1c66:	61 e0       	ldi	r22, 0x01	; 1
    1c68:	84 e0       	ldi	r24, 0x04	; 4
    1c6a:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1c6e:	aa c0       	rjmp	.+340    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1c70:	c1 15       	cp	r28, r1
    1c72:	8a e0       	ldi	r24, 0x0A	; 10
    1c74:	d8 07       	cpc	r29, r24
    1c76:	29 f4       	brne	.+10     	; 0x1c82 <usart_init_rs232+0xd6>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    1c78:	61 e0       	ldi	r22, 0x01	; 1
    1c7a:	85 e0       	ldi	r24, 0x05	; 5
    1c7c:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1c80:	a1 c0       	rjmp	.+322    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1c82:	c1 15       	cp	r28, r1
    1c84:	eb e0       	ldi	r30, 0x0B	; 11
    1c86:	de 07       	cpc	r29, r30
    1c88:	29 f4       	brne	.+10     	; 0x1c94 <usart_init_rs232+0xe8>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1c8a:	61 e0       	ldi	r22, 0x01	; 1
    1c8c:	86 e0       	ldi	r24, 0x06	; 6
    1c8e:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1c92:	98 c0       	rjmp	.+304    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1c94:	c0 34       	cpi	r28, 0x40	; 64
    1c96:	f8 e0       	ldi	r31, 0x08	; 8
    1c98:	df 07       	cpc	r29, r31
    1c9a:	29 f4       	brne	.+10     	; 0x1ca6 <usart_init_rs232+0xfa>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1c9c:	62 e0       	ldi	r22, 0x02	; 2
    1c9e:	83 e0       	ldi	r24, 0x03	; 3
    1ca0:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1ca4:	8f c0       	rjmp	.+286    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1ca6:	c0 34       	cpi	r28, 0x40	; 64
    1ca8:	89 e0       	ldi	r24, 0x09	; 9
    1caa:	d8 07       	cpc	r29, r24
    1cac:	29 f4       	brne	.+10     	; 0x1cb8 <usart_init_rs232+0x10c>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1cae:	62 e0       	ldi	r22, 0x02	; 2
    1cb0:	84 e0       	ldi	r24, 0x04	; 4
    1cb2:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1cb6:	86 c0       	rjmp	.+268    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1cb8:	c0 34       	cpi	r28, 0x40	; 64
    1cba:	ea e0       	ldi	r30, 0x0A	; 10
    1cbc:	de 07       	cpc	r29, r30
    1cbe:	29 f4       	brne	.+10     	; 0x1cca <usart_init_rs232+0x11e>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1cc0:	62 e0       	ldi	r22, 0x02	; 2
    1cc2:	85 e0       	ldi	r24, 0x05	; 5
    1cc4:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1cc8:	7d c0       	rjmp	.+250    	; 0x1dc4 <usart_init_rs232+0x218>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1cca:	c0 39       	cpi	r28, 0x90	; 144
    1ccc:	f8 e0       	ldi	r31, 0x08	; 8
    1cce:	df 07       	cpc	r29, r31
    1cd0:	29 f4       	brne	.+10     	; 0x1cdc <usart_init_rs232+0x130>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1cd2:	64 e0       	ldi	r22, 0x04	; 4
    1cd4:	83 e0       	ldi	r24, 0x03	; 3
    1cd6:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1cda:	74 c0       	rjmp	.+232    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1cdc:	c0 39       	cpi	r28, 0x90	; 144
    1cde:	89 e0       	ldi	r24, 0x09	; 9
    1ce0:	d8 07       	cpc	r29, r24
    1ce2:	29 f4       	brne	.+10     	; 0x1cee <usart_init_rs232+0x142>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1ce4:	64 e0       	ldi	r22, 0x04	; 4
    1ce6:	84 e0       	ldi	r24, 0x04	; 4
    1ce8:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1cec:	6b c0       	rjmp	.+214    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1cee:	c0 39       	cpi	r28, 0x90	; 144
    1cf0:	ea e0       	ldi	r30, 0x0A	; 10
    1cf2:	de 07       	cpc	r29, r30
    1cf4:	29 f4       	brne	.+10     	; 0x1d00 <usart_init_rs232+0x154>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1cf6:	64 e0       	ldi	r22, 0x04	; 4
    1cf8:	85 e0       	ldi	r24, 0x05	; 5
    1cfa:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1cfe:	62 c0       	rjmp	.+196    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    1d00:	c0 39       	cpi	r28, 0x90	; 144
    1d02:	fb e0       	ldi	r31, 0x0B	; 11
    1d04:	df 07       	cpc	r29, r31
    1d06:	29 f4       	brne	.+10     	; 0x1d12 <usart_init_rs232+0x166>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1d08:	64 e0       	ldi	r22, 0x04	; 4
    1d0a:	86 e0       	ldi	r24, 0x06	; 6
    1d0c:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1d10:	59 c0       	rjmp	.+178    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    1d12:	c0 3c       	cpi	r28, 0xC0	; 192
    1d14:	88 e0       	ldi	r24, 0x08	; 8
    1d16:	d8 07       	cpc	r29, r24
    1d18:	29 f4       	brne	.+10     	; 0x1d24 <usart_init_rs232+0x178>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1d1a:	68 e0       	ldi	r22, 0x08	; 8
    1d1c:	83 e0       	ldi	r24, 0x03	; 3
    1d1e:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1d22:	50 c0       	rjmp	.+160    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    1d24:	c0 3c       	cpi	r28, 0xC0	; 192
    1d26:	e9 e0       	ldi	r30, 0x09	; 9
    1d28:	de 07       	cpc	r29, r30
    1d2a:	29 f4       	brne	.+10     	; 0x1d36 <usart_init_rs232+0x18a>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1d2c:	68 e0       	ldi	r22, 0x08	; 8
    1d2e:	84 e0       	ldi	r24, 0x04	; 4
    1d30:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1d34:	47 c0       	rjmp	.+142    	; 0x1dc4 <usart_init_rs232+0x218>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1d36:	c0 3a       	cpi	r28, 0xA0	; 160
    1d38:	f8 e0       	ldi	r31, 0x08	; 8
    1d3a:	df 07       	cpc	r29, r31
    1d3c:	29 f4       	brne	.+10     	; 0x1d48 <usart_init_rs232+0x19c>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1d3e:	60 e1       	ldi	r22, 0x10	; 16
    1d40:	83 e0       	ldi	r24, 0x03	; 3
    1d42:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1d46:	3e c0       	rjmp	.+124    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1d48:	c0 3a       	cpi	r28, 0xA0	; 160
    1d4a:	89 e0       	ldi	r24, 0x09	; 9
    1d4c:	d8 07       	cpc	r29, r24
    1d4e:	29 f4       	brne	.+10     	; 0x1d5a <usart_init_rs232+0x1ae>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1d50:	60 e1       	ldi	r22, 0x10	; 16
    1d52:	84 e0       	ldi	r24, 0x04	; 4
    1d54:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1d58:	35 c0       	rjmp	.+106    	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1d5a:	c0 3a       	cpi	r28, 0xA0	; 160
    1d5c:	ea e0       	ldi	r30, 0x0A	; 10
    1d5e:	de 07       	cpc	r29, r30
    1d60:	29 f4       	brne	.+10     	; 0x1d6c <usart_init_rs232+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1d62:	60 e1       	ldi	r22, 0x10	; 16
    1d64:	85 e0       	ldi	r24, 0x05	; 5
    1d66:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1d6a:	2c c0       	rjmp	.+88     	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1d6c:	c0 3a       	cpi	r28, 0xA0	; 160
    1d6e:	fb e0       	ldi	r31, 0x0B	; 11
    1d70:	df 07       	cpc	r29, r31
    1d72:	29 f4       	brne	.+10     	; 0x1d7e <usart_init_rs232+0x1d2>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1d74:	60 e1       	ldi	r22, 0x10	; 16
    1d76:	86 e0       	ldi	r24, 0x06	; 6
    1d78:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1d7c:	23 c0       	rjmp	.+70     	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1d7e:	c0 3b       	cpi	r28, 0xB0	; 176
    1d80:	88 e0       	ldi	r24, 0x08	; 8
    1d82:	d8 07       	cpc	r29, r24
    1d84:	29 f4       	brne	.+10     	; 0x1d90 <usart_init_rs232+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1d86:	60 e2       	ldi	r22, 0x20	; 32
    1d88:	83 e0       	ldi	r24, 0x03	; 3
    1d8a:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1d8e:	1a c0       	rjmp	.+52     	; 0x1dc4 <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1d90:	c0 3b       	cpi	r28, 0xB0	; 176
    1d92:	e9 e0       	ldi	r30, 0x09	; 9
    1d94:	de 07       	cpc	r29, r30
    1d96:	29 f4       	brne	.+10     	; 0x1da2 <usart_init_rs232+0x1f6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1d98:	60 e2       	ldi	r22, 0x20	; 32
    1d9a:	84 e0       	ldi	r24, 0x04	; 4
    1d9c:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1da0:	11 c0       	rjmp	.+34     	; 0x1dc4 <usart_init_rs232+0x218>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1da2:	c0 38       	cpi	r28, 0x80	; 128
    1da4:	f4 e0       	ldi	r31, 0x04	; 4
    1da6:	df 07       	cpc	r29, r31
    1da8:	29 f4       	brne	.+10     	; 0x1db4 <usart_init_rs232+0x208>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1daa:	60 e4       	ldi	r22, 0x40	; 64
    1dac:	83 e0       	ldi	r24, 0x03	; 3
    1dae:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1db2:	08 c0       	rjmp	.+16     	; 0x1dc4 <usart_init_rs232+0x218>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1db4:	c0 3a       	cpi	r28, 0xA0	; 160
    1db6:	84 e0       	ldi	r24, 0x04	; 4
    1db8:	d8 07       	cpc	r29, r24
    1dba:	21 f4       	brne	.+8      	; 0x1dc4 <usart_init_rs232+0x218>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1dbc:	60 e4       	ldi	r22, 0x40	; 64
    1dbe:	85 e0       	ldi	r24, 0x05	; 5
    1dc0:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1dc4:	8d 81       	ldd	r24, Y+5	; 0x05
    1dc6:	8f 73       	andi	r24, 0x3F	; 63
    1dc8:	8d 83       	std	Y+5, r24	; 0x05
 *  \param twoStopBits Enable two stop bit mode. Use bool type.
 */
static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
		USART_PMODE_t parityMode, bool twoStopBits)
{
	(usart)->CTRLC = (uint8_t)charSize | parityMode
    1dca:	f8 01       	movw	r30, r16
    1dcc:	94 81       	ldd	r25, Z+4	; 0x04
    1dce:	85 81       	ldd	r24, Z+5	; 0x05
    1dd0:	89 2b       	or	r24, r25
    1dd2:	96 81       	ldd	r25, Z+6	; 0x06
    1dd4:	91 11       	cpse	r25, r1
    1dd6:	98 e0       	ldi	r25, 0x08	; 8
    1dd8:	89 2b       	or	r24, r25
    1dda:	8d 83       	std	Y+5, r24	; 0x05
	bool result;
	sysclk_enable_peripheral_clock(usart);
	usart_set_mode(usart, USART_CMODE_ASYNCHRONOUS_gc);
	usart_format_set(usart, opt->charlength, opt->paritytype,
			opt->stopbits);
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1ddc:	f8 01       	movw	r30, r16
    1dde:	40 81       	ld	r20, Z
    1de0:	51 81       	ldd	r21, Z+1	; 0x01
    1de2:	62 81       	ldd	r22, Z+2	; 0x02
    1de4:	73 81       	ldd	r23, Z+3	; 0x03
    1de6:	00 e8       	ldi	r16, 0x80	; 128
    1de8:	14 e8       	ldi	r17, 0x84	; 132
    1dea:	2e e1       	ldi	r18, 0x1E	; 30
    1dec:	30 e0       	ldi	r19, 0x00	; 0
    1dee:	ce 01       	movw	r24, r28
    1df0:	c4 dd       	rcall	.-1144   	; 0x197a <usart_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1df2:	9c 81       	ldd	r25, Y+4	; 0x04
    1df4:	98 60       	ori	r25, 0x08	; 8
    1df6:	9c 83       	std	Y+4, r25	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1df8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dfa:	90 61       	ori	r25, 0x10	; 16
    1dfc:	9c 83       	std	Y+4, r25	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
    1dfe:	df 91       	pop	r29
    1e00:	cf 91       	pop	r28
    1e02:	1f 91       	pop	r17
    1e04:	0f 91       	pop	r16
    1e06:	08 95       	ret

00001e08 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1e08:	cf 92       	push	r12
    1e0a:	df 92       	push	r13
    1e0c:	ef 92       	push	r14
    1e0e:	ff 92       	push	r15
    1e10:	0f 93       	push	r16
    1e12:	1f 93       	push	r17
    1e14:	cf 93       	push	r28
    1e16:	df 93       	push	r29
    1e18:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    1e1a:	d9 01       	movw	r26, r18
    1e1c:	c8 01       	movw	r24, r16
    1e1e:	b6 95       	lsr	r27
    1e20:	a7 95       	ror	r26
    1e22:	97 95       	ror	r25
    1e24:	87 95       	ror	r24
    1e26:	48 17       	cp	r20, r24
    1e28:	59 07       	cpc	r21, r25
    1e2a:	6a 07       	cpc	r22, r26
    1e2c:	7b 07       	cpc	r23, r27
    1e2e:	78 f4       	brcc	.+30     	; 0x1e4e <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1e30:	6a 01       	movw	r12, r20
    1e32:	7b 01       	movw	r14, r22
    1e34:	cc 0c       	add	r12, r12
    1e36:	dd 1c       	adc	r13, r13
    1e38:	ee 1c       	adc	r14, r14
    1e3a:	ff 1c       	adc	r15, r15
    1e3c:	c9 01       	movw	r24, r18
    1e3e:	b8 01       	movw	r22, r16
    1e40:	a7 01       	movw	r20, r14
    1e42:	96 01       	movw	r18, r12
    1e44:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <__udivmodsi4>
    1e48:	21 50       	subi	r18, 0x01	; 1
    1e4a:	31 09       	sbc	r19, r1
    1e4c:	02 c0       	rjmp	.+4      	; 0x1e52 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1e4e:	20 e0       	ldi	r18, 0x00	; 0
    1e50:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1e52:	83 2f       	mov	r24, r19
    1e54:	8f 70       	andi	r24, 0x0F	; 15
    1e56:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1e58:	2e 83       	std	Y+6, r18	; 0x06
}
    1e5a:	df 91       	pop	r29
    1e5c:	cf 91       	pop	r28
    1e5e:	1f 91       	pop	r17
    1e60:	0f 91       	pop	r16
    1e62:	ff 90       	pop	r15
    1e64:	ef 90       	pop	r14
    1e66:	df 90       	pop	r13
    1e68:	cf 90       	pop	r12
    1e6a:	08 95       	ret

00001e6c <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1e6c:	ef 92       	push	r14
    1e6e:	ff 92       	push	r15
    1e70:	0f 93       	push	r16
    1e72:	1f 93       	push	r17
    1e74:	cf 93       	push	r28
    1e76:	df 93       	push	r29
    1e78:	ec 01       	movw	r28, r24
    1e7a:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1e7c:	00 97       	sbiw	r24, 0x00	; 0
    1e7e:	09 f4       	brne	.+2      	; 0x1e82 <usart_init_spi+0x16>
    1e80:	90 c1       	rjmp	.+800    	; 0x21a2 <usart_init_spi+0x336>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1e82:	80 3c       	cpi	r24, 0xC0	; 192
    1e84:	91 05       	cpc	r25, r1
    1e86:	29 f4       	brne	.+10     	; 0x1e92 <usart_init_spi+0x26>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1e88:	60 e1       	ldi	r22, 0x10	; 16
    1e8a:	80 e0       	ldi	r24, 0x00	; 0
    1e8c:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1e90:	88 c1       	rjmp	.+784    	; 0x21a2 <usart_init_spi+0x336>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1e92:	80 38       	cpi	r24, 0x80	; 128
    1e94:	91 40       	sbci	r25, 0x01	; 1
    1e96:	29 f4       	brne	.+10     	; 0x1ea2 <usart_init_spi+0x36>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1e98:	62 e0       	ldi	r22, 0x02	; 2
    1e9a:	80 e0       	ldi	r24, 0x00	; 0
    1e9c:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1ea0:	80 c1       	rjmp	.+768    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1ea2:	c1 15       	cp	r28, r1
    1ea4:	81 e0       	ldi	r24, 0x01	; 1
    1ea6:	d8 07       	cpc	r29, r24
    1ea8:	29 f4       	brne	.+10     	; 0x1eb4 <usart_init_spi+0x48>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1eaa:	61 e0       	ldi	r22, 0x01	; 1
    1eac:	80 e0       	ldi	r24, 0x00	; 0
    1eae:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1eb2:	77 c1       	rjmp	.+750    	; 0x21a2 <usart_init_spi+0x336>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1eb4:	c0 38       	cpi	r28, 0x80	; 128
    1eb6:	e3 e0       	ldi	r30, 0x03	; 3
    1eb8:	de 07       	cpc	r29, r30
    1eba:	29 f4       	brne	.+10     	; 0x1ec6 <usart_init_spi+0x5a>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1ebc:	61 e0       	ldi	r22, 0x01	; 1
    1ebe:	81 e0       	ldi	r24, 0x01	; 1
    1ec0:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1ec4:	6e c1       	rjmp	.+732    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1ec6:	c0 39       	cpi	r28, 0x90	; 144
    1ec8:	f3 e0       	ldi	r31, 0x03	; 3
    1eca:	df 07       	cpc	r29, r31
    1ecc:	29 f4       	brne	.+10     	; 0x1ed8 <usart_init_spi+0x6c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1ece:	61 e0       	ldi	r22, 0x01	; 1
    1ed0:	82 e0       	ldi	r24, 0x02	; 2
    1ed2:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1ed6:	65 c1       	rjmp	.+714    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    1ed8:	c1 15       	cp	r28, r1
    1eda:	32 e0       	ldi	r19, 0x02	; 2
    1edc:	d3 07       	cpc	r29, r19
    1ede:	29 f4       	brne	.+10     	; 0x1eea <usart_init_spi+0x7e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1ee0:	62 e0       	ldi	r22, 0x02	; 2
    1ee2:	81 e0       	ldi	r24, 0x01	; 1
    1ee4:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1ee8:	5c c1       	rjmp	.+696    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    1eea:	c0 34       	cpi	r28, 0x40	; 64
    1eec:	82 e0       	ldi	r24, 0x02	; 2
    1eee:	d8 07       	cpc	r29, r24
    1ef0:	29 f4       	brne	.+10     	; 0x1efc <usart_init_spi+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1ef2:	62 e0       	ldi	r22, 0x02	; 2
    1ef4:	82 e0       	ldi	r24, 0x02	; 2
    1ef6:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1efa:	53 c1       	rjmp	.+678    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1efc:	c0 32       	cpi	r28, 0x20	; 32
    1efe:	e3 e0       	ldi	r30, 0x03	; 3
    1f00:	de 07       	cpc	r29, r30
    1f02:	29 f4       	brne	.+10     	; 0x1f0e <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1f04:	64 e0       	ldi	r22, 0x04	; 4
    1f06:	82 e0       	ldi	r24, 0x02	; 2
    1f08:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1f0c:	4a c1       	rjmp	.+660    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1f0e:	c1 15       	cp	r28, r1
    1f10:	f8 e0       	ldi	r31, 0x08	; 8
    1f12:	df 07       	cpc	r29, r31
    1f14:	29 f4       	brne	.+10     	; 0x1f20 <usart_init_spi+0xb4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1f16:	61 e0       	ldi	r22, 0x01	; 1
    1f18:	83 e0       	ldi	r24, 0x03	; 3
    1f1a:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1f1e:	41 c1       	rjmp	.+642    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1f20:	c1 15       	cp	r28, r1
    1f22:	39 e0       	ldi	r19, 0x09	; 9
    1f24:	d3 07       	cpc	r29, r19
    1f26:	29 f4       	brne	.+10     	; 0x1f32 <usart_init_spi+0xc6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1f28:	61 e0       	ldi	r22, 0x01	; 1
    1f2a:	84 e0       	ldi	r24, 0x04	; 4
    1f2c:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1f30:	38 c1       	rjmp	.+624    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1f32:	c1 15       	cp	r28, r1
    1f34:	8a e0       	ldi	r24, 0x0A	; 10
    1f36:	d8 07       	cpc	r29, r24
    1f38:	29 f4       	brne	.+10     	; 0x1f44 <usart_init_spi+0xd8>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    1f3a:	61 e0       	ldi	r22, 0x01	; 1
    1f3c:	85 e0       	ldi	r24, 0x05	; 5
    1f3e:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1f42:	2f c1       	rjmp	.+606    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1f44:	c1 15       	cp	r28, r1
    1f46:	eb e0       	ldi	r30, 0x0B	; 11
    1f48:	de 07       	cpc	r29, r30
    1f4a:	29 f4       	brne	.+10     	; 0x1f56 <usart_init_spi+0xea>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1f4c:	61 e0       	ldi	r22, 0x01	; 1
    1f4e:	86 e0       	ldi	r24, 0x06	; 6
    1f50:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1f54:	26 c1       	rjmp	.+588    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1f56:	c0 34       	cpi	r28, 0x40	; 64
    1f58:	f8 e0       	ldi	r31, 0x08	; 8
    1f5a:	df 07       	cpc	r29, r31
    1f5c:	29 f4       	brne	.+10     	; 0x1f68 <usart_init_spi+0xfc>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1f5e:	62 e0       	ldi	r22, 0x02	; 2
    1f60:	83 e0       	ldi	r24, 0x03	; 3
    1f62:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1f66:	1d c1       	rjmp	.+570    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1f68:	c0 34       	cpi	r28, 0x40	; 64
    1f6a:	39 e0       	ldi	r19, 0x09	; 9
    1f6c:	d3 07       	cpc	r29, r19
    1f6e:	29 f4       	brne	.+10     	; 0x1f7a <usart_init_spi+0x10e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1f70:	62 e0       	ldi	r22, 0x02	; 2
    1f72:	84 e0       	ldi	r24, 0x04	; 4
    1f74:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1f78:	14 c1       	rjmp	.+552    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1f7a:	c0 34       	cpi	r28, 0x40	; 64
    1f7c:	8a e0       	ldi	r24, 0x0A	; 10
    1f7e:	d8 07       	cpc	r29, r24
    1f80:	29 f4       	brne	.+10     	; 0x1f8c <usart_init_spi+0x120>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1f82:	62 e0       	ldi	r22, 0x02	; 2
    1f84:	85 e0       	ldi	r24, 0x05	; 5
    1f86:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1f8a:	0b c1       	rjmp	.+534    	; 0x21a2 <usart_init_spi+0x336>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1f8c:	c0 39       	cpi	r28, 0x90	; 144
    1f8e:	e8 e0       	ldi	r30, 0x08	; 8
    1f90:	de 07       	cpc	r29, r30
    1f92:	29 f4       	brne	.+10     	; 0x1f9e <usart_init_spi+0x132>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1f94:	64 e0       	ldi	r22, 0x04	; 4
    1f96:	83 e0       	ldi	r24, 0x03	; 3
    1f98:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1f9c:	02 c1       	rjmp	.+516    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1f9e:	c0 39       	cpi	r28, 0x90	; 144
    1fa0:	f9 e0       	ldi	r31, 0x09	; 9
    1fa2:	df 07       	cpc	r29, r31
    1fa4:	29 f4       	brne	.+10     	; 0x1fb0 <usart_init_spi+0x144>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1fa6:	64 e0       	ldi	r22, 0x04	; 4
    1fa8:	84 e0       	ldi	r24, 0x04	; 4
    1faa:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1fae:	f9 c0       	rjmp	.+498    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1fb0:	c0 39       	cpi	r28, 0x90	; 144
    1fb2:	3a e0       	ldi	r19, 0x0A	; 10
    1fb4:	d3 07       	cpc	r29, r19
    1fb6:	29 f4       	brne	.+10     	; 0x1fc2 <usart_init_spi+0x156>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1fb8:	64 e0       	ldi	r22, 0x04	; 4
    1fba:	85 e0       	ldi	r24, 0x05	; 5
    1fbc:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1fc0:	f0 c0       	rjmp	.+480    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    1fc2:	c0 39       	cpi	r28, 0x90	; 144
    1fc4:	8b e0       	ldi	r24, 0x0B	; 11
    1fc6:	d8 07       	cpc	r29, r24
    1fc8:	29 f4       	brne	.+10     	; 0x1fd4 <usart_init_spi+0x168>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1fca:	64 e0       	ldi	r22, 0x04	; 4
    1fcc:	86 e0       	ldi	r24, 0x06	; 6
    1fce:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1fd2:	e7 c0       	rjmp	.+462    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    1fd4:	c0 3c       	cpi	r28, 0xC0	; 192
    1fd6:	e8 e0       	ldi	r30, 0x08	; 8
    1fd8:	de 07       	cpc	r29, r30
    1fda:	29 f4       	brne	.+10     	; 0x1fe6 <usart_init_spi+0x17a>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1fdc:	68 e0       	ldi	r22, 0x08	; 8
    1fde:	83 e0       	ldi	r24, 0x03	; 3
    1fe0:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1fe4:	de c0       	rjmp	.+444    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    1fe6:	c0 3c       	cpi	r28, 0xC0	; 192
    1fe8:	f9 e0       	ldi	r31, 0x09	; 9
    1fea:	df 07       	cpc	r29, r31
    1fec:	29 f4       	brne	.+10     	; 0x1ff8 <usart_init_spi+0x18c>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1fee:	68 e0       	ldi	r22, 0x08	; 8
    1ff0:	84 e0       	ldi	r24, 0x04	; 4
    1ff2:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <sysclk_enable_module>
    1ff6:	d5 c0       	rjmp	.+426    	; 0x21a2 <usart_init_spi+0x336>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1ff8:	c0 3a       	cpi	r28, 0xA0	; 160
    1ffa:	38 e0       	ldi	r19, 0x08	; 8
    1ffc:	d3 07       	cpc	r29, r19
    1ffe:	61 f4       	brne	.+24     	; 0x2018 <usart_init_spi+0x1ac>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    2000:	60 e1       	ldi	r22, 0x10	; 16
    2002:	83 e0       	ldi	r24, 0x03	; 3
    2004:	f9 d7       	rcall	.+4082   	; 0x2ff8 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    2006:	e0 ea       	ldi	r30, 0xA0	; 160
    2008:	f8 e0       	ldi	r31, 0x08	; 8
    200a:	84 81       	ldd	r24, Z+4	; 0x04
    200c:	8f 7e       	andi	r24, 0xEF	; 239
    200e:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    2010:	f7 01       	movw	r30, r14
    2012:	24 81       	ldd	r18, Z+4	; 0x04
    2014:	22 50       	subi	r18, 0x02	; 2
    2016:	43 c0       	rjmp	.+134    	; 0x209e <usart_init_spi+0x232>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    2018:	c0 3a       	cpi	r28, 0xA0	; 160
    201a:	f9 e0       	ldi	r31, 0x09	; 9
    201c:	df 07       	cpc	r29, r31
    201e:	21 f4       	brne	.+8      	; 0x2028 <usart_init_spi+0x1bc>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    2020:	60 e1       	ldi	r22, 0x10	; 16
    2022:	84 e0       	ldi	r24, 0x04	; 4
    2024:	e9 d7       	rcall	.+4050   	; 0x2ff8 <sysclk_enable_module>
    2026:	bd c0       	rjmp	.+378    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    2028:	c0 3a       	cpi	r28, 0xA0	; 160
    202a:	3a e0       	ldi	r19, 0x0A	; 10
    202c:	d3 07       	cpc	r29, r19
    202e:	21 f4       	brne	.+8      	; 0x2038 <usart_init_spi+0x1cc>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    2030:	60 e1       	ldi	r22, 0x10	; 16
    2032:	85 e0       	ldi	r24, 0x05	; 5
    2034:	e1 d7       	rcall	.+4034   	; 0x2ff8 <sysclk_enable_module>
    2036:	b5 c0       	rjmp	.+362    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    2038:	c0 3a       	cpi	r28, 0xA0	; 160
    203a:	8b e0       	ldi	r24, 0x0B	; 11
    203c:	d8 07       	cpc	r29, r24
    203e:	21 f4       	brne	.+8      	; 0x2048 <usart_init_spi+0x1dc>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    2040:	60 e1       	ldi	r22, 0x10	; 16
    2042:	86 e0       	ldi	r24, 0x06	; 6
    2044:	d9 d7       	rcall	.+4018   	; 0x2ff8 <sysclk_enable_module>
    2046:	ad c0       	rjmp	.+346    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    2048:	c0 3b       	cpi	r28, 0xB0	; 176
    204a:	e8 e0       	ldi	r30, 0x08	; 8
    204c:	de 07       	cpc	r29, r30
    204e:	21 f4       	brne	.+8      	; 0x2058 <usart_init_spi+0x1ec>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    2050:	60 e2       	ldi	r22, 0x20	; 32
    2052:	83 e0       	ldi	r24, 0x03	; 3
    2054:	d1 d7       	rcall	.+4002   	; 0x2ff8 <sysclk_enable_module>
    2056:	a5 c0       	rjmp	.+330    	; 0x21a2 <usart_init_spi+0x336>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    2058:	c0 3b       	cpi	r28, 0xB0	; 176
    205a:	f9 e0       	ldi	r31, 0x09	; 9
    205c:	df 07       	cpc	r29, r31
    205e:	21 f4       	brne	.+8      	; 0x2068 <usart_init_spi+0x1fc>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    2060:	60 e2       	ldi	r22, 0x20	; 32
    2062:	84 e0       	ldi	r24, 0x04	; 4
    2064:	c9 d7       	rcall	.+3986   	; 0x2ff8 <sysclk_enable_module>
    2066:	9d c0       	rjmp	.+314    	; 0x21a2 <usart_init_spi+0x336>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    2068:	c0 38       	cpi	r28, 0x80	; 128
    206a:	34 e0       	ldi	r19, 0x04	; 4
    206c:	d3 07       	cpc	r29, r19
    206e:	21 f4       	brne	.+8      	; 0x2078 <usart_init_spi+0x20c>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    2070:	60 e4       	ldi	r22, 0x40	; 64
    2072:	83 e0       	ldi	r24, 0x03	; 3
    2074:	c1 d7       	rcall	.+3970   	; 0x2ff8 <sysclk_enable_module>
    2076:	95 c0       	rjmp	.+298    	; 0x21a2 <usart_init_spi+0x336>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    2078:	c0 3a       	cpi	r28, 0xA0	; 160
    207a:	84 e0       	ldi	r24, 0x04	; 4
    207c:	d8 07       	cpc	r29, r24
    207e:	21 f4       	brne	.+8      	; 0x2088 <usart_init_spi+0x21c>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    2080:	60 e4       	ldi	r22, 0x40	; 64
    2082:	85 e0       	ldi	r24, 0x05	; 5
    2084:	b9 d7       	rcall	.+3954   	; 0x2ff8 <sysclk_enable_module>
    2086:	8d c0       	rjmp	.+282    	; 0x21a2 <usart_init_spi+0x336>
    2088:	8c 81       	ldd	r24, Y+4	; 0x04
    208a:	8f 7e       	andi	r24, 0xEF	; 239
    208c:	8c 83       	std	Y+4, r24	; 0x04
    208e:	fb 01       	movw	r30, r22
    2090:	24 81       	ldd	r18, Z+4	; 0x04
    2092:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    2094:	ce 01       	movw	r24, r28
    2096:	c0 3a       	cpi	r28, 0xA0	; 160
    2098:	f8 e0       	ldi	r31, 0x08	; 8
    209a:	df 07       	cpc	r29, r31
    209c:	31 f4       	brne	.+12     	; 0x20aa <usart_init_spi+0x23e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    209e:	80 91 4e 06 	lds	r24, 0x064E
    20a2:	84 fd       	sbrc	r24, 4
    20a4:	86 c0       	rjmp	.+268    	; 0x21b2 <usart_init_spi+0x346>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    20a6:	11 e1       	ldi	r17, 0x11	; 17
    20a8:	85 c0       	rjmp	.+266    	; 0x21b4 <usart_init_spi+0x348>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    20aa:	80 3b       	cpi	r24, 0xB0	; 176
    20ac:	38 e0       	ldi	r19, 0x08	; 8
    20ae:	93 07       	cpc	r25, r19
    20b0:	79 f0       	breq	.+30     	; 0x20d0 <usart_init_spi+0x264>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    20b2:	80 3a       	cpi	r24, 0xA0	; 160
    20b4:	e9 e0       	ldi	r30, 0x09	; 9
    20b6:	9e 07       	cpc	r25, r30
    20b8:	31 f4       	brne	.+12     	; 0x20c6 <usart_init_spi+0x25a>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    20ba:	30 91 6e 06 	lds	r19, 0x066E
    20be:	34 fd       	sbrc	r19, 4
    20c0:	7c c0       	rjmp	.+248    	; 0x21ba <usart_init_spi+0x34e>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    20c2:	19 e1       	ldi	r17, 0x19	; 25
    20c4:	10 c0       	rjmp	.+32     	; 0x20e6 <usart_init_spi+0x27a>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    20c6:	80 3b       	cpi	r24, 0xB0	; 176
    20c8:	f9 e0       	ldi	r31, 0x09	; 9
    20ca:	9f 07       	cpc	r25, r31
    20cc:	a9 f0       	breq	.+42     	; 0x20f8 <usart_init_spi+0x28c>
    20ce:	01 c0       	rjmp	.+2      	; 0x20d2 <usart_init_spi+0x266>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    20d0:	15 e1       	ldi	r17, 0x15	; 21
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    20d2:	80 3a       	cpi	r24, 0xA0	; 160
    20d4:	3a e0       	ldi	r19, 0x0A	; 10
    20d6:	93 07       	cpc	r25, r19
    20d8:	31 f4       	brne	.+12     	; 0x20e6 <usart_init_spi+0x27a>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    20da:	80 91 8e 06 	lds	r24, 0x068E
    20de:	84 fd       	sbrc	r24, 4
    20e0:	6e c0       	rjmp	.+220    	; 0x21be <usart_init_spi+0x352>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    20e2:	11 e2       	ldi	r17, 0x21	; 33
    20e4:	0c c0       	rjmp	.+24     	; 0x20fe <usart_init_spi+0x292>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    20e6:	80 3a       	cpi	r24, 0xA0	; 160
    20e8:	9b 40       	sbci	r25, 0x0B	; 11
    20ea:	49 f4       	brne	.+18     	; 0x20fe <usart_init_spi+0x292>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    20ec:	80 91 ae 06 	lds	r24, 0x06AE
    20f0:	84 fd       	sbrc	r24, 4
    20f2:	04 c0       	rjmp	.+8      	; 0x20fc <usart_init_spi+0x290>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    20f4:	19 e2       	ldi	r17, 0x29	; 41
    20f6:	03 c0       	rjmp	.+6      	; 0x20fe <usart_init_spi+0x292>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    20f8:	1d e1       	ldi	r17, 0x1D	; 29
    20fa:	01 c0       	rjmp	.+2      	; 0x20fe <usart_init_spi+0x292>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    20fc:	1d e2       	ldi	r17, 0x2D	; 45
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    20fe:	e1 2f       	mov	r30, r17
    2100:	e6 95       	lsr	r30
    2102:	e6 95       	lsr	r30
    2104:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    2106:	30 e2       	ldi	r19, 0x20	; 32
    2108:	e3 9f       	mul	r30, r19
    210a:	f0 01       	movw	r30, r0
    210c:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    210e:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    2110:	17 70       	andi	r17, 0x07	; 7
    2112:	81 e0       	ldi	r24, 0x01	; 1
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	01 2e       	mov	r0, r17
    2118:	02 c0       	rjmp	.+4      	; 0x211e <usart_init_spi+0x2b2>
    211a:	88 0f       	add	r24, r24
    211c:	99 1f       	adc	r25, r25
    211e:	0a 94       	dec	r0
    2120:	e2 f7       	brpl	.-8      	; 0x211a <usart_init_spi+0x2ae>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    2122:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    2124:	22 30       	cpi	r18, 0x02	; 2
    2126:	10 f0       	brcs	.+4      	; 0x212c <usart_init_spi+0x2c0>
    2128:	40 e0       	ldi	r20, 0x00	; 0
    212a:	01 c0       	rjmp	.+2      	; 0x212e <usart_init_spi+0x2c2>
    212c:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    212e:	df 01       	movw	r26, r30
    2130:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    2132:	a1 0f       	add	r26, r17
    2134:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    2136:	3f b7       	in	r19, 0x3f	; 63
	cpu_irq_disable();
    2138:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    213a:	2c 91       	ld	r18, X
    213c:	27 70       	andi	r18, 0x07	; 7
    213e:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    2140:	9c 91       	ld	r25, X
    2142:	94 2b       	or	r25, r20
    2144:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    2146:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2148:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    214a:	8d 81       	ldd	r24, Y+5	; 0x05
    214c:	80 6c       	ori	r24, 0xC0	; 192
    214e:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    2150:	f7 01       	movw	r30, r14
    2152:	84 81       	ldd	r24, Z+4	; 0x04
    2154:	8d 7f       	andi	r24, 0xFD	; 253
    2156:	81 30       	cpi	r24, 0x01	; 1
    2158:	21 f4       	brne	.+8      	; 0x2162 <usart_init_spi+0x2f6>
		usart->CTRLC |= USART_UCPHA_bm;
    215a:	8d 81       	ldd	r24, Y+5	; 0x05
    215c:	82 60       	ori	r24, 0x02	; 2
    215e:	8d 83       	std	Y+5, r24	; 0x05
    2160:	03 c0       	rjmp	.+6      	; 0x2168 <usart_init_spi+0x2fc>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    2162:	8d 81       	ldd	r24, Y+5	; 0x05
    2164:	8d 7f       	andi	r24, 0xFD	; 253
    2166:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    2168:	f7 01       	movw	r30, r14
    216a:	85 81       	ldd	r24, Z+5	; 0x05
    216c:	88 23       	and	r24, r24
    216e:	21 f0       	breq	.+8      	; 0x2178 <usart_init_spi+0x30c>
		(usart)->CTRLC |= USART_DORD_bm;
    2170:	8d 81       	ldd	r24, Y+5	; 0x05
    2172:	84 60       	ori	r24, 0x04	; 4
    2174:	8d 83       	std	Y+5, r24	; 0x05
    2176:	03 c0       	rjmp	.+6      	; 0x217e <usart_init_spi+0x312>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    2178:	8d 81       	ldd	r24, Y+5	; 0x05
    217a:	8b 7f       	andi	r24, 0xFB	; 251
    217c:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    217e:	f7 01       	movw	r30, r14
    2180:	40 81       	ld	r20, Z
    2182:	51 81       	ldd	r21, Z+1	; 0x01
    2184:	62 81       	ldd	r22, Z+2	; 0x02
    2186:	73 81       	ldd	r23, Z+3	; 0x03
    2188:	00 e8       	ldi	r16, 0x80	; 128
    218a:	14 e8       	ldi	r17, 0x84	; 132
    218c:	2e e1       	ldi	r18, 0x1E	; 30
    218e:	30 e0       	ldi	r19, 0x00	; 0
    2190:	ce 01       	movw	r24, r28
    2192:	3a de       	rcall	.-908    	; 0x1e08 <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    2194:	8c 81       	ldd	r24, Y+4	; 0x04
    2196:	88 60       	ori	r24, 0x08	; 8
    2198:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    219a:	8c 81       	ldd	r24, Y+4	; 0x04
    219c:	80 61       	ori	r24, 0x10	; 16
    219e:	8c 83       	std	Y+4, r24	; 0x04
    21a0:	10 c0       	rjmp	.+32     	; 0x21c2 <usart_init_spi+0x356>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    21a2:	8c 81       	ldd	r24, Y+4	; 0x04
    21a4:	8f 7e       	andi	r24, 0xEF	; 239
    21a6:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    21a8:	f7 01       	movw	r30, r14
    21aa:	24 81       	ldd	r18, Z+4	; 0x04
    21ac:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    21ae:	ce 01       	movw	r24, r28
    21b0:	7c cf       	rjmp	.-264    	; 0x20aa <usart_init_spi+0x23e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    21b2:	15 e1       	ldi	r17, 0x15	; 21
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    21b4:	80 ea       	ldi	r24, 0xA0	; 160
    21b6:	98 e0       	ldi	r25, 0x08	; 8
    21b8:	86 cf       	rjmp	.-244    	; 0x20c6 <usart_init_spi+0x25a>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    21ba:	1d e1       	ldi	r17, 0x1D	; 29
    21bc:	94 cf       	rjmp	.-216    	; 0x20e6 <usart_init_spi+0x27a>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    21be:	15 e2       	ldi	r17, 0x25	; 37
    21c0:	9e cf       	rjmp	.-196    	; 0x20fe <usart_init_spi+0x292>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    21c2:	df 91       	pop	r29
    21c4:	cf 91       	pop	r28
    21c6:	1f 91       	pop	r17
    21c8:	0f 91       	pop	r16
    21ca:	ff 90       	pop	r15
    21cc:	ef 90       	pop	r14
    21ce:	08 95       	ret

000021d0 <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
    21d0:	80 3a       	cpi	r24, 0xA0	; 160
    21d2:	28 e0       	ldi	r18, 0x08	; 8
    21d4:	92 07       	cpc	r25, r18
    21d6:	21 f4       	brne	.+8      	; 0x21e0 <usart_spi_init+0x10>
    21d8:	60 e1       	ldi	r22, 0x10	; 16
    21da:	83 e0       	ldi	r24, 0x03	; 3
    21dc:	0d c7       	rjmp	.+3610   	; 0x2ff8 <sysclk_enable_module>
    21de:	08 95       	ret
    21e0:	80 3b       	cpi	r24, 0xB0	; 176
    21e2:	28 e0       	ldi	r18, 0x08	; 8
    21e4:	92 07       	cpc	r25, r18
    21e6:	21 f4       	brne	.+8      	; 0x21f0 <usart_spi_init+0x20>
    21e8:	60 e2       	ldi	r22, 0x20	; 32
    21ea:	83 e0       	ldi	r24, 0x03	; 3
    21ec:	05 c7       	rjmp	.+3594   	; 0x2ff8 <sysclk_enable_module>
    21ee:	08 95       	ret
    21f0:	80 3a       	cpi	r24, 0xA0	; 160
    21f2:	29 e0       	ldi	r18, 0x09	; 9
    21f4:	92 07       	cpc	r25, r18
    21f6:	21 f4       	brne	.+8      	; 0x2200 <usart_spi_init+0x30>
    21f8:	60 e1       	ldi	r22, 0x10	; 16
    21fa:	84 e0       	ldi	r24, 0x04	; 4
    21fc:	fd c6       	rjmp	.+3578   	; 0x2ff8 <sysclk_enable_module>
    21fe:	08 95       	ret
    2200:	80 3b       	cpi	r24, 0xB0	; 176
    2202:	29 e0       	ldi	r18, 0x09	; 9
    2204:	92 07       	cpc	r25, r18
    2206:	21 f4       	brne	.+8      	; 0x2210 <usart_spi_init+0x40>
    2208:	60 e2       	ldi	r22, 0x20	; 32
    220a:	84 e0       	ldi	r24, 0x04	; 4
    220c:	f5 c6       	rjmp	.+3562   	; 0x2ff8 <sysclk_enable_module>
    220e:	08 95       	ret
    2210:	80 3a       	cpi	r24, 0xA0	; 160
    2212:	2a e0       	ldi	r18, 0x0A	; 10
    2214:	92 07       	cpc	r25, r18
    2216:	21 f4       	brne	.+8      	; 0x2220 <usart_spi_init+0x50>
    2218:	60 e1       	ldi	r22, 0x10	; 16
    221a:	85 e0       	ldi	r24, 0x05	; 5
    221c:	ed c6       	rjmp	.+3546   	; 0x2ff8 <sysclk_enable_module>
    221e:	08 95       	ret
    2220:	80 3a       	cpi	r24, 0xA0	; 160
    2222:	9b 40       	sbci	r25, 0x0B	; 11
    2224:	19 f4       	brne	.+6      	; 0x222c <usart_spi_init+0x5c>
    2226:	60 e1       	ldi	r22, 0x10	; 16
    2228:	86 e0       	ldi	r24, 0x06	; 6
    222a:	e6 c6       	rjmp	.+3532   	; 0x2ff8 <sysclk_enable_module>
    222c:	08 95       	ret

0000222e <usart_spi_setup_device>:
    222e:	0f 93       	push	r16
    2230:	1f 93       	push	r17
    2232:	cf 93       	push	r28
    2234:	df 93       	push	r29
    2236:	00 d0       	rcall	.+0      	; 0x2238 <usart_spi_setup_device+0xa>
    2238:	00 d0       	rcall	.+0      	; 0x223a <usart_spi_setup_device+0xc>
    223a:	cd b7       	in	r28, 0x3d	; 61
    223c:	de b7       	in	r29, 0x3e	; 62
    223e:	09 83       	std	Y+1, r16	; 0x01
    2240:	1a 83       	std	Y+2, r17	; 0x02
    2242:	2b 83       	std	Y+3, r18	; 0x03
    2244:	3c 83       	std	Y+4, r19	; 0x04
    2246:	4d 83       	std	Y+5, r20	; 0x05
    2248:	1e 82       	std	Y+6, r1	; 0x06
    224a:	be 01       	movw	r22, r28
    224c:	6f 5f       	subi	r22, 0xFF	; 255
    224e:	7f 4f       	sbci	r23, 0xFF	; 255
    2250:	0d de       	rcall	.-998    	; 0x1e6c <usart_init_spi>
    2252:	26 96       	adiw	r28, 0x06	; 6
    2254:	cd bf       	out	0x3d, r28	; 61
    2256:	de bf       	out	0x3e, r29	; 62
    2258:	df 91       	pop	r29
    225a:	cf 91       	pop	r28
    225c:	1f 91       	pop	r17
    225e:	0f 91       	pop	r16
    2260:	08 95       	ret

00002262 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
    2262:	fb 01       	movw	r30, r22
    2264:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    2266:	e8 2f       	mov	r30, r24
    2268:	e6 95       	lsr	r30
    226a:	e6 95       	lsr	r30
    226c:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    226e:	40 e2       	ldi	r20, 0x20	; 32
    2270:	e4 9f       	mul	r30, r20
    2272:	f0 01       	movw	r30, r0
    2274:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2276:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    2278:	87 70       	andi	r24, 0x07	; 7
    227a:	21 e0       	ldi	r18, 0x01	; 1
    227c:	30 e0       	ldi	r19, 0x00	; 0
    227e:	a9 01       	movw	r20, r18
    2280:	02 c0       	rjmp	.+4      	; 0x2286 <usart_spi_select_device+0x24>
    2282:	44 0f       	add	r20, r20
    2284:	55 1f       	adc	r21, r21
    2286:	8a 95       	dec	r24
    2288:	e2 f7       	brpl	.-8      	; 0x2282 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    228a:	46 83       	std	Z+6, r20	; 0x06
    228c:	08 95       	ret

0000228e <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
    228e:	fb 01       	movw	r30, r22
    2290:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    2292:	e8 2f       	mov	r30, r24
    2294:	e6 95       	lsr	r30
    2296:	e6 95       	lsr	r30
    2298:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    229a:	40 e2       	ldi	r20, 0x20	; 32
    229c:	e4 9f       	mul	r30, r20
    229e:	f0 01       	movw	r30, r0
    22a0:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    22a2:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    22a4:	87 70       	andi	r24, 0x07	; 7
    22a6:	21 e0       	ldi	r18, 0x01	; 1
    22a8:	30 e0       	ldi	r19, 0x00	; 0
    22aa:	a9 01       	movw	r20, r18
    22ac:	02 c0       	rjmp	.+4      	; 0x22b2 <usart_spi_deselect_device+0x24>
    22ae:	44 0f       	add	r20, r20
    22b0:	55 1f       	adc	r21, r21
    22b2:	8a 95       	dec	r24
    22b4:	e2 f7       	brpl	.-8      	; 0x22ae <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    22b6:	45 83       	std	Z+5, r20	; 0x05
    22b8:	08 95       	ret

000022ba <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
    22ba:	80 93 1d 24 	sts	0x241D, r24
    22be:	90 93 1e 24 	sts	0x241E, r25
    22c2:	08 95       	ret

000022c4 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    22c4:	20 e8       	ldi	r18, 0x80	; 128
    22c6:	82 9f       	mul	r24, r18
    22c8:	c0 01       	movw	r24, r0
    22ca:	11 24       	eor	r1, r1
    22cc:	86 0f       	add	r24, r22
    22ce:	91 1d       	adc	r25, r1
    22d0:	e0 91 1d 24 	lds	r30, 0x241D
    22d4:	f0 91 1e 24 	lds	r31, 0x241E
    22d8:	e8 0f       	add	r30, r24
    22da:	f9 1f       	adc	r31, r25
    22dc:	40 83       	st	Z, r20
    22de:	08 95       	ret

000022e0 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
    22e0:	20 e8       	ldi	r18, 0x80	; 128
    22e2:	82 9f       	mul	r24, r18
    22e4:	c0 01       	movw	r24, r0
    22e6:	11 24       	eor	r1, r1
    22e8:	86 0f       	add	r24, r22
    22ea:	91 1d       	adc	r25, r1
    22ec:	e0 91 1d 24 	lds	r30, 0x241D
    22f0:	f0 91 1e 24 	lds	r31, 0x241E
    22f4:	e8 0f       	add	r30, r24
    22f6:	f9 1f       	adc	r31, r25
}
    22f8:	80 81       	ld	r24, Z
    22fa:	08 95       	ret

000022fc <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
    22fc:	ff 92       	push	r15
    22fe:	0f 93       	push	r16
    2300:	1f 93       	push	r17
    2302:	cf 93       	push	r28
    2304:	df 93       	push	r29
    2306:	e4 2f       	mov	r30, r20
    2308:	f0 e0       	ldi	r31, 0x00	; 0
    230a:	e8 0f       	add	r30, r24
    230c:	f1 1d       	adc	r31, r1
    230e:	e1 38       	cpi	r30, 0x81	; 129
    2310:	f1 05       	cpc	r31, r1
    2312:	1c f0       	brlt	.+6      	; 0x231a <gfx_mono_generic_draw_horizontal_line+0x1e>
    2314:	c0 e8       	ldi	r28, 0x80	; 128
    2316:	4c 2f       	mov	r20, r28
    2318:	48 1b       	sub	r20, r24
    231a:	44 23       	and	r20, r20
    231c:	09 f4       	brne	.+2      	; 0x2320 <gfx_mono_generic_draw_horizontal_line+0x24>
    231e:	56 c0       	rjmp	.+172    	; 0x23cc <gfx_mono_generic_draw_horizontal_line+0xd0>
    2320:	d6 2f       	mov	r29, r22
    2322:	d6 95       	lsr	r29
    2324:	d6 95       	lsr	r29
    2326:	d6 95       	lsr	r29
    2328:	ed 2f       	mov	r30, r29
    232a:	f0 e0       	ldi	r31, 0x00	; 0
    232c:	f1 95       	neg	r31
    232e:	e1 95       	neg	r30
    2330:	f1 09       	sbc	r31, r1
    2332:	ee 0f       	add	r30, r30
    2334:	ff 1f       	adc	r31, r31
    2336:	ee 0f       	add	r30, r30
    2338:	ff 1f       	adc	r31, r31
    233a:	ee 0f       	add	r30, r30
    233c:	ff 1f       	adc	r31, r31
    233e:	df 01       	movw	r26, r30
    2340:	a6 0f       	add	r26, r22
    2342:	b1 1d       	adc	r27, r1
    2344:	bd 01       	movw	r22, r26
    2346:	e1 e0       	ldi	r30, 0x01	; 1
    2348:	f0 e0       	ldi	r31, 0x00	; 0
    234a:	df 01       	movw	r26, r30
    234c:	02 c0       	rjmp	.+4      	; 0x2352 <gfx_mono_generic_draw_horizontal_line+0x56>
    234e:	aa 0f       	add	r26, r26
    2350:	bb 1f       	adc	r27, r27
    2352:	6a 95       	dec	r22
    2354:	e2 f7       	brpl	.-8      	; 0x234e <gfx_mono_generic_draw_horizontal_line+0x52>
    2356:	fa 2e       	mov	r15, r26
    2358:	21 30       	cpi	r18, 0x01	; 1
    235a:	21 f0       	breq	.+8      	; 0x2364 <gfx_mono_generic_draw_horizontal_line+0x68>
    235c:	a0 f0       	brcs	.+40     	; 0x2386 <gfx_mono_generic_draw_horizontal_line+0x8a>
    235e:	22 30       	cpi	r18, 0x02	; 2
    2360:	29 f1       	breq	.+74     	; 0x23ac <gfx_mono_generic_draw_horizontal_line+0xb0>
    2362:	34 c0       	rjmp	.+104    	; 0x23cc <gfx_mono_generic_draw_horizontal_line+0xd0>
    2364:	c4 2f       	mov	r28, r20
    2366:	1f ef       	ldi	r17, 0xFF	; 255
    2368:	18 0f       	add	r17, r24
    236a:	01 2f       	mov	r16, r17
    236c:	0c 0f       	add	r16, r28
    236e:	60 2f       	mov	r22, r16
    2370:	8d 2f       	mov	r24, r29
    2372:	23 d9       	rcall	.-3514   	; 0x15ba <gfx_mono_st7565r_get_byte>
    2374:	48 2f       	mov	r20, r24
    2376:	4f 29       	or	r20, r15
    2378:	60 2f       	mov	r22, r16
    237a:	8d 2f       	mov	r24, r29
    237c:	0e 94 b6 09 	call	0x136c	; 0x136c <gfx_mono_st7565r_put_byte>
    2380:	c1 50       	subi	r28, 0x01	; 1
    2382:	99 f7       	brne	.-26     	; 0x236a <gfx_mono_generic_draw_horizontal_line+0x6e>
    2384:	23 c0       	rjmp	.+70     	; 0x23cc <gfx_mono_generic_draw_horizontal_line+0xd0>
    2386:	c4 2f       	mov	r28, r20
    2388:	1f ef       	ldi	r17, 0xFF	; 255
    238a:	18 0f       	add	r17, r24
    238c:	fa 2e       	mov	r15, r26
    238e:	f0 94       	com	r15
    2390:	01 2f       	mov	r16, r17
    2392:	0c 0f       	add	r16, r28
    2394:	60 2f       	mov	r22, r16
    2396:	8d 2f       	mov	r24, r29
    2398:	10 d9       	rcall	.-3552   	; 0x15ba <gfx_mono_st7565r_get_byte>
    239a:	48 2f       	mov	r20, r24
    239c:	4f 21       	and	r20, r15
    239e:	60 2f       	mov	r22, r16
    23a0:	8d 2f       	mov	r24, r29
    23a2:	0e 94 b6 09 	call	0x136c	; 0x136c <gfx_mono_st7565r_put_byte>
    23a6:	c1 50       	subi	r28, 0x01	; 1
    23a8:	99 f7       	brne	.-26     	; 0x2390 <gfx_mono_generic_draw_horizontal_line+0x94>
    23aa:	10 c0       	rjmp	.+32     	; 0x23cc <gfx_mono_generic_draw_horizontal_line+0xd0>
    23ac:	c4 2f       	mov	r28, r20
    23ae:	1f ef       	ldi	r17, 0xFF	; 255
    23b0:	18 0f       	add	r17, r24
    23b2:	01 2f       	mov	r16, r17
    23b4:	0c 0f       	add	r16, r28
    23b6:	60 2f       	mov	r22, r16
    23b8:	8d 2f       	mov	r24, r29
    23ba:	ff d8       	rcall	.-3586   	; 0x15ba <gfx_mono_st7565r_get_byte>
    23bc:	48 2f       	mov	r20, r24
    23be:	4f 25       	eor	r20, r15
    23c0:	60 2f       	mov	r22, r16
    23c2:	8d 2f       	mov	r24, r29
    23c4:	0e 94 b6 09 	call	0x136c	; 0x136c <gfx_mono_st7565r_put_byte>
    23c8:	c1 50       	subi	r28, 0x01	; 1
    23ca:	99 f7       	brne	.-26     	; 0x23b2 <gfx_mono_generic_draw_horizontal_line+0xb6>
    23cc:	df 91       	pop	r29
    23ce:	cf 91       	pop	r28
    23d0:	1f 91       	pop	r17
    23d2:	0f 91       	pop	r16
    23d4:	ff 90       	pop	r15
    23d6:	08 95       	ret

000023d8 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
    23d8:	ff 92       	push	r15
    23da:	0f 93       	push	r16
    23dc:	1f 93       	push	r17
    23de:	cf 93       	push	r28
    23e0:	df 93       	push	r29
	if (height == 0) {
    23e2:	22 23       	and	r18, r18
    23e4:	69 f0       	breq	.+26     	; 0x2400 <gfx_mono_generic_draw_filled_rect+0x28>
    23e6:	c2 2f       	mov	r28, r18
    23e8:	f4 2e       	mov	r15, r20
    23ea:	18 2f       	mov	r17, r24
    23ec:	df ef       	ldi	r29, 0xFF	; 255
    23ee:	d6 0f       	add	r29, r22
    23f0:	6d 2f       	mov	r22, r29
    23f2:	6c 0f       	add	r22, r28
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
    23f4:	20 2f       	mov	r18, r16
    23f6:	4f 2d       	mov	r20, r15
    23f8:	81 2f       	mov	r24, r17
    23fa:	80 df       	rcall	.-256    	; 0x22fc <gfx_mono_generic_draw_horizontal_line>
    23fc:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
    23fe:	c1 f7       	brne	.-16     	; 0x23f0 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
    2400:	df 91       	pop	r29
    2402:	cf 91       	pop	r28
    2404:	1f 91       	pop	r17
    2406:	0f 91       	pop	r16
    2408:	ff 90       	pop	r15
    240a:	08 95       	ret

0000240c <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
    240c:	af 92       	push	r10
    240e:	bf 92       	push	r11
    2410:	cf 92       	push	r12
    2412:	df 92       	push	r13
    2414:	ef 92       	push	r14
    2416:	ff 92       	push	r15
    2418:	0f 93       	push	r16
    241a:	1f 93       	push	r17
    241c:	cf 93       	push	r28
    241e:	df 93       	push	r29
    2420:	c8 2f       	mov	r28, r24
    2422:	e6 2e       	mov	r14, r22
    2424:	b4 2e       	mov	r11, r20
    2426:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
    2428:	00 e0       	ldi	r16, 0x00	; 0
    242a:	f9 01       	movw	r30, r18
    242c:	24 81       	ldd	r18, Z+4	; 0x04
    242e:	43 81       	ldd	r20, Z+3	; 0x03
    2430:	6b 2d       	mov	r22, r11
    2432:	8e 2d       	mov	r24, r14
    2434:	d1 df       	rcall	.-94     	; 0x23d8 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
    2436:	f6 01       	movw	r30, r12
    2438:	80 81       	ld	r24, Z
    243a:	81 11       	cpse	r24, r1
    243c:	39 c0       	rjmp	.+114    	; 0x24b0 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
    243e:	83 81       	ldd	r24, Z+3	; 0x03
    2440:	28 2f       	mov	r18, r24
    2442:	26 95       	lsr	r18
    2444:	26 95       	lsr	r18
    2446:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
    2448:	87 70       	andi	r24, 0x07	; 7
    244a:	09 f0       	breq	.+2      	; 0x244e <gfx_mono_draw_char+0x42>
		char_row_size++;
    244c:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
    244e:	f6 01       	movw	r30, r12
    2450:	a4 80       	ldd	r10, Z+4	; 0x04
    2452:	2a 9d       	mul	r18, r10
    2454:	90 01       	movw	r18, r0
    2456:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
    2458:	8c 2f       	mov	r24, r28
    245a:	90 e0       	ldi	r25, 0x00	; 0
    245c:	45 81       	ldd	r20, Z+5	; 0x05
    245e:	84 1b       	sub	r24, r20
    2460:	91 09       	sbc	r25, r1
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
    2462:	28 9f       	mul	r18, r24
    2464:	a0 01       	movw	r20, r0
    2466:	29 9f       	mul	r18, r25
    2468:	50 0d       	add	r21, r0
    246a:	38 9f       	mul	r19, r24
    246c:	50 0d       	add	r21, r0
    246e:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
    2470:	01 81       	ldd	r16, Z+1	; 0x01
    2472:	12 81       	ldd	r17, Z+2	; 0x02
    2474:	04 0f       	add	r16, r20
    2476:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
    2478:	f6 01       	movw	r30, r12
    247a:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
    247c:	ff 20       	and	r15, r15
    247e:	a1 f0       	breq	.+40     	; 0x24a8 <gfx_mono_draw_char+0x9c>
    2480:	d0 e0       	ldi	r29, 0x00	; 0
    2482:	c0 e0       	ldi	r28, 0x00	; 0
    2484:	8c 2f       	mov	r24, r28
    2486:	8e 0d       	add	r24, r14
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
    2488:	9c 2f       	mov	r25, r28
    248a:	97 70       	andi	r25, 0x07	; 7
    248c:	21 f4       	brne	.+8      	; 0x2496 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
    248e:	f8 01       	movw	r30, r16
    2490:	d4 91       	lpm	r29, Z
				glyph_data++;
    2492:	0f 5f       	subi	r16, 0xFF	; 255
    2494:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
    2496:	dd 23       	and	r29, r29
    2498:	1c f4       	brge	.+6      	; 0x24a0 <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
    249a:	41 e0       	ldi	r20, 0x01	; 1
    249c:	6b 2d       	mov	r22, r11
    249e:	4f d8       	rcall	.-3938   	; 0x153e <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
    24a0:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
    24a2:	cf 5f       	subi	r28, 0xFF	; 255
    24a4:	cf 11       	cpse	r28, r15
    24a6:	ee cf       	rjmp	.-36     	; 0x2484 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
    24a8:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
    24aa:	aa 94       	dec	r10
	} while (rows_left > 0);
    24ac:	a1 10       	cpse	r10, r1
    24ae:	e4 cf       	rjmp	.-56     	; 0x2478 <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
    24b0:	df 91       	pop	r29
    24b2:	cf 91       	pop	r28
    24b4:	1f 91       	pop	r17
    24b6:	0f 91       	pop	r16
    24b8:	ff 90       	pop	r15
    24ba:	ef 90       	pop	r14
    24bc:	df 90       	pop	r13
    24be:	cf 90       	pop	r12
    24c0:	bf 90       	pop	r11
    24c2:	af 90       	pop	r10
    24c4:	08 95       	ret

000024c6 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
    24c6:	df 92       	push	r13
    24c8:	ef 92       	push	r14
    24ca:	ff 92       	push	r15
    24cc:	0f 93       	push	r16
    24ce:	1f 93       	push	r17
    24d0:	cf 93       	push	r28
    24d2:	df 93       	push	r29
    24d4:	04 2f       	mov	r16, r20
    24d6:	79 01       	movw	r14, r18
    24d8:	ec 01       	movw	r28, r24
    24da:	16 2f       	mov	r17, r22

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    24dc:	d6 2e       	mov	r13, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
    24de:	89 91       	ld	r24, Y+
    24e0:	8a 30       	cpi	r24, 0x0A	; 10
    24e2:	31 f4       	brne	.+12     	; 0x24f0 <gfx_mono_draw_string+0x2a>
    24e4:	f7 01       	movw	r30, r14
    24e6:	84 81       	ldd	r24, Z+4	; 0x04
    24e8:	8f 5f       	subi	r24, 0xFF	; 255
			x = start_of_string_position_x;
			y += font->height + 1;
    24ea:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    24ec:	1d 2d       	mov	r17, r13
    24ee:	09 c0       	rjmp	.+18     	; 0x2502 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
    24f0:	8d 30       	cpi	r24, 0x0D	; 13
    24f2:	39 f0       	breq	.+14     	; 0x2502 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
    24f4:	97 01       	movw	r18, r14
    24f6:	40 2f       	mov	r20, r16
    24f8:	61 2f       	mov	r22, r17
    24fa:	88 df       	rcall	.-240    	; 0x240c <gfx_mono_draw_char>
			x += font->width;
    24fc:	f7 01       	movw	r30, r14
    24fe:	83 81       	ldd	r24, Z+3	; 0x03
    2500:	18 0f       	add	r17, r24
		}
	} while (*(++str));
    2502:	88 81       	ld	r24, Y
    2504:	81 11       	cpse	r24, r1
    2506:	eb cf       	rjmp	.-42     	; 0x24de <gfx_mono_draw_string+0x18>
}
    2508:	df 91       	pop	r29
    250a:	cf 91       	pop	r28
    250c:	1f 91       	pop	r17
    250e:	0f 91       	pop	r16
    2510:	ff 90       	pop	r15
    2512:	ef 90       	pop	r14
    2514:	df 90       	pop	r13
    2516:	08 95       	ret

00002518 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2518:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    251a:	03 96       	adiw	r24, 0x03	; 3
    251c:	81 83       	std	Z+1, r24	; 0x01
    251e:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2520:	2f ef       	ldi	r18, 0xFF	; 255
    2522:	3f ef       	ldi	r19, 0xFF	; 255
    2524:	23 83       	std	Z+3, r18	; 0x03
    2526:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2528:	85 83       	std	Z+5, r24	; 0x05
    252a:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    252c:	87 83       	std	Z+7, r24	; 0x07
    252e:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2530:	10 82       	st	Z, r1
    2532:	08 95       	ret

00002534 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2534:	fc 01       	movw	r30, r24
    2536:	10 86       	std	Z+8, r1	; 0x08
    2538:	11 86       	std	Z+9, r1	; 0x09
    253a:	08 95       	ret

0000253c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    253c:	cf 93       	push	r28
    253e:	df 93       	push	r29
    2540:	9c 01       	movw	r18, r24
    2542:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2544:	dc 01       	movw	r26, r24
    2546:	11 96       	adiw	r26, 0x01	; 1
    2548:	cd 91       	ld	r28, X+
    254a:	dc 91       	ld	r29, X
    254c:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    254e:	c2 83       	std	Z+2, r28	; 0x02
    2550:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2552:	8c 81       	ldd	r24, Y+4	; 0x04
    2554:	9d 81       	ldd	r25, Y+5	; 0x05
    2556:	84 83       	std	Z+4, r24	; 0x04
    2558:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    255a:	8c 81       	ldd	r24, Y+4	; 0x04
    255c:	9d 81       	ldd	r25, Y+5	; 0x05
    255e:	dc 01       	movw	r26, r24
    2560:	12 96       	adiw	r26, 0x02	; 2
    2562:	6d 93       	st	X+, r22
    2564:	7c 93       	st	X, r23
    2566:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    2568:	6c 83       	std	Y+4, r22	; 0x04
    256a:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    256c:	20 87       	std	Z+8, r18	; 0x08
    256e:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    2570:	f9 01       	movw	r30, r18
    2572:	80 81       	ld	r24, Z
    2574:	8f 5f       	subi	r24, 0xFF	; 255
    2576:	80 83       	st	Z, r24
}
    2578:	df 91       	pop	r29
    257a:	cf 91       	pop	r28
    257c:	08 95       	ret

0000257e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    257e:	cf 93       	push	r28
    2580:	df 93       	push	r29
    2582:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2584:	48 81       	ld	r20, Y
    2586:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2588:	4f 3f       	cpi	r20, 0xFF	; 255
    258a:	2f ef       	ldi	r18, 0xFF	; 255
    258c:	52 07       	cpc	r21, r18
    258e:	21 f4       	brne	.+8      	; 0x2598 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2590:	fc 01       	movw	r30, r24
    2592:	a7 81       	ldd	r26, Z+7	; 0x07
    2594:	b0 85       	ldd	r27, Z+8	; 0x08
    2596:	0d c0       	rjmp	.+26     	; 0x25b2 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2598:	dc 01       	movw	r26, r24
    259a:	13 96       	adiw	r26, 0x03	; 3
    259c:	01 c0       	rjmp	.+2      	; 0x25a0 <vListInsert+0x22>
    259e:	df 01       	movw	r26, r30
    25a0:	12 96       	adiw	r26, 0x02	; 2
    25a2:	ed 91       	ld	r30, X+
    25a4:	fc 91       	ld	r31, X
    25a6:	13 97       	sbiw	r26, 0x03	; 3
    25a8:	20 81       	ld	r18, Z
    25aa:	31 81       	ldd	r19, Z+1	; 0x01
    25ac:	42 17       	cp	r20, r18
    25ae:	53 07       	cpc	r21, r19
    25b0:	b0 f7       	brcc	.-20     	; 0x259e <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    25b2:	12 96       	adiw	r26, 0x02	; 2
    25b4:	ed 91       	ld	r30, X+
    25b6:	fc 91       	ld	r31, X
    25b8:	13 97       	sbiw	r26, 0x03	; 3
    25ba:	ea 83       	std	Y+2, r30	; 0x02
    25bc:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    25be:	c4 83       	std	Z+4, r28	; 0x04
    25c0:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    25c2:	ac 83       	std	Y+4, r26	; 0x04
    25c4:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    25c6:	12 96       	adiw	r26, 0x02	; 2
    25c8:	cd 93       	st	X+, r28
    25ca:	dc 93       	st	X, r29
    25cc:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    25ce:	88 87       	std	Y+8, r24	; 0x08
    25d0:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    25d2:	fc 01       	movw	r30, r24
    25d4:	20 81       	ld	r18, Z
    25d6:	2f 5f       	subi	r18, 0xFF	; 255
    25d8:	20 83       	st	Z, r18
}
    25da:	df 91       	pop	r29
    25dc:	cf 91       	pop	r28
    25de:	08 95       	ret

000025e0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    25e0:	cf 93       	push	r28
    25e2:	df 93       	push	r29
    25e4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    25e6:	a0 85       	ldd	r26, Z+8	; 0x08
    25e8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    25ea:	c2 81       	ldd	r28, Z+2	; 0x02
    25ec:	d3 81       	ldd	r29, Z+3	; 0x03
    25ee:	84 81       	ldd	r24, Z+4	; 0x04
    25f0:	95 81       	ldd	r25, Z+5	; 0x05
    25f2:	8c 83       	std	Y+4, r24	; 0x04
    25f4:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    25f6:	c4 81       	ldd	r28, Z+4	; 0x04
    25f8:	d5 81       	ldd	r29, Z+5	; 0x05
    25fa:	82 81       	ldd	r24, Z+2	; 0x02
    25fc:	93 81       	ldd	r25, Z+3	; 0x03
    25fe:	8a 83       	std	Y+2, r24	; 0x02
    2600:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2602:	11 96       	adiw	r26, 0x01	; 1
    2604:	cd 91       	ld	r28, X+
    2606:	dc 91       	ld	r29, X
    2608:	12 97       	sbiw	r26, 0x02	; 2
    260a:	ce 17       	cp	r28, r30
    260c:	df 07       	cpc	r29, r31
    260e:	31 f4       	brne	.+12     	; 0x261c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2610:	8c 81       	ldd	r24, Y+4	; 0x04
    2612:	9d 81       	ldd	r25, Y+5	; 0x05
    2614:	11 96       	adiw	r26, 0x01	; 1
    2616:	8d 93       	st	X+, r24
    2618:	9c 93       	st	X, r25
    261a:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    261c:	10 86       	std	Z+8, r1	; 0x08
    261e:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    2620:	8c 91       	ld	r24, X
    2622:	81 50       	subi	r24, 0x01	; 1
    2624:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    2626:	df 91       	pop	r29
    2628:	cf 91       	pop	r28
    262a:	08 95       	ret

0000262c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    262c:	0f 93       	push	r16
    262e:	1f 93       	push	r17
    2630:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    2632:	71 e1       	ldi	r23, 0x11	; 17
    2634:	fc 01       	movw	r30, r24
    2636:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    2638:	31 97       	sbiw	r30, 0x01	; 1
    263a:	62 e2       	ldi	r22, 0x22	; 34
    263c:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    263e:	31 97       	sbiw	r30, 0x01	; 1
    2640:	23 e3       	ldi	r18, 0x33	; 51
    2642:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    2644:	01 2e       	mov	r0, r17
    2646:	00 0c       	add	r0, r0
    2648:	22 0b       	sbc	r18, r18
    264a:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    264c:	31 97       	sbiw	r30, 0x01	; 1
    264e:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    2650:	31 97       	sbiw	r30, 0x01	; 1
    2652:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    2654:	31 97       	sbiw	r30, 0x01	; 1
    2656:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    2658:	31 97       	sbiw	r30, 0x01	; 1
    265a:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    265c:	31 97       	sbiw	r30, 0x01	; 1
    265e:	20 e8       	ldi	r18, 0x80	; 128
    2660:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    2662:	31 97       	sbiw	r30, 0x01	; 1
    2664:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    2666:	31 97       	sbiw	r30, 0x01	; 1
    2668:	22 e0       	ldi	r18, 0x02	; 2
    266a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    266c:	31 97       	sbiw	r30, 0x01	; 1
    266e:	23 e0       	ldi	r18, 0x03	; 3
    2670:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    2672:	31 97       	sbiw	r30, 0x01	; 1
    2674:	24 e0       	ldi	r18, 0x04	; 4
    2676:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    2678:	31 97       	sbiw	r30, 0x01	; 1
    267a:	25 e0       	ldi	r18, 0x05	; 5
    267c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    267e:	31 97       	sbiw	r30, 0x01	; 1
    2680:	26 e0       	ldi	r18, 0x06	; 6
    2682:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    2684:	31 97       	sbiw	r30, 0x01	; 1
    2686:	27 e0       	ldi	r18, 0x07	; 7
    2688:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    268a:	31 97       	sbiw	r30, 0x01	; 1
    268c:	28 e0       	ldi	r18, 0x08	; 8
    268e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    2690:	31 97       	sbiw	r30, 0x01	; 1
    2692:	29 e0       	ldi	r18, 0x09	; 9
    2694:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    2696:	31 97       	sbiw	r30, 0x01	; 1
    2698:	20 e1       	ldi	r18, 0x10	; 16
    269a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    269c:	31 97       	sbiw	r30, 0x01	; 1
    269e:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    26a0:	31 97       	sbiw	r30, 0x01	; 1
    26a2:	22 e1       	ldi	r18, 0x12	; 18
    26a4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    26a6:	31 97       	sbiw	r30, 0x01	; 1
    26a8:	23 e1       	ldi	r18, 0x13	; 19
    26aa:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    26ac:	31 97       	sbiw	r30, 0x01	; 1
    26ae:	24 e1       	ldi	r18, 0x14	; 20
    26b0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    26b2:	31 97       	sbiw	r30, 0x01	; 1
    26b4:	25 e1       	ldi	r18, 0x15	; 21
    26b6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    26b8:	31 97       	sbiw	r30, 0x01	; 1
    26ba:	26 e1       	ldi	r18, 0x16	; 22
    26bc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    26be:	31 97       	sbiw	r30, 0x01	; 1
    26c0:	27 e1       	ldi	r18, 0x17	; 23
    26c2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    26c4:	31 97       	sbiw	r30, 0x01	; 1
    26c6:	28 e1       	ldi	r18, 0x18	; 24
    26c8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    26ca:	31 97       	sbiw	r30, 0x01	; 1
    26cc:	29 e1       	ldi	r18, 0x19	; 25
    26ce:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    26d0:	31 97       	sbiw	r30, 0x01	; 1
    26d2:	20 e2       	ldi	r18, 0x20	; 32
    26d4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    26d6:	31 97       	sbiw	r30, 0x01	; 1
    26d8:	21 e2       	ldi	r18, 0x21	; 33
    26da:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    26dc:	31 97       	sbiw	r30, 0x01	; 1
    26de:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    26e0:	31 97       	sbiw	r30, 0x01	; 1
    26e2:	23 e2       	ldi	r18, 0x23	; 35
    26e4:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    26e6:	31 97       	sbiw	r30, 0x01	; 1
    26e8:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    26ea:	31 97       	sbiw	r30, 0x01	; 1
    26ec:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    26ee:	31 97       	sbiw	r30, 0x01	; 1
    26f0:	26 e2       	ldi	r18, 0x26	; 38
    26f2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    26f4:	31 97       	sbiw	r30, 0x01	; 1
    26f6:	27 e2       	ldi	r18, 0x27	; 39
    26f8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    26fa:	31 97       	sbiw	r30, 0x01	; 1
    26fc:	28 e2       	ldi	r18, 0x28	; 40
    26fe:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    2700:	31 97       	sbiw	r30, 0x01	; 1
    2702:	29 e2       	ldi	r18, 0x29	; 41
    2704:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    2706:	31 97       	sbiw	r30, 0x01	; 1
    2708:	20 e3       	ldi	r18, 0x30	; 48
    270a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    270c:	31 97       	sbiw	r30, 0x01	; 1
    270e:	21 e3       	ldi	r18, 0x31	; 49
    2710:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    2712:	87 97       	sbiw	r24, 0x27	; 39
    2714:	1f 91       	pop	r17
    2716:	0f 91       	pop	r16
    2718:	08 95       	ret

0000271a <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    271a:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    271c:	e0 e7       	ldi	r30, 0x70	; 112
    271e:	f0 e0       	ldi	r31, 0x00	; 0
    2720:	83 81       	ldd	r24, Z+3	; 0x03
    2722:	8a 7f       	andi	r24, 0xFA	; 250
    2724:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    2726:	e0 e0       	ldi	r30, 0x00	; 0
    2728:	f8 e0       	ldi	r31, 0x08	; 8
    272a:	80 ea       	ldi	r24, 0xA0	; 160
    272c:	9f e0       	ldi	r25, 0x0F	; 15
    272e:	86 a3       	std	Z+38, r24	; 0x26
    2730:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    2732:	91 e0       	ldi	r25, 0x01	; 1
    2734:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    2736:	a0 ea       	ldi	r26, 0xA0	; 160
    2738:	b0 e0       	ldi	r27, 0x00	; 0
    273a:	12 96       	adiw	r26, 0x02	; 2
    273c:	8c 91       	ld	r24, X
    273e:	12 97       	sbiw	r26, 0x02	; 2
    2740:	81 60       	ori	r24, 0x01	; 1
    2742:	12 96       	adiw	r26, 0x02	; 2
    2744:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    2746:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    2748:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    274a:	a0 91 75 24 	lds	r26, 0x2475
    274e:	b0 91 76 24 	lds	r27, 0x2476
    2752:	0d 90       	ld	r0, X+
    2754:	0d be       	out	0x3d, r0	; 61
    2756:	0d 90       	ld	r0, X+
    2758:	0e be       	out	0x3e, r0	; 62
    275a:	ff 91       	pop	r31
    275c:	ef 91       	pop	r30
    275e:	df 91       	pop	r29
    2760:	cf 91       	pop	r28
    2762:	bf 91       	pop	r27
    2764:	af 91       	pop	r26
    2766:	9f 91       	pop	r25
    2768:	8f 91       	pop	r24
    276a:	7f 91       	pop	r23
    276c:	6f 91       	pop	r22
    276e:	5f 91       	pop	r21
    2770:	4f 91       	pop	r20
    2772:	3f 91       	pop	r19
    2774:	2f 91       	pop	r18
    2776:	1f 91       	pop	r17
    2778:	0f 91       	pop	r16
    277a:	ff 90       	pop	r15
    277c:	ef 90       	pop	r14
    277e:	df 90       	pop	r13
    2780:	cf 90       	pop	r12
    2782:	bf 90       	pop	r11
    2784:	af 90       	pop	r10
    2786:	9f 90       	pop	r9
    2788:	8f 90       	pop	r8
    278a:	7f 90       	pop	r7
    278c:	6f 90       	pop	r6
    278e:	5f 90       	pop	r5
    2790:	4f 90       	pop	r4
    2792:	3f 90       	pop	r3
    2794:	2f 90       	pop	r2
    2796:	1f 90       	pop	r1
    2798:	0f 90       	pop	r0
    279a:	0f be       	out	0x3f, r0	; 63
    279c:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    279e:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    27a0:	81 e0       	ldi	r24, 0x01	; 1
    27a2:	08 95       	ret

000027a4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    27a4:	0f 92       	push	r0
    27a6:	0f b6       	in	r0, 0x3f	; 63
    27a8:	f8 94       	cli
    27aa:	0f 92       	push	r0
    27ac:	1f 92       	push	r1
    27ae:	11 24       	eor	r1, r1
    27b0:	2f 92       	push	r2
    27b2:	3f 92       	push	r3
    27b4:	4f 92       	push	r4
    27b6:	5f 92       	push	r5
    27b8:	6f 92       	push	r6
    27ba:	7f 92       	push	r7
    27bc:	8f 92       	push	r8
    27be:	9f 92       	push	r9
    27c0:	af 92       	push	r10
    27c2:	bf 92       	push	r11
    27c4:	cf 92       	push	r12
    27c6:	df 92       	push	r13
    27c8:	ef 92       	push	r14
    27ca:	ff 92       	push	r15
    27cc:	0f 93       	push	r16
    27ce:	1f 93       	push	r17
    27d0:	2f 93       	push	r18
    27d2:	3f 93       	push	r19
    27d4:	4f 93       	push	r20
    27d6:	5f 93       	push	r21
    27d8:	6f 93       	push	r22
    27da:	7f 93       	push	r23
    27dc:	8f 93       	push	r24
    27de:	9f 93       	push	r25
    27e0:	af 93       	push	r26
    27e2:	bf 93       	push	r27
    27e4:	cf 93       	push	r28
    27e6:	df 93       	push	r29
    27e8:	ef 93       	push	r30
    27ea:	ff 93       	push	r31
    27ec:	a0 91 75 24 	lds	r26, 0x2475
    27f0:	b0 91 76 24 	lds	r27, 0x2476
    27f4:	0d b6       	in	r0, 0x3d	; 61
    27f6:	0d 92       	st	X+, r0
    27f8:	0e b6       	in	r0, 0x3e	; 62
    27fa:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    27fc:	80 d3       	rcall	.+1792   	; 0x2efe <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    27fe:	a0 91 75 24 	lds	r26, 0x2475
    2802:	b0 91 76 24 	lds	r27, 0x2476
    2806:	0d 90       	ld	r0, X+
    2808:	0d be       	out	0x3d, r0	; 61
    280a:	0d 90       	ld	r0, X+
    280c:	0e be       	out	0x3e, r0	; 62
    280e:	ff 91       	pop	r31
    2810:	ef 91       	pop	r30
    2812:	df 91       	pop	r29
    2814:	cf 91       	pop	r28
    2816:	bf 91       	pop	r27
    2818:	af 91       	pop	r26
    281a:	9f 91       	pop	r25
    281c:	8f 91       	pop	r24
    281e:	7f 91       	pop	r23
    2820:	6f 91       	pop	r22
    2822:	5f 91       	pop	r21
    2824:	4f 91       	pop	r20
    2826:	3f 91       	pop	r19
    2828:	2f 91       	pop	r18
    282a:	1f 91       	pop	r17
    282c:	0f 91       	pop	r16
    282e:	ff 90       	pop	r15
    2830:	ef 90       	pop	r14
    2832:	df 90       	pop	r13
    2834:	cf 90       	pop	r12
    2836:	bf 90       	pop	r11
    2838:	af 90       	pop	r10
    283a:	9f 90       	pop	r9
    283c:	8f 90       	pop	r8
    283e:	7f 90       	pop	r7
    2840:	6f 90       	pop	r6
    2842:	5f 90       	pop	r5
    2844:	4f 90       	pop	r4
    2846:	3f 90       	pop	r3
    2848:	2f 90       	pop	r2
    284a:	1f 90       	pop	r1
    284c:	0f 90       	pop	r0
    284e:	0f be       	out	0x3f, r0	; 63
    2850:	0f 90       	pop	r0

    asm volatile ( "ret" );
    2852:	08 95       	ret

00002854 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    2854:	0f 92       	push	r0
    2856:	0f b6       	in	r0, 0x3f	; 63
    2858:	f8 94       	cli
    285a:	0f 92       	push	r0
    285c:	1f 92       	push	r1
    285e:	11 24       	eor	r1, r1
    2860:	2f 92       	push	r2
    2862:	3f 92       	push	r3
    2864:	4f 92       	push	r4
    2866:	5f 92       	push	r5
    2868:	6f 92       	push	r6
    286a:	7f 92       	push	r7
    286c:	8f 92       	push	r8
    286e:	9f 92       	push	r9
    2870:	af 92       	push	r10
    2872:	bf 92       	push	r11
    2874:	cf 92       	push	r12
    2876:	df 92       	push	r13
    2878:	ef 92       	push	r14
    287a:	ff 92       	push	r15
    287c:	0f 93       	push	r16
    287e:	1f 93       	push	r17
    2880:	2f 93       	push	r18
    2882:	3f 93       	push	r19
    2884:	4f 93       	push	r20
    2886:	5f 93       	push	r21
    2888:	6f 93       	push	r22
    288a:	7f 93       	push	r23
    288c:	8f 93       	push	r24
    288e:	9f 93       	push	r25
    2890:	af 93       	push	r26
    2892:	bf 93       	push	r27
    2894:	cf 93       	push	r28
    2896:	df 93       	push	r29
    2898:	ef 93       	push	r30
    289a:	ff 93       	push	r31
    289c:	a0 91 75 24 	lds	r26, 0x2475
    28a0:	b0 91 76 24 	lds	r27, 0x2476
    28a4:	0d b6       	in	r0, 0x3d	; 61
    28a6:	0d 92       	st	X+, r0
    28a8:	0e b6       	in	r0, 0x3e	; 62
    28aa:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    28ac:	bd d1       	rcall	.+890    	; 0x2c28 <xTaskIncrementTick>
    28ae:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    28b0:	26 d3       	rcall	.+1612   	; 0x2efe <vTaskSwitchContext>
        }
        portRESTORE_CONTEXT();
    28b2:	a0 91 75 24 	lds	r26, 0x2475
    28b6:	b0 91 76 24 	lds	r27, 0x2476
    28ba:	0d 90       	ld	r0, X+
    28bc:	0d be       	out	0x3d, r0	; 61
    28be:	0d 90       	ld	r0, X+
    28c0:	0e be       	out	0x3e, r0	; 62
    28c2:	ff 91       	pop	r31
    28c4:	ef 91       	pop	r30
    28c6:	df 91       	pop	r29
    28c8:	cf 91       	pop	r28
    28ca:	bf 91       	pop	r27
    28cc:	af 91       	pop	r26
    28ce:	9f 91       	pop	r25
    28d0:	8f 91       	pop	r24
    28d2:	7f 91       	pop	r23
    28d4:	6f 91       	pop	r22
    28d6:	5f 91       	pop	r21
    28d8:	4f 91       	pop	r20
    28da:	3f 91       	pop	r19
    28dc:	2f 91       	pop	r18
    28de:	1f 91       	pop	r17
    28e0:	0f 91       	pop	r16
    28e2:	ff 90       	pop	r15
    28e4:	ef 90       	pop	r14
    28e6:	df 90       	pop	r13
    28e8:	cf 90       	pop	r12
    28ea:	bf 90       	pop	r11
    28ec:	af 90       	pop	r10
    28ee:	9f 90       	pop	r9
    28f0:	8f 90       	pop	r8
    28f2:	7f 90       	pop	r7
    28f4:	6f 90       	pop	r6
    28f6:	5f 90       	pop	r5
    28f8:	4f 90       	pop	r4
    28fa:	3f 90       	pop	r3
    28fc:	2f 90       	pop	r2
    28fe:	1f 90       	pop	r1
    2900:	0f 90       	pop	r0
    2902:	0f be       	out	0x3f, r0	; 63
    2904:	0f 90       	pop	r0

        asm volatile ( "reti" );
    2906:	18 95       	reti

00002908 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2908:	cf 93       	push	r28
    290a:	df 93       	push	r29
    290c:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    290e:	7c d1       	rcall	.+760    	; 0x2c08 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    2910:	ce 01       	movw	r24, r28
    2912:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <malloc>
    2916:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2918:	5a d2       	rcall	.+1204   	; 0x2dce <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    291a:	ce 01       	movw	r24, r28
    291c:	df 91       	pop	r29
    291e:	cf 91       	pop	r28
    2920:	08 95       	ret

00002922 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2922:	cf 93       	push	r28
    2924:	df 93       	push	r29
	if( pv )
    2926:	00 97       	sbiw	r24, 0x00	; 0
    2928:	31 f0       	breq	.+12     	; 0x2936 <vPortFree+0x14>
    292a:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    292c:	6d d1       	rcall	.+730    	; 0x2c08 <vTaskSuspendAll>
		{
			free( pv );
    292e:	ce 01       	movw	r24, r28
    2930:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    2934:	4c d2       	rcall	.+1176   	; 0x2dce <xTaskResumeAll>
	}
}
    2936:	df 91       	pop	r29
    2938:	cf 91       	pop	r28
    293a:	08 95       	ret

0000293c <prvIdleTask>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    293c:	c8 e4       	ldi	r28, 0x48	; 72
    293e:	d4 e2       	ldi	r29, 0x24	; 36
    2940:	88 81       	ld	r24, Y
    2942:	82 30       	cpi	r24, 0x02	; 2
    2944:	f0 f3       	brcs	.-4      	; 0x2942 <prvIdleTask+0x6>
    2946:	2e df       	rcall	.-420    	; 0x27a4 <vPortYield>
    2948:	fb cf       	rjmp	.-10     	; 0x2940 <prvIdleTask+0x4>

0000294a <prvAddCurrentTaskToDelayedList>:
    294a:	cf 93       	push	r28
    294c:	df 93       	push	r29
    294e:	ec 01       	movw	r28, r24
    2950:	e0 91 75 24 	lds	r30, 0x2475
    2954:	f0 91 76 24 	lds	r31, 0x2476
    2958:	82 83       	std	Z+2, r24	; 0x02
    295a:	93 83       	std	Z+3, r25	; 0x03
    295c:	80 91 26 24 	lds	r24, 0x2426
    2960:	90 91 27 24 	lds	r25, 0x2427
    2964:	c8 17       	cp	r28, r24
    2966:	d9 07       	cpc	r29, r25
    2968:	60 f4       	brcc	.+24     	; 0x2982 <prvAddCurrentTaskToDelayedList+0x38>
    296a:	60 91 75 24 	lds	r22, 0x2475
    296e:	70 91 76 24 	lds	r23, 0x2476
    2972:	80 91 32 24 	lds	r24, 0x2432
    2976:	90 91 33 24 	lds	r25, 0x2433
    297a:	6e 5f       	subi	r22, 0xFE	; 254
    297c:	7f 4f       	sbci	r23, 0xFF	; 255
    297e:	ff dd       	rcall	.-1026   	; 0x257e <vListInsert>
    2980:	16 c0       	rjmp	.+44     	; 0x29ae <prvAddCurrentTaskToDelayedList+0x64>
    2982:	60 91 75 24 	lds	r22, 0x2475
    2986:	70 91 76 24 	lds	r23, 0x2476
    298a:	80 91 34 24 	lds	r24, 0x2434
    298e:	90 91 35 24 	lds	r25, 0x2435
    2992:	6e 5f       	subi	r22, 0xFE	; 254
    2994:	7f 4f       	sbci	r23, 0xFF	; 255
    2996:	f3 dd       	rcall	.-1050   	; 0x257e <vListInsert>
    2998:	80 91 0e 20 	lds	r24, 0x200E
    299c:	90 91 0f 20 	lds	r25, 0x200F
    29a0:	c8 17       	cp	r28, r24
    29a2:	d9 07       	cpc	r29, r25
    29a4:	20 f4       	brcc	.+8      	; 0x29ae <prvAddCurrentTaskToDelayedList+0x64>
    29a6:	c0 93 0e 20 	sts	0x200E, r28
    29aa:	d0 93 0f 20 	sts	0x200F, r29
    29ae:	df 91       	pop	r29
    29b0:	cf 91       	pop	r28
    29b2:	08 95       	ret

000029b4 <xTaskGenericCreate>:
    29b4:	4f 92       	push	r4
    29b6:	5f 92       	push	r5
    29b8:	6f 92       	push	r6
    29ba:	7f 92       	push	r7
    29bc:	8f 92       	push	r8
    29be:	9f 92       	push	r9
    29c0:	af 92       	push	r10
    29c2:	bf 92       	push	r11
    29c4:	cf 92       	push	r12
    29c6:	df 92       	push	r13
    29c8:	ef 92       	push	r14
    29ca:	ff 92       	push	r15
    29cc:	0f 93       	push	r16
    29ce:	1f 93       	push	r17
    29d0:	cf 93       	push	r28
    29d2:	df 93       	push	r29
    29d4:	4c 01       	movw	r8, r24
    29d6:	eb 01       	movw	r28, r22
    29d8:	5a 01       	movw	r10, r20
    29da:	29 01       	movw	r4, r18
    29dc:	81 e2       	ldi	r24, 0x21	; 33
    29de:	90 e0       	ldi	r25, 0x00	; 0
    29e0:	93 df       	rcall	.-218    	; 0x2908 <pvPortMalloc>
    29e2:	3c 01       	movw	r6, r24
    29e4:	00 97       	sbiw	r24, 0x00	; 0
    29e6:	09 f4       	brne	.+2      	; 0x29ea <xTaskGenericCreate+0x36>
    29e8:	d4 c0       	rjmp	.+424    	; 0x2b92 <xTaskGenericCreate+0x1de>
    29ea:	c1 14       	cp	r12, r1
    29ec:	d1 04       	cpc	r13, r1
    29ee:	09 f0       	breq	.+2      	; 0x29f2 <xTaskGenericCreate+0x3e>
    29f0:	cc c0       	rjmp	.+408    	; 0x2b8a <xTaskGenericCreate+0x1d6>
    29f2:	c5 01       	movw	r24, r10
    29f4:	89 df       	rcall	.-238    	; 0x2908 <pvPortMalloc>
    29f6:	f3 01       	movw	r30, r6
    29f8:	87 8b       	std	Z+23, r24	; 0x17
    29fa:	90 8f       	std	Z+24, r25	; 0x18
    29fc:	89 2b       	or	r24, r25
    29fe:	19 f4       	brne	.+6      	; 0x2a06 <xTaskGenericCreate+0x52>
    2a00:	c3 01       	movw	r24, r6
    2a02:	8f df       	rcall	.-226    	; 0x2922 <vPortFree>
    2a04:	c6 c0       	rjmp	.+396    	; 0x2b92 <xTaskGenericCreate+0x1de>
    2a06:	f1 e0       	ldi	r31, 0x01	; 1
    2a08:	af 1a       	sub	r10, r31
    2a0a:	b1 08       	sbc	r11, r1
    2a0c:	f3 01       	movw	r30, r6
    2a0e:	87 89       	ldd	r24, Z+23	; 0x17
    2a10:	90 8d       	ldd	r25, Z+24	; 0x18
    2a12:	a8 0e       	add	r10, r24
    2a14:	b9 1e       	adc	r11, r25
    2a16:	88 81       	ld	r24, Y
    2a18:	81 8f       	std	Z+25, r24	; 0x19
    2a1a:	88 81       	ld	r24, Y
    2a1c:	88 23       	and	r24, r24
    2a1e:	81 f0       	breq	.+32     	; 0x2a40 <xTaskGenericCreate+0x8c>
    2a20:	d3 01       	movw	r26, r6
    2a22:	5a 96       	adiw	r26, 0x1a	; 26
    2a24:	fe 01       	movw	r30, r28
    2a26:	31 96       	adiw	r30, 0x01	; 1
    2a28:	9e 01       	movw	r18, r28
    2a2a:	28 5f       	subi	r18, 0xF8	; 248
    2a2c:	3f 4f       	sbci	r19, 0xFF	; 255
    2a2e:	ef 01       	movw	r28, r30
    2a30:	81 91       	ld	r24, Z+
    2a32:	8d 93       	st	X+, r24
    2a34:	88 81       	ld	r24, Y
    2a36:	88 23       	and	r24, r24
    2a38:	19 f0       	breq	.+6      	; 0x2a40 <xTaskGenericCreate+0x8c>
    2a3a:	e2 17       	cp	r30, r18
    2a3c:	f3 07       	cpc	r31, r19
    2a3e:	b9 f7       	brne	.-18     	; 0x2a2e <xTaskGenericCreate+0x7a>
    2a40:	f3 01       	movw	r30, r6
    2a42:	10 a2       	std	Z+32, r1	; 0x20
    2a44:	10 2f       	mov	r17, r16
    2a46:	05 30       	cpi	r16, 0x05	; 5
    2a48:	08 f0       	brcs	.+2      	; 0x2a4c <xTaskGenericCreate+0x98>
    2a4a:	14 e0       	ldi	r17, 0x04	; 4
    2a4c:	f3 01       	movw	r30, r6
    2a4e:	16 8b       	std	Z+22, r17	; 0x16
    2a50:	e3 01       	movw	r28, r6
    2a52:	22 96       	adiw	r28, 0x02	; 2
    2a54:	ce 01       	movw	r24, r28
    2a56:	6e dd       	rcall	.-1316   	; 0x2534 <vListInitialiseItem>
    2a58:	c3 01       	movw	r24, r6
    2a5a:	0c 96       	adiw	r24, 0x0c	; 12
    2a5c:	6b dd       	rcall	.-1322   	; 0x2534 <vListInitialiseItem>
    2a5e:	f3 01       	movw	r30, r6
    2a60:	60 86       	std	Z+8, r6	; 0x08
    2a62:	71 86       	std	Z+9, r7	; 0x09
    2a64:	85 e0       	ldi	r24, 0x05	; 5
    2a66:	90 e0       	ldi	r25, 0x00	; 0
    2a68:	81 1b       	sub	r24, r17
    2a6a:	91 09       	sbc	r25, r1
    2a6c:	84 87       	std	Z+12, r24	; 0x0c
    2a6e:	95 87       	std	Z+13, r25	; 0x0d
    2a70:	62 8a       	std	Z+18, r6	; 0x12
    2a72:	73 8a       	std	Z+19, r7	; 0x13
    2a74:	a2 01       	movw	r20, r4
    2a76:	b4 01       	movw	r22, r8
    2a78:	c5 01       	movw	r24, r10
    2a7a:	d8 dd       	rcall	.-1104   	; 0x262c <pxPortInitialiseStack>
    2a7c:	f3 01       	movw	r30, r6
    2a7e:	80 83       	st	Z, r24
    2a80:	91 83       	std	Z+1, r25	; 0x01
    2a82:	e1 14       	cp	r14, r1
    2a84:	f1 04       	cpc	r15, r1
    2a86:	19 f0       	breq	.+6      	; 0x2a8e <xTaskGenericCreate+0xda>
    2a88:	f7 01       	movw	r30, r14
    2a8a:	60 82       	st	Z, r6
    2a8c:	71 82       	std	Z+1, r7	; 0x01
    2a8e:	0f b6       	in	r0, 0x3f	; 63
    2a90:	f8 94       	cli
    2a92:	0f 92       	push	r0
    2a94:	80 91 28 24 	lds	r24, 0x2428
    2a98:	8f 5f       	subi	r24, 0xFF	; 255
    2a9a:	80 93 28 24 	sts	0x2428, r24
    2a9e:	80 91 75 24 	lds	r24, 0x2475
    2aa2:	90 91 76 24 	lds	r25, 0x2476
    2aa6:	89 2b       	or	r24, r25
    2aa8:	91 f5       	brne	.+100    	; 0x2b0e <xTaskGenericCreate+0x15a>
    2aaa:	60 92 75 24 	sts	0x2475, r6
    2aae:	70 92 76 24 	sts	0x2476, r7
    2ab2:	80 91 28 24 	lds	r24, 0x2428
    2ab6:	81 30       	cpi	r24, 0x01	; 1
    2ab8:	c9 f5       	brne	.+114    	; 0x2b2c <xTaskGenericCreate+0x178>
    2aba:	0f 2e       	mov	r0, r31
    2abc:	f8 e4       	ldi	r31, 0x48	; 72
    2abe:	ef 2e       	mov	r14, r31
    2ac0:	f4 e2       	ldi	r31, 0x24	; 36
    2ac2:	ff 2e       	mov	r15, r31
    2ac4:	f0 2d       	mov	r31, r0
    2ac6:	0f 2e       	mov	r0, r31
    2ac8:	f5 e7       	ldi	r31, 0x75	; 117
    2aca:	cf 2e       	mov	r12, r31
    2acc:	f4 e2       	ldi	r31, 0x24	; 36
    2ace:	df 2e       	mov	r13, r31
    2ad0:	f0 2d       	mov	r31, r0
    2ad2:	c7 01       	movw	r24, r14
    2ad4:	21 dd       	rcall	.-1470   	; 0x2518 <vListInitialise>
    2ad6:	f9 e0       	ldi	r31, 0x09	; 9
    2ad8:	ef 0e       	add	r14, r31
    2ada:	f1 1c       	adc	r15, r1
    2adc:	ec 14       	cp	r14, r12
    2ade:	fd 04       	cpc	r15, r13
    2ae0:	c1 f7       	brne	.-16     	; 0x2ad2 <xTaskGenericCreate+0x11e>
    2ae2:	8f e3       	ldi	r24, 0x3F	; 63
    2ae4:	94 e2       	ldi	r25, 0x24	; 36
    2ae6:	18 dd       	rcall	.-1488   	; 0x2518 <vListInitialise>
    2ae8:	86 e3       	ldi	r24, 0x36	; 54
    2aea:	94 e2       	ldi	r25, 0x24	; 36
    2aec:	15 dd       	rcall	.-1494   	; 0x2518 <vListInitialise>
    2aee:	89 e2       	ldi	r24, 0x29	; 41
    2af0:	94 e2       	ldi	r25, 0x24	; 36
    2af2:	12 dd       	rcall	.-1500   	; 0x2518 <vListInitialise>
    2af4:	8f e3       	ldi	r24, 0x3F	; 63
    2af6:	94 e2       	ldi	r25, 0x24	; 36
    2af8:	80 93 34 24 	sts	0x2434, r24
    2afc:	90 93 35 24 	sts	0x2435, r25
    2b00:	86 e3       	ldi	r24, 0x36	; 54
    2b02:	94 e2       	ldi	r25, 0x24	; 36
    2b04:	80 93 32 24 	sts	0x2432, r24
    2b08:	90 93 33 24 	sts	0x2433, r25
    2b0c:	0f c0       	rjmp	.+30     	; 0x2b2c <xTaskGenericCreate+0x178>
    2b0e:	80 91 24 24 	lds	r24, 0x2424
    2b12:	81 11       	cpse	r24, r1
    2b14:	0b c0       	rjmp	.+22     	; 0x2b2c <xTaskGenericCreate+0x178>
    2b16:	e0 91 75 24 	lds	r30, 0x2475
    2b1a:	f0 91 76 24 	lds	r31, 0x2476
    2b1e:	86 89       	ldd	r24, Z+22	; 0x16
    2b20:	08 17       	cp	r16, r24
    2b22:	20 f0       	brcs	.+8      	; 0x2b2c <xTaskGenericCreate+0x178>
    2b24:	60 92 75 24 	sts	0x2475, r6
    2b28:	70 92 76 24 	sts	0x2476, r7
    2b2c:	80 91 20 24 	lds	r24, 0x2420
    2b30:	8f 5f       	subi	r24, 0xFF	; 255
    2b32:	80 93 20 24 	sts	0x2420, r24
    2b36:	f3 01       	movw	r30, r6
    2b38:	86 89       	ldd	r24, Z+22	; 0x16
    2b3a:	90 91 25 24 	lds	r25, 0x2425
    2b3e:	98 17       	cp	r25, r24
    2b40:	10 f4       	brcc	.+4      	; 0x2b46 <xTaskGenericCreate+0x192>
    2b42:	80 93 25 24 	sts	0x2425, r24
    2b46:	90 e0       	ldi	r25, 0x00	; 0
    2b48:	9c 01       	movw	r18, r24
    2b4a:	22 0f       	add	r18, r18
    2b4c:	33 1f       	adc	r19, r19
    2b4e:	22 0f       	add	r18, r18
    2b50:	33 1f       	adc	r19, r19
    2b52:	22 0f       	add	r18, r18
    2b54:	33 1f       	adc	r19, r19
    2b56:	82 0f       	add	r24, r18
    2b58:	93 1f       	adc	r25, r19
    2b5a:	be 01       	movw	r22, r28
    2b5c:	88 5b       	subi	r24, 0xB8	; 184
    2b5e:	9b 4d       	sbci	r25, 0xDB	; 219
    2b60:	ed dc       	rcall	.-1574   	; 0x253c <vListInsertEnd>
    2b62:	0f 90       	pop	r0
    2b64:	0f be       	out	0x3f, r0	; 63
    2b66:	80 91 24 24 	lds	r24, 0x2424
    2b6a:	88 23       	and	r24, r24
    2b6c:	51 f0       	breq	.+20     	; 0x2b82 <xTaskGenericCreate+0x1ce>
    2b6e:	e0 91 75 24 	lds	r30, 0x2475
    2b72:	f0 91 76 24 	lds	r31, 0x2476
    2b76:	86 89       	ldd	r24, Z+22	; 0x16
    2b78:	80 17       	cp	r24, r16
    2b7a:	28 f4       	brcc	.+10     	; 0x2b86 <xTaskGenericCreate+0x1d2>
    2b7c:	13 de       	rcall	.-986    	; 0x27a4 <vPortYield>
    2b7e:	81 e0       	ldi	r24, 0x01	; 1
    2b80:	09 c0       	rjmp	.+18     	; 0x2b94 <xTaskGenericCreate+0x1e0>
    2b82:	81 e0       	ldi	r24, 0x01	; 1
    2b84:	07 c0       	rjmp	.+14     	; 0x2b94 <xTaskGenericCreate+0x1e0>
    2b86:	81 e0       	ldi	r24, 0x01	; 1
    2b88:	05 c0       	rjmp	.+10     	; 0x2b94 <xTaskGenericCreate+0x1e0>
    2b8a:	fc 01       	movw	r30, r24
    2b8c:	c7 8a       	std	Z+23, r12	; 0x17
    2b8e:	d0 8e       	std	Z+24, r13	; 0x18
    2b90:	3a cf       	rjmp	.-396    	; 0x2a06 <xTaskGenericCreate+0x52>
    2b92:	8f ef       	ldi	r24, 0xFF	; 255
    2b94:	df 91       	pop	r29
    2b96:	cf 91       	pop	r28
    2b98:	1f 91       	pop	r17
    2b9a:	0f 91       	pop	r16
    2b9c:	ff 90       	pop	r15
    2b9e:	ef 90       	pop	r14
    2ba0:	df 90       	pop	r13
    2ba2:	cf 90       	pop	r12
    2ba4:	bf 90       	pop	r11
    2ba6:	af 90       	pop	r10
    2ba8:	9f 90       	pop	r9
    2baa:	8f 90       	pop	r8
    2bac:	7f 90       	pop	r7
    2bae:	6f 90       	pop	r6
    2bb0:	5f 90       	pop	r5
    2bb2:	4f 90       	pop	r4
    2bb4:	08 95       	ret

00002bb6 <vTaskStartScheduler>:
    2bb6:	af 92       	push	r10
    2bb8:	bf 92       	push	r11
    2bba:	cf 92       	push	r12
    2bbc:	df 92       	push	r13
    2bbe:	ef 92       	push	r14
    2bc0:	ff 92       	push	r15
    2bc2:	0f 93       	push	r16
    2bc4:	a1 2c       	mov	r10, r1
    2bc6:	b1 2c       	mov	r11, r1
    2bc8:	c1 2c       	mov	r12, r1
    2bca:	d1 2c       	mov	r13, r1
    2bcc:	e1 2c       	mov	r14, r1
    2bce:	f1 2c       	mov	r15, r1
    2bd0:	00 e0       	ldi	r16, 0x00	; 0
    2bd2:	20 e0       	ldi	r18, 0x00	; 0
    2bd4:	30 e0       	ldi	r19, 0x00	; 0
    2bd6:	45 e5       	ldi	r20, 0x55	; 85
    2bd8:	50 e0       	ldi	r21, 0x00	; 0
    2bda:	6c e1       	ldi	r22, 0x1C	; 28
    2bdc:	70 e2       	ldi	r23, 0x20	; 32
    2bde:	8e e9       	ldi	r24, 0x9E	; 158
    2be0:	94 e1       	ldi	r25, 0x14	; 20
    2be2:	e8 de       	rcall	.-560    	; 0x29b4 <xTaskGenericCreate>
    2be4:	81 30       	cpi	r24, 0x01	; 1
    2be6:	41 f4       	brne	.+16     	; 0x2bf8 <vTaskStartScheduler+0x42>
    2be8:	f8 94       	cli
    2bea:	80 93 24 24 	sts	0x2424, r24
    2bee:	10 92 26 24 	sts	0x2426, r1
    2bf2:	10 92 27 24 	sts	0x2427, r1
    2bf6:	91 dd       	rcall	.-1246   	; 0x271a <xPortStartScheduler>
    2bf8:	0f 91       	pop	r16
    2bfa:	ff 90       	pop	r15
    2bfc:	ef 90       	pop	r14
    2bfe:	df 90       	pop	r13
    2c00:	cf 90       	pop	r12
    2c02:	bf 90       	pop	r11
    2c04:	af 90       	pop	r10
    2c06:	08 95       	ret

00002c08 <vTaskSuspendAll>:
    2c08:	80 91 1f 24 	lds	r24, 0x241F
    2c0c:	8f 5f       	subi	r24, 0xFF	; 255
    2c0e:	80 93 1f 24 	sts	0x241F, r24
    2c12:	08 95       	ret

00002c14 <xTaskGetTickCount>:
    2c14:	0f b6       	in	r0, 0x3f	; 63
    2c16:	f8 94       	cli
    2c18:	0f 92       	push	r0
    2c1a:	80 91 26 24 	lds	r24, 0x2426
    2c1e:	90 91 27 24 	lds	r25, 0x2427
    2c22:	0f 90       	pop	r0
    2c24:	0f be       	out	0x3f, r0	; 63
    2c26:	08 95       	ret

00002c28 <xTaskIncrementTick>:
    2c28:	df 92       	push	r13
    2c2a:	ef 92       	push	r14
    2c2c:	ff 92       	push	r15
    2c2e:	0f 93       	push	r16
    2c30:	1f 93       	push	r17
    2c32:	cf 93       	push	r28
    2c34:	df 93       	push	r29
    2c36:	80 91 1f 24 	lds	r24, 0x241F
    2c3a:	81 11       	cpse	r24, r1
    2c3c:	b3 c0       	rjmp	.+358    	; 0x2da4 <xTaskIncrementTick+0x17c>
    2c3e:	80 91 26 24 	lds	r24, 0x2426
    2c42:	90 91 27 24 	lds	r25, 0x2427
    2c46:	01 96       	adiw	r24, 0x01	; 1
    2c48:	80 93 26 24 	sts	0x2426, r24
    2c4c:	90 93 27 24 	sts	0x2427, r25
    2c50:	e0 90 26 24 	lds	r14, 0x2426
    2c54:	f0 90 27 24 	lds	r15, 0x2427
    2c58:	e1 14       	cp	r14, r1
    2c5a:	f1 04       	cpc	r15, r1
    2c5c:	99 f5       	brne	.+102    	; 0x2cc4 <xTaskIncrementTick+0x9c>
    2c5e:	80 91 34 24 	lds	r24, 0x2434
    2c62:	90 91 35 24 	lds	r25, 0x2435
    2c66:	20 91 32 24 	lds	r18, 0x2432
    2c6a:	30 91 33 24 	lds	r19, 0x2433
    2c6e:	20 93 34 24 	sts	0x2434, r18
    2c72:	30 93 35 24 	sts	0x2435, r19
    2c76:	80 93 32 24 	sts	0x2432, r24
    2c7a:	90 93 33 24 	sts	0x2433, r25
    2c7e:	80 91 21 24 	lds	r24, 0x2421
    2c82:	8f 5f       	subi	r24, 0xFF	; 255
    2c84:	80 93 21 24 	sts	0x2421, r24
    2c88:	e0 91 34 24 	lds	r30, 0x2434
    2c8c:	f0 91 35 24 	lds	r31, 0x2435
    2c90:	80 81       	ld	r24, Z
    2c92:	81 11       	cpse	r24, r1
    2c94:	07 c0       	rjmp	.+14     	; 0x2ca4 <xTaskIncrementTick+0x7c>
    2c96:	8f ef       	ldi	r24, 0xFF	; 255
    2c98:	9f ef       	ldi	r25, 0xFF	; 255
    2c9a:	80 93 0e 20 	sts	0x200E, r24
    2c9e:	90 93 0f 20 	sts	0x200F, r25
    2ca2:	10 c0       	rjmp	.+32     	; 0x2cc4 <xTaskIncrementTick+0x9c>
    2ca4:	e0 91 34 24 	lds	r30, 0x2434
    2ca8:	f0 91 35 24 	lds	r31, 0x2435
    2cac:	05 80       	ldd	r0, Z+5	; 0x05
    2cae:	f6 81       	ldd	r31, Z+6	; 0x06
    2cb0:	e0 2d       	mov	r30, r0
    2cb2:	06 80       	ldd	r0, Z+6	; 0x06
    2cb4:	f7 81       	ldd	r31, Z+7	; 0x07
    2cb6:	e0 2d       	mov	r30, r0
    2cb8:	82 81       	ldd	r24, Z+2	; 0x02
    2cba:	93 81       	ldd	r25, Z+3	; 0x03
    2cbc:	80 93 0e 20 	sts	0x200E, r24
    2cc0:	90 93 0f 20 	sts	0x200F, r25
    2cc4:	80 91 0e 20 	lds	r24, 0x200E
    2cc8:	90 91 0f 20 	lds	r25, 0x200F
    2ccc:	e8 16       	cp	r14, r24
    2cce:	f9 06       	cpc	r15, r25
    2cd0:	10 f4       	brcc	.+4      	; 0x2cd6 <xTaskIncrementTick+0xae>
    2cd2:	d1 2c       	mov	r13, r1
    2cd4:	4f c0       	rjmp	.+158    	; 0x2d74 <xTaskIncrementTick+0x14c>
    2cd6:	d1 2c       	mov	r13, r1
    2cd8:	e0 91 34 24 	lds	r30, 0x2434
    2cdc:	f0 91 35 24 	lds	r31, 0x2435
    2ce0:	90 81       	ld	r25, Z
    2ce2:	91 11       	cpse	r25, r1
    2ce4:	07 c0       	rjmp	.+14     	; 0x2cf4 <xTaskIncrementTick+0xcc>
    2ce6:	8f ef       	ldi	r24, 0xFF	; 255
    2ce8:	9f ef       	ldi	r25, 0xFF	; 255
    2cea:	80 93 0e 20 	sts	0x200E, r24
    2cee:	90 93 0f 20 	sts	0x200F, r25
    2cf2:	40 c0       	rjmp	.+128    	; 0x2d74 <xTaskIncrementTick+0x14c>
    2cf4:	e0 91 34 24 	lds	r30, 0x2434
    2cf8:	f0 91 35 24 	lds	r31, 0x2435
    2cfc:	05 80       	ldd	r0, Z+5	; 0x05
    2cfe:	f6 81       	ldd	r31, Z+6	; 0x06
    2d00:	e0 2d       	mov	r30, r0
    2d02:	c6 81       	ldd	r28, Z+6	; 0x06
    2d04:	d7 81       	ldd	r29, Z+7	; 0x07
    2d06:	2a 81       	ldd	r18, Y+2	; 0x02
    2d08:	3b 81       	ldd	r19, Y+3	; 0x03
    2d0a:	e2 16       	cp	r14, r18
    2d0c:	f3 06       	cpc	r15, r19
    2d0e:	28 f4       	brcc	.+10     	; 0x2d1a <xTaskIncrementTick+0xf2>
    2d10:	20 93 0e 20 	sts	0x200E, r18
    2d14:	30 93 0f 20 	sts	0x200F, r19
    2d18:	2d c0       	rjmp	.+90     	; 0x2d74 <xTaskIncrementTick+0x14c>
    2d1a:	8e 01       	movw	r16, r28
    2d1c:	0e 5f       	subi	r16, 0xFE	; 254
    2d1e:	1f 4f       	sbci	r17, 0xFF	; 255
    2d20:	c8 01       	movw	r24, r16
    2d22:	5e dc       	rcall	.-1860   	; 0x25e0 <uxListRemove>
    2d24:	8c 89       	ldd	r24, Y+20	; 0x14
    2d26:	9d 89       	ldd	r25, Y+21	; 0x15
    2d28:	89 2b       	or	r24, r25
    2d2a:	19 f0       	breq	.+6      	; 0x2d32 <xTaskIncrementTick+0x10a>
    2d2c:	ce 01       	movw	r24, r28
    2d2e:	0c 96       	adiw	r24, 0x0c	; 12
    2d30:	57 dc       	rcall	.-1874   	; 0x25e0 <uxListRemove>
    2d32:	2e 89       	ldd	r18, Y+22	; 0x16
    2d34:	80 91 25 24 	lds	r24, 0x2425
    2d38:	82 17       	cp	r24, r18
    2d3a:	10 f4       	brcc	.+4      	; 0x2d40 <xTaskIncrementTick+0x118>
    2d3c:	20 93 25 24 	sts	0x2425, r18
    2d40:	30 e0       	ldi	r19, 0x00	; 0
    2d42:	c9 01       	movw	r24, r18
    2d44:	88 0f       	add	r24, r24
    2d46:	99 1f       	adc	r25, r25
    2d48:	88 0f       	add	r24, r24
    2d4a:	99 1f       	adc	r25, r25
    2d4c:	88 0f       	add	r24, r24
    2d4e:	99 1f       	adc	r25, r25
    2d50:	82 0f       	add	r24, r18
    2d52:	93 1f       	adc	r25, r19
    2d54:	b8 01       	movw	r22, r16
    2d56:	88 5b       	subi	r24, 0xB8	; 184
    2d58:	9b 4d       	sbci	r25, 0xDB	; 219
    2d5a:	f0 db       	rcall	.-2080   	; 0x253c <vListInsertEnd>
    2d5c:	e0 91 75 24 	lds	r30, 0x2475
    2d60:	f0 91 76 24 	lds	r31, 0x2476
    2d64:	9e 89       	ldd	r25, Y+22	; 0x16
    2d66:	86 89       	ldd	r24, Z+22	; 0x16
    2d68:	98 17       	cp	r25, r24
    2d6a:	08 f4       	brcc	.+2      	; 0x2d6e <xTaskIncrementTick+0x146>
    2d6c:	b5 cf       	rjmp	.-150    	; 0x2cd8 <xTaskIncrementTick+0xb0>
    2d6e:	dd 24       	eor	r13, r13
    2d70:	d3 94       	inc	r13
    2d72:	b2 cf       	rjmp	.-156    	; 0x2cd8 <xTaskIncrementTick+0xb0>
    2d74:	e0 91 75 24 	lds	r30, 0x2475
    2d78:	f0 91 76 24 	lds	r31, 0x2476
    2d7c:	86 89       	ldd	r24, Z+22	; 0x16
    2d7e:	90 e0       	ldi	r25, 0x00	; 0
    2d80:	fc 01       	movw	r30, r24
    2d82:	ee 0f       	add	r30, r30
    2d84:	ff 1f       	adc	r31, r31
    2d86:	ee 0f       	add	r30, r30
    2d88:	ff 1f       	adc	r31, r31
    2d8a:	ee 0f       	add	r30, r30
    2d8c:	ff 1f       	adc	r31, r31
    2d8e:	8e 0f       	add	r24, r30
    2d90:	9f 1f       	adc	r25, r31
    2d92:	fc 01       	movw	r30, r24
    2d94:	e8 5b       	subi	r30, 0xB8	; 184
    2d96:	fb 4d       	sbci	r31, 0xDB	; 219
    2d98:	80 81       	ld	r24, Z
    2d9a:	82 30       	cpi	r24, 0x02	; 2
    2d9c:	48 f0       	brcs	.+18     	; 0x2db0 <xTaskIncrementTick+0x188>
    2d9e:	dd 24       	eor	r13, r13
    2da0:	d3 94       	inc	r13
    2da2:	06 c0       	rjmp	.+12     	; 0x2db0 <xTaskIncrementTick+0x188>
    2da4:	80 91 23 24 	lds	r24, 0x2423
    2da8:	8f 5f       	subi	r24, 0xFF	; 255
    2daa:	80 93 23 24 	sts	0x2423, r24
    2dae:	d1 2c       	mov	r13, r1
    2db0:	80 91 22 24 	lds	r24, 0x2422
    2db4:	88 23       	and	r24, r24
    2db6:	11 f0       	breq	.+4      	; 0x2dbc <xTaskIncrementTick+0x194>
    2db8:	dd 24       	eor	r13, r13
    2dba:	d3 94       	inc	r13
    2dbc:	8d 2d       	mov	r24, r13
    2dbe:	df 91       	pop	r29
    2dc0:	cf 91       	pop	r28
    2dc2:	1f 91       	pop	r17
    2dc4:	0f 91       	pop	r16
    2dc6:	ff 90       	pop	r15
    2dc8:	ef 90       	pop	r14
    2dca:	df 90       	pop	r13
    2dcc:	08 95       	ret

00002dce <xTaskResumeAll>:
    2dce:	df 92       	push	r13
    2dd0:	ef 92       	push	r14
    2dd2:	ff 92       	push	r15
    2dd4:	0f 93       	push	r16
    2dd6:	1f 93       	push	r17
    2dd8:	cf 93       	push	r28
    2dda:	df 93       	push	r29
    2ddc:	0f b6       	in	r0, 0x3f	; 63
    2dde:	f8 94       	cli
    2de0:	0f 92       	push	r0
    2de2:	80 91 1f 24 	lds	r24, 0x241F
    2de6:	81 50       	subi	r24, 0x01	; 1
    2de8:	80 93 1f 24 	sts	0x241F, r24
    2dec:	80 91 1f 24 	lds	r24, 0x241F
    2df0:	81 11       	cpse	r24, r1
    2df2:	5d c0       	rjmp	.+186    	; 0x2eae <xTaskResumeAll+0xe0>
    2df4:	80 91 28 24 	lds	r24, 0x2428
    2df8:	81 11       	cpse	r24, r1
    2dfa:	30 c0       	rjmp	.+96     	; 0x2e5c <xTaskResumeAll+0x8e>
    2dfc:	5b c0       	rjmp	.+182    	; 0x2eb4 <xTaskResumeAll+0xe6>
    2dfe:	d7 01       	movw	r26, r14
    2e00:	15 96       	adiw	r26, 0x05	; 5
    2e02:	ed 91       	ld	r30, X+
    2e04:	fc 91       	ld	r31, X
    2e06:	16 97       	sbiw	r26, 0x06	; 6
    2e08:	c6 81       	ldd	r28, Z+6	; 0x06
    2e0a:	d7 81       	ldd	r29, Z+7	; 0x07
    2e0c:	ce 01       	movw	r24, r28
    2e0e:	0c 96       	adiw	r24, 0x0c	; 12
    2e10:	e7 db       	rcall	.-2098   	; 0x25e0 <uxListRemove>
    2e12:	8e 01       	movw	r16, r28
    2e14:	0e 5f       	subi	r16, 0xFE	; 254
    2e16:	1f 4f       	sbci	r17, 0xFF	; 255
    2e18:	c8 01       	movw	r24, r16
    2e1a:	e2 db       	rcall	.-2108   	; 0x25e0 <uxListRemove>
    2e1c:	2e 89       	ldd	r18, Y+22	; 0x16
    2e1e:	80 91 25 24 	lds	r24, 0x2425
    2e22:	82 17       	cp	r24, r18
    2e24:	10 f4       	brcc	.+4      	; 0x2e2a <xTaskResumeAll+0x5c>
    2e26:	20 93 25 24 	sts	0x2425, r18
    2e2a:	30 e0       	ldi	r19, 0x00	; 0
    2e2c:	c9 01       	movw	r24, r18
    2e2e:	88 0f       	add	r24, r24
    2e30:	99 1f       	adc	r25, r25
    2e32:	88 0f       	add	r24, r24
    2e34:	99 1f       	adc	r25, r25
    2e36:	88 0f       	add	r24, r24
    2e38:	99 1f       	adc	r25, r25
    2e3a:	82 0f       	add	r24, r18
    2e3c:	93 1f       	adc	r25, r19
    2e3e:	b8 01       	movw	r22, r16
    2e40:	88 5b       	subi	r24, 0xB8	; 184
    2e42:	9b 4d       	sbci	r25, 0xDB	; 219
    2e44:	7b db       	rcall	.-2314   	; 0x253c <vListInsertEnd>
    2e46:	e0 91 75 24 	lds	r30, 0x2475
    2e4a:	f0 91 76 24 	lds	r31, 0x2476
    2e4e:	9e 89       	ldd	r25, Y+22	; 0x16
    2e50:	86 89       	ldd	r24, Z+22	; 0x16
    2e52:	98 17       	cp	r25, r24
    2e54:	58 f0       	brcs	.+22     	; 0x2e6c <xTaskResumeAll+0x9e>
    2e56:	d0 92 22 24 	sts	0x2422, r13
    2e5a:	08 c0       	rjmp	.+16     	; 0x2e6c <xTaskResumeAll+0x9e>
    2e5c:	0f 2e       	mov	r0, r31
    2e5e:	f9 e2       	ldi	r31, 0x29	; 41
    2e60:	ef 2e       	mov	r14, r31
    2e62:	f4 e2       	ldi	r31, 0x24	; 36
    2e64:	ff 2e       	mov	r15, r31
    2e66:	f0 2d       	mov	r31, r0
    2e68:	dd 24       	eor	r13, r13
    2e6a:	d3 94       	inc	r13
    2e6c:	f7 01       	movw	r30, r14
    2e6e:	80 81       	ld	r24, Z
    2e70:	81 11       	cpse	r24, r1
    2e72:	c5 cf       	rjmp	.-118    	; 0x2dfe <xTaskResumeAll+0x30>
    2e74:	80 91 23 24 	lds	r24, 0x2423
    2e78:	88 23       	and	r24, r24
    2e7a:	91 f0       	breq	.+36     	; 0x2ea0 <xTaskResumeAll+0xd2>
    2e7c:	80 91 23 24 	lds	r24, 0x2423
    2e80:	88 23       	and	r24, r24
    2e82:	71 f0       	breq	.+28     	; 0x2ea0 <xTaskResumeAll+0xd2>
    2e84:	c1 e0       	ldi	r28, 0x01	; 1
    2e86:	d0 de       	rcall	.-608    	; 0x2c28 <xTaskIncrementTick>
    2e88:	81 11       	cpse	r24, r1
    2e8a:	c0 93 22 24 	sts	0x2422, r28
    2e8e:	80 91 23 24 	lds	r24, 0x2423
    2e92:	81 50       	subi	r24, 0x01	; 1
    2e94:	80 93 23 24 	sts	0x2423, r24
    2e98:	80 91 23 24 	lds	r24, 0x2423
    2e9c:	81 11       	cpse	r24, r1
    2e9e:	f3 cf       	rjmp	.-26     	; 0x2e86 <xTaskResumeAll+0xb8>
    2ea0:	80 91 22 24 	lds	r24, 0x2422
    2ea4:	81 30       	cpi	r24, 0x01	; 1
    2ea6:	29 f4       	brne	.+10     	; 0x2eb2 <xTaskResumeAll+0xe4>
    2ea8:	7d dc       	rcall	.-1798   	; 0x27a4 <vPortYield>
    2eaa:	81 e0       	ldi	r24, 0x01	; 1
    2eac:	03 c0       	rjmp	.+6      	; 0x2eb4 <xTaskResumeAll+0xe6>
    2eae:	80 e0       	ldi	r24, 0x00	; 0
    2eb0:	01 c0       	rjmp	.+2      	; 0x2eb4 <xTaskResumeAll+0xe6>
    2eb2:	80 e0       	ldi	r24, 0x00	; 0
    2eb4:	0f 90       	pop	r0
    2eb6:	0f be       	out	0x3f, r0	; 63
    2eb8:	df 91       	pop	r29
    2eba:	cf 91       	pop	r28
    2ebc:	1f 91       	pop	r17
    2ebe:	0f 91       	pop	r16
    2ec0:	ff 90       	pop	r15
    2ec2:	ef 90       	pop	r14
    2ec4:	df 90       	pop	r13
    2ec6:	08 95       	ret

00002ec8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2ec8:	cf 93       	push	r28
    2eca:	df 93       	push	r29
    2ecc:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2ece:	89 2b       	or	r24, r25
    2ed0:	91 f0       	breq	.+36     	; 0x2ef6 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2ed2:	9a de       	rcall	.-716    	; 0x2c08 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2ed4:	80 91 26 24 	lds	r24, 0x2426
    2ed8:	90 91 27 24 	lds	r25, 0x2427
    2edc:	c8 0f       	add	r28, r24
    2ede:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2ee0:	80 91 75 24 	lds	r24, 0x2475
    2ee4:	90 91 76 24 	lds	r25, 0x2476
    2ee8:	02 96       	adiw	r24, 0x02	; 2
    2eea:	7a db       	rcall	.-2316   	; 0x25e0 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2eec:	ce 01       	movw	r24, r28
    2eee:	2d dd       	rcall	.-1446   	; 0x294a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2ef0:	6e df       	rcall	.-292    	; 0x2dce <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2ef2:	81 11       	cpse	r24, r1
    2ef4:	01 c0       	rjmp	.+2      	; 0x2ef8 <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    2ef6:	56 dc       	rcall	.-1876   	; 0x27a4 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2ef8:	df 91       	pop	r29
    2efa:	cf 91       	pop	r28
    2efc:	08 95       	ret

00002efe <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2efe:	80 91 1f 24 	lds	r24, 0x241F
    2f02:	88 23       	and	r24, r24
    2f04:	21 f0       	breq	.+8      	; 0x2f0e <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2f06:	81 e0       	ldi	r24, 0x01	; 1
    2f08:	80 93 22 24 	sts	0x2422, r24
    2f0c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    2f0e:	10 92 22 24 	sts	0x2422, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2f12:	80 91 25 24 	lds	r24, 0x2425
    2f16:	90 e0       	ldi	r25, 0x00	; 0
    2f18:	fc 01       	movw	r30, r24
    2f1a:	ee 0f       	add	r30, r30
    2f1c:	ff 1f       	adc	r31, r31
    2f1e:	ee 0f       	add	r30, r30
    2f20:	ff 1f       	adc	r31, r31
    2f22:	ee 0f       	add	r30, r30
    2f24:	ff 1f       	adc	r31, r31
    2f26:	8e 0f       	add	r24, r30
    2f28:	9f 1f       	adc	r25, r31
    2f2a:	fc 01       	movw	r30, r24
    2f2c:	e8 5b       	subi	r30, 0xB8	; 184
    2f2e:	fb 4d       	sbci	r31, 0xDB	; 219
    2f30:	80 81       	ld	r24, Z
    2f32:	81 11       	cpse	r24, r1
    2f34:	17 c0       	rjmp	.+46     	; 0x2f64 <vTaskSwitchContext+0x66>
    2f36:	80 91 25 24 	lds	r24, 0x2425
    2f3a:	81 50       	subi	r24, 0x01	; 1
    2f3c:	80 93 25 24 	sts	0x2425, r24
    2f40:	80 91 25 24 	lds	r24, 0x2425
    2f44:	90 e0       	ldi	r25, 0x00	; 0
    2f46:	fc 01       	movw	r30, r24
    2f48:	ee 0f       	add	r30, r30
    2f4a:	ff 1f       	adc	r31, r31
    2f4c:	ee 0f       	add	r30, r30
    2f4e:	ff 1f       	adc	r31, r31
    2f50:	ee 0f       	add	r30, r30
    2f52:	ff 1f       	adc	r31, r31
    2f54:	8e 0f       	add	r24, r30
    2f56:	9f 1f       	adc	r25, r31
    2f58:	fc 01       	movw	r30, r24
    2f5a:	e8 5b       	subi	r30, 0xB8	; 184
    2f5c:	fb 4d       	sbci	r31, 0xDB	; 219
    2f5e:	80 81       	ld	r24, Z
    2f60:	88 23       	and	r24, r24
    2f62:	49 f3       	breq	.-46     	; 0x2f36 <vTaskSwitchContext+0x38>
    2f64:	80 91 25 24 	lds	r24, 0x2425
    2f68:	90 e0       	ldi	r25, 0x00	; 0
    2f6a:	9c 01       	movw	r18, r24
    2f6c:	22 0f       	add	r18, r18
    2f6e:	33 1f       	adc	r19, r19
    2f70:	22 0f       	add	r18, r18
    2f72:	33 1f       	adc	r19, r19
    2f74:	22 0f       	add	r18, r18
    2f76:	33 1f       	adc	r19, r19
    2f78:	28 0f       	add	r18, r24
    2f7a:	39 1f       	adc	r19, r25
    2f7c:	d9 01       	movw	r26, r18
    2f7e:	a8 5b       	subi	r26, 0xB8	; 184
    2f80:	bb 4d       	sbci	r27, 0xDB	; 219
    2f82:	11 96       	adiw	r26, 0x01	; 1
    2f84:	ed 91       	ld	r30, X+
    2f86:	fc 91       	ld	r31, X
    2f88:	12 97       	sbiw	r26, 0x02	; 2
    2f8a:	02 80       	ldd	r0, Z+2	; 0x02
    2f8c:	f3 81       	ldd	r31, Z+3	; 0x03
    2f8e:	e0 2d       	mov	r30, r0
    2f90:	11 96       	adiw	r26, 0x01	; 1
    2f92:	ed 93       	st	X+, r30
    2f94:	fc 93       	st	X, r31
    2f96:	12 97       	sbiw	r26, 0x02	; 2
    2f98:	25 5b       	subi	r18, 0xB5	; 181
    2f9a:	3b 4d       	sbci	r19, 0xDB	; 219
    2f9c:	e2 17       	cp	r30, r18
    2f9e:	f3 07       	cpc	r31, r19
    2fa0:	29 f4       	brne	.+10     	; 0x2fac <vTaskSwitchContext+0xae>
    2fa2:	22 81       	ldd	r18, Z+2	; 0x02
    2fa4:	33 81       	ldd	r19, Z+3	; 0x03
    2fa6:	fd 01       	movw	r30, r26
    2fa8:	21 83       	std	Z+1, r18	; 0x01
    2faa:	32 83       	std	Z+2, r19	; 0x02
    2fac:	fc 01       	movw	r30, r24
    2fae:	ee 0f       	add	r30, r30
    2fb0:	ff 1f       	adc	r31, r31
    2fb2:	ee 0f       	add	r30, r30
    2fb4:	ff 1f       	adc	r31, r31
    2fb6:	ee 0f       	add	r30, r30
    2fb8:	ff 1f       	adc	r31, r31
    2fba:	8e 0f       	add	r24, r30
    2fbc:	9f 1f       	adc	r25, r31
    2fbe:	fc 01       	movw	r30, r24
    2fc0:	e8 5b       	subi	r30, 0xB8	; 184
    2fc2:	fb 4d       	sbci	r31, 0xDB	; 219
    2fc4:	01 80       	ldd	r0, Z+1	; 0x01
    2fc6:	f2 81       	ldd	r31, Z+2	; 0x02
    2fc8:	e0 2d       	mov	r30, r0
    2fca:	86 81       	ldd	r24, Z+6	; 0x06
    2fcc:	97 81       	ldd	r25, Z+7	; 0x07
    2fce:	80 93 75 24 	sts	0x2475, r24
    2fd2:	90 93 76 24 	sts	0x2476, r25
    2fd6:	08 95       	ret

00002fd8 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
    2fd8:	8f ef       	ldi	r24, 0xFF	; 255
    2fda:	80 93 70 00 	sts	0x0070, r24
    2fde:	80 93 71 00 	sts	0x0071, r24
    2fe2:	80 93 72 00 	sts	0x0072, r24
    2fe6:	80 93 73 00 	sts	0x0073, r24
    2fea:	80 93 74 00 	sts	0x0074, r24
    2fee:	80 93 75 00 	sts	0x0075, r24
    2ff2:	80 93 76 00 	sts	0x0076, r24
    2ff6:	08 95       	ret

00002ff8 <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    2ff8:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    2ffa:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    2ffc:	e8 2f       	mov	r30, r24
    2ffe:	f0 e0       	ldi	r31, 0x00	; 0
    3000:	e0 59       	subi	r30, 0x90	; 144
    3002:	ff 4f       	sbci	r31, 0xFF	; 255
    3004:	60 95       	com	r22
    3006:	80 81       	ld	r24, Z
    3008:	68 23       	and	r22, r24
    300a:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    300c:	9f bf       	out	0x3f, r25	; 63
    300e:	08 95       	ret

00003010 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    3010:	cf 93       	push	r28
    3012:	df 93       	push	r29
    3014:	fc 01       	movw	r30, r24
    3016:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3018:	20 e0       	ldi	r18, 0x00	; 0
    301a:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    301c:	c6 2f       	mov	r28, r22
    301e:	d0 e0       	ldi	r29, 0x00	; 0
    3020:	de 01       	movw	r26, r28
    3022:	02 2e       	mov	r0, r18
    3024:	02 c0       	rjmp	.+4      	; 0x302a <ioport_configure_port_pin+0x1a>
    3026:	b5 95       	asr	r27
    3028:	a7 95       	ror	r26
    302a:	0a 94       	dec	r0
    302c:	e2 f7       	brpl	.-8      	; 0x3026 <ioport_configure_port_pin+0x16>
    302e:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3030:	50 83       	st	Z, r21
    3032:	2f 5f       	subi	r18, 0xFF	; 255
    3034:	3f 4f       	sbci	r19, 0xFF	; 255
    3036:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    3038:	28 30       	cpi	r18, 0x08	; 8
    303a:	31 05       	cpc	r19, r1
    303c:	89 f7       	brne	.-30     	; 0x3020 <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    303e:	40 ff       	sbrs	r20, 0
    3040:	0a c0       	rjmp	.+20     	; 0x3056 <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
    3042:	41 ff       	sbrs	r20, 1
    3044:	03 c0       	rjmp	.+6      	; 0x304c <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    3046:	fc 01       	movw	r30, r24
    3048:	65 83       	std	Z+5, r22	; 0x05
    304a:	02 c0       	rjmp	.+4      	; 0x3050 <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    304c:	fc 01       	movw	r30, r24
    304e:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    3050:	fc 01       	movw	r30, r24
    3052:	61 83       	std	Z+1, r22	; 0x01
    3054:	02 c0       	rjmp	.+4      	; 0x305a <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    3056:	fc 01       	movw	r30, r24
    3058:	62 83       	std	Z+2, r22	; 0x02
	}
}
    305a:	df 91       	pop	r29
    305c:	cf 91       	pop	r28
    305e:	08 95       	ret

00003060 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    3060:	43 e0       	ldi	r20, 0x03	; 3
    3062:	50 e0       	ldi	r21, 0x00	; 0
    3064:	61 e0       	ldi	r22, 0x01	; 1
    3066:	80 ee       	ldi	r24, 0xE0	; 224
    3068:	97 e0       	ldi	r25, 0x07	; 7
    306a:	d2 df       	rcall	.-92     	; 0x3010 <ioport_configure_port_pin>
    306c:	43 e0       	ldi	r20, 0x03	; 3
    306e:	50 e0       	ldi	r21, 0x00	; 0
    3070:	62 e0       	ldi	r22, 0x02	; 2
    3072:	80 ee       	ldi	r24, 0xE0	; 224
    3074:	97 e0       	ldi	r25, 0x07	; 7
    3076:	cc df       	rcall	.-104    	; 0x3010 <ioport_configure_port_pin>
    3078:	43 e0       	ldi	r20, 0x03	; 3
    307a:	50 e0       	ldi	r21, 0x00	; 0
    307c:	60 e1       	ldi	r22, 0x10	; 16
    307e:	80 e6       	ldi	r24, 0x60	; 96
    3080:	96 e0       	ldi	r25, 0x06	; 6
    3082:	c6 df       	rcall	.-116    	; 0x3010 <ioport_configure_port_pin>
    3084:	41 e0       	ldi	r20, 0x01	; 1
    3086:	50 e4       	ldi	r21, 0x40	; 64
    3088:	60 e2       	ldi	r22, 0x20	; 32
    308a:	80 e6       	ldi	r24, 0x60	; 96
    308c:	96 e0       	ldi	r25, 0x06	; 6
    308e:	c0 df       	rcall	.-128    	; 0x3010 <ioport_configure_port_pin>
    3090:	40 e0       	ldi	r20, 0x00	; 0
    3092:	5b e1       	ldi	r21, 0x1B	; 27
    3094:	60 e2       	ldi	r22, 0x20	; 32
    3096:	80 e8       	ldi	r24, 0x80	; 128
    3098:	96 e0       	ldi	r25, 0x06	; 6
    309a:	ba df       	rcall	.-140    	; 0x3010 <ioport_configure_port_pin>
    309c:	40 e0       	ldi	r20, 0x00	; 0
    309e:	5b e1       	ldi	r21, 0x1B	; 27
    30a0:	62 e0       	ldi	r22, 0x02	; 2
    30a2:	80 ea       	ldi	r24, 0xA0	; 160
    30a4:	96 e0       	ldi	r25, 0x06	; 6
    30a6:	b4 df       	rcall	.-152    	; 0x3010 <ioport_configure_port_pin>
    30a8:	40 e0       	ldi	r20, 0x00	; 0
    30aa:	5b e1       	ldi	r21, 0x1B	; 27
    30ac:	64 e0       	ldi	r22, 0x04	; 4
    30ae:	80 ea       	ldi	r24, 0xA0	; 160
    30b0:	96 e0       	ldi	r25, 0x06	; 6
    30b2:	ae df       	rcall	.-164    	; 0x3010 <ioport_configure_port_pin>
    30b4:	43 e0       	ldi	r20, 0x03	; 3
    30b6:	50 e0       	ldi	r21, 0x00	; 0
    30b8:	62 e0       	ldi	r22, 0x02	; 2
    30ba:	80 e6       	ldi	r24, 0x60	; 96
    30bc:	96 e0       	ldi	r25, 0x06	; 6
    30be:	a8 df       	rcall	.-176    	; 0x3010 <ioport_configure_port_pin>
    30c0:	43 e0       	ldi	r20, 0x03	; 3
    30c2:	50 e0       	ldi	r21, 0x00	; 0
    30c4:	68 e0       	ldi	r22, 0x08	; 8
    30c6:	80 e6       	ldi	r24, 0x60	; 96
    30c8:	96 e0       	ldi	r25, 0x06	; 6
    30ca:	a2 df       	rcall	.-188    	; 0x3010 <ioport_configure_port_pin>
    30cc:	43 e0       	ldi	r20, 0x03	; 3
    30ce:	50 e0       	ldi	r21, 0x00	; 0
    30d0:	68 e0       	ldi	r22, 0x08	; 8
    30d2:	80 ea       	ldi	r24, 0xA0	; 160
    30d4:	96 e0       	ldi	r25, 0x06	; 6
    30d6:	9c df       	rcall	.-200    	; 0x3010 <ioport_configure_port_pin>
    30d8:	43 e0       	ldi	r20, 0x03	; 3
    30da:	50 e0       	ldi	r21, 0x00	; 0
    30dc:	61 e0       	ldi	r22, 0x01	; 1
    30de:	80 e6       	ldi	r24, 0x60	; 96
    30e0:	96 e0       	ldi	r25, 0x06	; 6
    30e2:	96 df       	rcall	.-212    	; 0x3010 <ioport_configure_port_pin>
    30e4:	43 e0       	ldi	r20, 0x03	; 3
    30e6:	50 e0       	ldi	r21, 0x00	; 0
    30e8:	68 e0       	ldi	r22, 0x08	; 8
    30ea:	80 e0       	ldi	r24, 0x00	; 0
    30ec:	96 e0       	ldi	r25, 0x06	; 6
    30ee:	90 df       	rcall	.-224    	; 0x3010 <ioport_configure_port_pin>
    30f0:	41 e0       	ldi	r20, 0x01	; 1
    30f2:	50 e0       	ldi	r21, 0x00	; 0
    30f4:	60 e1       	ldi	r22, 0x10	; 16
    30f6:	80 e8       	ldi	r24, 0x80	; 128
    30f8:	96 e0       	ldi	r25, 0x06	; 6
    30fa:	8a cf       	rjmp	.-236    	; 0x3010 <ioport_configure_port_pin>
    30fc:	08 95       	ret

000030fe <button>:
}
*/

void switchDisplay(int dest){
	menuSelected = dest;
	switchDisp = true;
    30fe:	c0 e8       	ldi	r28, 0x80	; 128
    3100:	d6 e0       	ldi	r29, 0x06	; 6
    3102:	00 ea       	ldi	r16, 0xA0	; 160
    3104:	16 e0       	ldi	r17, 0x06	; 6
    3106:	0f 2e       	mov	r0, r31
    3108:	f0 e6       	ldi	r31, 0x60	; 96
    310a:	cf 2e       	mov	r12, r31
    310c:	f6 e0       	ldi	r31, 0x06	; 6
    310e:	df 2e       	mov	r13, r31
    3110:	f0 2d       	mov	r31, r0
    3112:	68 94       	set
    3114:	33 24       	eor	r3, r3
    3116:	35 f8       	bld	r3, 5
    3118:	68 94       	set
    311a:	44 24       	eor	r4, r4
    311c:	44 f8       	bld	r4, 4
    311e:	0f 2e       	mov	r0, r31
    3120:	f0 ee       	ldi	r31, 0xE0	; 224
    3122:	ef 2e       	mov	r14, r31
    3124:	f7 e0       	ldi	r31, 0x07	; 7
    3126:	ff 2e       	mov	r15, r31
    3128:	f0 2d       	mov	r31, r0
    312a:	55 24       	eor	r5, r5
    312c:	53 94       	inc	r5
    312e:	0f 2e       	mov	r0, r31
    3130:	f3 e0       	ldi	r31, 0x03	; 3
    3132:	6f 2e       	mov	r6, r31
    3134:	71 2c       	mov	r7, r1
    3136:	f0 2d       	mov	r31, r0
    3138:	68 94       	set
    313a:	88 24       	eor	r8, r8
    313c:	81 f8       	bld	r8, 1
    313e:	91 2c       	mov	r9, r1
    3140:	aa 24       	eor	r10, r10
    3142:	a3 94       	inc	r10
    3144:	b1 2c       	mov	r11, r1
    3146:	82 e3       	ldi	r24, 0x32	; 50
    3148:	90 e0       	ldi	r25, 0x00	; 0
    314a:	be de       	rcall	.-644    	; 0x2ec8 <vTaskDelay>
    314c:	88 85       	ldd	r24, Y+8	; 0x08
    314e:	85 fd       	sbrc	r24, 5
    3150:	07 c0       	rjmp	.+14     	; 0x3160 <button+0x62>
    3152:	f7 01       	movw	r30, r14
    3154:	56 82       	std	Z+6, r5	; 0x06
    3156:	10 92 41 25 	sts	0x2541, r1
    315a:	10 92 42 25 	sts	0x2542, r1
    315e:	f3 cf       	rjmp	.-26     	; 0x3146 <button+0x48>
    3160:	f8 01       	movw	r30, r16
    3162:	80 85       	ldd	r24, Z+8	; 0x08
    3164:	81 fd       	sbrc	r24, 1
    3166:	07 c0       	rjmp	.+14     	; 0x3176 <button+0x78>
    3168:	f6 01       	movw	r30, r12
    316a:	46 82       	std	Z+6, r4	; 0x06
    316c:	a0 92 41 25 	sts	0x2541, r10
    3170:	b0 92 42 25 	sts	0x2542, r11
    3174:	e8 cf       	rjmp	.-48     	; 0x3146 <button+0x48>
    3176:	f8 01       	movw	r30, r16
    3178:	80 85       	ldd	r24, Z+8	; 0x08
    317a:	82 fd       	sbrc	r24, 2
    317c:	07 c0       	rjmp	.+14     	; 0x318c <button+0x8e>
    317e:	f6 01       	movw	r30, r12
    3180:	36 82       	std	Z+6, r3	; 0x06
    3182:	80 92 41 25 	sts	0x2541, r8
    3186:	90 92 42 25 	sts	0x2542, r9
    318a:	dd cf       	rjmp	.-70     	; 0x3146 <button+0x48>
    318c:	f8 01       	movw	r30, r16
    318e:	80 85       	ldd	r24, Z+8	; 0x08
    3190:	81 ff       	sbrs	r24, 1
    3192:	d9 cf       	rjmp	.-78     	; 0x3146 <button+0x48>
    3194:	80 85       	ldd	r24, Z+8	; 0x08
    3196:	82 ff       	sbrs	r24, 2
    3198:	d6 cf       	rjmp	.-84     	; 0x3146 <button+0x48>
    319a:	88 85       	ldd	r24, Y+8	; 0x08
    319c:	85 ff       	sbrs	r24, 5
    319e:	d3 cf       	rjmp	.-90     	; 0x3146 <button+0x48>
    31a0:	f6 01       	movw	r30, r12
    31a2:	35 82       	std	Z+5, r3	; 0x05
    31a4:	45 82       	std	Z+5, r4	; 0x05
    31a6:	f7 01       	movw	r30, r14
    31a8:	55 82       	std	Z+5, r5	; 0x05
    31aa:	60 92 41 25 	sts	0x2541, r6
    31ae:	70 92 42 25 	sts	0x2542, r7
    31b2:	c9 cf       	rjmp	.-110    	; 0x3146 <button+0x48>

000031b4 <Touch>:
    31b4:	d1 e0       	ldi	r29, 0x01	; 1
    31b6:	00 ee       	ldi	r16, 0xE0	; 224
    31b8:	17 e0       	ldi	r17, 0x07	; 7
    31ba:	c2 e0       	ldi	r28, 0x02	; 2
    31bc:	0e 94 0a 0b 	call	0x1614	; 0x1614 <tb_is_touched>
    31c0:	8d 27       	eor	r24, r29
    31c2:	80 93 43 25 	sts	0x2543, r24
    31c6:	82 e3       	ldi	r24, 0x32	; 50
    31c8:	90 e0       	ldi	r25, 0x00	; 0
    31ca:	7e de       	rcall	.-772    	; 0x2ec8 <vTaskDelay>
    31cc:	80 91 43 25 	lds	r24, 0x2543
    31d0:	88 23       	and	r24, r24
    31d2:	19 f0       	breq	.+6      	; 0x31da <Touch+0x26>
    31d4:	f8 01       	movw	r30, r16
    31d6:	c6 83       	std	Z+6, r28	; 0x06
    31d8:	f1 cf       	rjmp	.-30     	; 0x31bc <Touch+0x8>
    31da:	f8 01       	movw	r30, r16
    31dc:	c5 83       	std	Z+5, r28	; 0x05
    31de:	ee cf       	rjmp	.-36     	; 0x31bc <Touch+0x8>

000031e0 <menuNav>:
    31e0:	8a e0       	ldi	r24, 0x0A	; 10
    31e2:	90 e0       	ldi	r25, 0x00	; 0
    31e4:	80 93 41 25 	sts	0x2541, r24
    31e8:	90 93 42 25 	sts	0x2542, r25
    31ec:	bb 24       	eor	r11, r11
    31ee:	b3 94       	inc	r11
    31f0:	02 e0       	ldi	r16, 0x02	; 2
    31f2:	10 e0       	ldi	r17, 0x00	; 0
    31f4:	68 94       	set
    31f6:	cc 24       	eor	r12, r12
    31f8:	c2 f8       	bld	r12, 2
    31fa:	d1 2c       	mov	r13, r1
    31fc:	0f 2e       	mov	r0, r31
    31fe:	f3 e0       	ldi	r31, 0x03	; 3
    3200:	ef 2e       	mov	r14, r31
    3202:	f1 2c       	mov	r15, r1
    3204:	f0 2d       	mov	r31, r0
    3206:	c1 e0       	ldi	r28, 0x01	; 1
    3208:	d0 e0       	ldi	r29, 0x00	; 0
    320a:	82 e3       	ldi	r24, 0x32	; 50
    320c:	90 e0       	ldi	r25, 0x00	; 0
    320e:	5c de       	rcall	.-840    	; 0x2ec8 <vTaskDelay>
    3210:	80 91 7b 24 	lds	r24, 0x247B
    3214:	90 91 7c 24 	lds	r25, 0x247C
    3218:	00 97       	sbiw	r24, 0x00	; 0
    321a:	89 f5       	brne	.+98     	; 0x327e <menuNav+0x9e>
    321c:	80 91 41 25 	lds	r24, 0x2541
    3220:	90 91 42 25 	lds	r25, 0x2542
    3224:	89 2b       	or	r24, r25
    3226:	39 f4       	brne	.+14     	; 0x3236 <menuNav+0x56>
    3228:	c0 93 7b 24 	sts	0x247B, r28
    322c:	d0 93 7c 24 	sts	0x247C, r29
    3230:	b0 92 17 20 	sts	0x2017, r11
    3234:	19 c0       	rjmp	.+50     	; 0x3268 <menuNav+0x88>
    3236:	80 91 41 25 	lds	r24, 0x2541
    323a:	90 91 42 25 	lds	r25, 0x2542
    323e:	01 97       	sbiw	r24, 0x01	; 1
    3240:	39 f4       	brne	.+14     	; 0x3250 <menuNav+0x70>
    3242:	e0 92 7b 24 	sts	0x247B, r14
    3246:	f0 92 7c 24 	sts	0x247C, r15
    324a:	b0 92 17 20 	sts	0x2017, r11
    324e:	0c c0       	rjmp	.+24     	; 0x3268 <menuNav+0x88>
    3250:	80 91 41 25 	lds	r24, 0x2541
    3254:	90 91 42 25 	lds	r25, 0x2542
    3258:	02 97       	sbiw	r24, 0x02	; 2
    325a:	31 f4       	brne	.+12     	; 0x3268 <menuNav+0x88>
    325c:	c0 92 7b 24 	sts	0x247B, r12
    3260:	d0 92 7c 24 	sts	0x247C, r13
    3264:	b0 92 17 20 	sts	0x2017, r11
    3268:	80 91 43 25 	lds	r24, 0x2543
    326c:	88 23       	and	r24, r24
    326e:	69 f2       	breq	.-102    	; 0x320a <menuNav+0x2a>
    3270:	00 93 7b 24 	sts	0x247B, r16
    3274:	10 93 7c 24 	sts	0x247C, r17
    3278:	b0 92 17 20 	sts	0x2017, r11
    327c:	c6 cf       	rjmp	.-116    	; 0x320a <menuNav+0x2a>
    327e:	81 30       	cpi	r24, 0x01	; 1
    3280:	91 05       	cpc	r25, r1
    3282:	39 f5       	brne	.+78     	; 0x32d2 <menuNav+0xf2>
    3284:	80 91 41 25 	lds	r24, 0x2541
    3288:	90 91 42 25 	lds	r25, 0x2542
    328c:	89 2b       	or	r24, r25
    328e:	39 f4       	brne	.+14     	; 0x329e <menuNav+0xbe>
    3290:	10 92 7b 24 	sts	0x247B, r1
    3294:	10 92 7c 24 	sts	0x247C, r1
    3298:	b0 92 17 20 	sts	0x2017, r11
    329c:	10 c0       	rjmp	.+32     	; 0x32be <menuNav+0xde>
    329e:	80 91 41 25 	lds	r24, 0x2541
    32a2:	90 91 42 25 	lds	r25, 0x2542
    32a6:	01 97       	sbiw	r24, 0x01	; 1
    32a8:	51 f0       	breq	.+20     	; 0x32be <menuNav+0xde>
    32aa:	80 91 41 25 	lds	r24, 0x2541
    32ae:	90 91 42 25 	lds	r25, 0x2542
    32b2:	02 97       	sbiw	r24, 0x02	; 2
    32b4:	21 f0       	breq	.+8      	; 0x32be <menuNav+0xde>
    32b6:	80 91 41 25 	lds	r24, 0x2541
    32ba:	90 91 42 25 	lds	r25, 0x2542
    32be:	80 91 43 25 	lds	r24, 0x2543
    32c2:	88 23       	and	r24, r24
    32c4:	19 f0       	breq	.+6      	; 0x32cc <menuNav+0xec>
    32c6:	b0 92 7d 24 	sts	0x247D, r11
    32ca:	9f cf       	rjmp	.-194    	; 0x320a <menuNav+0x2a>
    32cc:	10 92 7d 24 	sts	0x247D, r1
    32d0:	9c cf       	rjmp	.-200    	; 0x320a <menuNav+0x2a>
    32d2:	82 30       	cpi	r24, 0x02	; 2
    32d4:	91 05       	cpc	r25, r1
    32d6:	d1 f4       	brne	.+52     	; 0x330c <menuNav+0x12c>
    32d8:	80 91 41 25 	lds	r24, 0x2541
    32dc:	90 91 42 25 	lds	r25, 0x2542
    32e0:	89 2b       	or	r24, r25
    32e2:	39 f4       	brne	.+14     	; 0x32f2 <menuNav+0x112>
    32e4:	10 92 7b 24 	sts	0x247B, r1
    32e8:	10 92 7c 24 	sts	0x247C, r1
    32ec:	b0 92 17 20 	sts	0x2017, r11
    32f0:	0a c0       	rjmp	.+20     	; 0x3306 <menuNav+0x126>
    32f2:	80 91 41 25 	lds	r24, 0x2541
    32f6:	90 91 42 25 	lds	r25, 0x2542
    32fa:	01 97       	sbiw	r24, 0x01	; 1
    32fc:	21 f0       	breq	.+8      	; 0x3306 <menuNav+0x126>
    32fe:	80 91 41 25 	lds	r24, 0x2541
    3302:	90 91 42 25 	lds	r25, 0x2542
    3306:	80 91 43 25 	lds	r24, 0x2543
    330a:	7f cf       	rjmp	.-258    	; 0x320a <menuNav+0x2a>
    330c:	83 30       	cpi	r24, 0x03	; 3
    330e:	91 05       	cpc	r25, r1
    3310:	09 f0       	breq	.+2      	; 0x3314 <menuNav+0x134>
    3312:	45 c0       	rjmp	.+138    	; 0x339e <menuNav+0x1be>
    3314:	80 91 79 24 	lds	r24, 0x2479
    3318:	90 91 7a 24 	lds	r25, 0x247A
    331c:	fc 01       	movw	r30, r24
    331e:	e8 56       	subi	r30, 0x68	; 104
    3320:	fb 4d       	sbci	r31, 0xDB	; 219
    3322:	40 81       	ld	r20, Z
    3324:	20 91 41 25 	lds	r18, 0x2541
    3328:	30 91 42 25 	lds	r19, 0x2542
    332c:	23 2b       	or	r18, r19
    332e:	39 f4       	brne	.+14     	; 0x333e <menuNav+0x15e>
    3330:	10 92 7b 24 	sts	0x247B, r1
    3334:	10 92 7c 24 	sts	0x247C, r1
    3338:	b0 92 17 20 	sts	0x2017, r11
    333c:	19 c0       	rjmp	.+50     	; 0x3370 <menuNav+0x190>
    333e:	20 91 41 25 	lds	r18, 0x2541
    3342:	30 91 42 25 	lds	r19, 0x2542
    3346:	21 30       	cpi	r18, 0x01	; 1
    3348:	31 05       	cpc	r19, r1
    334a:	31 f4       	brne	.+12     	; 0x3358 <menuNav+0x178>
    334c:	01 97       	sbiw	r24, 0x01	; 1
    334e:	80 93 79 24 	sts	0x2479, r24
    3352:	90 93 7a 24 	sts	0x247A, r25
    3356:	0c c0       	rjmp	.+24     	; 0x3370 <menuNav+0x190>
    3358:	20 91 41 25 	lds	r18, 0x2541
    335c:	30 91 42 25 	lds	r19, 0x2542
    3360:	22 30       	cpi	r18, 0x02	; 2
    3362:	31 05       	cpc	r19, r1
    3364:	29 f4       	brne	.+10     	; 0x3370 <menuNav+0x190>
    3366:	01 96       	adiw	r24, 0x01	; 1
    3368:	80 93 79 24 	sts	0x2479, r24
    336c:	90 93 7a 24 	sts	0x247A, r25
    3370:	80 91 43 25 	lds	r24, 0x2543
    3374:	88 23       	and	r24, r24
    3376:	09 f4       	brne	.+2      	; 0x337a <menuNav+0x19a>
    3378:	48 cf       	rjmp	.-368    	; 0x320a <menuNav+0x2a>
    337a:	44 23       	and	r20, r20
    337c:	41 f0       	breq	.+16     	; 0x338e <menuNav+0x1ae>
    337e:	e0 91 79 24 	lds	r30, 0x2479
    3382:	f0 91 7a 24 	lds	r31, 0x247A
    3386:	e8 56       	subi	r30, 0x68	; 104
    3388:	fb 4d       	sbci	r31, 0xDB	; 219
    338a:	10 82       	st	Z, r1
    338c:	3e cf       	rjmp	.-388    	; 0x320a <menuNav+0x2a>
    338e:	e0 91 79 24 	lds	r30, 0x2479
    3392:	f0 91 7a 24 	lds	r31, 0x247A
    3396:	e8 56       	subi	r30, 0x68	; 104
    3398:	fb 4d       	sbci	r31, 0xDB	; 219
    339a:	b0 82       	st	Z, r11
    339c:	36 cf       	rjmp	.-404    	; 0x320a <menuNav+0x2a>
    339e:	04 97       	sbiw	r24, 0x04	; 4
    33a0:	09 f0       	breq	.+2      	; 0x33a4 <menuNav+0x1c4>
    33a2:	33 cf       	rjmp	.-410    	; 0x320a <menuNav+0x2a>
    33a4:	80 91 41 25 	lds	r24, 0x2541
    33a8:	90 91 42 25 	lds	r25, 0x2542
    33ac:	89 2b       	or	r24, r25
    33ae:	39 f4       	brne	.+14     	; 0x33be <menuNav+0x1de>
    33b0:	10 92 7b 24 	sts	0x247B, r1
    33b4:	10 92 7c 24 	sts	0x247C, r1
    33b8:	b0 92 17 20 	sts	0x2017, r11
    33bc:	1f c0       	rjmp	.+62     	; 0x33fc <menuNav+0x21c>
    33be:	80 91 41 25 	lds	r24, 0x2541
    33c2:	90 91 42 25 	lds	r25, 0x2542
    33c6:	01 97       	sbiw	r24, 0x01	; 1
    33c8:	51 f4       	brne	.+20     	; 0x33de <menuNav+0x1fe>
    33ca:	80 91 77 24 	lds	r24, 0x2477
    33ce:	90 91 78 24 	lds	r25, 0x2478
    33d2:	01 97       	sbiw	r24, 0x01	; 1
    33d4:	80 93 77 24 	sts	0x2477, r24
    33d8:	90 93 78 24 	sts	0x2478, r25
    33dc:	0f c0       	rjmp	.+30     	; 0x33fc <menuNav+0x21c>
    33de:	80 91 41 25 	lds	r24, 0x2541
    33e2:	90 91 42 25 	lds	r25, 0x2542
    33e6:	02 97       	sbiw	r24, 0x02	; 2
    33e8:	49 f4       	brne	.+18     	; 0x33fc <menuNav+0x21c>
    33ea:	80 91 77 24 	lds	r24, 0x2477
    33ee:	90 91 78 24 	lds	r25, 0x2478
    33f2:	01 96       	adiw	r24, 0x01	; 1
    33f4:	80 93 77 24 	sts	0x2477, r24
    33f8:	90 93 78 24 	sts	0x2478, r25
    33fc:	80 91 43 25 	lds	r24, 0x2543
    3400:	88 23       	and	r24, r24
    3402:	19 f0       	breq	.+6      	; 0x340a <menuNav+0x22a>
    3404:	b0 92 7e 24 	sts	0x247E, r11
    3408:	00 cf       	rjmp	.-512    	; 0x320a <menuNav+0x2a>
    340a:	10 92 7e 24 	sts	0x247E, r1
    340e:	fd ce       	rjmp	.-518    	; 0x320a <menuNav+0x2a>

00003410 <setUpSerial>:
    3410:	10 92 a7 08 	sts	0x08A7, r1
    3414:	8c e0       	ldi	r24, 0x0C	; 12
    3416:	80 93 a6 08 	sts	0x08A6, r24
    341a:	10 92 a3 08 	sts	0x08A3, r1
    341e:	83 e0       	ldi	r24, 0x03	; 3
    3420:	80 93 a5 08 	sts	0x08A5, r24
    3424:	88 e1       	ldi	r24, 0x18	; 24
    3426:	80 93 a4 08 	sts	0x08A4, r24
    342a:	08 95       	ret

0000342c <sendChar>:
    342c:	e1 ea       	ldi	r30, 0xA1	; 161
    342e:	f8 e0       	ldi	r31, 0x08	; 8
    3430:	90 81       	ld	r25, Z
    3432:	95 ff       	sbrs	r25, 5
    3434:	fd cf       	rjmp	.-6      	; 0x3430 <sendChar+0x4>
    3436:	80 93 a0 08 	sts	0x08A0, r24
    343a:	08 95       	ret

0000343c <sendString>:
    343c:	cf 93       	push	r28
    343e:	df 93       	push	r29
    3440:	ec 01       	movw	r28, r24
    3442:	81 e0       	ldi	r24, 0x01	; 1
    3444:	80 93 7f 24 	sts	0x247F, r24
    3448:	88 81       	ld	r24, Y
    344a:	88 23       	and	r24, r24
    344c:	29 f0       	breq	.+10     	; 0x3458 <sendString+0x1c>
    344e:	21 96       	adiw	r28, 0x01	; 1
    3450:	ed df       	rcall	.-38     	; 0x342c <sendChar>
    3452:	89 91       	ld	r24, Y+
    3454:	81 11       	cpse	r24, r1
    3456:	fc cf       	rjmp	.-8      	; 0x3450 <sendString+0x14>
    3458:	10 92 7f 24 	sts	0x247F, r1
    345c:	df 91       	pop	r29
    345e:	cf 91       	pop	r28
    3460:	08 95       	ret

00003462 <commGate_OUT>:
    3462:	c0 91 c7 24 	lds	r28, 0x24C7
    3466:	d0 91 c8 24 	lds	r29, 0x24C8
    346a:	80 e0       	ldi	r24, 0x00	; 0
    346c:	90 e0       	ldi	r25, 0x00	; 0
    346e:	2c dd       	rcall	.-1448   	; 0x2ec8 <vTaskDelay>
    3470:	90 91 7d 24 	lds	r25, 0x247D
    3474:	99 23       	and	r25, r25
    3476:	c9 f3       	breq	.-14     	; 0x346a <commGate_OUT+0x8>
    3478:	ce 01       	movw	r24, r28
    347a:	e0 df       	rcall	.-64     	; 0x343c <sendString>
    347c:	f6 cf       	rjmp	.-20     	; 0x346a <commGate_OUT+0x8>

0000347e <receiveChar>:
    347e:	e1 ea       	ldi	r30, 0xA1	; 161
    3480:	f8 e0       	ldi	r31, 0x08	; 8
    3482:	80 81       	ld	r24, Z
    3484:	88 23       	and	r24, r24
    3486:	ec f7       	brge	.-6      	; 0x3482 <receiveChar+0x4>
    3488:	80 91 a0 08 	lds	r24, 0x08A0
    348c:	08 95       	ret

0000348e <receiveString>:
    348e:	cf 93       	push	r28
    3490:	df 93       	push	r29
    3492:	cd ed       	ldi	r28, 0xDD	; 221
    3494:	d4 e2       	ldi	r29, 0x24	; 36
    3496:	f3 df       	rcall	.-26     	; 0x347e <receiveChar>
    3498:	8a 30       	cpi	r24, 0x0A	; 10
    349a:	11 f0       	breq	.+4      	; 0x34a0 <receiveString+0x12>
    349c:	89 93       	st	Y+, r24
    349e:	fb cf       	rjmp	.-10     	; 0x3496 <receiveString+0x8>
    34a0:	df 91       	pop	r29
    34a2:	cf 91       	pop	r28
    34a4:	08 95       	ret

000034a6 <commGate_IN>:
    34a6:	00 e8       	ldi	r16, 0x80	; 128
    34a8:	14 e2       	ldi	r17, 0x24	; 36
    34aa:	c0 91 c5 24 	lds	r28, 0x24C5
    34ae:	d0 91 c6 24 	lds	r29, 0x24C6
    34b2:	80 e0       	ldi	r24, 0x00	; 0
    34b4:	90 e0       	ldi	r25, 0x00	; 0
    34b6:	08 dd       	rcall	.-1520   	; 0x2ec8 <vTaskDelay>
    34b8:	80 91 7e 24 	lds	r24, 0x247E
    34bc:	88 23       	and	r24, r24
    34be:	c9 f3       	breq	.-14     	; 0x34b2 <commGate_IN+0xc>
    34c0:	e6 df       	rcall	.-52     	; 0x348e <receiveString>
    34c2:	88 81       	ld	r24, Y
    34c4:	08 2e       	mov	r0, r24
    34c6:	00 0c       	add	r0, r0
    34c8:	99 0b       	sbc	r25, r25
    34ca:	f8 01       	movw	r30, r16
    34cc:	80 83       	st	Z, r24
    34ce:	91 83       	std	Z+1, r25	; 0x01
    34d0:	f0 cf       	rjmp	.-32     	; 0x34b2 <commGate_IN+0xc>

000034d2 <initMenu>:
}

void initMenu(void){
	
	int nn;
	maxFeature=7;
    34d2:	87 e0       	ldi	r24, 0x07	; 7
    34d4:	90 e0       	ldi	r25, 0x00	; 0
    34d6:	80 93 1a 20 	sts	0x201A, r24
    34da:	90 93 1b 20 	sts	0x201B, r25
	maxStatus=5;
    34de:	85 e0       	ldi	r24, 0x05	; 5
    34e0:	90 e0       	ldi	r25, 0x00	; 0
    34e2:	80 93 18 20 	sts	0x2018, r24
    34e6:	90 93 19 20 	sts	0x2019, r25
    34ea:	e8 e9       	ldi	r30, 0x98	; 152
    34ec:	f4 e2       	ldi	r31, 0x24	; 36
    34ee:	8f e9       	ldi	r24, 0x9F	; 159
    34f0:	94 e2       	ldi	r25, 0x24	; 36
	
	for(nn=0; nn<maxFeature; nn++){
		featureStat[nn] = false;
    34f2:	11 92       	st	Z+, r1
	
	int nn;
	maxFeature=7;
	maxStatus=5;
	
	for(nn=0; nn<maxFeature; nn++){
    34f4:	e8 17       	cp	r30, r24
    34f6:	f9 07       	cpc	r31, r25
    34f8:	e1 f7       	brne	.-8      	; 0x34f2 <initMenu+0x20>
		featureStat[nn] = false;
	}
	
	featureList[0] = "Tap 1       ";
    34fa:	e7 ea       	ldi	r30, 0xA7	; 167
    34fc:	f4 e2       	ldi	r31, 0x24	; 36
    34fe:	81 e2       	ldi	r24, 0x21	; 33
    3500:	90 e2       	ldi	r25, 0x20	; 32
    3502:	80 83       	st	Z, r24
    3504:	91 83       	std	Z+1, r25	; 0x01
	featureList[1] = "Tap 2       ";
    3506:	8e e2       	ldi	r24, 0x2E	; 46
    3508:	90 e2       	ldi	r25, 0x20	; 32
    350a:	82 83       	std	Z+2, r24	; 0x02
    350c:	93 83       	std	Z+3, r25	; 0x03
	featureList[2] = "Tap 3       ";
    350e:	8b e3       	ldi	r24, 0x3B	; 59
    3510:	90 e2       	ldi	r25, 0x20	; 32
    3512:	84 83       	std	Z+4, r24	; 0x04
    3514:	95 83       	std	Z+5, r25	; 0x05
	featureList[3] = "Tap 4       ";
    3516:	88 e4       	ldi	r24, 0x48	; 72
    3518:	90 e2       	ldi	r25, 0x20	; 32
    351a:	86 83       	std	Z+6, r24	; 0x06
    351c:	97 83       	std	Z+7, r25	; 0x07
	featureList[4] = "Discharge   ";
    351e:	85 e5       	ldi	r24, 0x55	; 85
    3520:	90 e2       	ldi	r25, 0x20	; 32
    3522:	80 87       	std	Z+8, r24	; 0x08
    3524:	91 87       	std	Z+9, r25	; 0x09
	featureList[5] = "AutoWatering";
    3526:	82 e6       	ldi	r24, 0x62	; 98
    3528:	90 e2       	ldi	r25, 0x20	; 32
    352a:	82 87       	std	Z+10, r24	; 0x0a
    352c:	93 87       	std	Z+11, r25	; 0x0b
	featureList[6] = "Watering    ";
    352e:	8f e6       	ldi	r24, 0x6F	; 111
    3530:	90 e2       	ldi	r25, 0x20	; 32
    3532:	84 87       	std	Z+12, r24	; 0x0c
    3534:	95 87       	std	Z+13, r25	; 0x0d
	
	
	statusList[0] = "Water Usage    ";
    3536:	ec e8       	ldi	r30, 0x8C	; 140
    3538:	f4 e2       	ldi	r31, 0x24	; 36
    353a:	8c e7       	ldi	r24, 0x7C	; 124
    353c:	90 e2       	ldi	r25, 0x20	; 32
    353e:	80 83       	st	Z, r24
    3540:	91 83       	std	Z+1, r25	; 0x01
	statusList[1] = "Water Storage  ";
    3542:	8c e8       	ldi	r24, 0x8C	; 140
    3544:	90 e2       	ldi	r25, 0x20	; 32
    3546:	82 83       	std	Z+2, r24	; 0x02
    3548:	93 83       	std	Z+3, r25	; 0x03
	statusList[2] = "Alarm Status   ";
    354a:	8c e9       	ldi	r24, 0x9C	; 156
    354c:	90 e2       	ldi	r25, 0x20	; 32
    354e:	84 83       	std	Z+4, r24	; 0x04
    3550:	95 83       	std	Z+5, r25	; 0x05
	statusList[3] = "Water Temp     ";
    3552:	8c ea       	ldi	r24, 0xAC	; 172
    3554:	90 e2       	ldi	r25, 0x20	; 32
    3556:	86 83       	std	Z+6, r24	; 0x06
    3558:	97 83       	std	Z+7, r25	; 0x07
	statusList[4] = "Watering Manual";
    355a:	8c eb       	ldi	r24, 0xBC	; 188
    355c:	90 e2       	ldi	r25, 0x20	; 32
    355e:	80 87       	std	Z+8, r24	; 0x08
    3560:	91 87       	std	Z+9, r25	; 0x09
	
	for(nn=0; nn<maxStatus; nn++){
		statusRes[nn]="unknown";
    3562:	e0 e8       	ldi	r30, 0x80	; 128
    3564:	f4 e2       	ldi	r31, 0x24	; 36
    3566:	8c ec       	ldi	r24, 0xCC	; 204
    3568:	90 e2       	ldi	r25, 0x20	; 32
    356a:	80 83       	st	Z, r24
    356c:	91 83       	std	Z+1, r25	; 0x01
    356e:	82 83       	std	Z+2, r24	; 0x02
    3570:	93 83       	std	Z+3, r25	; 0x03
    3572:	84 83       	std	Z+4, r24	; 0x04
    3574:	95 83       	std	Z+5, r25	; 0x05
    3576:	86 83       	std	Z+6, r24	; 0x06
    3578:	97 83       	std	Z+7, r25	; 0x07
    357a:	80 87       	std	Z+8, r24	; 0x08
    357c:	91 87       	std	Z+9, r25	; 0x09
    357e:	08 95       	ret

00003580 <printLCD>:
    3580:	80 e1       	ldi	r24, 0x10	; 16
    3582:	80 93 85 06 	sts	0x0685, r24
	vTaskStartScheduler();
}

static portTASK_FUNCTION(printLCD, p_){
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	initMenu();
    3586:	a5 df       	rcall	.-182    	; 0x34d2 <initMenu>
		else if(menuSelected==4){
			if(status_displayed<0) status_displayed=maxStatus;
			else if (status_displayed>=maxStatus) status_displayed=0;
			
			gfx_mono_draw_string("==   SD's Status   ==",0,0,&sysfont);
			snprintf(strbuf_menu, sizeof(strbuf_menu), "Status No.%2d", status_displayed+1);
    3588:	0f 2e       	mov	r0, r31
    358a:	f1 ec       	ldi	r31, 0xC1	; 193
    358c:	cf 2e       	mov	r12, r31
    358e:	f1 e2       	ldi	r31, 0x21	; 33
    3590:	df 2e       	mov	r13, r31
    3592:	f0 2d       	mov	r31, r0
    3594:	14 e1       	ldi	r17, 0x14	; 20
    3596:	c9 ec       	ldi	r28, 0xC9	; 201
    3598:	d4 e2       	ldi	r29, 0x24	; 36
			if(feature_selected<0) feature_selected=maxFeature;
			else if (feature_selected>=maxFeature) feature_selected=0;
			
			gfx_mono_draw_string("==  Features Menu  ==",0,0,&sysfont);
			
			snprintf(strbuf_menu, sizeof(strbuf_menu), "Feature No.%2d", feature_selected+1);
    359a:	0f 2e       	mov	r0, r31
    359c:	f6 e8       	ldi	r31, 0x86	; 134
    359e:	ef 2e       	mov	r14, r31
    35a0:	f1 e2       	ldi	r31, 0x21	; 33
    35a2:	ff 2e       	mov	r15, r31
    35a4:	f0 2d       	mov	r31, r0

static portTASK_FUNCTION(printLCD, p_){
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	initMenu();
	while(1){
		if(switchDisp){
    35a6:	90 91 17 20 	lds	r25, 0x2017
    35aa:	99 23       	and	r25, r25
    35ac:	89 f0       	breq	.+34     	; 0x35d0 <printLCD+0x50>
			portENTER_CRITICAL();
    35ae:	0f b6       	in	r0, 0x3f	; 63
    35b0:	f8 94       	cli
    35b2:	0f 92       	push	r0
			gfx_mono_generic_draw_filled_rect(0,0,128,32,GFX_PIXEL_CLR);
    35b4:	00 e0       	ldi	r16, 0x00	; 0
    35b6:	20 e2       	ldi	r18, 0x20	; 32
    35b8:	40 e8       	ldi	r20, 0x80	; 128
    35ba:	60 e0       	ldi	r22, 0x00	; 0
    35bc:	80 e0       	ldi	r24, 0x00	; 0
    35be:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <gfx_mono_generic_draw_filled_rect>
			vTaskDelay(200/portTICK_PERIOD_MS);
    35c2:	84 e6       	ldi	r24, 0x64	; 100
    35c4:	90 e0       	ldi	r25, 0x00	; 0
    35c6:	80 dc       	rcall	.-1792   	; 0x2ec8 <vTaskDelay>
			portEXIT_CRITICAL();
    35c8:	0f 90       	pop	r0
    35ca:	0f be       	out	0x3f, r0	; 63
			switchDisp = false;
    35cc:	10 92 17 20 	sts	0x2017, r1
		}
		
		//main menu
		if(menuSelected==0){			
    35d0:	20 91 7b 24 	lds	r18, 0x247B
    35d4:	30 91 7c 24 	lds	r19, 0x247C
    35d8:	21 15       	cp	r18, r1
    35da:	31 05       	cpc	r19, r1
    35dc:	09 f5       	brne	.+66     	; 0x3620 <printLCD+0xa0>
			gfx_mono_draw_string("==GH Control Center==",0,0,&sysfont);
    35de:	27 e0       	ldi	r18, 0x07	; 7
    35e0:	30 e2       	ldi	r19, 0x20	; 32
    35e2:	40 e0       	ldi	r20, 0x00	; 0
    35e4:	60 e0       	ldi	r22, 0x00	; 0
    35e6:	84 ed       	ldi	r24, 0xD4	; 212
    35e8:	90 e2       	ldi	r25, 0x20	; 32
    35ea:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
			gfx_mono_draw_string("---------------------",0,(SYSFONT_HEIGHT*1)+1,&sysfont);
    35ee:	27 e0       	ldi	r18, 0x07	; 7
    35f0:	30 e2       	ldi	r19, 0x20	; 32
    35f2:	48 e0       	ldi	r20, 0x08	; 8
    35f4:	60 e0       	ldi	r22, 0x00	; 0
    35f6:	8a ee       	ldi	r24, 0xEA	; 234
    35f8:	90 e2       	ldi	r25, 0x20	; 32
    35fa:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
			gfx_mono_draw_string("Ping         Features",0,(SYSFONT_HEIGHT*2)+1,&sysfont);
    35fe:	27 e0       	ldi	r18, 0x07	; 7
    3600:	30 e2       	ldi	r19, 0x20	; 32
    3602:	4f e0       	ldi	r20, 0x0F	; 15
    3604:	60 e0       	ldi	r22, 0x00	; 0
    3606:	80 e0       	ldi	r24, 0x00	; 0
    3608:	91 e2       	ldi	r25, 0x21	; 33
    360a:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
			gfx_mono_draw_string("PingBrst    StatsDisp",0,(SYSFONT_HEIGHT*3)+2,&sysfont);	
    360e:	27 e0       	ldi	r18, 0x07	; 7
    3610:	30 e2       	ldi	r19, 0x20	; 32
    3612:	47 e1       	ldi	r20, 0x17	; 23
    3614:	60 e0       	ldi	r22, 0x00	; 0
    3616:	86 e1       	ldi	r24, 0x16	; 22
    3618:	91 e2       	ldi	r25, 0x21	; 33
    361a:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
    361e:	54 c1       	rjmp	.+680    	; 0x38c8 <printLCD+0x348>
		}
		//ping
		else if(menuSelected==1){
    3620:	21 30       	cpi	r18, 0x01	; 1
    3622:	31 05       	cpc	r19, r1
    3624:	21 f5       	brne	.+72     	; 0x366e <printLCD+0xee>
			gfx_mono_draw_string("==    Ping Menu    ==",0,0,&sysfont);
    3626:	27 e0       	ldi	r18, 0x07	; 7
    3628:	30 e2       	ldi	r19, 0x20	; 32
    362a:	40 e0       	ldi	r20, 0x00	; 0
    362c:	60 e0       	ldi	r22, 0x00	; 0
    362e:	8c e2       	ldi	r24, 0x2C	; 44
    3630:	91 e2       	ldi	r25, 0x21	; 33
    3632:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
			if(flag_ping){
    3636:	80 91 7d 24 	lds	r24, 0x247D
    363a:	88 23       	and	r24, r24
    363c:	09 f4       	brne	.+2      	; 0x3640 <printLCD+0xc0>
    363e:	44 c1       	rjmp	.+648    	; 0x38c8 <printLCD+0x348>
				
				sendChar('p');
    3640:	80 e7       	ldi	r24, 0x70	; 112
    3642:	f4 de       	rcall	.-536    	; 0x342c <sendChar>
				char x = receiveChar();
    3644:	1c df       	rcall	.-456    	; 0x347e <receiveChar>
				if(x=='p'){
    3646:	80 37       	cpi	r24, 0x70	; 112
    3648:	49 f4       	brne	.+18     	; 0x365c <printLCD+0xdc>
					gfx_mono_draw_string("Ping Balik!",0,(SYSFONT_HEIGHT*1)+1,&sysfont);
    364a:	27 e0       	ldi	r18, 0x07	; 7
    364c:	30 e2       	ldi	r19, 0x20	; 32
    364e:	48 e0       	ldi	r20, 0x08	; 8
    3650:	60 e0       	ldi	r22, 0x00	; 0
    3652:	82 e4       	ldi	r24, 0x42	; 66
    3654:	91 e2       	ldi	r25, 0x21	; 33
    3656:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
    365a:	36 c1       	rjmp	.+620    	; 0x38c8 <printLCD+0x348>
				}
				else{
					gfx_mono_draw_string("Ping       ",0,(SYSFONT_HEIGHT*1)+1,&sysfont);
    365c:	27 e0       	ldi	r18, 0x07	; 7
    365e:	30 e2       	ldi	r19, 0x20	; 32
    3660:	48 e0       	ldi	r20, 0x08	; 8
    3662:	60 e0       	ldi	r22, 0x00	; 0
    3664:	8e e4       	ldi	r24, 0x4E	; 78
    3666:	91 e2       	ldi	r25, 0x21	; 33
    3668:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
    366c:	2d c1       	rjmp	.+602    	; 0x38c8 <printLCD+0x348>
				//gfx_mono_draw_string(strbuf_read,0,(SYSFONT_HEIGHT*2)+1,&sysfont);	
			}
			
		}
		//ping burst
		else if(menuSelected==2){
    366e:	22 30       	cpi	r18, 0x02	; 2
    3670:	31 05       	cpc	r19, r1
    3672:	49 f4       	brne	.+18     	; 0x3686 <printLCD+0x106>
			gfx_mono_draw_string("==  PingBrst Menu  ==",0,0,&sysfont);
    3674:	27 e0       	ldi	r18, 0x07	; 7
    3676:	30 e2       	ldi	r19, 0x20	; 32
    3678:	40 e0       	ldi	r20, 0x00	; 0
    367a:	60 e0       	ldi	r22, 0x00	; 0
    367c:	8a e5       	ldi	r24, 0x5A	; 90
    367e:	91 e2       	ldi	r25, 0x21	; 33
    3680:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
    3684:	21 c1       	rjmp	.+578    	; 0x38c8 <printLCD+0x348>
			
		}
		//features
		else if(menuSelected==3){
    3686:	23 30       	cpi	r18, 0x03	; 3
    3688:	31 05       	cpc	r19, r1
    368a:	09 f0       	breq	.+2      	; 0x368e <printLCD+0x10e>
    368c:	c5 c0       	rjmp	.+394    	; 0x3818 <printLCD+0x298>
			
			if(feature_selected<0) feature_selected=maxFeature;
    368e:	80 91 79 24 	lds	r24, 0x2479
    3692:	90 91 7a 24 	lds	r25, 0x247A
    3696:	99 23       	and	r25, r25
    3698:	4c f4       	brge	.+18     	; 0x36ac <printLCD+0x12c>
    369a:	80 91 1a 20 	lds	r24, 0x201A
    369e:	90 91 1b 20 	lds	r25, 0x201B
    36a2:	80 93 79 24 	sts	0x2479, r24
    36a6:	90 93 7a 24 	sts	0x247A, r25
    36aa:	0b c0       	rjmp	.+22     	; 0x36c2 <printLCD+0x142>
			else if (feature_selected>=maxFeature) feature_selected=0;
    36ac:	20 91 1a 20 	lds	r18, 0x201A
    36b0:	30 91 1b 20 	lds	r19, 0x201B
    36b4:	82 17       	cp	r24, r18
    36b6:	93 07       	cpc	r25, r19
    36b8:	24 f0       	brlt	.+8      	; 0x36c2 <printLCD+0x142>
    36ba:	10 92 79 24 	sts	0x2479, r1
    36be:	10 92 7a 24 	sts	0x247A, r1
			
			gfx_mono_draw_string("==  Features Menu  ==",0,0,&sysfont);
    36c2:	27 e0       	ldi	r18, 0x07	; 7
    36c4:	30 e2       	ldi	r19, 0x20	; 32
    36c6:	40 e0       	ldi	r20, 0x00	; 0
    36c8:	60 e0       	ldi	r22, 0x00	; 0
    36ca:	80 e7       	ldi	r24, 0x70	; 112
    36cc:	91 e2       	ldi	r25, 0x21	; 33
    36ce:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
			
			snprintf(strbuf_menu, sizeof(strbuf_menu), "Feature No.%2d", feature_selected+1);
    36d2:	80 91 79 24 	lds	r24, 0x2479
    36d6:	90 91 7a 24 	lds	r25, 0x247A
    36da:	01 96       	adiw	r24, 0x01	; 1
    36dc:	9f 93       	push	r25
    36de:	8f 93       	push	r24
    36e0:	ff 92       	push	r15
    36e2:	ef 92       	push	r14
    36e4:	1f 92       	push	r1
    36e6:	1f 93       	push	r17
    36e8:	df 93       	push	r29
    36ea:	cf 93       	push	r28
    36ec:	dc d2       	rcall	.+1464   	; 0x3ca6 <snprintf>
			gfx_mono_draw_string(strbuf_menu,0, (SYSFONT_HEIGHT)+1, &sysfont);
    36ee:	27 e0       	ldi	r18, 0x07	; 7
    36f0:	30 e2       	ldi	r19, 0x20	; 32
    36f2:	48 e0       	ldi	r20, 0x08	; 8
    36f4:	60 e0       	ldi	r22, 0x00	; 0
    36f6:	ce 01       	movw	r24, r28
    36f8:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
			gfx_mono_draw_string(featureList[feature_selected],0, (SYSFONT_HEIGHT*2)+1, &sysfont);
    36fc:	e0 91 79 24 	lds	r30, 0x2479
    3700:	f0 91 7a 24 	lds	r31, 0x247A
    3704:	ee 0f       	add	r30, r30
    3706:	ff 1f       	adc	r31, r31
    3708:	e9 55       	subi	r30, 0x59	; 89
    370a:	fb 4d       	sbci	r31, 0xDB	; 219
    370c:	27 e0       	ldi	r18, 0x07	; 7
    370e:	30 e2       	ldi	r19, 0x20	; 32
    3710:	4f e0       	ldi	r20, 0x0F	; 15
    3712:	60 e0       	ldi	r22, 0x00	; 0
    3714:	80 81       	ld	r24, Z
    3716:	91 81       	ldd	r25, Z+1	; 0x01
    3718:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
			gfx_mono_draw_string("   A             B   ",0, (SYSFONT_HEIGHT*3)+3, &sysfont);
    371c:	27 e0       	ldi	r18, 0x07	; 7
    371e:	30 e2       	ldi	r19, 0x20	; 32
    3720:	48 e1       	ldi	r20, 0x18	; 24
    3722:	60 e0       	ldi	r22, 0x00	; 0
    3724:	85 e9       	ldi	r24, 0x95	; 149
    3726:	91 e2       	ldi	r25, 0x21	; 33
    3728:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
			//gfx_mono_generic_draw_filled_rect((SYSFONT_WIDTH*2)-1,(SYSFONT_HEIGHT*3)+2,SYSFONT_WIDTH*3,SYSFONT_HEIGHT+2,GFX_PIXEL_XOR);
			if(!featureStat[feature_selected]){
    372c:	e0 91 79 24 	lds	r30, 0x2479
    3730:	f0 91 7a 24 	lds	r31, 0x247A
    3734:	e8 56       	subi	r30, 0x68	; 104
    3736:	fb 4d       	sbci	r31, 0xDB	; 219
    3738:	8d b7       	in	r24, 0x3d	; 61
    373a:	9e b7       	in	r25, 0x3e	; 62
    373c:	08 96       	adiw	r24, 0x08	; 8
    373e:	8d bf       	out	0x3d, r24	; 61
    3740:	9e bf       	out	0x3e, r25	; 62
    3742:	80 81       	ld	r24, Z
    3744:	81 11       	cpse	r24, r1
    3746:	34 c0       	rjmp	.+104    	; 0x37b0 <printLCD+0x230>
				gfx_mono_generic_draw_filled_rect((SYSFONT_WIDTH*2)-1,(SYSFONT_HEIGHT*3)+2,SYSFONT_WIDTH*3,SYSFONT_HEIGHT+2,GFX_PIXEL_XOR);
    3748:	02 e0       	ldi	r16, 0x02	; 2
    374a:	29 e0       	ldi	r18, 0x09	; 9
    374c:	42 e1       	ldi	r20, 0x12	; 18
    374e:	67 e1       	ldi	r22, 0x17	; 23
    3750:	8b e0       	ldi	r24, 0x0B	; 11
    3752:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <gfx_mono_generic_draw_filled_rect>
				if(feature_selected==0){
    3756:	80 91 79 24 	lds	r24, 0x2479
    375a:	90 91 7a 24 	lds	r25, 0x247A
    375e:	00 97       	sbiw	r24, 0x00	; 0
    3760:	19 f4       	brne	.+6      	; 0x3768 <printLCD+0x1e8>
					sendChar('1');
    3762:	81 e3       	ldi	r24, 0x31	; 49
    3764:	63 de       	rcall	.-826    	; 0x342c <sendChar>
    3766:	b0 c0       	rjmp	.+352    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==1){
    3768:	81 30       	cpi	r24, 0x01	; 1
    376a:	91 05       	cpc	r25, r1
    376c:	19 f4       	brne	.+6      	; 0x3774 <printLCD+0x1f4>
					sendChar('2');
    376e:	82 e3       	ldi	r24, 0x32	; 50
    3770:	5d de       	rcall	.-838    	; 0x342c <sendChar>
    3772:	aa c0       	rjmp	.+340    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==2){
    3774:	82 30       	cpi	r24, 0x02	; 2
    3776:	91 05       	cpc	r25, r1
    3778:	19 f4       	brne	.+6      	; 0x3780 <printLCD+0x200>
					sendChar('3');
    377a:	83 e3       	ldi	r24, 0x33	; 51
    377c:	57 de       	rcall	.-850    	; 0x342c <sendChar>
    377e:	a4 c0       	rjmp	.+328    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==3){
    3780:	83 30       	cpi	r24, 0x03	; 3
    3782:	91 05       	cpc	r25, r1
    3784:	19 f4       	brne	.+6      	; 0x378c <printLCD+0x20c>
					sendChar('4');
    3786:	84 e3       	ldi	r24, 0x34	; 52
    3788:	51 de       	rcall	.-862    	; 0x342c <sendChar>
    378a:	9e c0       	rjmp	.+316    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==4){
    378c:	84 30       	cpi	r24, 0x04	; 4
    378e:	91 05       	cpc	r25, r1
    3790:	19 f4       	brne	.+6      	; 0x3798 <printLCD+0x218>
					sendChar('5');
    3792:	85 e3       	ldi	r24, 0x35	; 53
    3794:	4b de       	rcall	.-874    	; 0x342c <sendChar>
    3796:	98 c0       	rjmp	.+304    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==5){
    3798:	85 30       	cpi	r24, 0x05	; 5
    379a:	91 05       	cpc	r25, r1
    379c:	19 f4       	brne	.+6      	; 0x37a4 <printLCD+0x224>
					sendChar('6');
    379e:	86 e3       	ldi	r24, 0x36	; 54
    37a0:	45 de       	rcall	.-886    	; 0x342c <sendChar>
    37a2:	92 c0       	rjmp	.+292    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==6){
    37a4:	06 97       	sbiw	r24, 0x06	; 6
    37a6:	09 f0       	breq	.+2      	; 0x37aa <printLCD+0x22a>
    37a8:	8f c0       	rjmp	.+286    	; 0x38c8 <printLCD+0x348>
					sendChar('7');
    37aa:	87 e3       	ldi	r24, 0x37	; 55
    37ac:	3f de       	rcall	.-898    	; 0x342c <sendChar>
    37ae:	8c c0       	rjmp	.+280    	; 0x38c8 <printLCD+0x348>
				}
			}
			else{
				gfx_mono_generic_draw_filled_rect((SYSFONT_WIDTH*16)-1,(SYSFONT_HEIGHT*3)+2,SYSFONT_WIDTH*3,SYSFONT_HEIGHT+2,GFX_PIXEL_XOR);
    37b0:	02 e0       	ldi	r16, 0x02	; 2
    37b2:	29 e0       	ldi	r18, 0x09	; 9
    37b4:	42 e1       	ldi	r20, 0x12	; 18
    37b6:	67 e1       	ldi	r22, 0x17	; 23
    37b8:	8f e5       	ldi	r24, 0x5F	; 95
    37ba:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <gfx_mono_generic_draw_filled_rect>
				if(feature_selected==0){
    37be:	80 91 79 24 	lds	r24, 0x2479
    37c2:	90 91 7a 24 	lds	r25, 0x247A
    37c6:	00 97       	sbiw	r24, 0x00	; 0
    37c8:	19 f4       	brne	.+6      	; 0x37d0 <printLCD+0x250>
					sendChar('a');
    37ca:	81 e6       	ldi	r24, 0x61	; 97
    37cc:	2f de       	rcall	.-930    	; 0x342c <sendChar>
    37ce:	7c c0       	rjmp	.+248    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==1){
    37d0:	81 30       	cpi	r24, 0x01	; 1
    37d2:	91 05       	cpc	r25, r1
    37d4:	19 f4       	brne	.+6      	; 0x37dc <printLCD+0x25c>
					sendChar('b');
    37d6:	82 e6       	ldi	r24, 0x62	; 98
    37d8:	29 de       	rcall	.-942    	; 0x342c <sendChar>
    37da:	76 c0       	rjmp	.+236    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==2){
    37dc:	82 30       	cpi	r24, 0x02	; 2
    37de:	91 05       	cpc	r25, r1
    37e0:	19 f4       	brne	.+6      	; 0x37e8 <printLCD+0x268>
					sendChar('c');
    37e2:	83 e6       	ldi	r24, 0x63	; 99
    37e4:	23 de       	rcall	.-954    	; 0x342c <sendChar>
    37e6:	70 c0       	rjmp	.+224    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==3){
    37e8:	83 30       	cpi	r24, 0x03	; 3
    37ea:	91 05       	cpc	r25, r1
    37ec:	19 f4       	brne	.+6      	; 0x37f4 <printLCD+0x274>
					sendChar('d');
    37ee:	84 e6       	ldi	r24, 0x64	; 100
    37f0:	1d de       	rcall	.-966    	; 0x342c <sendChar>
    37f2:	6a c0       	rjmp	.+212    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==4){
    37f4:	84 30       	cpi	r24, 0x04	; 4
    37f6:	91 05       	cpc	r25, r1
    37f8:	19 f4       	brne	.+6      	; 0x3800 <printLCD+0x280>
					sendChar('e');
    37fa:	85 e6       	ldi	r24, 0x65	; 101
    37fc:	17 de       	rcall	.-978    	; 0x342c <sendChar>
    37fe:	64 c0       	rjmp	.+200    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==5){
    3800:	85 30       	cpi	r24, 0x05	; 5
    3802:	91 05       	cpc	r25, r1
    3804:	19 f4       	brne	.+6      	; 0x380c <printLCD+0x28c>
					sendChar('f');
    3806:	86 e6       	ldi	r24, 0x66	; 102
    3808:	11 de       	rcall	.-990    	; 0x342c <sendChar>
    380a:	5e c0       	rjmp	.+188    	; 0x38c8 <printLCD+0x348>
				}
				else if(feature_selected==6){
    380c:	06 97       	sbiw	r24, 0x06	; 6
    380e:	09 f0       	breq	.+2      	; 0x3812 <printLCD+0x292>
    3810:	5b c0       	rjmp	.+182    	; 0x38c8 <printLCD+0x348>
					sendChar('g');
    3812:	87 e6       	ldi	r24, 0x67	; 103
    3814:	0b de       	rcall	.-1002   	; 0x342c <sendChar>
    3816:	58 c0       	rjmp	.+176    	; 0x38c8 <printLCD+0x348>
				}
			}
		}
		//status display
		else if(menuSelected==4){
    3818:	24 30       	cpi	r18, 0x04	; 4
    381a:	31 05       	cpc	r19, r1
    381c:	09 f0       	breq	.+2      	; 0x3820 <printLCD+0x2a0>
    381e:	54 c0       	rjmp	.+168    	; 0x38c8 <printLCD+0x348>
			if(status_displayed<0) status_displayed=maxStatus;
    3820:	80 91 77 24 	lds	r24, 0x2477
    3824:	90 91 78 24 	lds	r25, 0x2478
    3828:	99 23       	and	r25, r25
    382a:	4c f4       	brge	.+18     	; 0x383e <printLCD+0x2be>
    382c:	80 91 18 20 	lds	r24, 0x2018
    3830:	90 91 19 20 	lds	r25, 0x2019
    3834:	80 93 77 24 	sts	0x2477, r24
    3838:	90 93 78 24 	sts	0x2478, r25
    383c:	0b c0       	rjmp	.+22     	; 0x3854 <printLCD+0x2d4>
			else if (status_displayed>=maxStatus) status_displayed=0;
    383e:	20 91 18 20 	lds	r18, 0x2018
    3842:	30 91 19 20 	lds	r19, 0x2019
    3846:	82 17       	cp	r24, r18
    3848:	93 07       	cpc	r25, r19
    384a:	24 f0       	brlt	.+8      	; 0x3854 <printLCD+0x2d4>
    384c:	10 92 77 24 	sts	0x2477, r1
    3850:	10 92 78 24 	sts	0x2478, r1
			
			gfx_mono_draw_string("==   SD's Status   ==",0,0,&sysfont);
    3854:	27 e0       	ldi	r18, 0x07	; 7
    3856:	30 e2       	ldi	r19, 0x20	; 32
    3858:	40 e0       	ldi	r20, 0x00	; 0
    385a:	60 e0       	ldi	r22, 0x00	; 0
    385c:	8b ea       	ldi	r24, 0xAB	; 171
    385e:	91 e2       	ldi	r25, 0x21	; 33
    3860:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
			snprintf(strbuf_menu, sizeof(strbuf_menu), "Status No.%2d", status_displayed+1);
    3864:	80 91 77 24 	lds	r24, 0x2477
    3868:	90 91 78 24 	lds	r25, 0x2478
    386c:	01 96       	adiw	r24, 0x01	; 1
    386e:	9f 93       	push	r25
    3870:	8f 93       	push	r24
    3872:	df 92       	push	r13
    3874:	cf 92       	push	r12
    3876:	1f 92       	push	r1
    3878:	1f 93       	push	r17
    387a:	df 93       	push	r29
    387c:	cf 93       	push	r28
    387e:	13 d2       	rcall	.+1062   	; 0x3ca6 <snprintf>
			gfx_mono_draw_string(strbuf_menu,0, (SYSFONT_HEIGHT)+1, &sysfont);
    3880:	27 e0       	ldi	r18, 0x07	; 7
    3882:	30 e2       	ldi	r19, 0x20	; 32
    3884:	48 e0       	ldi	r20, 0x08	; 8
    3886:	60 e0       	ldi	r22, 0x00	; 0
    3888:	ce 01       	movw	r24, r28
    388a:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
			gfx_mono_draw_string(statusList[status_displayed],0, (SYSFONT_HEIGHT*2)+1, &sysfont);
    388e:	e0 91 77 24 	lds	r30, 0x2477
    3892:	f0 91 78 24 	lds	r31, 0x2478
    3896:	ee 0f       	add	r30, r30
    3898:	ff 1f       	adc	r31, r31
    389a:	e4 57       	subi	r30, 0x74	; 116
    389c:	fb 4d       	sbci	r31, 0xDB	; 219
    389e:	27 e0       	ldi	r18, 0x07	; 7
    38a0:	30 e2       	ldi	r19, 0x20	; 32
    38a2:	4f e0       	ldi	r20, 0x0F	; 15
    38a4:	60 e0       	ldi	r22, 0x00	; 0
    38a6:	80 81       	ld	r24, Z
    38a8:	91 81       	ldd	r25, Z+1	; 0x01
    38aa:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
			
			gfx_mono_draw_string(reads,0, (SYSFONT_HEIGHT*3)+3, &sysfont);
    38ae:	27 e0       	ldi	r18, 0x07	; 7
    38b0:	30 e2       	ldi	r19, 0x20	; 32
    38b2:	48 e1       	ldi	r20, 0x18	; 24
    38b4:	60 e0       	ldi	r22, 0x00	; 0
    38b6:	8d ed       	ldi	r24, 0xDD	; 221
    38b8:	94 e2       	ldi	r25, 0x24	; 36
    38ba:	0e 94 63 12 	call	0x24c6	; 0x24c6 <gfx_mono_draw_string>
    38be:	8d b7       	in	r24, 0x3d	; 61
    38c0:	9e b7       	in	r25, 0x3e	; 62
    38c2:	08 96       	adiw	r24, 0x08	; 8
    38c4:	8d bf       	out	0x3d, r24	; 61
    38c6:	9e bf       	out	0x3e, r25	; 62
		}	
		vTaskDelay(50/portTICK_PERIOD_MS);	
    38c8:	89 e1       	ldi	r24, 0x19	; 25
    38ca:	90 e0       	ldi	r25, 0x00	; 0
    38cc:	fd da       	rcall	.-2566   	; 0x2ec8 <vTaskDelay>
	}
    38ce:	6b ce       	rjmp	.-810    	; 0x35a6 <printLCD+0x26>

000038d0 <main>:

/************************************************************************/
/* Main                                                                     */
/************************************************************************/
int main (void)
{
    38d0:	af 92       	push	r10
    38d2:	bf 92       	push	r11
    38d4:	cf 92       	push	r12
    38d6:	df 92       	push	r13
    38d8:	ef 92       	push	r14
    38da:	ff 92       	push	r15
    38dc:	0f 93       	push	r16
	sysclk_init();
    38de:	7c db       	rcall	.-2312   	; 0x2fd8 <sysclk_init>
	board_init();
    38e0:	bf db       	rcall	.-2178   	; 0x3060 <board_init>

	gfx_mono_init();
    38e2:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <gfx_mono_st7565r_init>
	tb_init();
    38e6:	0e 94 df 0a 	call	0x15be	; 0x15be <tb_init>
	//adc_sensors_init();
	
	usart_init_rs232(USART_SERIAL_EXAMPLE, &USART_SERIAL_OPTIONS);
    38ea:	60 e1       	ldi	r22, 0x10	; 16
    38ec:	70 e2       	ldi	r23, 0x20	; 32
    38ee:	80 ea       	ldi	r24, 0xA0	; 160
    38f0:	98 e0       	ldi	r25, 0x08	; 8
    38f2:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <usart_init_rs232>
	//usart_set_mode(USART_SERIAL_EXAMPLE,USART_CMODE_SYNCHRONOUS_gc);
	
	PORTC_OUTCLR = PIN2_bm; //PC2 as RX
    38f6:	84 e0       	ldi	r24, 0x04	; 4
    38f8:	80 93 46 06 	sts	0x0646, r24
	PORTC_DIRCLR = PIN2_bm; //RX pin as input
    38fc:	80 93 42 06 	sts	0x0642, r24
	
	PORTC_OUTSET = PIN3_bm; //PC3 as TX
    3900:	a5 e4       	ldi	r26, 0x45	; 69
    3902:	b6 e0       	ldi	r27, 0x06	; 6
    3904:	88 e0       	ldi	r24, 0x08	; 8
    3906:	8c 93       	st	X, r24
	PORTC_DIRSET = PIN3_bm; //TX pin as output
    3908:	e1 e4       	ldi	r30, 0x41	; 65
    390a:	f6 e0       	ldi	r31, 0x06	; 6
    390c:	80 83       	st	Z, r24
	
	//PORTC_OUTCLR = PIN4_bm; //PC4 as sig-in
	//PORTC_DIRCLR = PIN4_bm; //PC4 pin as input
	
	PORTC_OUTSET = PIN3_bm; //PC5 as sig-out
    390e:	8c 93       	st	X, r24
	PORTC_DIRSET = PIN3_bm; //PC5 pin as output
    3910:	80 83       	st	Z, r24

	setUpSerial();
    3912:	7e dd       	rcall	.-1284   	; 0x3410 <setUpSerial>
	
	xTaskCreate(printLCD,"",500,NULL,1,NULL);
    3914:	a1 2c       	mov	r10, r1
    3916:	b1 2c       	mov	r11, r1
    3918:	c1 2c       	mov	r12, r1
    391a:	d1 2c       	mov	r13, r1
    391c:	e1 2c       	mov	r14, r1
    391e:	f1 2c       	mov	r15, r1
    3920:	01 e0       	ldi	r16, 0x01	; 1
    3922:	20 e0       	ldi	r18, 0x00	; 0
    3924:	30 e0       	ldi	r19, 0x00	; 0
    3926:	44 ef       	ldi	r20, 0xF4	; 244
    3928:	51 e0       	ldi	r21, 0x01	; 1
    392a:	6d e2       	ldi	r22, 0x2D	; 45
    392c:	70 e2       	ldi	r23, 0x20	; 32
    392e:	80 ec       	ldi	r24, 0xC0	; 192
    3930:	9a e1       	ldi	r25, 0x1A	; 26
    3932:	40 d8       	rcall	.-3968   	; 0x29b4 <xTaskGenericCreate>
	xTaskCreate(button,"",500,NULL,1,NULL);
    3934:	20 e0       	ldi	r18, 0x00	; 0
    3936:	30 e0       	ldi	r19, 0x00	; 0
    3938:	44 ef       	ldi	r20, 0xF4	; 244
    393a:	51 e0       	ldi	r21, 0x01	; 1
    393c:	6d e2       	ldi	r22, 0x2D	; 45
    393e:	70 e2       	ldi	r23, 0x20	; 32
    3940:	8f e7       	ldi	r24, 0x7F	; 127
    3942:	98 e1       	ldi	r25, 0x18	; 24
    3944:	37 d8       	rcall	.-3986   	; 0x29b4 <xTaskGenericCreate>
	xTaskCreate(menuNav,"",500,NULL,1,NULL);
    3946:	20 e0       	ldi	r18, 0x00	; 0
    3948:	30 e0       	ldi	r19, 0x00	; 0
    394a:	44 ef       	ldi	r20, 0xF4	; 244
    394c:	51 e0       	ldi	r21, 0x01	; 1
    394e:	6d e2       	ldi	r22, 0x2D	; 45
    3950:	70 e2       	ldi	r23, 0x20	; 32
    3952:	80 ef       	ldi	r24, 0xF0	; 240
    3954:	98 e1       	ldi	r25, 0x18	; 24
    3956:	2e d8       	rcall	.-4004   	; 0x29b4 <xTaskGenericCreate>
	xTaskCreate(Touch, "", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
    3958:	20 e0       	ldi	r18, 0x00	; 0
    395a:	30 e0       	ldi	r19, 0x00	; 0
    395c:	45 e5       	ldi	r20, 0x55	; 85
    395e:	50 e0       	ldi	r21, 0x00	; 0
    3960:	6d e2       	ldi	r22, 0x2D	; 45
    3962:	70 e2       	ldi	r23, 0x20	; 32
    3964:	8a ed       	ldi	r24, 0xDA	; 218
    3966:	98 e1       	ldi	r25, 0x18	; 24
    3968:	25 d8       	rcall	.-4022   	; 0x29b4 <xTaskGenericCreate>
	xTaskCreate(commGate_IN, "",500, NULL, 0, NULL);
    396a:	00 e0       	ldi	r16, 0x00	; 0
    396c:	20 e0       	ldi	r18, 0x00	; 0
    396e:	30 e0       	ldi	r19, 0x00	; 0
    3970:	44 ef       	ldi	r20, 0xF4	; 244
    3972:	51 e0       	ldi	r21, 0x01	; 1
    3974:	6d e2       	ldi	r22, 0x2D	; 45
    3976:	70 e2       	ldi	r23, 0x20	; 32
    3978:	83 e5       	ldi	r24, 0x53	; 83
    397a:	9a e1       	ldi	r25, 0x1A	; 26
    397c:	1b d8       	rcall	.-4042   	; 0x29b4 <xTaskGenericCreate>
	xTaskCreate(commGate_OUT, "", 500, NULL, 0, NULL);
    397e:	20 e0       	ldi	r18, 0x00	; 0
    3980:	30 e0       	ldi	r19, 0x00	; 0
    3982:	44 ef       	ldi	r20, 0xF4	; 244
    3984:	51 e0       	ldi	r21, 0x01	; 1
    3986:	6d e2       	ldi	r22, 0x2D	; 45
    3988:	70 e2       	ldi	r23, 0x20	; 32
    398a:	81 e3       	ldi	r24, 0x31	; 49
    398c:	9a e1       	ldi	r25, 0x1A	; 26
    398e:	12 d8       	rcall	.-4060   	; 0x29b4 <xTaskGenericCreate>
	//xTaskCreate(commGate_SIG, "", 500, NULL, 0, NULL);

	
	vTaskStartScheduler();
    3990:	12 d9       	rcall	.-3548   	; 0x2bb6 <vTaskStartScheduler>
}
    3992:	80 e0       	ldi	r24, 0x00	; 0
    3994:	90 e0       	ldi	r25, 0x00	; 0
    3996:	0f 91       	pop	r16
    3998:	ff 90       	pop	r15
    399a:	ef 90       	pop	r14
    399c:	df 90       	pop	r13
    399e:	cf 90       	pop	r12
    39a0:	bf 90       	pop	r11
    39a2:	af 90       	pop	r10
    39a4:	08 95       	ret

000039a6 <__udivmodsi4>:
    39a6:	a1 e2       	ldi	r26, 0x21	; 33
    39a8:	1a 2e       	mov	r1, r26
    39aa:	aa 1b       	sub	r26, r26
    39ac:	bb 1b       	sub	r27, r27
    39ae:	fd 01       	movw	r30, r26
    39b0:	0d c0       	rjmp	.+26     	; 0x39cc <__udivmodsi4_ep>

000039b2 <__udivmodsi4_loop>:
    39b2:	aa 1f       	adc	r26, r26
    39b4:	bb 1f       	adc	r27, r27
    39b6:	ee 1f       	adc	r30, r30
    39b8:	ff 1f       	adc	r31, r31
    39ba:	a2 17       	cp	r26, r18
    39bc:	b3 07       	cpc	r27, r19
    39be:	e4 07       	cpc	r30, r20
    39c0:	f5 07       	cpc	r31, r21
    39c2:	20 f0       	brcs	.+8      	; 0x39cc <__udivmodsi4_ep>
    39c4:	a2 1b       	sub	r26, r18
    39c6:	b3 0b       	sbc	r27, r19
    39c8:	e4 0b       	sbc	r30, r20
    39ca:	f5 0b       	sbc	r31, r21

000039cc <__udivmodsi4_ep>:
    39cc:	66 1f       	adc	r22, r22
    39ce:	77 1f       	adc	r23, r23
    39d0:	88 1f       	adc	r24, r24
    39d2:	99 1f       	adc	r25, r25
    39d4:	1a 94       	dec	r1
    39d6:	69 f7       	brne	.-38     	; 0x39b2 <__udivmodsi4_loop>
    39d8:	60 95       	com	r22
    39da:	70 95       	com	r23
    39dc:	80 95       	com	r24
    39de:	90 95       	com	r25
    39e0:	9b 01       	movw	r18, r22
    39e2:	ac 01       	movw	r20, r24
    39e4:	bd 01       	movw	r22, r26
    39e6:	cf 01       	movw	r24, r30
    39e8:	08 95       	ret

000039ea <__prologue_saves__>:
    39ea:	2f 92       	push	r2
    39ec:	3f 92       	push	r3
    39ee:	4f 92       	push	r4
    39f0:	5f 92       	push	r5
    39f2:	6f 92       	push	r6
    39f4:	7f 92       	push	r7
    39f6:	8f 92       	push	r8
    39f8:	9f 92       	push	r9
    39fa:	af 92       	push	r10
    39fc:	bf 92       	push	r11
    39fe:	cf 92       	push	r12
    3a00:	df 92       	push	r13
    3a02:	ef 92       	push	r14
    3a04:	ff 92       	push	r15
    3a06:	0f 93       	push	r16
    3a08:	1f 93       	push	r17
    3a0a:	cf 93       	push	r28
    3a0c:	df 93       	push	r29
    3a0e:	cd b7       	in	r28, 0x3d	; 61
    3a10:	de b7       	in	r29, 0x3e	; 62
    3a12:	ca 1b       	sub	r28, r26
    3a14:	db 0b       	sbc	r29, r27
    3a16:	cd bf       	out	0x3d, r28	; 61
    3a18:	de bf       	out	0x3e, r29	; 62
    3a1a:	19 94       	eijmp

00003a1c <__epilogue_restores__>:
    3a1c:	2a 88       	ldd	r2, Y+18	; 0x12
    3a1e:	39 88       	ldd	r3, Y+17	; 0x11
    3a20:	48 88       	ldd	r4, Y+16	; 0x10
    3a22:	5f 84       	ldd	r5, Y+15	; 0x0f
    3a24:	6e 84       	ldd	r6, Y+14	; 0x0e
    3a26:	7d 84       	ldd	r7, Y+13	; 0x0d
    3a28:	8c 84       	ldd	r8, Y+12	; 0x0c
    3a2a:	9b 84       	ldd	r9, Y+11	; 0x0b
    3a2c:	aa 84       	ldd	r10, Y+10	; 0x0a
    3a2e:	b9 84       	ldd	r11, Y+9	; 0x09
    3a30:	c8 84       	ldd	r12, Y+8	; 0x08
    3a32:	df 80       	ldd	r13, Y+7	; 0x07
    3a34:	ee 80       	ldd	r14, Y+6	; 0x06
    3a36:	fd 80       	ldd	r15, Y+5	; 0x05
    3a38:	0c 81       	ldd	r16, Y+4	; 0x04
    3a3a:	1b 81       	ldd	r17, Y+3	; 0x03
    3a3c:	aa 81       	ldd	r26, Y+2	; 0x02
    3a3e:	b9 81       	ldd	r27, Y+1	; 0x01
    3a40:	ce 0f       	add	r28, r30
    3a42:	d1 1d       	adc	r29, r1
    3a44:	cd bf       	out	0x3d, r28	; 61
    3a46:	de bf       	out	0x3e, r29	; 62
    3a48:	ed 01       	movw	r28, r26
    3a4a:	08 95       	ret

00003a4c <malloc>:
    3a4c:	cf 93       	push	r28
    3a4e:	df 93       	push	r29
    3a50:	82 30       	cpi	r24, 0x02	; 2
    3a52:	91 05       	cpc	r25, r1
    3a54:	10 f4       	brcc	.+4      	; 0x3a5a <malloc+0xe>
    3a56:	82 e0       	ldi	r24, 0x02	; 2
    3a58:	90 e0       	ldi	r25, 0x00	; 0
    3a5a:	e0 91 4a 25 	lds	r30, 0x254A
    3a5e:	f0 91 4b 25 	lds	r31, 0x254B
    3a62:	20 e0       	ldi	r18, 0x00	; 0
    3a64:	30 e0       	ldi	r19, 0x00	; 0
    3a66:	c0 e0       	ldi	r28, 0x00	; 0
    3a68:	d0 e0       	ldi	r29, 0x00	; 0
    3a6a:	30 97       	sbiw	r30, 0x00	; 0
    3a6c:	11 f1       	breq	.+68     	; 0x3ab2 <malloc+0x66>
    3a6e:	40 81       	ld	r20, Z
    3a70:	51 81       	ldd	r21, Z+1	; 0x01
    3a72:	48 17       	cp	r20, r24
    3a74:	59 07       	cpc	r21, r25
    3a76:	c0 f0       	brcs	.+48     	; 0x3aa8 <malloc+0x5c>
    3a78:	48 17       	cp	r20, r24
    3a7a:	59 07       	cpc	r21, r25
    3a7c:	61 f4       	brne	.+24     	; 0x3a96 <malloc+0x4a>
    3a7e:	82 81       	ldd	r24, Z+2	; 0x02
    3a80:	93 81       	ldd	r25, Z+3	; 0x03
    3a82:	20 97       	sbiw	r28, 0x00	; 0
    3a84:	19 f0       	breq	.+6      	; 0x3a8c <malloc+0x40>
    3a86:	8a 83       	std	Y+2, r24	; 0x02
    3a88:	9b 83       	std	Y+3, r25	; 0x03
    3a8a:	2b c0       	rjmp	.+86     	; 0x3ae2 <malloc+0x96>
    3a8c:	80 93 4a 25 	sts	0x254A, r24
    3a90:	90 93 4b 25 	sts	0x254B, r25
    3a94:	26 c0       	rjmp	.+76     	; 0x3ae2 <malloc+0x96>
    3a96:	21 15       	cp	r18, r1
    3a98:	31 05       	cpc	r19, r1
    3a9a:	19 f0       	breq	.+6      	; 0x3aa2 <malloc+0x56>
    3a9c:	42 17       	cp	r20, r18
    3a9e:	53 07       	cpc	r21, r19
    3aa0:	18 f4       	brcc	.+6      	; 0x3aa8 <malloc+0x5c>
    3aa2:	9a 01       	movw	r18, r20
    3aa4:	be 01       	movw	r22, r28
    3aa6:	df 01       	movw	r26, r30
    3aa8:	ef 01       	movw	r28, r30
    3aaa:	02 80       	ldd	r0, Z+2	; 0x02
    3aac:	f3 81       	ldd	r31, Z+3	; 0x03
    3aae:	e0 2d       	mov	r30, r0
    3ab0:	dc cf       	rjmp	.-72     	; 0x3a6a <malloc+0x1e>
    3ab2:	21 15       	cp	r18, r1
    3ab4:	31 05       	cpc	r19, r1
    3ab6:	09 f1       	breq	.+66     	; 0x3afa <malloc+0xae>
    3ab8:	28 1b       	sub	r18, r24
    3aba:	39 0b       	sbc	r19, r25
    3abc:	24 30       	cpi	r18, 0x04	; 4
    3abe:	31 05       	cpc	r19, r1
    3ac0:	90 f4       	brcc	.+36     	; 0x3ae6 <malloc+0x9a>
    3ac2:	12 96       	adiw	r26, 0x02	; 2
    3ac4:	8d 91       	ld	r24, X+
    3ac6:	9c 91       	ld	r25, X
    3ac8:	13 97       	sbiw	r26, 0x03	; 3
    3aca:	61 15       	cp	r22, r1
    3acc:	71 05       	cpc	r23, r1
    3ace:	21 f0       	breq	.+8      	; 0x3ad8 <malloc+0x8c>
    3ad0:	fb 01       	movw	r30, r22
    3ad2:	82 83       	std	Z+2, r24	; 0x02
    3ad4:	93 83       	std	Z+3, r25	; 0x03
    3ad6:	04 c0       	rjmp	.+8      	; 0x3ae0 <malloc+0x94>
    3ad8:	80 93 4a 25 	sts	0x254A, r24
    3adc:	90 93 4b 25 	sts	0x254B, r25
    3ae0:	fd 01       	movw	r30, r26
    3ae2:	32 96       	adiw	r30, 0x02	; 2
    3ae4:	44 c0       	rjmp	.+136    	; 0x3b6e <malloc+0x122>
    3ae6:	fd 01       	movw	r30, r26
    3ae8:	e2 0f       	add	r30, r18
    3aea:	f3 1f       	adc	r31, r19
    3aec:	81 93       	st	Z+, r24
    3aee:	91 93       	st	Z+, r25
    3af0:	22 50       	subi	r18, 0x02	; 2
    3af2:	31 09       	sbc	r19, r1
    3af4:	2d 93       	st	X+, r18
    3af6:	3c 93       	st	X, r19
    3af8:	3a c0       	rjmp	.+116    	; 0x3b6e <malloc+0x122>
    3afa:	20 91 48 25 	lds	r18, 0x2548
    3afe:	30 91 49 25 	lds	r19, 0x2549
    3b02:	23 2b       	or	r18, r19
    3b04:	41 f4       	brne	.+16     	; 0x3b16 <malloc+0xca>
    3b06:	20 91 03 20 	lds	r18, 0x2003
    3b0a:	30 91 04 20 	lds	r19, 0x2004
    3b0e:	20 93 48 25 	sts	0x2548, r18
    3b12:	30 93 49 25 	sts	0x2549, r19
    3b16:	20 91 01 20 	lds	r18, 0x2001
    3b1a:	30 91 02 20 	lds	r19, 0x2002
    3b1e:	21 15       	cp	r18, r1
    3b20:	31 05       	cpc	r19, r1
    3b22:	41 f4       	brne	.+16     	; 0x3b34 <malloc+0xe8>
    3b24:	2d b7       	in	r18, 0x3d	; 61
    3b26:	3e b7       	in	r19, 0x3e	; 62
    3b28:	40 91 05 20 	lds	r20, 0x2005
    3b2c:	50 91 06 20 	lds	r21, 0x2006
    3b30:	24 1b       	sub	r18, r20
    3b32:	35 0b       	sbc	r19, r21
    3b34:	e0 91 48 25 	lds	r30, 0x2548
    3b38:	f0 91 49 25 	lds	r31, 0x2549
    3b3c:	e2 17       	cp	r30, r18
    3b3e:	f3 07       	cpc	r31, r19
    3b40:	a0 f4       	brcc	.+40     	; 0x3b6a <malloc+0x11e>
    3b42:	2e 1b       	sub	r18, r30
    3b44:	3f 0b       	sbc	r19, r31
    3b46:	28 17       	cp	r18, r24
    3b48:	39 07       	cpc	r19, r25
    3b4a:	78 f0       	brcs	.+30     	; 0x3b6a <malloc+0x11e>
    3b4c:	ac 01       	movw	r20, r24
    3b4e:	4e 5f       	subi	r20, 0xFE	; 254
    3b50:	5f 4f       	sbci	r21, 0xFF	; 255
    3b52:	24 17       	cp	r18, r20
    3b54:	35 07       	cpc	r19, r21
    3b56:	48 f0       	brcs	.+18     	; 0x3b6a <malloc+0x11e>
    3b58:	4e 0f       	add	r20, r30
    3b5a:	5f 1f       	adc	r21, r31
    3b5c:	40 93 48 25 	sts	0x2548, r20
    3b60:	50 93 49 25 	sts	0x2549, r21
    3b64:	81 93       	st	Z+, r24
    3b66:	91 93       	st	Z+, r25
    3b68:	02 c0       	rjmp	.+4      	; 0x3b6e <malloc+0x122>
    3b6a:	e0 e0       	ldi	r30, 0x00	; 0
    3b6c:	f0 e0       	ldi	r31, 0x00	; 0
    3b6e:	cf 01       	movw	r24, r30
    3b70:	df 91       	pop	r29
    3b72:	cf 91       	pop	r28
    3b74:	08 95       	ret

00003b76 <free>:
    3b76:	0f 93       	push	r16
    3b78:	1f 93       	push	r17
    3b7a:	cf 93       	push	r28
    3b7c:	df 93       	push	r29
    3b7e:	00 97       	sbiw	r24, 0x00	; 0
    3b80:	09 f4       	brne	.+2      	; 0x3b84 <free+0xe>
    3b82:	8c c0       	rjmp	.+280    	; 0x3c9c <free+0x126>
    3b84:	fc 01       	movw	r30, r24
    3b86:	32 97       	sbiw	r30, 0x02	; 2
    3b88:	12 82       	std	Z+2, r1	; 0x02
    3b8a:	13 82       	std	Z+3, r1	; 0x03
    3b8c:	00 91 4a 25 	lds	r16, 0x254A
    3b90:	10 91 4b 25 	lds	r17, 0x254B
    3b94:	01 15       	cp	r16, r1
    3b96:	11 05       	cpc	r17, r1
    3b98:	81 f4       	brne	.+32     	; 0x3bba <free+0x44>
    3b9a:	20 81       	ld	r18, Z
    3b9c:	31 81       	ldd	r19, Z+1	; 0x01
    3b9e:	82 0f       	add	r24, r18
    3ba0:	93 1f       	adc	r25, r19
    3ba2:	20 91 48 25 	lds	r18, 0x2548
    3ba6:	30 91 49 25 	lds	r19, 0x2549
    3baa:	28 17       	cp	r18, r24
    3bac:	39 07       	cpc	r19, r25
    3bae:	79 f5       	brne	.+94     	; 0x3c0e <free+0x98>
    3bb0:	e0 93 48 25 	sts	0x2548, r30
    3bb4:	f0 93 49 25 	sts	0x2549, r31
    3bb8:	71 c0       	rjmp	.+226    	; 0x3c9c <free+0x126>
    3bba:	d8 01       	movw	r26, r16
    3bbc:	40 e0       	ldi	r20, 0x00	; 0
    3bbe:	50 e0       	ldi	r21, 0x00	; 0
    3bc0:	ae 17       	cp	r26, r30
    3bc2:	bf 07       	cpc	r27, r31
    3bc4:	50 f4       	brcc	.+20     	; 0x3bda <free+0x64>
    3bc6:	12 96       	adiw	r26, 0x02	; 2
    3bc8:	2d 91       	ld	r18, X+
    3bca:	3c 91       	ld	r19, X
    3bcc:	13 97       	sbiw	r26, 0x03	; 3
    3bce:	ad 01       	movw	r20, r26
    3bd0:	21 15       	cp	r18, r1
    3bd2:	31 05       	cpc	r19, r1
    3bd4:	09 f1       	breq	.+66     	; 0x3c18 <free+0xa2>
    3bd6:	d9 01       	movw	r26, r18
    3bd8:	f3 cf       	rjmp	.-26     	; 0x3bc0 <free+0x4a>
    3bda:	9d 01       	movw	r18, r26
    3bdc:	da 01       	movw	r26, r20
    3bde:	22 83       	std	Z+2, r18	; 0x02
    3be0:	33 83       	std	Z+3, r19	; 0x03
    3be2:	60 81       	ld	r22, Z
    3be4:	71 81       	ldd	r23, Z+1	; 0x01
    3be6:	86 0f       	add	r24, r22
    3be8:	97 1f       	adc	r25, r23
    3bea:	82 17       	cp	r24, r18
    3bec:	93 07       	cpc	r25, r19
    3bee:	69 f4       	brne	.+26     	; 0x3c0a <free+0x94>
    3bf0:	ec 01       	movw	r28, r24
    3bf2:	28 81       	ld	r18, Y
    3bf4:	39 81       	ldd	r19, Y+1	; 0x01
    3bf6:	26 0f       	add	r18, r22
    3bf8:	37 1f       	adc	r19, r23
    3bfa:	2e 5f       	subi	r18, 0xFE	; 254
    3bfc:	3f 4f       	sbci	r19, 0xFF	; 255
    3bfe:	20 83       	st	Z, r18
    3c00:	31 83       	std	Z+1, r19	; 0x01
    3c02:	8a 81       	ldd	r24, Y+2	; 0x02
    3c04:	9b 81       	ldd	r25, Y+3	; 0x03
    3c06:	82 83       	std	Z+2, r24	; 0x02
    3c08:	93 83       	std	Z+3, r25	; 0x03
    3c0a:	45 2b       	or	r20, r21
    3c0c:	29 f4       	brne	.+10     	; 0x3c18 <free+0xa2>
    3c0e:	e0 93 4a 25 	sts	0x254A, r30
    3c12:	f0 93 4b 25 	sts	0x254B, r31
    3c16:	42 c0       	rjmp	.+132    	; 0x3c9c <free+0x126>
    3c18:	12 96       	adiw	r26, 0x02	; 2
    3c1a:	ed 93       	st	X+, r30
    3c1c:	fc 93       	st	X, r31
    3c1e:	13 97       	sbiw	r26, 0x03	; 3
    3c20:	ed 01       	movw	r28, r26
    3c22:	49 91       	ld	r20, Y+
    3c24:	59 91       	ld	r21, Y+
    3c26:	9e 01       	movw	r18, r28
    3c28:	24 0f       	add	r18, r20
    3c2a:	35 1f       	adc	r19, r21
    3c2c:	e2 17       	cp	r30, r18
    3c2e:	f3 07       	cpc	r31, r19
    3c30:	71 f4       	brne	.+28     	; 0x3c4e <free+0xd8>
    3c32:	80 81       	ld	r24, Z
    3c34:	91 81       	ldd	r25, Z+1	; 0x01
    3c36:	84 0f       	add	r24, r20
    3c38:	95 1f       	adc	r25, r21
    3c3a:	02 96       	adiw	r24, 0x02	; 2
    3c3c:	8d 93       	st	X+, r24
    3c3e:	9c 93       	st	X, r25
    3c40:	11 97       	sbiw	r26, 0x01	; 1
    3c42:	82 81       	ldd	r24, Z+2	; 0x02
    3c44:	93 81       	ldd	r25, Z+3	; 0x03
    3c46:	12 96       	adiw	r26, 0x02	; 2
    3c48:	8d 93       	st	X+, r24
    3c4a:	9c 93       	st	X, r25
    3c4c:	13 97       	sbiw	r26, 0x03	; 3
    3c4e:	e0 e0       	ldi	r30, 0x00	; 0
    3c50:	f0 e0       	ldi	r31, 0x00	; 0
    3c52:	d8 01       	movw	r26, r16
    3c54:	12 96       	adiw	r26, 0x02	; 2
    3c56:	8d 91       	ld	r24, X+
    3c58:	9c 91       	ld	r25, X
    3c5a:	13 97       	sbiw	r26, 0x03	; 3
    3c5c:	00 97       	sbiw	r24, 0x00	; 0
    3c5e:	19 f0       	breq	.+6      	; 0x3c66 <free+0xf0>
    3c60:	f8 01       	movw	r30, r16
    3c62:	8c 01       	movw	r16, r24
    3c64:	f6 cf       	rjmp	.-20     	; 0x3c52 <free+0xdc>
    3c66:	8d 91       	ld	r24, X+
    3c68:	9c 91       	ld	r25, X
    3c6a:	98 01       	movw	r18, r16
    3c6c:	2e 5f       	subi	r18, 0xFE	; 254
    3c6e:	3f 4f       	sbci	r19, 0xFF	; 255
    3c70:	82 0f       	add	r24, r18
    3c72:	93 1f       	adc	r25, r19
    3c74:	20 91 48 25 	lds	r18, 0x2548
    3c78:	30 91 49 25 	lds	r19, 0x2549
    3c7c:	28 17       	cp	r18, r24
    3c7e:	39 07       	cpc	r19, r25
    3c80:	69 f4       	brne	.+26     	; 0x3c9c <free+0x126>
    3c82:	30 97       	sbiw	r30, 0x00	; 0
    3c84:	29 f4       	brne	.+10     	; 0x3c90 <free+0x11a>
    3c86:	10 92 4a 25 	sts	0x254A, r1
    3c8a:	10 92 4b 25 	sts	0x254B, r1
    3c8e:	02 c0       	rjmp	.+4      	; 0x3c94 <free+0x11e>
    3c90:	12 82       	std	Z+2, r1	; 0x02
    3c92:	13 82       	std	Z+3, r1	; 0x03
    3c94:	00 93 48 25 	sts	0x2548, r16
    3c98:	10 93 49 25 	sts	0x2549, r17
    3c9c:	df 91       	pop	r29
    3c9e:	cf 91       	pop	r28
    3ca0:	1f 91       	pop	r17
    3ca2:	0f 91       	pop	r16
    3ca4:	08 95       	ret

00003ca6 <snprintf>:
    3ca6:	0f 93       	push	r16
    3ca8:	1f 93       	push	r17
    3caa:	cf 93       	push	r28
    3cac:	df 93       	push	r29
    3cae:	cd b7       	in	r28, 0x3d	; 61
    3cb0:	de b7       	in	r29, 0x3e	; 62
    3cb2:	2e 97       	sbiw	r28, 0x0e	; 14
    3cb4:	cd bf       	out	0x3d, r28	; 61
    3cb6:	de bf       	out	0x3e, r29	; 62
    3cb8:	0e 89       	ldd	r16, Y+22	; 0x16
    3cba:	1f 89       	ldd	r17, Y+23	; 0x17
    3cbc:	88 8d       	ldd	r24, Y+24	; 0x18
    3cbe:	99 8d       	ldd	r25, Y+25	; 0x19
    3cc0:	26 e0       	ldi	r18, 0x06	; 6
    3cc2:	2c 83       	std	Y+4, r18	; 0x04
    3cc4:	09 83       	std	Y+1, r16	; 0x01
    3cc6:	1a 83       	std	Y+2, r17	; 0x02
    3cc8:	97 ff       	sbrs	r25, 7
    3cca:	02 c0       	rjmp	.+4      	; 0x3cd0 <snprintf+0x2a>
    3ccc:	80 e0       	ldi	r24, 0x00	; 0
    3cce:	90 e8       	ldi	r25, 0x80	; 128
    3cd0:	01 97       	sbiw	r24, 0x01	; 1
    3cd2:	8d 83       	std	Y+5, r24	; 0x05
    3cd4:	9e 83       	std	Y+6, r25	; 0x06
    3cd6:	ae 01       	movw	r20, r28
    3cd8:	44 5e       	subi	r20, 0xE4	; 228
    3cda:	5f 4f       	sbci	r21, 0xFF	; 255
    3cdc:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3cde:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3ce0:	ce 01       	movw	r24, r28
    3ce2:	01 96       	adiw	r24, 0x01	; 1
    3ce4:	16 d0       	rcall	.+44     	; 0x3d12 <vfprintf>
    3ce6:	4d 81       	ldd	r20, Y+5	; 0x05
    3ce8:	5e 81       	ldd	r21, Y+6	; 0x06
    3cea:	57 fd       	sbrc	r21, 7
    3cec:	0a c0       	rjmp	.+20     	; 0x3d02 <snprintf+0x5c>
    3cee:	2f 81       	ldd	r18, Y+7	; 0x07
    3cf0:	38 85       	ldd	r19, Y+8	; 0x08
    3cf2:	42 17       	cp	r20, r18
    3cf4:	53 07       	cpc	r21, r19
    3cf6:	0c f4       	brge	.+2      	; 0x3cfa <snprintf+0x54>
    3cf8:	9a 01       	movw	r18, r20
    3cfa:	f8 01       	movw	r30, r16
    3cfc:	e2 0f       	add	r30, r18
    3cfe:	f3 1f       	adc	r31, r19
    3d00:	10 82       	st	Z, r1
    3d02:	2e 96       	adiw	r28, 0x0e	; 14
    3d04:	cd bf       	out	0x3d, r28	; 61
    3d06:	de bf       	out	0x3e, r29	; 62
    3d08:	df 91       	pop	r29
    3d0a:	cf 91       	pop	r28
    3d0c:	1f 91       	pop	r17
    3d0e:	0f 91       	pop	r16
    3d10:	08 95       	ret

00003d12 <vfprintf>:
    3d12:	2f 92       	push	r2
    3d14:	3f 92       	push	r3
    3d16:	4f 92       	push	r4
    3d18:	5f 92       	push	r5
    3d1a:	6f 92       	push	r6
    3d1c:	7f 92       	push	r7
    3d1e:	8f 92       	push	r8
    3d20:	9f 92       	push	r9
    3d22:	af 92       	push	r10
    3d24:	bf 92       	push	r11
    3d26:	cf 92       	push	r12
    3d28:	df 92       	push	r13
    3d2a:	ef 92       	push	r14
    3d2c:	ff 92       	push	r15
    3d2e:	0f 93       	push	r16
    3d30:	1f 93       	push	r17
    3d32:	cf 93       	push	r28
    3d34:	df 93       	push	r29
    3d36:	cd b7       	in	r28, 0x3d	; 61
    3d38:	de b7       	in	r29, 0x3e	; 62
    3d3a:	2c 97       	sbiw	r28, 0x0c	; 12
    3d3c:	cd bf       	out	0x3d, r28	; 61
    3d3e:	de bf       	out	0x3e, r29	; 62
    3d40:	7c 01       	movw	r14, r24
    3d42:	6b 01       	movw	r12, r22
    3d44:	8a 01       	movw	r16, r20
    3d46:	fc 01       	movw	r30, r24
    3d48:	16 82       	std	Z+6, r1	; 0x06
    3d4a:	17 82       	std	Z+7, r1	; 0x07
    3d4c:	83 81       	ldd	r24, Z+3	; 0x03
    3d4e:	81 ff       	sbrs	r24, 1
    3d50:	b0 c1       	rjmp	.+864    	; 0x40b2 <vfprintf+0x3a0>
    3d52:	ce 01       	movw	r24, r28
    3d54:	01 96       	adiw	r24, 0x01	; 1
    3d56:	4c 01       	movw	r8, r24
    3d58:	f7 01       	movw	r30, r14
    3d5a:	93 81       	ldd	r25, Z+3	; 0x03
    3d5c:	f6 01       	movw	r30, r12
    3d5e:	93 fd       	sbrc	r25, 3
    3d60:	85 91       	lpm	r24, Z+
    3d62:	93 ff       	sbrs	r25, 3
    3d64:	81 91       	ld	r24, Z+
    3d66:	6f 01       	movw	r12, r30
    3d68:	88 23       	and	r24, r24
    3d6a:	09 f4       	brne	.+2      	; 0x3d6e <vfprintf+0x5c>
    3d6c:	9e c1       	rjmp	.+828    	; 0x40aa <vfprintf+0x398>
    3d6e:	85 32       	cpi	r24, 0x25	; 37
    3d70:	39 f4       	brne	.+14     	; 0x3d80 <vfprintf+0x6e>
    3d72:	93 fd       	sbrc	r25, 3
    3d74:	85 91       	lpm	r24, Z+
    3d76:	93 ff       	sbrs	r25, 3
    3d78:	81 91       	ld	r24, Z+
    3d7a:	6f 01       	movw	r12, r30
    3d7c:	85 32       	cpi	r24, 0x25	; 37
    3d7e:	21 f4       	brne	.+8      	; 0x3d88 <vfprintf+0x76>
    3d80:	b7 01       	movw	r22, r14
    3d82:	90 e0       	ldi	r25, 0x00	; 0
    3d84:	c4 d1       	rcall	.+904    	; 0x410e <fputc>
    3d86:	e8 cf       	rjmp	.-48     	; 0x3d58 <vfprintf+0x46>
    3d88:	51 2c       	mov	r5, r1
    3d8a:	31 2c       	mov	r3, r1
    3d8c:	20 e0       	ldi	r18, 0x00	; 0
    3d8e:	20 32       	cpi	r18, 0x20	; 32
    3d90:	a0 f4       	brcc	.+40     	; 0x3dba <vfprintf+0xa8>
    3d92:	8b 32       	cpi	r24, 0x2B	; 43
    3d94:	69 f0       	breq	.+26     	; 0x3db0 <vfprintf+0x9e>
    3d96:	30 f4       	brcc	.+12     	; 0x3da4 <vfprintf+0x92>
    3d98:	80 32       	cpi	r24, 0x20	; 32
    3d9a:	59 f0       	breq	.+22     	; 0x3db2 <vfprintf+0xa0>
    3d9c:	83 32       	cpi	r24, 0x23	; 35
    3d9e:	69 f4       	brne	.+26     	; 0x3dba <vfprintf+0xa8>
    3da0:	20 61       	ori	r18, 0x10	; 16
    3da2:	2c c0       	rjmp	.+88     	; 0x3dfc <vfprintf+0xea>
    3da4:	8d 32       	cpi	r24, 0x2D	; 45
    3da6:	39 f0       	breq	.+14     	; 0x3db6 <vfprintf+0xa4>
    3da8:	80 33       	cpi	r24, 0x30	; 48
    3daa:	39 f4       	brne	.+14     	; 0x3dba <vfprintf+0xa8>
    3dac:	21 60       	ori	r18, 0x01	; 1
    3dae:	26 c0       	rjmp	.+76     	; 0x3dfc <vfprintf+0xea>
    3db0:	22 60       	ori	r18, 0x02	; 2
    3db2:	24 60       	ori	r18, 0x04	; 4
    3db4:	23 c0       	rjmp	.+70     	; 0x3dfc <vfprintf+0xea>
    3db6:	28 60       	ori	r18, 0x08	; 8
    3db8:	21 c0       	rjmp	.+66     	; 0x3dfc <vfprintf+0xea>
    3dba:	27 fd       	sbrc	r18, 7
    3dbc:	27 c0       	rjmp	.+78     	; 0x3e0c <vfprintf+0xfa>
    3dbe:	30 ed       	ldi	r19, 0xD0	; 208
    3dc0:	38 0f       	add	r19, r24
    3dc2:	3a 30       	cpi	r19, 0x0A	; 10
    3dc4:	78 f4       	brcc	.+30     	; 0x3de4 <vfprintf+0xd2>
    3dc6:	26 ff       	sbrs	r18, 6
    3dc8:	06 c0       	rjmp	.+12     	; 0x3dd6 <vfprintf+0xc4>
    3dca:	fa e0       	ldi	r31, 0x0A	; 10
    3dcc:	5f 9e       	mul	r5, r31
    3dce:	30 0d       	add	r19, r0
    3dd0:	11 24       	eor	r1, r1
    3dd2:	53 2e       	mov	r5, r19
    3dd4:	13 c0       	rjmp	.+38     	; 0x3dfc <vfprintf+0xea>
    3dd6:	8a e0       	ldi	r24, 0x0A	; 10
    3dd8:	38 9e       	mul	r3, r24
    3dda:	30 0d       	add	r19, r0
    3ddc:	11 24       	eor	r1, r1
    3dde:	33 2e       	mov	r3, r19
    3de0:	20 62       	ori	r18, 0x20	; 32
    3de2:	0c c0       	rjmp	.+24     	; 0x3dfc <vfprintf+0xea>
    3de4:	8e 32       	cpi	r24, 0x2E	; 46
    3de6:	21 f4       	brne	.+8      	; 0x3df0 <vfprintf+0xde>
    3de8:	26 fd       	sbrc	r18, 6
    3dea:	5f c1       	rjmp	.+702    	; 0x40aa <vfprintf+0x398>
    3dec:	20 64       	ori	r18, 0x40	; 64
    3dee:	06 c0       	rjmp	.+12     	; 0x3dfc <vfprintf+0xea>
    3df0:	8c 36       	cpi	r24, 0x6C	; 108
    3df2:	11 f4       	brne	.+4      	; 0x3df8 <vfprintf+0xe6>
    3df4:	20 68       	ori	r18, 0x80	; 128
    3df6:	02 c0       	rjmp	.+4      	; 0x3dfc <vfprintf+0xea>
    3df8:	88 36       	cpi	r24, 0x68	; 104
    3dfa:	41 f4       	brne	.+16     	; 0x3e0c <vfprintf+0xfa>
    3dfc:	f6 01       	movw	r30, r12
    3dfe:	93 fd       	sbrc	r25, 3
    3e00:	85 91       	lpm	r24, Z+
    3e02:	93 ff       	sbrs	r25, 3
    3e04:	81 91       	ld	r24, Z+
    3e06:	6f 01       	movw	r12, r30
    3e08:	81 11       	cpse	r24, r1
    3e0a:	c1 cf       	rjmp	.-126    	; 0x3d8e <vfprintf+0x7c>
    3e0c:	98 2f       	mov	r25, r24
    3e0e:	9f 7d       	andi	r25, 0xDF	; 223
    3e10:	95 54       	subi	r25, 0x45	; 69
    3e12:	93 30       	cpi	r25, 0x03	; 3
    3e14:	28 f4       	brcc	.+10     	; 0x3e20 <vfprintf+0x10e>
    3e16:	0c 5f       	subi	r16, 0xFC	; 252
    3e18:	1f 4f       	sbci	r17, 0xFF	; 255
    3e1a:	ff e3       	ldi	r31, 0x3F	; 63
    3e1c:	f9 83       	std	Y+1, r31	; 0x01
    3e1e:	0d c0       	rjmp	.+26     	; 0x3e3a <vfprintf+0x128>
    3e20:	83 36       	cpi	r24, 0x63	; 99
    3e22:	31 f0       	breq	.+12     	; 0x3e30 <vfprintf+0x11e>
    3e24:	83 37       	cpi	r24, 0x73	; 115
    3e26:	71 f0       	breq	.+28     	; 0x3e44 <vfprintf+0x132>
    3e28:	83 35       	cpi	r24, 0x53	; 83
    3e2a:	09 f0       	breq	.+2      	; 0x3e2e <vfprintf+0x11c>
    3e2c:	57 c0       	rjmp	.+174    	; 0x3edc <vfprintf+0x1ca>
    3e2e:	21 c0       	rjmp	.+66     	; 0x3e72 <vfprintf+0x160>
    3e30:	f8 01       	movw	r30, r16
    3e32:	80 81       	ld	r24, Z
    3e34:	89 83       	std	Y+1, r24	; 0x01
    3e36:	0e 5f       	subi	r16, 0xFE	; 254
    3e38:	1f 4f       	sbci	r17, 0xFF	; 255
    3e3a:	44 24       	eor	r4, r4
    3e3c:	43 94       	inc	r4
    3e3e:	51 2c       	mov	r5, r1
    3e40:	54 01       	movw	r10, r8
    3e42:	14 c0       	rjmp	.+40     	; 0x3e6c <vfprintf+0x15a>
    3e44:	38 01       	movw	r6, r16
    3e46:	f2 e0       	ldi	r31, 0x02	; 2
    3e48:	6f 0e       	add	r6, r31
    3e4a:	71 1c       	adc	r7, r1
    3e4c:	f8 01       	movw	r30, r16
    3e4e:	a0 80       	ld	r10, Z
    3e50:	b1 80       	ldd	r11, Z+1	; 0x01
    3e52:	26 ff       	sbrs	r18, 6
    3e54:	03 c0       	rjmp	.+6      	; 0x3e5c <vfprintf+0x14a>
    3e56:	65 2d       	mov	r22, r5
    3e58:	70 e0       	ldi	r23, 0x00	; 0
    3e5a:	02 c0       	rjmp	.+4      	; 0x3e60 <vfprintf+0x14e>
    3e5c:	6f ef       	ldi	r22, 0xFF	; 255
    3e5e:	7f ef       	ldi	r23, 0xFF	; 255
    3e60:	c5 01       	movw	r24, r10
    3e62:	2c 87       	std	Y+12, r18	; 0x0c
    3e64:	49 d1       	rcall	.+658    	; 0x40f8 <strnlen>
    3e66:	2c 01       	movw	r4, r24
    3e68:	83 01       	movw	r16, r6
    3e6a:	2c 85       	ldd	r18, Y+12	; 0x0c
    3e6c:	2f 77       	andi	r18, 0x7F	; 127
    3e6e:	22 2e       	mov	r2, r18
    3e70:	16 c0       	rjmp	.+44     	; 0x3e9e <vfprintf+0x18c>
    3e72:	38 01       	movw	r6, r16
    3e74:	f2 e0       	ldi	r31, 0x02	; 2
    3e76:	6f 0e       	add	r6, r31
    3e78:	71 1c       	adc	r7, r1
    3e7a:	f8 01       	movw	r30, r16
    3e7c:	a0 80       	ld	r10, Z
    3e7e:	b1 80       	ldd	r11, Z+1	; 0x01
    3e80:	26 ff       	sbrs	r18, 6
    3e82:	03 c0       	rjmp	.+6      	; 0x3e8a <vfprintf+0x178>
    3e84:	65 2d       	mov	r22, r5
    3e86:	70 e0       	ldi	r23, 0x00	; 0
    3e88:	02 c0       	rjmp	.+4      	; 0x3e8e <vfprintf+0x17c>
    3e8a:	6f ef       	ldi	r22, 0xFF	; 255
    3e8c:	7f ef       	ldi	r23, 0xFF	; 255
    3e8e:	c5 01       	movw	r24, r10
    3e90:	2c 87       	std	Y+12, r18	; 0x0c
    3e92:	27 d1       	rcall	.+590    	; 0x40e2 <strnlen_P>
    3e94:	2c 01       	movw	r4, r24
    3e96:	2c 85       	ldd	r18, Y+12	; 0x0c
    3e98:	20 68       	ori	r18, 0x80	; 128
    3e9a:	22 2e       	mov	r2, r18
    3e9c:	83 01       	movw	r16, r6
    3e9e:	23 fc       	sbrc	r2, 3
    3ea0:	19 c0       	rjmp	.+50     	; 0x3ed4 <vfprintf+0x1c2>
    3ea2:	83 2d       	mov	r24, r3
    3ea4:	90 e0       	ldi	r25, 0x00	; 0
    3ea6:	48 16       	cp	r4, r24
    3ea8:	59 06       	cpc	r5, r25
    3eaa:	a0 f4       	brcc	.+40     	; 0x3ed4 <vfprintf+0x1c2>
    3eac:	b7 01       	movw	r22, r14
    3eae:	80 e2       	ldi	r24, 0x20	; 32
    3eb0:	90 e0       	ldi	r25, 0x00	; 0
    3eb2:	2d d1       	rcall	.+602    	; 0x410e <fputc>
    3eb4:	3a 94       	dec	r3
    3eb6:	f5 cf       	rjmp	.-22     	; 0x3ea2 <vfprintf+0x190>
    3eb8:	f5 01       	movw	r30, r10
    3eba:	27 fc       	sbrc	r2, 7
    3ebc:	85 91       	lpm	r24, Z+
    3ebe:	27 fe       	sbrs	r2, 7
    3ec0:	81 91       	ld	r24, Z+
    3ec2:	5f 01       	movw	r10, r30
    3ec4:	b7 01       	movw	r22, r14
    3ec6:	90 e0       	ldi	r25, 0x00	; 0
    3ec8:	22 d1       	rcall	.+580    	; 0x410e <fputc>
    3eca:	31 10       	cpse	r3, r1
    3ecc:	3a 94       	dec	r3
    3ece:	f1 e0       	ldi	r31, 0x01	; 1
    3ed0:	4f 1a       	sub	r4, r31
    3ed2:	51 08       	sbc	r5, r1
    3ed4:	41 14       	cp	r4, r1
    3ed6:	51 04       	cpc	r5, r1
    3ed8:	79 f7       	brne	.-34     	; 0x3eb8 <vfprintf+0x1a6>
    3eda:	de c0       	rjmp	.+444    	; 0x4098 <vfprintf+0x386>
    3edc:	84 36       	cpi	r24, 0x64	; 100
    3ede:	11 f0       	breq	.+4      	; 0x3ee4 <vfprintf+0x1d2>
    3ee0:	89 36       	cpi	r24, 0x69	; 105
    3ee2:	31 f5       	brne	.+76     	; 0x3f30 <vfprintf+0x21e>
    3ee4:	f8 01       	movw	r30, r16
    3ee6:	27 ff       	sbrs	r18, 7
    3ee8:	07 c0       	rjmp	.+14     	; 0x3ef8 <vfprintf+0x1e6>
    3eea:	60 81       	ld	r22, Z
    3eec:	71 81       	ldd	r23, Z+1	; 0x01
    3eee:	82 81       	ldd	r24, Z+2	; 0x02
    3ef0:	93 81       	ldd	r25, Z+3	; 0x03
    3ef2:	0c 5f       	subi	r16, 0xFC	; 252
    3ef4:	1f 4f       	sbci	r17, 0xFF	; 255
    3ef6:	08 c0       	rjmp	.+16     	; 0x3f08 <vfprintf+0x1f6>
    3ef8:	60 81       	ld	r22, Z
    3efa:	71 81       	ldd	r23, Z+1	; 0x01
    3efc:	07 2e       	mov	r0, r23
    3efe:	00 0c       	add	r0, r0
    3f00:	88 0b       	sbc	r24, r24
    3f02:	99 0b       	sbc	r25, r25
    3f04:	0e 5f       	subi	r16, 0xFE	; 254
    3f06:	1f 4f       	sbci	r17, 0xFF	; 255
    3f08:	2f 76       	andi	r18, 0x6F	; 111
    3f0a:	72 2e       	mov	r7, r18
    3f0c:	97 ff       	sbrs	r25, 7
    3f0e:	09 c0       	rjmp	.+18     	; 0x3f22 <vfprintf+0x210>
    3f10:	90 95       	com	r25
    3f12:	80 95       	com	r24
    3f14:	70 95       	com	r23
    3f16:	61 95       	neg	r22
    3f18:	7f 4f       	sbci	r23, 0xFF	; 255
    3f1a:	8f 4f       	sbci	r24, 0xFF	; 255
    3f1c:	9f 4f       	sbci	r25, 0xFF	; 255
    3f1e:	20 68       	ori	r18, 0x80	; 128
    3f20:	72 2e       	mov	r7, r18
    3f22:	2a e0       	ldi	r18, 0x0A	; 10
    3f24:	30 e0       	ldi	r19, 0x00	; 0
    3f26:	a4 01       	movw	r20, r8
    3f28:	2a d1       	rcall	.+596    	; 0x417e <__ultoa_invert>
    3f2a:	a8 2e       	mov	r10, r24
    3f2c:	a8 18       	sub	r10, r8
    3f2e:	43 c0       	rjmp	.+134    	; 0x3fb6 <vfprintf+0x2a4>
    3f30:	85 37       	cpi	r24, 0x75	; 117
    3f32:	29 f4       	brne	.+10     	; 0x3f3e <vfprintf+0x22c>
    3f34:	2f 7e       	andi	r18, 0xEF	; 239
    3f36:	b2 2e       	mov	r11, r18
    3f38:	2a e0       	ldi	r18, 0x0A	; 10
    3f3a:	30 e0       	ldi	r19, 0x00	; 0
    3f3c:	25 c0       	rjmp	.+74     	; 0x3f88 <vfprintf+0x276>
    3f3e:	f2 2f       	mov	r31, r18
    3f40:	f9 7f       	andi	r31, 0xF9	; 249
    3f42:	bf 2e       	mov	r11, r31
    3f44:	8f 36       	cpi	r24, 0x6F	; 111
    3f46:	c1 f0       	breq	.+48     	; 0x3f78 <vfprintf+0x266>
    3f48:	18 f4       	brcc	.+6      	; 0x3f50 <vfprintf+0x23e>
    3f4a:	88 35       	cpi	r24, 0x58	; 88
    3f4c:	79 f0       	breq	.+30     	; 0x3f6c <vfprintf+0x25a>
    3f4e:	ad c0       	rjmp	.+346    	; 0x40aa <vfprintf+0x398>
    3f50:	80 37       	cpi	r24, 0x70	; 112
    3f52:	19 f0       	breq	.+6      	; 0x3f5a <vfprintf+0x248>
    3f54:	88 37       	cpi	r24, 0x78	; 120
    3f56:	21 f0       	breq	.+8      	; 0x3f60 <vfprintf+0x24e>
    3f58:	a8 c0       	rjmp	.+336    	; 0x40aa <vfprintf+0x398>
    3f5a:	2f 2f       	mov	r18, r31
    3f5c:	20 61       	ori	r18, 0x10	; 16
    3f5e:	b2 2e       	mov	r11, r18
    3f60:	b4 fe       	sbrs	r11, 4
    3f62:	0d c0       	rjmp	.+26     	; 0x3f7e <vfprintf+0x26c>
    3f64:	8b 2d       	mov	r24, r11
    3f66:	84 60       	ori	r24, 0x04	; 4
    3f68:	b8 2e       	mov	r11, r24
    3f6a:	09 c0       	rjmp	.+18     	; 0x3f7e <vfprintf+0x26c>
    3f6c:	24 ff       	sbrs	r18, 4
    3f6e:	0a c0       	rjmp	.+20     	; 0x3f84 <vfprintf+0x272>
    3f70:	9f 2f       	mov	r25, r31
    3f72:	96 60       	ori	r25, 0x06	; 6
    3f74:	b9 2e       	mov	r11, r25
    3f76:	06 c0       	rjmp	.+12     	; 0x3f84 <vfprintf+0x272>
    3f78:	28 e0       	ldi	r18, 0x08	; 8
    3f7a:	30 e0       	ldi	r19, 0x00	; 0
    3f7c:	05 c0       	rjmp	.+10     	; 0x3f88 <vfprintf+0x276>
    3f7e:	20 e1       	ldi	r18, 0x10	; 16
    3f80:	30 e0       	ldi	r19, 0x00	; 0
    3f82:	02 c0       	rjmp	.+4      	; 0x3f88 <vfprintf+0x276>
    3f84:	20 e1       	ldi	r18, 0x10	; 16
    3f86:	32 e0       	ldi	r19, 0x02	; 2
    3f88:	f8 01       	movw	r30, r16
    3f8a:	b7 fe       	sbrs	r11, 7
    3f8c:	07 c0       	rjmp	.+14     	; 0x3f9c <vfprintf+0x28a>
    3f8e:	60 81       	ld	r22, Z
    3f90:	71 81       	ldd	r23, Z+1	; 0x01
    3f92:	82 81       	ldd	r24, Z+2	; 0x02
    3f94:	93 81       	ldd	r25, Z+3	; 0x03
    3f96:	0c 5f       	subi	r16, 0xFC	; 252
    3f98:	1f 4f       	sbci	r17, 0xFF	; 255
    3f9a:	06 c0       	rjmp	.+12     	; 0x3fa8 <vfprintf+0x296>
    3f9c:	60 81       	ld	r22, Z
    3f9e:	71 81       	ldd	r23, Z+1	; 0x01
    3fa0:	80 e0       	ldi	r24, 0x00	; 0
    3fa2:	90 e0       	ldi	r25, 0x00	; 0
    3fa4:	0e 5f       	subi	r16, 0xFE	; 254
    3fa6:	1f 4f       	sbci	r17, 0xFF	; 255
    3fa8:	a4 01       	movw	r20, r8
    3faa:	e9 d0       	rcall	.+466    	; 0x417e <__ultoa_invert>
    3fac:	a8 2e       	mov	r10, r24
    3fae:	a8 18       	sub	r10, r8
    3fb0:	fb 2d       	mov	r31, r11
    3fb2:	ff 77       	andi	r31, 0x7F	; 127
    3fb4:	7f 2e       	mov	r7, r31
    3fb6:	76 fe       	sbrs	r7, 6
    3fb8:	0b c0       	rjmp	.+22     	; 0x3fd0 <vfprintf+0x2be>
    3fba:	37 2d       	mov	r19, r7
    3fbc:	3e 7f       	andi	r19, 0xFE	; 254
    3fbe:	a5 14       	cp	r10, r5
    3fc0:	50 f4       	brcc	.+20     	; 0x3fd6 <vfprintf+0x2c4>
    3fc2:	74 fe       	sbrs	r7, 4
    3fc4:	0a c0       	rjmp	.+20     	; 0x3fda <vfprintf+0x2c8>
    3fc6:	72 fc       	sbrc	r7, 2
    3fc8:	08 c0       	rjmp	.+16     	; 0x3fda <vfprintf+0x2c8>
    3fca:	37 2d       	mov	r19, r7
    3fcc:	3e 7e       	andi	r19, 0xEE	; 238
    3fce:	05 c0       	rjmp	.+10     	; 0x3fda <vfprintf+0x2c8>
    3fd0:	ba 2c       	mov	r11, r10
    3fd2:	37 2d       	mov	r19, r7
    3fd4:	03 c0       	rjmp	.+6      	; 0x3fdc <vfprintf+0x2ca>
    3fd6:	ba 2c       	mov	r11, r10
    3fd8:	01 c0       	rjmp	.+2      	; 0x3fdc <vfprintf+0x2ca>
    3fda:	b5 2c       	mov	r11, r5
    3fdc:	34 ff       	sbrs	r19, 4
    3fde:	0d c0       	rjmp	.+26     	; 0x3ffa <vfprintf+0x2e8>
    3fe0:	fe 01       	movw	r30, r28
    3fe2:	ea 0d       	add	r30, r10
    3fe4:	f1 1d       	adc	r31, r1
    3fe6:	80 81       	ld	r24, Z
    3fe8:	80 33       	cpi	r24, 0x30	; 48
    3fea:	11 f4       	brne	.+4      	; 0x3ff0 <vfprintf+0x2de>
    3fec:	39 7e       	andi	r19, 0xE9	; 233
    3fee:	09 c0       	rjmp	.+18     	; 0x4002 <vfprintf+0x2f0>
    3ff0:	32 ff       	sbrs	r19, 2
    3ff2:	06 c0       	rjmp	.+12     	; 0x4000 <vfprintf+0x2ee>
    3ff4:	b3 94       	inc	r11
    3ff6:	b3 94       	inc	r11
    3ff8:	04 c0       	rjmp	.+8      	; 0x4002 <vfprintf+0x2f0>
    3ffa:	83 2f       	mov	r24, r19
    3ffc:	86 78       	andi	r24, 0x86	; 134
    3ffe:	09 f0       	breq	.+2      	; 0x4002 <vfprintf+0x2f0>
    4000:	b3 94       	inc	r11
    4002:	33 fd       	sbrc	r19, 3
    4004:	12 c0       	rjmp	.+36     	; 0x402a <vfprintf+0x318>
    4006:	30 ff       	sbrs	r19, 0
    4008:	06 c0       	rjmp	.+12     	; 0x4016 <vfprintf+0x304>
    400a:	5a 2c       	mov	r5, r10
    400c:	b3 14       	cp	r11, r3
    400e:	18 f4       	brcc	.+6      	; 0x4016 <vfprintf+0x304>
    4010:	53 0c       	add	r5, r3
    4012:	5b 18       	sub	r5, r11
    4014:	b3 2c       	mov	r11, r3
    4016:	b3 14       	cp	r11, r3
    4018:	60 f4       	brcc	.+24     	; 0x4032 <vfprintf+0x320>
    401a:	b7 01       	movw	r22, r14
    401c:	80 e2       	ldi	r24, 0x20	; 32
    401e:	90 e0       	ldi	r25, 0x00	; 0
    4020:	3c 87       	std	Y+12, r19	; 0x0c
    4022:	75 d0       	rcall	.+234    	; 0x410e <fputc>
    4024:	b3 94       	inc	r11
    4026:	3c 85       	ldd	r19, Y+12	; 0x0c
    4028:	f6 cf       	rjmp	.-20     	; 0x4016 <vfprintf+0x304>
    402a:	b3 14       	cp	r11, r3
    402c:	10 f4       	brcc	.+4      	; 0x4032 <vfprintf+0x320>
    402e:	3b 18       	sub	r3, r11
    4030:	01 c0       	rjmp	.+2      	; 0x4034 <vfprintf+0x322>
    4032:	31 2c       	mov	r3, r1
    4034:	34 ff       	sbrs	r19, 4
    4036:	11 c0       	rjmp	.+34     	; 0x405a <vfprintf+0x348>
    4038:	b7 01       	movw	r22, r14
    403a:	80 e3       	ldi	r24, 0x30	; 48
    403c:	90 e0       	ldi	r25, 0x00	; 0
    403e:	3c 87       	std	Y+12, r19	; 0x0c
    4040:	66 d0       	rcall	.+204    	; 0x410e <fputc>
    4042:	3c 85       	ldd	r19, Y+12	; 0x0c
    4044:	32 ff       	sbrs	r19, 2
    4046:	16 c0       	rjmp	.+44     	; 0x4074 <vfprintf+0x362>
    4048:	31 fd       	sbrc	r19, 1
    404a:	03 c0       	rjmp	.+6      	; 0x4052 <vfprintf+0x340>
    404c:	88 e7       	ldi	r24, 0x78	; 120
    404e:	90 e0       	ldi	r25, 0x00	; 0
    4050:	02 c0       	rjmp	.+4      	; 0x4056 <vfprintf+0x344>
    4052:	88 e5       	ldi	r24, 0x58	; 88
    4054:	90 e0       	ldi	r25, 0x00	; 0
    4056:	b7 01       	movw	r22, r14
    4058:	0c c0       	rjmp	.+24     	; 0x4072 <vfprintf+0x360>
    405a:	83 2f       	mov	r24, r19
    405c:	86 78       	andi	r24, 0x86	; 134
    405e:	51 f0       	breq	.+20     	; 0x4074 <vfprintf+0x362>
    4060:	31 ff       	sbrs	r19, 1
    4062:	02 c0       	rjmp	.+4      	; 0x4068 <vfprintf+0x356>
    4064:	8b e2       	ldi	r24, 0x2B	; 43
    4066:	01 c0       	rjmp	.+2      	; 0x406a <vfprintf+0x358>
    4068:	80 e2       	ldi	r24, 0x20	; 32
    406a:	37 fd       	sbrc	r19, 7
    406c:	8d e2       	ldi	r24, 0x2D	; 45
    406e:	b7 01       	movw	r22, r14
    4070:	90 e0       	ldi	r25, 0x00	; 0
    4072:	4d d0       	rcall	.+154    	; 0x410e <fputc>
    4074:	a5 14       	cp	r10, r5
    4076:	30 f4       	brcc	.+12     	; 0x4084 <vfprintf+0x372>
    4078:	b7 01       	movw	r22, r14
    407a:	80 e3       	ldi	r24, 0x30	; 48
    407c:	90 e0       	ldi	r25, 0x00	; 0
    407e:	47 d0       	rcall	.+142    	; 0x410e <fputc>
    4080:	5a 94       	dec	r5
    4082:	f8 cf       	rjmp	.-16     	; 0x4074 <vfprintf+0x362>
    4084:	aa 94       	dec	r10
    4086:	f4 01       	movw	r30, r8
    4088:	ea 0d       	add	r30, r10
    408a:	f1 1d       	adc	r31, r1
    408c:	80 81       	ld	r24, Z
    408e:	b7 01       	movw	r22, r14
    4090:	90 e0       	ldi	r25, 0x00	; 0
    4092:	3d d0       	rcall	.+122    	; 0x410e <fputc>
    4094:	a1 10       	cpse	r10, r1
    4096:	f6 cf       	rjmp	.-20     	; 0x4084 <vfprintf+0x372>
    4098:	33 20       	and	r3, r3
    409a:	09 f4       	brne	.+2      	; 0x409e <vfprintf+0x38c>
    409c:	5d ce       	rjmp	.-838    	; 0x3d58 <vfprintf+0x46>
    409e:	b7 01       	movw	r22, r14
    40a0:	80 e2       	ldi	r24, 0x20	; 32
    40a2:	90 e0       	ldi	r25, 0x00	; 0
    40a4:	34 d0       	rcall	.+104    	; 0x410e <fputc>
    40a6:	3a 94       	dec	r3
    40a8:	f7 cf       	rjmp	.-18     	; 0x4098 <vfprintf+0x386>
    40aa:	f7 01       	movw	r30, r14
    40ac:	86 81       	ldd	r24, Z+6	; 0x06
    40ae:	97 81       	ldd	r25, Z+7	; 0x07
    40b0:	02 c0       	rjmp	.+4      	; 0x40b6 <vfprintf+0x3a4>
    40b2:	8f ef       	ldi	r24, 0xFF	; 255
    40b4:	9f ef       	ldi	r25, 0xFF	; 255
    40b6:	2c 96       	adiw	r28, 0x0c	; 12
    40b8:	cd bf       	out	0x3d, r28	; 61
    40ba:	de bf       	out	0x3e, r29	; 62
    40bc:	df 91       	pop	r29
    40be:	cf 91       	pop	r28
    40c0:	1f 91       	pop	r17
    40c2:	0f 91       	pop	r16
    40c4:	ff 90       	pop	r15
    40c6:	ef 90       	pop	r14
    40c8:	df 90       	pop	r13
    40ca:	cf 90       	pop	r12
    40cc:	bf 90       	pop	r11
    40ce:	af 90       	pop	r10
    40d0:	9f 90       	pop	r9
    40d2:	8f 90       	pop	r8
    40d4:	7f 90       	pop	r7
    40d6:	6f 90       	pop	r6
    40d8:	5f 90       	pop	r5
    40da:	4f 90       	pop	r4
    40dc:	3f 90       	pop	r3
    40de:	2f 90       	pop	r2
    40e0:	08 95       	ret

000040e2 <strnlen_P>:
    40e2:	fc 01       	movw	r30, r24
    40e4:	05 90       	lpm	r0, Z+
    40e6:	61 50       	subi	r22, 0x01	; 1
    40e8:	70 40       	sbci	r23, 0x00	; 0
    40ea:	01 10       	cpse	r0, r1
    40ec:	d8 f7       	brcc	.-10     	; 0x40e4 <strnlen_P+0x2>
    40ee:	80 95       	com	r24
    40f0:	90 95       	com	r25
    40f2:	8e 0f       	add	r24, r30
    40f4:	9f 1f       	adc	r25, r31
    40f6:	08 95       	ret

000040f8 <strnlen>:
    40f8:	fc 01       	movw	r30, r24
    40fa:	61 50       	subi	r22, 0x01	; 1
    40fc:	70 40       	sbci	r23, 0x00	; 0
    40fe:	01 90       	ld	r0, Z+
    4100:	01 10       	cpse	r0, r1
    4102:	d8 f7       	brcc	.-10     	; 0x40fa <strnlen+0x2>
    4104:	80 95       	com	r24
    4106:	90 95       	com	r25
    4108:	8e 0f       	add	r24, r30
    410a:	9f 1f       	adc	r25, r31
    410c:	08 95       	ret

0000410e <fputc>:
    410e:	0f 93       	push	r16
    4110:	1f 93       	push	r17
    4112:	cf 93       	push	r28
    4114:	df 93       	push	r29
    4116:	fb 01       	movw	r30, r22
    4118:	23 81       	ldd	r18, Z+3	; 0x03
    411a:	21 fd       	sbrc	r18, 1
    411c:	03 c0       	rjmp	.+6      	; 0x4124 <fputc+0x16>
    411e:	8f ef       	ldi	r24, 0xFF	; 255
    4120:	9f ef       	ldi	r25, 0xFF	; 255
    4122:	28 c0       	rjmp	.+80     	; 0x4174 <fputc+0x66>
    4124:	22 ff       	sbrs	r18, 2
    4126:	16 c0       	rjmp	.+44     	; 0x4154 <fputc+0x46>
    4128:	46 81       	ldd	r20, Z+6	; 0x06
    412a:	57 81       	ldd	r21, Z+7	; 0x07
    412c:	24 81       	ldd	r18, Z+4	; 0x04
    412e:	35 81       	ldd	r19, Z+5	; 0x05
    4130:	42 17       	cp	r20, r18
    4132:	53 07       	cpc	r21, r19
    4134:	44 f4       	brge	.+16     	; 0x4146 <fputc+0x38>
    4136:	a0 81       	ld	r26, Z
    4138:	b1 81       	ldd	r27, Z+1	; 0x01
    413a:	9d 01       	movw	r18, r26
    413c:	2f 5f       	subi	r18, 0xFF	; 255
    413e:	3f 4f       	sbci	r19, 0xFF	; 255
    4140:	20 83       	st	Z, r18
    4142:	31 83       	std	Z+1, r19	; 0x01
    4144:	8c 93       	st	X, r24
    4146:	26 81       	ldd	r18, Z+6	; 0x06
    4148:	37 81       	ldd	r19, Z+7	; 0x07
    414a:	2f 5f       	subi	r18, 0xFF	; 255
    414c:	3f 4f       	sbci	r19, 0xFF	; 255
    414e:	26 83       	std	Z+6, r18	; 0x06
    4150:	37 83       	std	Z+7, r19	; 0x07
    4152:	10 c0       	rjmp	.+32     	; 0x4174 <fputc+0x66>
    4154:	eb 01       	movw	r28, r22
    4156:	09 2f       	mov	r16, r25
    4158:	18 2f       	mov	r17, r24
    415a:	00 84       	ldd	r0, Z+8	; 0x08
    415c:	f1 85       	ldd	r31, Z+9	; 0x09
    415e:	e0 2d       	mov	r30, r0
    4160:	19 95       	eicall
    4162:	89 2b       	or	r24, r25
    4164:	e1 f6       	brne	.-72     	; 0x411e <fputc+0x10>
    4166:	8e 81       	ldd	r24, Y+6	; 0x06
    4168:	9f 81       	ldd	r25, Y+7	; 0x07
    416a:	01 96       	adiw	r24, 0x01	; 1
    416c:	8e 83       	std	Y+6, r24	; 0x06
    416e:	9f 83       	std	Y+7, r25	; 0x07
    4170:	81 2f       	mov	r24, r17
    4172:	90 2f       	mov	r25, r16
    4174:	df 91       	pop	r29
    4176:	cf 91       	pop	r28
    4178:	1f 91       	pop	r17
    417a:	0f 91       	pop	r16
    417c:	08 95       	ret

0000417e <__ultoa_invert>:
    417e:	fa 01       	movw	r30, r20
    4180:	aa 27       	eor	r26, r26
    4182:	28 30       	cpi	r18, 0x08	; 8
    4184:	51 f1       	breq	.+84     	; 0x41da <__ultoa_invert+0x5c>
    4186:	20 31       	cpi	r18, 0x10	; 16
    4188:	81 f1       	breq	.+96     	; 0x41ea <__ultoa_invert+0x6c>
    418a:	e8 94       	clt
    418c:	6f 93       	push	r22
    418e:	6e 7f       	andi	r22, 0xFE	; 254
    4190:	6e 5f       	subi	r22, 0xFE	; 254
    4192:	7f 4f       	sbci	r23, 0xFF	; 255
    4194:	8f 4f       	sbci	r24, 0xFF	; 255
    4196:	9f 4f       	sbci	r25, 0xFF	; 255
    4198:	af 4f       	sbci	r26, 0xFF	; 255
    419a:	b1 e0       	ldi	r27, 0x01	; 1
    419c:	3e d0       	rcall	.+124    	; 0x421a <__ultoa_invert+0x9c>
    419e:	b4 e0       	ldi	r27, 0x04	; 4
    41a0:	3c d0       	rcall	.+120    	; 0x421a <__ultoa_invert+0x9c>
    41a2:	67 0f       	add	r22, r23
    41a4:	78 1f       	adc	r23, r24
    41a6:	89 1f       	adc	r24, r25
    41a8:	9a 1f       	adc	r25, r26
    41aa:	a1 1d       	adc	r26, r1
    41ac:	68 0f       	add	r22, r24
    41ae:	79 1f       	adc	r23, r25
    41b0:	8a 1f       	adc	r24, r26
    41b2:	91 1d       	adc	r25, r1
    41b4:	a1 1d       	adc	r26, r1
    41b6:	6a 0f       	add	r22, r26
    41b8:	71 1d       	adc	r23, r1
    41ba:	81 1d       	adc	r24, r1
    41bc:	91 1d       	adc	r25, r1
    41be:	a1 1d       	adc	r26, r1
    41c0:	20 d0       	rcall	.+64     	; 0x4202 <__ultoa_invert+0x84>
    41c2:	09 f4       	brne	.+2      	; 0x41c6 <__ultoa_invert+0x48>
    41c4:	68 94       	set
    41c6:	3f 91       	pop	r19
    41c8:	2a e0       	ldi	r18, 0x0A	; 10
    41ca:	26 9f       	mul	r18, r22
    41cc:	11 24       	eor	r1, r1
    41ce:	30 19       	sub	r19, r0
    41d0:	30 5d       	subi	r19, 0xD0	; 208
    41d2:	31 93       	st	Z+, r19
    41d4:	de f6       	brtc	.-74     	; 0x418c <__ultoa_invert+0xe>
    41d6:	cf 01       	movw	r24, r30
    41d8:	08 95       	ret
    41da:	46 2f       	mov	r20, r22
    41dc:	47 70       	andi	r20, 0x07	; 7
    41de:	40 5d       	subi	r20, 0xD0	; 208
    41e0:	41 93       	st	Z+, r20
    41e2:	b3 e0       	ldi	r27, 0x03	; 3
    41e4:	0f d0       	rcall	.+30     	; 0x4204 <__ultoa_invert+0x86>
    41e6:	c9 f7       	brne	.-14     	; 0x41da <__ultoa_invert+0x5c>
    41e8:	f6 cf       	rjmp	.-20     	; 0x41d6 <__ultoa_invert+0x58>
    41ea:	46 2f       	mov	r20, r22
    41ec:	4f 70       	andi	r20, 0x0F	; 15
    41ee:	40 5d       	subi	r20, 0xD0	; 208
    41f0:	4a 33       	cpi	r20, 0x3A	; 58
    41f2:	18 f0       	brcs	.+6      	; 0x41fa <__ultoa_invert+0x7c>
    41f4:	49 5d       	subi	r20, 0xD9	; 217
    41f6:	31 fd       	sbrc	r19, 1
    41f8:	40 52       	subi	r20, 0x20	; 32
    41fa:	41 93       	st	Z+, r20
    41fc:	02 d0       	rcall	.+4      	; 0x4202 <__ultoa_invert+0x84>
    41fe:	a9 f7       	brne	.-22     	; 0x41ea <__ultoa_invert+0x6c>
    4200:	ea cf       	rjmp	.-44     	; 0x41d6 <__ultoa_invert+0x58>
    4202:	b4 e0       	ldi	r27, 0x04	; 4
    4204:	a6 95       	lsr	r26
    4206:	97 95       	ror	r25
    4208:	87 95       	ror	r24
    420a:	77 95       	ror	r23
    420c:	67 95       	ror	r22
    420e:	ba 95       	dec	r27
    4210:	c9 f7       	brne	.-14     	; 0x4204 <__ultoa_invert+0x86>
    4212:	00 97       	sbiw	r24, 0x00	; 0
    4214:	61 05       	cpc	r22, r1
    4216:	71 05       	cpc	r23, r1
    4218:	08 95       	ret
    421a:	9b 01       	movw	r18, r22
    421c:	ac 01       	movw	r20, r24
    421e:	0a 2e       	mov	r0, r26
    4220:	06 94       	lsr	r0
    4222:	57 95       	ror	r21
    4224:	47 95       	ror	r20
    4226:	37 95       	ror	r19
    4228:	27 95       	ror	r18
    422a:	ba 95       	dec	r27
    422c:	c9 f7       	brne	.-14     	; 0x4220 <__ultoa_invert+0xa2>
    422e:	62 0f       	add	r22, r18
    4230:	73 1f       	adc	r23, r19
    4232:	84 1f       	adc	r24, r20
    4234:	95 1f       	adc	r25, r21
    4236:	a0 1d       	adc	r26, r0
    4238:	08 95       	ret

0000423a <_exit>:
    423a:	f8 94       	cli

0000423c <__stop_program>:
    423c:	ff cf       	rjmp	.-2      	; 0x423c <__stop_program>
