
TugasAkhir.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004200  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000140  00802000  00004200  00004294  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000037d  00802140  00802140  000043d4  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000043d4  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000005a8  00000000  00000000  00004430  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000ee62  00000000  00000000  000049d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002b25  00000000  00000000  0001383a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000a7fd  00000000  00000000  0001635f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000126c  00000000  00000000  00020b5c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00032be9  00000000  00000000  00021dc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00006ff1  00000000  00000000  000549b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000007f8  00000000  00000000  0005b9a2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00003edf  00000000  00000000  0005c19a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	46 c2       	rjmp	.+1164   	; 0x48e <__ctors_end>
       2:	00 00       	nop
       4:	65 c2       	rjmp	.+1226   	; 0x4d0 <__bad_interrupt>
       6:	00 00       	nop
       8:	63 c2       	rjmp	.+1222   	; 0x4d0 <__bad_interrupt>
       a:	00 00       	nop
       c:	61 c2       	rjmp	.+1218   	; 0x4d0 <__bad_interrupt>
       e:	00 00       	nop
      10:	5f c2       	rjmp	.+1214   	; 0x4d0 <__bad_interrupt>
      12:	00 00       	nop
      14:	5d c2       	rjmp	.+1210   	; 0x4d0 <__bad_interrupt>
      16:	00 00       	nop
      18:	5b c2       	rjmp	.+1206   	; 0x4d0 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	59 c2       	rjmp	.+1202   	; 0x4d0 <__bad_interrupt>
      1e:	00 00       	nop
      20:	57 c2       	rjmp	.+1198   	; 0x4d0 <__bad_interrupt>
      22:	00 00       	nop
      24:	55 c2       	rjmp	.+1194   	; 0x4d0 <__bad_interrupt>
      26:	00 00       	nop
      28:	53 c2       	rjmp	.+1190   	; 0x4d0 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	51 c2       	rjmp	.+1186   	; 0x4d0 <__bad_interrupt>
      2e:	00 00       	nop
      30:	4f c2       	rjmp	.+1182   	; 0x4d0 <__bad_interrupt>
      32:	00 00       	nop
      34:	4d c2       	rjmp	.+1178   	; 0x4d0 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 77 14 	jmp	0x28ee	; 0x28ee <__vector_14>
      3c:	49 c2       	rjmp	.+1170   	; 0x4d0 <__bad_interrupt>
      3e:	00 00       	nop
      40:	47 c2       	rjmp	.+1166   	; 0x4d0 <__bad_interrupt>
      42:	00 00       	nop
      44:	45 c2       	rjmp	.+1162   	; 0x4d0 <__bad_interrupt>
      46:	00 00       	nop
      48:	43 c2       	rjmp	.+1158   	; 0x4d0 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	41 c2       	rjmp	.+1154   	; 0x4d0 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3f c2       	rjmp	.+1150   	; 0x4d0 <__bad_interrupt>
      52:	00 00       	nop
      54:	3d c2       	rjmp	.+1146   	; 0x4d0 <__bad_interrupt>
      56:	00 00       	nop
      58:	3b c2       	rjmp	.+1142   	; 0x4d0 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	39 c2       	rjmp	.+1138   	; 0x4d0 <__bad_interrupt>
      5e:	00 00       	nop
      60:	37 c2       	rjmp	.+1134   	; 0x4d0 <__bad_interrupt>
      62:	00 00       	nop
      64:	35 c2       	rjmp	.+1130   	; 0x4d0 <__bad_interrupt>
      66:	00 00       	nop
      68:	33 c2       	rjmp	.+1126   	; 0x4d0 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	31 c2       	rjmp	.+1122   	; 0x4d0 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2f c2       	rjmp	.+1118   	; 0x4d0 <__bad_interrupt>
      72:	00 00       	nop
      74:	2d c2       	rjmp	.+1114   	; 0x4d0 <__bad_interrupt>
      76:	00 00       	nop
      78:	2b c2       	rjmp	.+1110   	; 0x4d0 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	29 c2       	rjmp	.+1106   	; 0x4d0 <__bad_interrupt>
      7e:	00 00       	nop
      80:	27 c2       	rjmp	.+1102   	; 0x4d0 <__bad_interrupt>
      82:	00 00       	nop
      84:	25 c2       	rjmp	.+1098   	; 0x4d0 <__bad_interrupt>
      86:	00 00       	nop
      88:	23 c2       	rjmp	.+1094   	; 0x4d0 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	21 c2       	rjmp	.+1090   	; 0x4d0 <__bad_interrupt>
      8e:	00 00       	nop
      90:	1f c2       	rjmp	.+1086   	; 0x4d0 <__bad_interrupt>
      92:	00 00       	nop
      94:	1d c2       	rjmp	.+1082   	; 0x4d0 <__bad_interrupt>
      96:	00 00       	nop
      98:	1b c2       	rjmp	.+1078   	; 0x4d0 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 12 0c 	jmp	0x1824	; 0x1824 <__vector_39>
      a0:	0c 94 44 0c 	jmp	0x1888	; 0x1888 <__vector_40>
      a4:	0c 94 76 0c 	jmp	0x18ec	; 0x18ec <__vector_41>
      a8:	0c 94 a8 0c 	jmp	0x1950	; 0x1950 <__vector_42>
      ac:	11 c2       	rjmp	.+1058   	; 0x4d0 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	0f c2       	rjmp	.+1054   	; 0x4d0 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	0d c2       	rjmp	.+1050   	; 0x4d0 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	0b c2       	rjmp	.+1046   	; 0x4d0 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	09 c2       	rjmp	.+1042   	; 0x4d0 <__bad_interrupt>
      be:	00 00       	nop
      c0:	07 c2       	rjmp	.+1038   	; 0x4d0 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	05 c2       	rjmp	.+1034   	; 0x4d0 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	03 c2       	rjmp	.+1030   	; 0x4d0 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	01 c2       	rjmp	.+1026   	; 0x4d0 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	ff c1       	rjmp	.+1022   	; 0x4d0 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	fd c1       	rjmp	.+1018   	; 0x4d0 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	fb c1       	rjmp	.+1014   	; 0x4d0 <__bad_interrupt>
      da:	00 00       	nop
      dc:	f9 c1       	rjmp	.+1010   	; 0x4d0 <__bad_interrupt>
      de:	00 00       	nop
      e0:	f7 c1       	rjmp	.+1006   	; 0x4d0 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	f5 c1       	rjmp	.+1002   	; 0x4d0 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	f3 c1       	rjmp	.+998    	; 0x4d0 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	f1 c1       	rjmp	.+994    	; 0x4d0 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	ef c1       	rjmp	.+990    	; 0x4d0 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	ed c1       	rjmp	.+986    	; 0x4d0 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	eb c1       	rjmp	.+982    	; 0x4d0 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	e9 c1       	rjmp	.+978    	; 0x4d0 <__bad_interrupt>
      fe:	00 00       	nop
     100:	e7 c1       	rjmp	.+974    	; 0x4d0 <__bad_interrupt>
     102:	00 00       	nop
     104:	e5 c1       	rjmp	.+970    	; 0x4d0 <__bad_interrupt>
     106:	00 00       	nop
     108:	e3 c1       	rjmp	.+966    	; 0x4d0 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	e1 c1       	rjmp	.+962    	; 0x4d0 <__bad_interrupt>
     10e:	00 00       	nop
     110:	df c1       	rjmp	.+958    	; 0x4d0 <__bad_interrupt>
     112:	00 00       	nop
     114:	dd c1       	rjmp	.+954    	; 0x4d0 <__bad_interrupt>
     116:	00 00       	nop
     118:	db c1       	rjmp	.+950    	; 0x4d0 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	0c 94 4a 0b 	jmp	0x1694	; 0x1694 <__vector_71>
     120:	0c 94 7c 0b 	jmp	0x16f8	; 0x16f8 <__vector_72>
     124:	0c 94 ae 0b 	jmp	0x175c	; 0x175c <__vector_73>
     128:	0c 94 e0 0b 	jmp	0x17c0	; 0x17c0 <__vector_74>
     12c:	d1 c1       	rjmp	.+930    	; 0x4d0 <__bad_interrupt>
     12e:	00 00       	nop
     130:	cf c1       	rjmp	.+926    	; 0x4d0 <__bad_interrupt>
     132:	00 00       	nop
     134:	cd c1       	rjmp	.+922    	; 0x4d0 <__bad_interrupt>
     136:	00 00       	nop
     138:	cb c1       	rjmp	.+918    	; 0x4d0 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	c9 c1       	rjmp	.+914    	; 0x4d0 <__bad_interrupt>
     13e:	00 00       	nop
     140:	c7 c1       	rjmp	.+910    	; 0x4d0 <__bad_interrupt>
     142:	00 00       	nop
     144:	c5 c1       	rjmp	.+906    	; 0x4d0 <__bad_interrupt>
     146:	00 00       	nop
     148:	c3 c1       	rjmp	.+902    	; 0x4d0 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	c1 c1       	rjmp	.+898    	; 0x4d0 <__bad_interrupt>
     14e:	00 00       	nop
     150:	bf c1       	rjmp	.+894    	; 0x4d0 <__bad_interrupt>
     152:	00 00       	nop
     154:	bd c1       	rjmp	.+890    	; 0x4d0 <__bad_interrupt>
     156:	00 00       	nop
     158:	bb c1       	rjmp	.+886    	; 0x4d0 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	b9 c1       	rjmp	.+882    	; 0x4d0 <__bad_interrupt>
     15e:	00 00       	nop
     160:	b7 c1       	rjmp	.+878    	; 0x4d0 <__bad_interrupt>
     162:	00 00       	nop
     164:	b5 c1       	rjmp	.+874    	; 0x4d0 <__bad_interrupt>
     166:	00 00       	nop
     168:	b3 c1       	rjmp	.+870    	; 0x4d0 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	b1 c1       	rjmp	.+866    	; 0x4d0 <__bad_interrupt>
     16e:	00 00       	nop
     170:	af c1       	rjmp	.+862    	; 0x4d0 <__bad_interrupt>
     172:	00 00       	nop
     174:	ad c1       	rjmp	.+858    	; 0x4d0 <__bad_interrupt>
     176:	00 00       	nop
     178:	ab c1       	rjmp	.+854    	; 0x4d0 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	a9 c1       	rjmp	.+850    	; 0x4d0 <__bad_interrupt>
     17e:	00 00       	nop
     180:	a7 c1       	rjmp	.+846    	; 0x4d0 <__bad_interrupt>
     182:	00 00       	nop
     184:	a5 c1       	rjmp	.+842    	; 0x4d0 <__bad_interrupt>
     186:	00 00       	nop
     188:	a3 c1       	rjmp	.+838    	; 0x4d0 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	a1 c1       	rjmp	.+834    	; 0x4d0 <__bad_interrupt>
     18e:	00 00       	nop
     190:	9f c1       	rjmp	.+830    	; 0x4d0 <__bad_interrupt>
     192:	00 00       	nop
     194:	9d c1       	rjmp	.+826    	; 0x4d0 <__bad_interrupt>
     196:	00 00       	nop
     198:	9b c1       	rjmp	.+822    	; 0x4d0 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	99 c1       	rjmp	.+818    	; 0x4d0 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	97 c1       	rjmp	.+814    	; 0x4d0 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	95 c1       	rjmp	.+810    	; 0x4d0 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	93 c1       	rjmp	.+806    	; 0x4d0 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	91 c1       	rjmp	.+802    	; 0x4d0 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	8f c1       	rjmp	.+798    	; 0x4d0 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	8d c1       	rjmp	.+794    	; 0x4d0 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	8b c1       	rjmp	.+790    	; 0x4d0 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	89 c1       	rjmp	.+786    	; 0x4d0 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	87 c1       	rjmp	.+782    	; 0x4d0 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	85 c1       	rjmp	.+778    	; 0x4d0 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	83 c1       	rjmp	.+774    	; 0x4d0 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	81 c1       	rjmp	.+770    	; 0x4d0 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	7f c1       	rjmp	.+766    	; 0x4d0 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	7d c1       	rjmp	.+762    	; 0x4d0 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	7b c1       	rjmp	.+758    	; 0x4d0 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	79 c1       	rjmp	.+754    	; 0x4d0 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	77 c1       	rjmp	.+750    	; 0x4d0 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	75 c1       	rjmp	.+746    	; 0x4d0 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	73 c1       	rjmp	.+742    	; 0x4d0 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	71 c1       	rjmp	.+738    	; 0x4d0 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	6f c1       	rjmp	.+734    	; 0x4d0 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	6d c1       	rjmp	.+730    	; 0x4d0 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	6b c1       	rjmp	.+726    	; 0x4d0 <__bad_interrupt>
	...

000001fc <__trampolines_end>:
     1fc:	00 00       	nop
     1fe:	00 00       	nop
     200:	00 00       	nop
     202:	00 20       	and	r0, r0
     204:	20 20       	and	r2, r0
     206:	20 20       	and	r2, r0
     208:	00 20       	and	r0, r0
     20a:	50 50       	subi	r21, 0x00	; 0
     20c:	50 00       	.word	0x0050	; ????
     20e:	00 00       	nop
     210:	00 50       	subi	r16, 0x00	; 0
     212:	50 f8       	bld	r5, 0
     214:	50 f8       	bld	r5, 0
     216:	50 50       	subi	r21, 0x00	; 0
     218:	20 78       	andi	r18, 0x80	; 128
     21a:	a0 70       	andi	r26, 0x00	; 0
     21c:	28 f0       	brcs	.+10     	; 0x228 <__trampolines_end+0x2c>
     21e:	20 c0       	rjmp	.+64     	; 0x260 <__trampolines_end+0x64>
     220:	c8 10       	cpse	r12, r8
     222:	20 40       	sbci	r18, 0x00	; 0
     224:	98 18       	sub	r9, r8
     226:	60 90 a0 40 	lds	r6, 0x40A0
     22a:	a8 90       	.word	0x90a8	; ????
     22c:	68 60       	ori	r22, 0x08	; 8
     22e:	20 40       	sbci	r18, 0x00	; 0
     230:	00 00       	nop
     232:	00 00       	nop
     234:	10 20       	and	r1, r0
     236:	40 40       	sbci	r20, 0x00	; 0
     238:	40 20       	and	r4, r0
     23a:	10 40       	sbci	r17, 0x00	; 0
     23c:	20 10       	cpse	r2, r0
     23e:	10 10       	cpse	r1, r0
     240:	20 40       	sbci	r18, 0x00	; 0
     242:	00 50       	subi	r16, 0x00	; 0
     244:	20 f8       	bld	r2, 0
     246:	20 50       	subi	r18, 0x00	; 0
     248:	00 00       	nop
     24a:	20 20       	and	r2, r0
     24c:	f8 20       	and	r15, r8
     24e:	20 00       	.word	0x0020	; ????
     250:	00 00       	nop
     252:	00 00       	nop
     254:	60 20       	and	r6, r0
     256:	40 00       	.word	0x0040	; ????
     258:	00 00       	nop
     25a:	f8 00       	.word	0x00f8	; ????
     25c:	00 00       	nop
     25e:	00 00       	nop
     260:	00 00       	nop
     262:	00 60       	ori	r16, 0x00	; 0
     264:	60 00       	.word	0x0060	; ????
     266:	08 10       	cpse	r0, r8
     268:	20 40       	sbci	r18, 0x00	; 0
     26a:	80 00       	.word	0x0080	; ????
     26c:	70 88       	ldd	r7, Z+16	; 0x10
     26e:	98 a8       	ldd	r9, Y+48	; 0x30
     270:	c8 88       	ldd	r12, Y+16	; 0x10
     272:	70 20       	and	r7, r0
     274:	60 20       	and	r6, r0
     276:	20 20       	and	r2, r0
     278:	20 70       	andi	r18, 0x00	; 0
     27a:	70 88       	ldd	r7, Z+16	; 0x10
     27c:	08 10       	cpse	r0, r8
     27e:	20 40       	sbci	r18, 0x00	; 0
     280:	f8 f8       	.word	0xf8f8	; ????
     282:	10 20       	and	r1, r0
     284:	10 08       	sbc	r1, r0
     286:	88 70       	andi	r24, 0x08	; 8
     288:	10 30       	cpi	r17, 0x00	; 0
     28a:	50 90 f8 10 	lds	r5, 0x10F8
     28e:	10 f8       	bld	r1, 0
     290:	80 f0       	brcs	.+32     	; 0x2b2 <__trampolines_end+0xb6>
     292:	08 08       	sbc	r0, r8
     294:	88 70       	andi	r24, 0x08	; 8
     296:	30 40       	sbci	r19, 0x00	; 0
     298:	80 f0       	brcs	.+32     	; 0x2ba <__trampolines_end+0xbe>
     29a:	88 88       	ldd	r8, Y+16	; 0x10
     29c:	70 f8       	bld	r7, 0
     29e:	08 10       	cpse	r0, r8
     2a0:	20 40       	sbci	r18, 0x00	; 0
     2a2:	40 40       	sbci	r20, 0x00	; 0
     2a4:	70 88       	ldd	r7, Z+16	; 0x10
     2a6:	88 70       	andi	r24, 0x08	; 8
     2a8:	88 88       	ldd	r8, Y+16	; 0x10
     2aa:	70 70       	andi	r23, 0x00	; 0
     2ac:	88 88       	ldd	r8, Y+16	; 0x10
     2ae:	78 08       	sbc	r7, r8
     2b0:	10 60       	ori	r17, 0x00	; 0
     2b2:	00 60       	ori	r16, 0x00	; 0
     2b4:	60 00       	.word	0x0060	; ????
     2b6:	60 60       	ori	r22, 0x00	; 0
     2b8:	00 00       	nop
     2ba:	60 60       	ori	r22, 0x00	; 0
     2bc:	00 60       	ori	r16, 0x00	; 0
     2be:	20 40       	sbci	r18, 0x00	; 0
     2c0:	08 10       	cpse	r0, r8
     2c2:	20 40       	sbci	r18, 0x00	; 0
     2c4:	20 10       	cpse	r2, r0
     2c6:	08 00       	.word	0x0008	; ????
     2c8:	00 f8       	bld	r0, 0
     2ca:	00 f8       	bld	r0, 0
     2cc:	00 00       	nop
     2ce:	80 40       	sbci	r24, 0x00	; 0
     2d0:	20 10       	cpse	r2, r0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	80 70       	andi	r24, 0x00	; 0
     2d6:	88 08       	sbc	r8, r8
     2d8:	10 20       	and	r1, r0
     2da:	00 20       	and	r0, r0
     2dc:	70 88       	ldd	r7, Z+16	; 0x10
     2de:	08 68       	ori	r16, 0x88	; 136
     2e0:	a8 a8       	ldd	r10, Y+48	; 0x30
     2e2:	70 70       	andi	r23, 0x00	; 0
     2e4:	88 88       	ldd	r8, Y+16	; 0x10
     2e6:	88 f8       	.word	0xf888	; ????
     2e8:	88 88       	ldd	r8, Y+16	; 0x10
     2ea:	f0 88       	ldd	r15, Z+16	; 0x10
     2ec:	88 f0       	brcs	.+34     	; 0x310 <__trampolines_end+0x114>
     2ee:	88 88       	ldd	r8, Y+16	; 0x10
     2f0:	f0 70       	andi	r31, 0x00	; 0
     2f2:	88 80       	ld	r8, Y
     2f4:	80 80       	ld	r8, Z
     2f6:	88 70       	andi	r24, 0x08	; 8
     2f8:	e0 90 88 88 	lds	r14, 0x8888
     2fc:	88 90       	.word	0x9088	; ????
     2fe:	e0 f8       	bld	r14, 0
     300:	80 80       	ld	r8, Z
     302:	f0 80       	ld	r15, Z
     304:	80 f8       	bld	r8, 0
     306:	f8 80       	ld	r15, Y
     308:	80 e0       	ldi	r24, 0x00	; 0
     30a:	80 80       	ld	r8, Z
     30c:	80 70       	andi	r24, 0x00	; 0
     30e:	88 80       	ld	r8, Y
     310:	80 98       	cbi	0x10, 0	; 16
     312:	88 70       	andi	r24, 0x08	; 8
     314:	88 88       	ldd	r8, Y+16	; 0x10
     316:	88 f8       	.word	0xf888	; ????
     318:	88 88       	ldd	r8, Y+16	; 0x10
     31a:	88 70       	andi	r24, 0x08	; 8
     31c:	20 20       	and	r2, r0
     31e:	20 20       	and	r2, r0
     320:	20 70       	andi	r18, 0x00	; 0
     322:	38 10       	cpse	r3, r8
     324:	10 10       	cpse	r1, r0
     326:	10 90 60 88 	lds	r1, 0x8860
     32a:	90 a0       	ldd	r9, Z+32	; 0x20
     32c:	c0 a0       	ldd	r12, Z+32	; 0x20
     32e:	90 88       	ldd	r9, Z+16	; 0x10
     330:	80 80       	ld	r8, Z
     332:	80 80       	ld	r8, Z
     334:	80 80       	ld	r8, Z
     336:	f8 88       	ldd	r15, Y+16	; 0x10
     338:	d8 a8       	ldd	r13, Y+48	; 0x30
     33a:	88 88       	ldd	r8, Y+16	; 0x10
     33c:	88 88       	ldd	r8, Y+16	; 0x10
     33e:	88 88       	ldd	r8, Y+16	; 0x10
     340:	c8 a8       	ldd	r12, Y+48	; 0x30
     342:	98 88       	ldd	r9, Y+16	; 0x10
     344:	88 70       	andi	r24, 0x08	; 8
     346:	88 88       	ldd	r8, Y+16	; 0x10
     348:	88 88       	ldd	r8, Y+16	; 0x10
     34a:	88 70       	andi	r24, 0x08	; 8
     34c:	f0 88       	ldd	r15, Z+16	; 0x10
     34e:	88 f0       	brcs	.+34     	; 0x372 <__trampolines_end+0x176>
     350:	80 80       	ld	r8, Z
     352:	80 70       	andi	r24, 0x00	; 0
     354:	88 88       	ldd	r8, Y+16	; 0x10
     356:	88 a8       	ldd	r8, Y+48	; 0x30
     358:	90 68       	ori	r25, 0x80	; 128
     35a:	f0 88       	ldd	r15, Z+16	; 0x10
     35c:	88 f0       	brcs	.+34     	; 0x380 <__trampolines_end+0x184>
     35e:	a0 90 88 78 	lds	r10, 0x7888
     362:	80 80       	ld	r8, Z
     364:	70 08       	sbc	r7, r0
     366:	08 f0       	brcs	.+2      	; 0x36a <__trampolines_end+0x16e>
     368:	f8 20       	and	r15, r8
     36a:	20 20       	and	r2, r0
     36c:	20 20       	and	r2, r0
     36e:	20 88       	ldd	r2, Z+16	; 0x10
     370:	88 88       	ldd	r8, Y+16	; 0x10
     372:	88 88       	ldd	r8, Y+16	; 0x10
     374:	88 70       	andi	r24, 0x08	; 8
     376:	88 88       	ldd	r8, Y+16	; 0x10
     378:	88 88       	ldd	r8, Y+16	; 0x10
     37a:	88 50       	subi	r24, 0x08	; 8
     37c:	20 88       	ldd	r2, Z+16	; 0x10
     37e:	88 88       	ldd	r8, Y+16	; 0x10
     380:	a8 a8       	ldd	r10, Y+48	; 0x30
     382:	d8 88       	ldd	r13, Y+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	50 20       	and	r5, r0
     388:	50 88       	ldd	r5, Z+16	; 0x10
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 50       	subi	r24, 0x08	; 8
     38e:	20 20       	and	r2, r0
     390:	20 20       	and	r2, r0
     392:	f8 08       	sbc	r15, r8
     394:	10 20       	and	r1, r0
     396:	40 80       	ld	r4, Z
     398:	f8 38       	cpi	r31, 0x88	; 136
     39a:	20 20       	and	r2, r0
     39c:	20 20       	and	r2, r0
     39e:	20 38       	cpi	r18, 0x80	; 128
     3a0:	00 80       	ld	r0, Z
     3a2:	40 20       	and	r4, r0
     3a4:	10 08       	sbc	r1, r0
     3a6:	00 e0       	ldi	r16, 0x00	; 0
     3a8:	20 20       	and	r2, r0
     3aa:	20 20       	and	r2, r0
     3ac:	20 e0       	ldi	r18, 0x00	; 0
     3ae:	20 50       	subi	r18, 0x00	; 0
     3b0:	88 00       	.word	0x0088	; ????
	...
     3ba:	00 f8       	bld	r0, 0
     3bc:	40 20       	and	r4, r0
     3be:	10 00       	.word	0x0010	; ????
     3c0:	00 00       	nop
     3c2:	00 00       	nop
     3c4:	00 70       	andi	r16, 0x00	; 0
     3c6:	08 78       	andi	r16, 0x88	; 136
     3c8:	88 78       	andi	r24, 0x88	; 136
     3ca:	80 80       	ld	r8, Z
     3cc:	b0 c8       	rjmp	.-3744   	; 0xfffff52e <__eeprom_end+0xff7ef52e>
     3ce:	88 88       	ldd	r8, Y+16	; 0x10
     3d0:	f0 00       	.word	0x00f0	; ????
     3d2:	00 70       	andi	r16, 0x00	; 0
     3d4:	80 80       	ld	r8, Z
     3d6:	88 70       	andi	r24, 0x08	; 8
     3d8:	08 08       	sbc	r0, r8
     3da:	68 98       	cbi	0x0d, 0	; 13
     3dc:	88 88       	ldd	r8, Y+16	; 0x10
     3de:	78 00       	.word	0x0078	; ????
     3e0:	00 70       	andi	r16, 0x00	; 0
     3e2:	88 f8       	.word	0xf888	; ????
     3e4:	80 70       	andi	r24, 0x00	; 0
     3e6:	30 48       	sbci	r19, 0x80	; 128
     3e8:	40 e0       	ldi	r20, 0x00	; 0
     3ea:	40 40       	sbci	r20, 0x00	; 0
     3ec:	40 00       	.word	0x0040	; ????
     3ee:	00 78       	andi	r16, 0x80	; 128
     3f0:	88 78       	andi	r24, 0x88	; 136
     3f2:	08 30       	cpi	r16, 0x08	; 8
     3f4:	80 80       	ld	r8, Z
     3f6:	b0 c8       	rjmp	.-3744   	; 0xfffff558 <__eeprom_end+0xff7ef558>
     3f8:	88 88       	ldd	r8, Y+16	; 0x10
     3fa:	88 20       	and	r8, r8
     3fc:	00 60       	ori	r16, 0x00	; 0
     3fe:	20 20       	and	r2, r0
     400:	20 70       	andi	r18, 0x00	; 0
     402:	10 00       	.word	0x0010	; ????
     404:	30 10       	cpse	r3, r0
     406:	10 90 60 40 	lds	r1, 0x4060
     40a:	40 48       	sbci	r20, 0x80	; 128
     40c:	50 60       	ori	r21, 0x00	; 0
     40e:	50 48       	sbci	r21, 0x80	; 128
     410:	60 20       	and	r6, r0
     412:	20 20       	and	r2, r0
     414:	20 20       	and	r2, r0
     416:	70 00       	.word	0x0070	; ????
     418:	00 d0       	rcall	.+0      	; 0x41a <__trampolines_end+0x21e>
     41a:	a8 a8       	ldd	r10, Y+48	; 0x30
     41c:	88 88       	ldd	r8, Y+16	; 0x10
     41e:	00 00       	nop
     420:	b0 c8       	rjmp	.-3744   	; 0xfffff582 <__eeprom_end+0xff7ef582>
     422:	88 88       	ldd	r8, Y+16	; 0x10
     424:	88 00       	.word	0x0088	; ????
     426:	00 70       	andi	r16, 0x00	; 0
     428:	88 88       	ldd	r8, Y+16	; 0x10
     42a:	88 70       	andi	r24, 0x08	; 8
     42c:	00 00       	nop
     42e:	f0 88       	ldd	r15, Z+16	; 0x10
     430:	f0 80       	ld	r15, Z
     432:	80 00       	.word	0x0080	; ????
     434:	00 68       	ori	r16, 0x80	; 128
     436:	98 78       	andi	r25, 0x88	; 136
     438:	08 08       	sbc	r0, r8
     43a:	00 00       	nop
     43c:	b0 c8       	rjmp	.-3744   	; 0xfffff59e <__eeprom_end+0xff7ef59e>
     43e:	80 80       	ld	r8, Z
     440:	80 00       	.word	0x0080	; ????
     442:	00 70       	andi	r16, 0x00	; 0
     444:	80 70       	andi	r24, 0x00	; 0
     446:	08 f0       	brcs	.+2      	; 0x44a <__trampolines_end+0x24e>
     448:	40 40       	sbci	r20, 0x00	; 0
     44a:	e0 40       	sbci	r30, 0x00	; 0
     44c:	40 48       	sbci	r20, 0x80	; 128
     44e:	30 00       	.word	0x0030	; ????
     450:	00 88       	ldd	r0, Z+16	; 0x10
     452:	88 88       	ldd	r8, Y+16	; 0x10
     454:	98 68       	ori	r25, 0x88	; 136
     456:	00 00       	nop
     458:	88 88       	ldd	r8, Y+16	; 0x10
     45a:	88 50       	subi	r24, 0x08	; 8
     45c:	20 00       	.word	0x0020	; ????
     45e:	00 88       	ldd	r0, Z+16	; 0x10
     460:	88 a8       	ldd	r8, Y+48	; 0x30
     462:	a8 50       	subi	r26, 0x08	; 8
     464:	00 00       	nop
     466:	88 50       	subi	r24, 0x08	; 8
     468:	20 50       	subi	r18, 0x00	; 0
     46a:	88 00       	.word	0x0088	; ????
     46c:	00 88       	ldd	r0, Z+16	; 0x10
     46e:	88 78       	andi	r24, 0x88	; 136
     470:	08 70       	andi	r16, 0x08	; 8
     472:	00 00       	nop
     474:	f8 10       	cpse	r15, r8
     476:	20 40       	sbci	r18, 0x00	; 0
     478:	f8 10       	cpse	r15, r8
     47a:	20 20       	and	r2, r0
     47c:	40 20       	and	r4, r0
     47e:	20 10       	cpse	r2, r0
     480:	20 20       	and	r2, r0
     482:	20 20       	and	r2, r0
     484:	20 20       	and	r2, r0
     486:	20 40       	sbci	r18, 0x00	; 0
     488:	20 20       	and	r2, r0
     48a:	10 20       	and	r1, r0
     48c:	20 40       	sbci	r18, 0x00	; 0

0000048e <__ctors_end>:
     48e:	11 24       	eor	r1, r1
     490:	1f be       	out	0x3f, r1	; 63
     492:	cf ef       	ldi	r28, 0xFF	; 255
     494:	cd bf       	out	0x3d, r28	; 61
     496:	df e5       	ldi	r29, 0x5F	; 95
     498:	de bf       	out	0x3e, r29	; 62
     49a:	00 e0       	ldi	r16, 0x00	; 0
     49c:	0c bf       	out	0x3c, r16	; 60

0000049e <__do_copy_data>:
     49e:	11 e2       	ldi	r17, 0x21	; 33
     4a0:	a0 e0       	ldi	r26, 0x00	; 0
     4a2:	b0 e2       	ldi	r27, 0x20	; 32
     4a4:	e0 e0       	ldi	r30, 0x00	; 0
     4a6:	f2 e4       	ldi	r31, 0x42	; 66
     4a8:	00 e0       	ldi	r16, 0x00	; 0
     4aa:	0b bf       	out	0x3b, r16	; 59
     4ac:	02 c0       	rjmp	.+4      	; 0x4b2 <__do_copy_data+0x14>
     4ae:	07 90       	elpm	r0, Z+
     4b0:	0d 92       	st	X+, r0
     4b2:	a0 34       	cpi	r26, 0x40	; 64
     4b4:	b1 07       	cpc	r27, r17
     4b6:	d9 f7       	brne	.-10     	; 0x4ae <__do_copy_data+0x10>

000004b8 <__do_clear_bss>:
     4b8:	24 e2       	ldi	r18, 0x24	; 36
     4ba:	a0 e4       	ldi	r26, 0x40	; 64
     4bc:	b1 e2       	ldi	r27, 0x21	; 33
     4be:	01 c0       	rjmp	.+2      	; 0x4c2 <.do_clear_bss_start>

000004c0 <.do_clear_bss_loop>:
     4c0:	1d 92       	st	X+, r1

000004c2 <.do_clear_bss_start>:
     4c2:	ad 3b       	cpi	r26, 0xBD	; 189
     4c4:	b2 07       	cpc	r27, r18
     4c6:	e1 f7       	brne	.-8      	; 0x4c0 <.do_clear_bss_loop>
     4c8:	0e 94 40 1c 	call	0x3880	; 0x3880 <main>
     4cc:	0c 94 fe 20 	jmp	0x41fc	; 0x41fc <_exit>

000004d0 <__bad_interrupt>:
     4d0:	97 cd       	rjmp	.-1234   	; 0x0 <__vectors>

000004d2 <_1101010101_>:

#if ((_STATIC_PORT_PIN_CONF_ == 1) && (QTOUCH_SNS_PORT_COUNT >= 1))

GLOBAL_FUNCTION _1101010101_
_1101010101_:
    sts	CONCAT( PORT, SNS1, _DIRCLR ), p_1
     4d2:	80 93 a2 06 	sts	0x06A2, r24
    sts	CONCAT( PORT, SNSK1, _DIRCLR ), p_2
     4d6:	60 93 a2 06 	sts	0x06A2, r22
    sts	CONCAT( PORT, SNS1, _OUTSET), p_1
     4da:	80 93 a5 06 	sts	0x06A5, r24
    sts	CONCAT( PORT, SNSK1, _OUTCLR), p_2    
     4de:	60 93 a6 06 	sts	0x06A6, r22
    sts	CONCAT( PORT, SNSK1, _DIRSET), p_2   
     4e2:	60 93 a1 06 	sts	0x06A1, r22
    ret
     4e6:	08 95       	ret

000004e8 <_1101010111_>:


GLOBAL_FUNCTION _1101010111_
_1101010111_:
    push r19
     4e8:	3f 93       	push	r19
    sts	CONCAT( PORT, SNSK1, _DIRCLR), p_2
     4ea:	60 93 a2 06 	sts	0x06A2, r22
    sts	CONCAT( PORT, SNS1, _DIRSET), p_1
     4ee:	80 93 a1 06 	sts	0x06A1, r24
    _10100011_
    _01101001_
    _00011001_
    _00011001_
#endif
    sts	CONCAT( PORT, SNS1, _DIRCLR ), p_1
     4f2:	80 93 a2 06 	sts	0x06A2, r24
    sts	CONCAT( PORT, SNSK1, _DIRSET ), p_2 
     4f6:	60 93 a1 06 	sts	0x06A1, r22
    pop  r19
     4fa:	3f 91       	pop	r19
    lds	r_v, CONCAT(PORT, SNS1, _IN )
     4fc:	80 91 a8 06 	lds	r24, 0x06A8
    and	r_v, p_3
     500:	84 23       	and	r24, r20
    ret
     502:	08 95       	ret

00000504 <_1101010110_>:

GLOBAL_FUNCTION _1101010110_
_1101010110_:
    sts	CONCAT( PORT, SNS1, _OUTCLR), p_1
     504:	80 93 a6 06 	sts	0x06A6, r24
    sts	CONCAT( PORT, SNS1, _DIRSET), p_1
     508:	80 93 a1 06 	sts	0x06A1, r24
    ret
     50c:	08 95       	ret

0000050e <burst_1_1_10_0_1>:
     50e:	a1 e0       	ldi	r26, 0x01	; 1
     510:	b0 e0       	ldi	r27, 0x00	; 0
     512:	ed e8       	ldi	r30, 0x8D	; 141
     514:	f2 e0       	ldi	r31, 0x02	; 2
     516:	0c 94 e8 1c 	jmp	0x39d0	; 0x39d0 <__prologue_saves__+0xc>
     51a:	e8 2f       	mov	r30, r24
     51c:	0f b7       	in	r16, 0x3f	; 63
     51e:	00 78       	andi	r16, 0x80	; 128
     520:	19 82       	std	Y+1, r1	; 0x01
     522:	80 91 41 21 	lds	r24, 0x2141
     526:	81 30       	cpi	r24, 0x01	; 1
     528:	19 f0       	breq	.+6      	; 0x530 <burst_1_1_10_0_1+0x22>
     52a:	81 e0       	ldi	r24, 0x01	; 1
     52c:	80 93 41 21 	sts	0x2141, r24
     530:	ce 2e       	mov	r12, r30
     532:	dd 24       	eor	r13, r13
     534:	f6 01       	movw	r30, r12
     536:	ed 57       	subi	r30, 0x7D	; 125
     538:	fe 4d       	sbci	r31, 0xDE	; 222
     53a:	b0 80       	ld	r11, Z
     53c:	f6 01       	movw	r30, r12
     53e:	e9 57       	subi	r30, 0x79	; 121
     540:	fe 4d       	sbci	r31, 0xDE	; 222
     542:	a0 80       	ld	r10, Z
     544:	f8 94       	cli
     546:	bb 20       	and	r11, r11
     548:	09 f4       	brne	.+2      	; 0x54c <burst_1_1_10_0_1+0x3e>
     54a:	aa c0       	rjmp	.+340    	; 0x6a0 <burst_1_1_10_0_1+0x192>
     54c:	8b 2d       	mov	r24, r11
     54e:	da df       	rcall	.-76     	; 0x504 <_1101010110_>
     550:	8b 2d       	mov	r24, r11
     552:	6a 2d       	mov	r22, r10
     554:	be df       	rcall	.-132    	; 0x4d2 <_1101010101_>
     556:	1b 2d       	mov	r17, r11
     558:	ee 24       	eor	r14, r14
     55a:	ff 24       	eor	r15, r15
     55c:	60 e0       	ldi	r22, 0x00	; 0
     55e:	81 2c       	mov	r8, r1
     560:	30 e2       	ldi	r19, 0x20	; 32
     562:	93 2e       	mov	r9, r19
     564:	f5 fe       	sbrs	r15, 5
     566:	07 c0       	rjmp	.+14     	; 0x576 <burst_1_1_10_0_1+0x68>
     568:	90 91 84 21 	lds	r25, 0x2184
     56c:	80 91 83 21 	lds	r24, 0x2183
     570:	98 2b       	or	r25, r24
     572:	19 f5       	brne	.+70     	; 0x5ba <burst_1_1_10_0_1+0xac>
     574:	35 c0       	rjmp	.+106    	; 0x5e0 <burst_1_1_10_0_1+0xd2>
     576:	8f b7       	in	r24, 0x3f	; 63
     578:	80 2b       	or	r24, r16
     57a:	8f bf       	out	0x3f, r24	; 63
     57c:	00 00       	nop
     57e:	f8 94       	cli
     580:	8b 2d       	mov	r24, r11
     582:	6a 2d       	mov	r22, r10
     584:	41 2f       	mov	r20, r17
     586:	b0 df       	rcall	.-160    	; 0x4e8 <_1101010111_>
     588:	68 2f       	mov	r22, r24
     58a:	08 94       	sec
     58c:	e1 1c       	adc	r14, r1
     58e:	f1 1c       	adc	r15, r1
     590:	80 91 00 20 	lds	r24, 0x2000
     594:	8f 5f       	subi	r24, 0xFF	; 255
     596:	80 93 00 20 	sts	0x2000, r24
     59a:	82 30       	cpi	r24, 0x02	; 2
     59c:	30 f0       	brcs	.+12     	; 0x5aa <burst_1_1_10_0_1+0x9c>
     59e:	82 30       	cpi	r24, 0x02	; 2
     5a0:	21 f0       	breq	.+8      	; 0x5aa <burst_1_1_10_0_1+0x9c>
     5a2:	83 30       	cpi	r24, 0x03	; 3
     5a4:	11 f0       	breq	.+4      	; 0x5aa <burst_1_1_10_0_1+0x9c>
     5a6:	10 92 00 20 	sts	0x2000, r1
     5aa:	66 23       	and	r22, r22
     5ac:	d9 f2       	breq	.-74     	; 0x564 <burst_1_1_10_0_1+0x56>
     5ae:	20 91 84 21 	lds	r18, 0x2184
     5b2:	80 91 83 21 	lds	r24, 0x2183
     5b6:	28 2b       	or	r18, r24
     5b8:	15 c0       	rjmp	.+42     	; 0x5e4 <burst_1_1_10_0_1+0xd6>
     5ba:	41 2f       	mov	r20, r17
     5bc:	80 e0       	ldi	r24, 0x00	; 0
     5be:	40 ff       	sbrs	r20, 0
     5c0:	09 c0       	rjmp	.+18     	; 0x5d4 <burst_1_1_10_0_1+0xc6>
     5c2:	e8 2f       	mov	r30, r24
     5c4:	f0 e0       	ldi	r31, 0x00	; 0
     5c6:	ee 0f       	add	r30, r30
     5c8:	ff 1f       	adc	r31, r31
     5ca:	e4 5b       	subi	r30, 0xB4	; 180
     5cc:	fe 4d       	sbci	r31, 0xDE	; 222
     5ce:	80 82       	st	Z, r8
     5d0:	91 82       	std	Z+1, r9	; 0x01
     5d2:	01 c0       	rjmp	.+2      	; 0x5d6 <burst_1_1_10_0_1+0xc8>
     5d4:	90 fd       	sbrc	r25, 0
     5d6:	8f 5f       	subi	r24, 0xFF	; 255
     5d8:	96 95       	lsr	r25
     5da:	46 95       	lsr	r20
     5dc:	99 23       	and	r25, r25
     5de:	79 f7       	brne	.-34     	; 0x5be <burst_1_1_10_0_1+0xb0>
     5e0:	10 e0       	ldi	r17, 0x00	; 0
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	8f b7       	in	r24, 0x3f	; 63
     5e6:	80 2b       	or	r24, r16
     5e8:	8f bf       	out	0x3f, r24	; 63
     5ea:	10 92 42 21 	sts	0x2142, r1
     5ee:	22 23       	and	r18, r18
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <burst_1_1_10_0_1+0xe6>
     5f2:	3f c0       	rjmp	.+126    	; 0x672 <burst_1_1_10_0_1+0x164>
     5f4:	11 23       	and	r17, r17
     5f6:	09 f4       	brne	.+2      	; 0x5fa <burst_1_1_10_0_1+0xec>
     5f8:	3c c0       	rjmp	.+120    	; 0x672 <burst_1_1_10_0_1+0x164>
     5fa:	30 91 88 21 	lds	r19, 0x2188
     5fe:	80 91 87 21 	lds	r24, 0x2187
     602:	38 2b       	or	r19, r24
     604:	56 2f       	mov	r21, r22
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	80 e0       	ldi	r24, 0x00	; 0
     60a:	70 e0       	ldi	r23, 0x00	; 0
     60c:	40 e0       	ldi	r20, 0x00	; 0
     60e:	23 c0       	rjmp	.+70     	; 0x656 <burst_1_1_10_0_1+0x148>
     610:	50 fd       	sbrc	r21, 0
     612:	17 c0       	rjmp	.+46     	; 0x642 <burst_1_1_10_0_1+0x134>
     614:	19 c0       	rjmp	.+50     	; 0x648 <burst_1_1_10_0_1+0x13a>
     616:	30 ff       	sbrs	r19, 0
     618:	13 c0       	rjmp	.+38     	; 0x640 <burst_1_1_10_0_1+0x132>
     61a:	98 17       	cp	r25, r24
     61c:	81 f4       	brne	.+32     	; 0x63e <burst_1_1_10_0_1+0x130>
     61e:	e4 2f       	mov	r30, r20
     620:	f0 e0       	ldi	r31, 0x00	; 0
     622:	ee 0f       	add	r30, r30
     624:	ff 1f       	adc	r31, r31
     626:	e4 5b       	subi	r30, 0xB4	; 180
     628:	fe 4d       	sbci	r31, 0xDE	; 222
     62a:	e0 82       	st	Z, r14
     62c:	f1 82       	std	Z+1, r15	; 0x01
     62e:	85 2f       	mov	r24, r21
     630:	8e 7f       	andi	r24, 0xFE	; 254
     632:	19 f4       	brne	.+6      	; 0x63a <burst_1_1_10_0_1+0x12c>
     634:	89 2f       	mov	r24, r25
     636:	71 e0       	ldi	r23, 0x01	; 1
     638:	08 c0       	rjmp	.+16     	; 0x64a <burst_1_1_10_0_1+0x13c>
     63a:	89 2f       	mov	r24, r25
     63c:	06 c0       	rjmp	.+12     	; 0x64a <burst_1_1_10_0_1+0x13c>
     63e:	8f 5f       	subi	r24, 0xFF	; 255
     640:	36 95       	lsr	r19
     642:	33 23       	and	r19, r19
     644:	41 f7       	brne	.-48     	; 0x616 <burst_1_1_10_0_1+0x108>
     646:	01 c0       	rjmp	.+2      	; 0x64a <burst_1_1_10_0_1+0x13c>
     648:	20 fd       	sbrc	r18, 0
     64a:	9f 5f       	subi	r25, 0xFF	; 255
     64c:	20 fd       	sbrc	r18, 0
     64e:	4f 5f       	subi	r20, 0xFF	; 255
     650:	56 95       	lsr	r21
     652:	26 95       	lsr	r18
     654:	11 f0       	breq	.+4      	; 0x65a <burst_1_1_10_0_1+0x14c>
     656:	55 23       	and	r21, r21
     658:	d9 f6       	brne	.-74     	; 0x610 <burst_1_1_10_0_1+0x102>
     65a:	40 93 42 21 	sts	0x2142, r20
     65e:	60 95       	com	r22
     660:	16 23       	and	r17, r22
     662:	71 30       	cpi	r23, 0x01	; 1
     664:	21 f4       	brne	.+8      	; 0x66e <burst_1_1_10_0_1+0x160>
     666:	11 23       	and	r17, r17
     668:	11 f4       	brne	.+4      	; 0x66e <burst_1_1_10_0_1+0x160>
     66a:	ee 24       	eor	r14, r14
     66c:	ff 24       	eor	r15, r15
     66e:	60 e0       	ldi	r22, 0x00	; 0
     670:	13 c0       	rjmp	.+38     	; 0x698 <burst_1_1_10_0_1+0x18a>
     672:	80 91 84 21 	lds	r24, 0x2184
     676:	90 91 83 21 	lds	r25, 0x2183
     67a:	89 2b       	or	r24, r25
     67c:	89 83       	std	Y+1, r24	; 0x01
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	06 c0       	rjmp	.+12     	; 0x68e <burst_1_1_10_0_1+0x180>
     682:	89 81       	ldd	r24, Y+1	; 0x01
     684:	80 fd       	sbrc	r24, 0
     686:	9f 5f       	subi	r25, 0xFF	; 255
     688:	89 81       	ldd	r24, Y+1	; 0x01
     68a:	86 95       	lsr	r24
     68c:	89 83       	std	Y+1, r24	; 0x01
     68e:	89 81       	ldd	r24, Y+1	; 0x01
     690:	88 23       	and	r24, r24
     692:	b9 f7       	brne	.-18     	; 0x682 <burst_1_1_10_0_1+0x174>
     694:	90 93 42 21 	sts	0x2142, r25
     698:	f8 94       	cli
     69a:	11 23       	and	r17, r17
     69c:	09 f0       	breq	.+2      	; 0x6a0 <burst_1_1_10_0_1+0x192>
     69e:	62 cf       	rjmp	.-316    	; 0x564 <burst_1_1_10_0_1+0x56>
     6a0:	83 e8       	ldi	r24, 0x83	; 131
     6a2:	91 e2       	ldi	r25, 0x21	; 33
     6a4:	c8 0e       	add	r12, r24
     6a6:	d9 1e       	adc	r13, r25
     6a8:	f6 01       	movw	r30, r12
     6aa:	80 81       	ld	r24, Z
     6ac:	2b df       	rcall	.-426    	; 0x504 <_1101010110_>
     6ae:	10 92 40 21 	sts	0x2140, r1
     6b2:	8f b7       	in	r24, 0x3f	; 63
     6b4:	08 2b       	or	r16, r24
     6b6:	0f bf       	out	0x3f, r16	; 63
     6b8:	21 96       	adiw	r28, 0x01	; 1
     6ba:	ec e0       	ldi	r30, 0x0C	; 12
     6bc:	0c 94 01 1d 	jmp	0x3a02	; 0x3a02 <__epilogue_restores__+0xc>

000006c0 <qt_get_library_sig>:
     6c0:	fc 01       	movw	r30, r24
     6c2:	80 e2       	ldi	r24, 0x20	; 32
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	80 83       	st	Z, r24
     6c8:	91 83       	std	Z+1, r25	; 0x01
     6ca:	12 82       	std	Z+2, r1	; 0x02
     6cc:	13 82       	std	Z+3, r1	; 0x03
     6ce:	80 e4       	ldi	r24, 0x40	; 64
     6d0:	94 e0       	ldi	r25, 0x04	; 4
     6d2:	84 83       	std	Z+4, r24	; 0x04
     6d4:	95 83       	std	Z+5, r25	; 0x05
     6d6:	08 95       	ret

000006d8 <qt_enable_key>:
     6d8:	90 91 7d 21 	lds	r25, 0x217D
     6dc:	a9 2f       	mov	r26, r25
     6de:	b0 e0       	ldi	r27, 0x00	; 0
     6e0:	fd 01       	movw	r30, r26
     6e2:	ee 0f       	add	r30, r30
     6e4:	ff 1f       	adc	r31, r31
     6e6:	ea 0f       	add	r30, r26
     6e8:	fb 1f       	adc	r31, r27
     6ea:	ee 0f       	add	r30, r30
     6ec:	ff 1f       	adc	r31, r31
     6ee:	eb 59       	subi	r30, 0x9B	; 155
     6f0:	fe 4d       	sbci	r31, 0xDE	; 222
     6f2:	43 83       	std	Z+3, r20	; 0x03
     6f4:	67 70       	andi	r22, 0x07	; 7
     6f6:	85 83       	std	Z+5, r24	; 0x05
     6f8:	23 70       	andi	r18, 0x03	; 3
     6fa:	66 0f       	add	r22, r22
     6fc:	66 0f       	add	r22, r22
     6fe:	66 0f       	add	r22, r22
     700:	26 2b       	or	r18, r22
     702:	24 83       	std	Z+4, r18	; 0x04
     704:	9f 5f       	subi	r25, 0xFF	; 255
     706:	90 93 7d 21 	sts	0x217D, r25
     70a:	08 95       	ret

0000070c <qt_get_sensor_delta>:
     70c:	1f 93       	push	r17
     70e:	cf 93       	push	r28
     710:	df 93       	push	r29
     712:	28 2f       	mov	r18, r24
     714:	c8 2f       	mov	r28, r24
     716:	d0 e0       	ldi	r29, 0x00	; 0
     718:	fe 01       	movw	r30, r28
     71a:	ee 0f       	add	r30, r30
     71c:	ff 1f       	adc	r31, r31
     71e:	ec 0f       	add	r30, r28
     720:	fd 1f       	adc	r31, r29
     722:	ee 0f       	add	r30, r30
     724:	ff 1f       	adc	r31, r31
     726:	eb 59       	subi	r30, 0x9B	; 155
     728:	fe 4d       	sbci	r31, 0xDE	; 222
     72a:	35 81       	ldd	r19, Z+5	; 0x05
     72c:	83 81       	ldd	r24, Z+3	; 0x03
     72e:	90 e0       	ldi	r25, 0x00	; 0
     730:	00 90 45 21 	lds	r0, 0x2145
     734:	02 c0       	rjmp	.+4      	; 0x73a <qt_get_sensor_delta+0x2e>
     736:	95 95       	asr	r25
     738:	87 95       	ror	r24
     73a:	0a 94       	dec	r0
     73c:	e2 f7       	brpl	.-8      	; 0x736 <qt_get_sensor_delta+0x2a>
     73e:	18 2f       	mov	r17, r24
     740:	84 30       	cpi	r24, 0x04	; 4
     742:	08 f4       	brcc	.+2      	; 0x746 <qt_get_sensor_delta+0x3a>
     744:	14 e0       	ldi	r17, 0x04	; 4
     746:	80 91 7d 21 	lds	r24, 0x217D
     74a:	28 17       	cp	r18, r24
     74c:	18 f0       	brcs	.+6      	; 0x754 <qt_get_sensor_delta+0x48>
     74e:	20 e0       	ldi	r18, 0x00	; 0
     750:	30 e0       	ldi	r19, 0x00	; 0
     752:	2d c0       	rjmp	.+90     	; 0x7ae <qt_get_sensor_delta+0xa2>
     754:	83 2f       	mov	r24, r19
     756:	1d d1       	rcall	.+570    	; 0x992 <get_channel_delta>
     758:	9c 01       	movw	r18, r24
     75a:	41 2f       	mov	r20, r17
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	16 95       	lsr	r17
     760:	16 95       	lsr	r17
     762:	81 2f       	mov	r24, r17
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	84 1b       	sub	r24, r20
     768:	95 0b       	sbc	r25, r21
     76a:	82 17       	cp	r24, r18
     76c:	93 07       	cpc	r25, r19
     76e:	64 f4       	brge	.+24     	; 0x788 <qt_get_sensor_delta+0x7c>
     770:	fe 01       	movw	r30, r28
     772:	ee 0f       	add	r30, r30
     774:	ff 1f       	adc	r31, r31
     776:	ec 0f       	add	r30, r28
     778:	fd 1f       	adc	r31, r29
     77a:	ee 0f       	add	r30, r30
     77c:	ff 1f       	adc	r31, r31
     77e:	eb 59       	subi	r30, 0x9B	; 155
     780:	fe 4d       	sbci	r31, 0xDE	; 222
     782:	84 81       	ldd	r24, Z+4	; 0x04
     784:	8b 7f       	andi	r24, 0xFB	; 251
     786:	84 83       	std	Z+4, r24	; 0x04
     788:	88 27       	eor	r24, r24
     78a:	99 27       	eor	r25, r25
     78c:	84 1b       	sub	r24, r20
     78e:	95 0b       	sbc	r25, r21
     790:	82 17       	cp	r24, r18
     792:	93 07       	cpc	r25, r19
     794:	64 f0       	brlt	.+24     	; 0x7ae <qt_get_sensor_delta+0xa2>
     796:	fe 01       	movw	r30, r28
     798:	ee 0f       	add	r30, r30
     79a:	ff 1f       	adc	r31, r31
     79c:	ec 0f       	add	r30, r28
     79e:	fd 1f       	adc	r31, r29
     7a0:	ee 0f       	add	r30, r30
     7a2:	ff 1f       	adc	r31, r31
     7a4:	eb 59       	subi	r30, 0x9B	; 155
     7a6:	fe 4d       	sbci	r31, 0xDE	; 222
     7a8:	84 81       	ldd	r24, Z+4	; 0x04
     7aa:	84 60       	ori	r24, 0x04	; 4
     7ac:	84 83       	std	Z+4, r24	; 0x04
     7ae:	c9 01       	movw	r24, r18
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	1f 91       	pop	r17
     7b6:	08 95       	ret

000007b8 <qt_measure_sensors>:
     7b8:	ff 92       	push	r15
     7ba:	0f 93       	push	r16
     7bc:	1f 93       	push	r17
     7be:	cf 93       	push	r28
     7c0:	df 93       	push	r29
     7c2:	10 92 5d 21 	sts	0x215D, r1
     7c6:	10 92 5e 21 	sts	0x215E, r1
     7ca:	20 91 61 21 	lds	r18, 0x2161
     7ce:	30 91 62 21 	lds	r19, 0x2162
     7d2:	80 93 61 21 	sts	0x2161, r24
     7d6:	90 93 62 21 	sts	0x2162, r25
     7da:	40 91 63 21 	lds	r20, 0x2163
     7de:	50 91 64 21 	lds	r21, 0x2164
     7e2:	42 1b       	sub	r20, r18
     7e4:	53 0b       	sbc	r21, r19
     7e6:	48 0f       	add	r20, r24
     7e8:	59 1f       	adc	r21, r25
     7ea:	ff 24       	eor	r15, r15
     7ec:	03 c0       	rjmp	.+6      	; 0x7f4 <qt_measure_sensors+0x3c>
     7ee:	f3 94       	inc	r15
     7f0:	48 5c       	subi	r20, 0xC8	; 200
     7f2:	50 40       	sbci	r21, 0x00	; 0
     7f4:	48 3c       	cpi	r20, 0xC8	; 200
     7f6:	51 05       	cpc	r21, r1
     7f8:	d0 f7       	brcc	.-12     	; 0x7ee <qt_measure_sensors+0x36>
     7fa:	40 93 63 21 	sts	0x2163, r20
     7fe:	50 93 64 21 	sts	0x2164, r21
     802:	80 91 7e 21 	lds	r24, 0x217E
     806:	88 23       	and	r24, r24
     808:	41 f0       	breq	.+16     	; 0x81a <qt_measure_sensors+0x62>
     80a:	8f 15       	cp	r24, r15
     80c:	18 f4       	brcc	.+6      	; 0x814 <qt_measure_sensors+0x5c>
     80e:	10 92 7e 21 	sts	0x217E, r1
     812:	03 c0       	rjmp	.+6      	; 0x81a <qt_measure_sensors+0x62>
     814:	8f 19       	sub	r24, r15
     816:	80 93 7e 21 	sts	0x217E, r24
     81a:	c3 d3       	rcall	.+1926   	; 0xfa2 <burst>
     81c:	e0 91 5f 21 	lds	r30, 0x215F
     820:	f0 91 60 21 	lds	r31, 0x2160
     824:	30 97       	sbiw	r30, 0x00	; 0
     826:	09 f0       	breq	.+2      	; 0x82a <qt_measure_sensors+0x72>
     828:	19 95       	eicall
     82a:	10 e0       	ldi	r17, 0x00	; 0
     82c:	00 e0       	ldi	r16, 0x00	; 0
     82e:	05 c0       	rjmp	.+10     	; 0x83a <qt_measure_sensors+0x82>
     830:	81 2f       	mov	r24, r17
     832:	6f 2d       	mov	r22, r15
     834:	c3 d0       	rcall	.+390    	; 0x9bc <process_sensor>
     836:	08 2b       	or	r16, r24
     838:	1f 5f       	subi	r17, 0xFF	; 255
     83a:	60 91 7d 21 	lds	r22, 0x217D
     83e:	16 17       	cp	r17, r22
     840:	b8 f3       	brcs	.-18     	; 0x830 <qt_measure_sensors+0x78>
     842:	00 23       	and	r16, r16
     844:	49 f0       	breq	.+18     	; 0x858 <qt_measure_sensors+0xa0>
     846:	80 91 5d 21 	lds	r24, 0x215D
     84a:	90 91 5e 21 	lds	r25, 0x215E
     84e:	91 60       	ori	r25, 0x01	; 1
     850:	80 93 5d 21 	sts	0x215D, r24
     854:	90 93 5e 21 	sts	0x215E, r25
     858:	10 92 5c 21 	sts	0x215C, r1
     85c:	a5 e6       	ldi	r26, 0x65	; 101
     85e:	b1 e2       	ldi	r27, 0x21	; 33
     860:	30 e0       	ldi	r19, 0x00	; 0
     862:	41 e0       	ldi	r20, 0x01	; 1
     864:	50 e0       	ldi	r21, 0x00	; 0
     866:	17 c0       	rjmp	.+46     	; 0x896 <qt_measure_sensors+0xde>
     868:	8c 91       	ld	r24, X
     86a:	88 71       	andi	r24, 0x18	; 24
     86c:	91 f0       	breq	.+36     	; 0x892 <qt_measure_sensors+0xda>
     86e:	e3 2f       	mov	r30, r19
     870:	e6 95       	lsr	r30
     872:	e6 95       	lsr	r30
     874:	e6 95       	lsr	r30
     876:	f0 e0       	ldi	r31, 0x00	; 0
     878:	e4 5b       	subi	r30, 0xB4	; 180
     87a:	fe 4d       	sbci	r31, 0xDE	; 222
     87c:	83 2f       	mov	r24, r19
     87e:	87 70       	andi	r24, 0x07	; 7
     880:	ea 01       	movw	r28, r20
     882:	02 c0       	rjmp	.+4      	; 0x888 <qt_measure_sensors+0xd0>
     884:	cc 0f       	add	r28, r28
     886:	dd 1f       	adc	r29, r29
     888:	8a 95       	dec	r24
     88a:	e2 f7       	brpl	.-8      	; 0x884 <qt_measure_sensors+0xcc>
     88c:	20 89       	ldd	r18, Z+16	; 0x10
     88e:	2c 2b       	or	r18, r28
     890:	20 8b       	std	Z+16, r18	; 0x10
     892:	3f 5f       	subi	r19, 0xFF	; 255
     894:	16 96       	adiw	r26, 0x06	; 6
     896:	36 17       	cp	r19, r22
     898:	38 f3       	brcs	.-50     	; 0x868 <qt_measure_sensors+0xb0>
     89a:	80 91 5d 21 	lds	r24, 0x215D
     89e:	90 91 5e 21 	lds	r25, 0x215E
     8a2:	cd b7       	in	r28, 0x3d	; 61
     8a4:	de b7       	in	r29, 0x3e	; 62
     8a6:	e5 e0       	ldi	r30, 0x05	; 5
     8a8:	0c 94 08 1d 	jmp	0x3a10	; 0x3a10 <__epilogue_restores__+0x1a>

000008ac <qt_reset_sensing>:
     8ac:	10 92 7d 21 	sts	0x217D, r1
     8b0:	84 e0       	ldi	r24, 0x04	; 4
     8b2:	80 93 46 21 	sts	0x2146, r24
     8b6:	94 e1       	ldi	r25, 0x14	; 20
     8b8:	90 93 49 21 	sts	0x2149, r25
     8bc:	85 e0       	ldi	r24, 0x05	; 5
     8be:	80 93 4a 21 	sts	0x214A, r24
     8c2:	10 92 48 21 	sts	0x2148, r1
     8c6:	90 93 47 21 	sts	0x2147, r25
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	80 93 45 21 	sts	0x2145, r24
     8d0:	83 e0       	ldi	r24, 0x03	; 3
     8d2:	80 93 4b 21 	sts	0x214B, r24
     8d6:	54 d3       	rcall	.+1704   	; 0xf80 <burst_reset>
     8d8:	10 92 5f 21 	sts	0x215F, r1
     8dc:	10 92 60 21 	sts	0x2160, r1
     8e0:	08 95       	ret

000008e2 <qt_calibrate_sensing>:
     8e2:	1f 93       	push	r17
     8e4:	10 e0       	ldi	r17, 0x00	; 0
     8e6:	03 c0       	rjmp	.+6      	; 0x8ee <qt_calibrate_sensing+0xc>
     8e8:	81 2f       	mov	r24, r17
     8ea:	27 d0       	rcall	.+78     	; 0x93a <start_cal_sensor>
     8ec:	1f 5f       	subi	r17, 0xFF	; 255
     8ee:	80 91 7d 21 	lds	r24, 0x217D
     8f2:	18 17       	cp	r17, r24
     8f4:	c8 f3       	brcs	.-14     	; 0x8e8 <qt_calibrate_sensing+0x6>
     8f6:	1f 91       	pop	r17
     8f8:	08 95       	ret

000008fa <qt_init_sensing_with_burst>:
     8fa:	ef 92       	push	r14
     8fc:	ff 92       	push	r15
     8fe:	1f 93       	push	r17
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
     904:	ec 01       	movw	r28, r24
     906:	7b 01       	movw	r14, r22
     908:	10 e0       	ldi	r17, 0x00	; 0
     90a:	03 c0       	rjmp	.+6      	; 0x912 <qt_init_sensing_with_burst+0x18>
     90c:	81 2f       	mov	r24, r17
     90e:	15 d0       	rcall	.+42     	; 0x93a <start_cal_sensor>
     910:	1f 5f       	subi	r17, 0xFF	; 255
     912:	80 91 7d 21 	lds	r24, 0x217D
     916:	18 17       	cp	r17, r24
     918:	c8 f3       	brcs	.-14     	; 0x90c <qt_init_sensing_with_burst+0x12>
     91a:	10 92 61 21 	sts	0x2161, r1
     91e:	10 92 62 21 	sts	0x2162, r1
     922:	c0 93 43 21 	sts	0x2143, r28
     926:	d0 93 44 21 	sts	0x2144, r29
     92a:	c7 01       	movw	r24, r14
     92c:	24 d3       	rcall	.+1608   	; 0xf76 <burst_init>
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	1f 91       	pop	r17
     934:	ff 90       	pop	r15
     936:	ef 90       	pop	r14
     938:	08 95       	ret

0000093a <start_cal_sensor>:
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	e5 e6       	ldi	r30, 0x65	; 101
     93e:	f1 e2       	ldi	r31, 0x21	; 33
     940:	9c 01       	movw	r18, r24
     942:	22 0f       	add	r18, r18
     944:	33 1f       	adc	r19, r19
     946:	28 0f       	add	r18, r24
     948:	39 1f       	adc	r19, r25
     94a:	d9 01       	movw	r26, r18
     94c:	aa 0f       	add	r26, r26
     94e:	bb 1f       	adc	r27, r27
     950:	ae 0f       	add	r26, r30
     952:	bf 1f       	adc	r27, r31
     954:	15 96       	adiw	r26, 0x05	; 5
     956:	4c 91       	ld	r20, X
     958:	15 97       	sbiw	r26, 0x05	; 5
     95a:	80 91 5d 21 	lds	r24, 0x215D
     95e:	90 91 5e 21 	lds	r25, 0x215E
     962:	82 60       	ori	r24, 0x02	; 2
     964:	80 93 5d 21 	sts	0x215D, r24
     968:	90 93 5e 21 	sts	0x215E, r25
     96c:	2f 5f       	subi	r18, 0xFF	; 255
     96e:	3f 4f       	sbci	r19, 0xFF	; 255
     970:	22 0f       	add	r18, r18
     972:	33 1f       	adc	r19, r19
     974:	e2 0f       	add	r30, r18
     976:	f3 1f       	adc	r31, r19
     978:	10 82       	st	Z, r1
     97a:	ef e7       	ldi	r30, 0x7F	; 127
     97c:	f1 e2       	ldi	r31, 0x21	; 33
     97e:	e4 0f       	add	r30, r20
     980:	f1 1d       	adc	r31, r1
     982:	80 e8       	ldi	r24, 0x80	; 128
     984:	80 83       	st	Z, r24
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	8c 93       	st	X, r24
     98a:	8f e0       	ldi	r24, 0x0F	; 15
     98c:	11 96       	adiw	r26, 0x01	; 1
     98e:	8c 93       	st	X, r24
     990:	08 95       	ret

00000992 <get_channel_delta>:
     992:	90 e0       	ldi	r25, 0x00	; 0
     994:	fc 01       	movw	r30, r24
     996:	34 96       	adiw	r30, 0x04	; 4
     998:	ac e4       	ldi	r26, 0x4C	; 76
     99a:	b1 e2       	ldi	r27, 0x21	; 33
     99c:	ee 0f       	add	r30, r30
     99e:	ff 1f       	adc	r31, r31
     9a0:	ea 0f       	add	r30, r26
     9a2:	fb 1f       	adc	r31, r27
     9a4:	88 0f       	add	r24, r24
     9a6:	99 1f       	adc	r25, r25
     9a8:	a8 0f       	add	r26, r24
     9aa:	b9 1f       	adc	r27, r25
     9ac:	20 81       	ld	r18, Z
     9ae:	31 81       	ldd	r19, Z+1	; 0x01
     9b0:	8d 91       	ld	r24, X+
     9b2:	9c 91       	ld	r25, X
     9b4:	28 1b       	sub	r18, r24
     9b6:	39 0b       	sbc	r19, r25
     9b8:	c9 01       	movw	r24, r18
     9ba:	08 95       	ret

000009bc <process_sensor>:
     9bc:	a0 e0       	ldi	r26, 0x00	; 0
     9be:	b0 e0       	ldi	r27, 0x00	; 0
     9c0:	e4 ee       	ldi	r30, 0xE4	; 228
     9c2:	f4 e0       	ldi	r31, 0x04	; 4
     9c4:	0c 94 e6 1c 	jmp	0x39cc	; 0x39cc <__prologue_saves__+0x8>
     9c8:	78 2e       	mov	r7, r24
     9ca:	f6 2e       	mov	r15, r22
     9cc:	9f de       	rcall	.-706    	; 0x70c <qt_get_sensor_delta>
     9ce:	5c 01       	movw	r10, r24
     9d0:	07 2d       	mov	r16, r7
     9d2:	10 e0       	ldi	r17, 0x00	; 0
     9d4:	f8 01       	movw	r30, r16
     9d6:	ee 0f       	add	r30, r30
     9d8:	ff 1f       	adc	r31, r31
     9da:	e0 0f       	add	r30, r16
     9dc:	f1 1f       	adc	r31, r17
     9de:	ee 0f       	add	r30, r30
     9e0:	ff 1f       	adc	r31, r31
     9e2:	eb 59       	subi	r30, 0x9B	; 155
     9e4:	fe 4d       	sbci	r31, 0xDE	; 222
     9e6:	54 81       	ldd	r21, Z+4	; 0x04
     9e8:	43 81       	ldd	r20, Z+3	; 0x03
     9ea:	24 2f       	mov	r18, r20
     9ec:	30 e0       	ldi	r19, 0x00	; 0
     9ee:	85 2f       	mov	r24, r21
     9f0:	83 70       	andi	r24, 0x03	; 3
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	01 96       	adiw	r24, 0x01	; 1
     9f6:	02 c0       	rjmp	.+4      	; 0x9fc <process_sensor+0x40>
     9f8:	35 95       	asr	r19
     9fa:	27 95       	ror	r18
     9fc:	8a 95       	dec	r24
     9fe:	e2 f7       	brpl	.-8      	; 0x9f8 <process_sensor+0x3c>
     a00:	82 2f       	mov	r24, r18
     a02:	22 30       	cpi	r18, 0x02	; 2
     a04:	08 f4       	brcc	.+2      	; 0xa08 <process_sensor+0x4c>
     a06:	82 e0       	ldi	r24, 0x02	; 2
     a08:	24 2f       	mov	r18, r20
     a0a:	30 e0       	ldi	r19, 0x00	; 0
     a0c:	b9 01       	movw	r22, r18
     a0e:	68 1b       	sub	r22, r24
     a10:	71 09       	sbc	r23, r1
     a12:	f8 01       	movw	r30, r16
     a14:	ee 0f       	add	r30, r30
     a16:	ff 1f       	adc	r31, r31
     a18:	e0 0f       	add	r30, r16
     a1a:	f1 1f       	adc	r31, r17
     a1c:	ef 01       	movw	r28, r30
     a1e:	cc 0f       	add	r28, r28
     a20:	dd 1f       	adc	r29, r29
     a22:	cb 59       	subi	r28, 0x9B	; 155
     a24:	de 4d       	sbci	r29, 0xDE	; 222
     a26:	88 81       	ld	r24, Y
     a28:	84 30       	cpi	r24, 0x04	; 4
     a2a:	09 f4       	brne	.+2      	; 0xa2e <process_sensor+0x72>
     a2c:	fb c0       	rjmp	.+502    	; 0xc24 <process_sensor+0x268>
     a2e:	85 30       	cpi	r24, 0x05	; 5
     a30:	30 f4       	brcc	.+12     	; 0xa3e <process_sensor+0x82>
     a32:	81 30       	cpi	r24, 0x01	; 1
     a34:	71 f0       	breq	.+28     	; 0xa52 <process_sensor+0x96>
     a36:	82 30       	cpi	r24, 0x02	; 2
     a38:	09 f0       	breq	.+2      	; 0xa3c <process_sensor+0x80>
     a3a:	96 c2       	rjmp	.+1324   	; 0xf68 <process_sensor+0x5ac>
     a3c:	6e c0       	rjmp	.+220    	; 0xb1a <process_sensor+0x15e>
     a3e:	80 31       	cpi	r24, 0x10	; 16
     a40:	09 f4       	brne	.+2      	; 0xa44 <process_sensor+0x88>
     a42:	a5 c1       	rjmp	.+842    	; 0xd8e <process_sensor+0x3d2>
     a44:	80 32       	cpi	r24, 0x20	; 32
     a46:	09 f4       	brne	.+2      	; 0xa4a <process_sensor+0x8e>
     a48:	56 c2       	rjmp	.+1196   	; 0xef6 <process_sensor+0x53a>
     a4a:	88 30       	cpi	r24, 0x08	; 8
     a4c:	09 f0       	breq	.+2      	; 0xa50 <process_sensor+0x94>
     a4e:	8c c2       	rjmp	.+1304   	; 0xf68 <process_sensor+0x5ac>
     a50:	02 c2       	rjmp	.+1028   	; 0xe56 <process_sensor+0x49a>
     a52:	40 91 5d 21 	lds	r20, 0x215D
     a56:	50 91 5e 21 	lds	r21, 0x215E
     a5a:	ca 01       	movw	r24, r20
     a5c:	92 60       	ori	r25, 0x02	; 2
     a5e:	80 93 5d 21 	sts	0x215D, r24
     a62:	90 93 5e 21 	sts	0x215E, r25
     a66:	8d 81       	ldd	r24, Y+5	; 0x05
     a68:	69 81       	ldd	r22, Y+1	; 0x01
     a6a:	a8 2f       	mov	r26, r24
     a6c:	b0 e0       	ldi	r27, 0x00	; 0
     a6e:	6a 30       	cpi	r22, 0x0A	; 10
     a70:	60 f0       	brcs	.+24     	; 0xa8a <process_sensor+0xce>
     a72:	aa 0f       	add	r26, r26
     a74:	bb 1f       	adc	r27, r27
     a76:	fd 01       	movw	r30, r26
     a78:	e4 5b       	subi	r30, 0xB4	; 180
     a7a:	fe 4d       	sbci	r31, 0xDE	; 222
     a7c:	80 81       	ld	r24, Z
     a7e:	91 81       	ldd	r25, Z+1	; 0x01
     a80:	ac 5a       	subi	r26, 0xAC	; 172
     a82:	be 4d       	sbci	r27, 0xDE	; 222
     a84:	8d 93       	st	X+, r24
     a86:	9c 93       	st	X, r25
     a88:	18 c0       	rjmp	.+48     	; 0xaba <process_sensor+0xfe>
     a8a:	aa 0f       	add	r26, r26
     a8c:	bb 1f       	adc	r27, r27
     a8e:	fd 01       	movw	r30, r26
     a90:	ec 5a       	subi	r30, 0xAC	; 172
     a92:	fe 4d       	sbci	r31, 0xDE	; 222
     a94:	20 81       	ld	r18, Z
     a96:	31 81       	ldd	r19, Z+1	; 0x01
     a98:	a4 5b       	subi	r26, 0xB4	; 180
     a9a:	be 4d       	sbci	r27, 0xDE	; 222
     a9c:	8d 91       	ld	r24, X+
     a9e:	9c 91       	ld	r25, X
     aa0:	82 17       	cp	r24, r18
     aa2:	93 07       	cpc	r25, r19
     aa4:	18 f4       	brcc	.+6      	; 0xaac <process_sensor+0xf0>
     aa6:	21 50       	subi	r18, 0x01	; 1
     aa8:	30 40       	sbci	r19, 0x00	; 0
     aaa:	05 c0       	rjmp	.+10     	; 0xab6 <process_sensor+0xfa>
     aac:	28 17       	cp	r18, r24
     aae:	39 07       	cpc	r19, r25
     ab0:	50 f4       	brcc	.+20     	; 0xac6 <process_sensor+0x10a>
     ab2:	2f 5f       	subi	r18, 0xFF	; 255
     ab4:	3f 4f       	sbci	r19, 0xFF	; 255
     ab6:	20 83       	st	Z, r18
     ab8:	31 83       	std	Z+1, r19	; 0x01
     aba:	48 60       	ori	r20, 0x08	; 8
     abc:	52 60       	ori	r21, 0x02	; 2
     abe:	40 93 5d 21 	sts	0x215D, r20
     ac2:	50 93 5e 21 	sts	0x215E, r21
     ac6:	86 2f       	mov	r24, r22
     ac8:	81 50       	subi	r24, 0x01	; 1
     aca:	f8 01       	movw	r30, r16
     acc:	ee 0f       	add	r30, r30
     ace:	ff 1f       	adc	r31, r31
     ad0:	e0 0f       	add	r30, r16
     ad2:	f1 1f       	adc	r31, r17
     ad4:	ef 01       	movw	r28, r30
     ad6:	cc 0f       	add	r28, r28
     ad8:	dd 1f       	adc	r29, r29
     ada:	cb 59       	subi	r28, 0x9B	; 155
     adc:	de 4d       	sbci	r29, 0xDE	; 222
     ade:	89 83       	std	Y+1, r24	; 0x01
     ae0:	88 23       	and	r24, r24
     ae2:	b1 f4       	brne	.+44     	; 0xb10 <process_sensor+0x154>
     ae4:	ad 81       	ldd	r26, Y+5	; 0x05
     ae6:	82 e0       	ldi	r24, 0x02	; 2
     ae8:	88 83       	st	Y, r24
     aea:	80 91 5d 21 	lds	r24, 0x215D
     aee:	90 91 5e 21 	lds	r25, 0x215E
     af2:	82 60       	ori	r24, 0x02	; 2
     af4:	80 93 5d 21 	sts	0x215D, r24
     af8:	90 93 5e 21 	sts	0x215E, r25
     afc:	ee 0f       	add	r30, r30
     afe:	ff 1f       	adc	r31, r31
     b00:	e9 59       	subi	r30, 0x99	; 153
     b02:	fe 4d       	sbci	r31, 0xDE	; 222
     b04:	10 82       	st	Z, r1
     b06:	b0 e0       	ldi	r27, 0x00	; 0
     b08:	a1 58       	subi	r26, 0x81	; 129
     b0a:	be 4d       	sbci	r27, 0xDE	; 222
     b0c:	80 e8       	ldi	r24, 0x80	; 128
     b0e:	8c 93       	st	X, r24
     b10:	80 91 47 21 	lds	r24, 0x2147
     b14:	80 93 7e 21 	sts	0x217E, r24
     b18:	25 c2       	rjmp	.+1098   	; 0xf64 <process_sensor+0x5a8>
     b1a:	52 ff       	sbrs	r21, 2
     b1c:	08 c0       	rjmp	.+16     	; 0xb2e <process_sensor+0x172>
     b1e:	ed 81       	ldd	r30, Y+5	; 0x05
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	e1 58       	subi	r30, 0x81	; 129
     b24:	fe 4d       	sbci	r31, 0xDE	; 222
     b26:	10 82       	st	Z, r1
     b28:	80 e2       	ldi	r24, 0x20	; 32
     b2a:	88 83       	st	Y, r24
     b2c:	0c c2       	rjmp	.+1048   	; 0xf46 <process_sensor+0x58a>
     b2e:	c5 01       	movw	r24, r10
     b30:	b7 fe       	sbrs	r11, 7
     b32:	02 c0       	rjmp	.+4      	; 0xb38 <process_sensor+0x17c>
     b34:	80 e0       	ldi	r24, 0x00	; 0
     b36:	90 e0       	ldi	r25, 0x00	; 0
     b38:	82 17       	cp	r24, r18
     b3a:	93 07       	cpc	r25, r19
     b3c:	80 f0       	brcs	.+32     	; 0xb5e <process_sensor+0x1a2>
     b3e:	f8 01       	movw	r30, r16
     b40:	ee 0f       	add	r30, r30
     b42:	ff 1f       	adc	r31, r31
     b44:	e0 0f       	add	r30, r16
     b46:	f1 1f       	adc	r31, r17
     b48:	ee 0f       	add	r30, r30
     b4a:	ff 1f       	adc	r31, r31
     b4c:	df 01       	movw	r26, r30
     b4e:	ab 59       	subi	r26, 0x9B	; 155
     b50:	be 4d       	sbci	r27, 0xDE	; 222
     b52:	84 e0       	ldi	r24, 0x04	; 4
     b54:	8c 93       	st	X, r24
     b56:	e9 59       	subi	r30, 0x99	; 153
     b58:	fe 4d       	sbci	r31, 0xDE	; 222
     b5a:	10 82       	st	Z, r1
     b5c:	fa c1       	rjmp	.+1012   	; 0xf52 <process_sensor+0x596>
     b5e:	ff 20       	and	r15, r15
     b60:	09 f4       	brne	.+2      	; 0xb64 <process_sensor+0x1a8>
     b62:	02 c2       	rjmp	.+1028   	; 0xf68 <process_sensor+0x5ac>
     b64:	80 91 7e 21 	lds	r24, 0x217E
     b68:	88 23       	and	r24, r24
     b6a:	09 f0       	breq	.+2      	; 0xb6e <process_sensor+0x1b2>
     b6c:	fd c1       	rjmp	.+1018   	; 0xf68 <process_sensor+0x5ac>
     b6e:	f8 01       	movw	r30, r16
     b70:	ee 0f       	add	r30, r30
     b72:	ff 1f       	adc	r31, r31
     b74:	e0 0f       	add	r30, r16
     b76:	f1 1f       	adc	r31, r17
     b78:	ee 0f       	add	r30, r30
     b7a:	ff 1f       	adc	r31, r31
     b7c:	eb 59       	subi	r30, 0x9B	; 155
     b7e:	fe 4d       	sbci	r31, 0xDE	; 222
     b80:	85 81       	ldd	r24, Z+5	; 0x05
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	ec 01       	movw	r28, r24
     b86:	cc 0f       	add	r28, r28
     b88:	dd 1f       	adc	r29, r29
     b8a:	cc 5a       	subi	r28, 0xAC	; 172
     b8c:	de 4d       	sbci	r29, 0xDE	; 222
     b8e:	28 81       	ld	r18, Y
     b90:	39 81       	ldd	r19, Y+1	; 0x01
     b92:	fc 01       	movw	r30, r24
     b94:	ee 0f       	add	r30, r30
     b96:	ff 1f       	adc	r31, r31
     b98:	e4 5b       	subi	r30, 0xB4	; 180
     b9a:	fe 4d       	sbci	r31, 0xDE	; 222
     b9c:	01 90       	ld	r0, Z+
     b9e:	f0 81       	ld	r31, Z
     ba0:	e0 2d       	mov	r30, r0
     ba2:	2e 17       	cp	r18, r30
     ba4:	3f 07       	cpc	r19, r31
     ba6:	88 f4       	brcc	.+34     	; 0xbca <process_sensor+0x20e>
     ba8:	fc 01       	movw	r30, r24
     baa:	e1 58       	subi	r30, 0x81	; 129
     bac:	fe 4d       	sbci	r31, 0xDE	; 222
     bae:	90 81       	ld	r25, Z
     bb0:	9f 0d       	add	r25, r15
     bb2:	90 83       	st	Z, r25
     bb4:	80 91 4a 21 	lds	r24, 0x214A
     bb8:	80 58       	subi	r24, 0x80	; 128
     bba:	98 17       	cp	r25, r24
     bbc:	08 f4       	brcc	.+2      	; 0xbc0 <process_sensor+0x204>
     bbe:	d4 c1       	rjmp	.+936    	; 0xf68 <process_sensor+0x5ac>
     bc0:	80 e8       	ldi	r24, 0x80	; 128
     bc2:	80 83       	st	Z, r24
     bc4:	2f 5f       	subi	r18, 0xFF	; 255
     bc6:	3f 4f       	sbci	r19, 0xFF	; 255
     bc8:	14 c0       	rjmp	.+40     	; 0xbf2 <process_sensor+0x236>
     bca:	dc 01       	movw	r26, r24
     bcc:	a1 58       	subi	r26, 0x81	; 129
     bce:	be 4d       	sbci	r27, 0xDE	; 222
     bd0:	e2 17       	cp	r30, r18
     bd2:	f3 07       	cpc	r31, r19
     bd4:	d0 f4       	brcc	.+52     	; 0xc0a <process_sensor+0x24e>
     bd6:	8c 91       	ld	r24, X
     bd8:	8f 19       	sub	r24, r15
     bda:	8c 93       	st	X, r24
     bdc:	40 e8       	ldi	r20, 0x80	; 128
     bde:	90 91 49 21 	lds	r25, 0x2149
     be2:	54 2f       	mov	r21, r20
     be4:	59 1b       	sub	r21, r25
     be6:	58 17       	cp	r21, r24
     be8:	08 f4       	brcc	.+2      	; 0xbec <process_sensor+0x230>
     bea:	be c1       	rjmp	.+892    	; 0xf68 <process_sensor+0x5ac>
     bec:	4c 93       	st	X, r20
     bee:	21 50       	subi	r18, 0x01	; 1
     bf0:	30 40       	sbci	r19, 0x00	; 0
     bf2:	28 83       	st	Y, r18
     bf4:	39 83       	std	Y+1, r19	; 0x01
     bf6:	80 91 5d 21 	lds	r24, 0x215D
     bfa:	90 91 5e 21 	lds	r25, 0x215E
     bfe:	88 60       	ori	r24, 0x08	; 8
     c00:	80 93 5d 21 	sts	0x215D, r24
     c04:	90 93 5e 21 	sts	0x215E, r25
     c08:	af c1       	rjmp	.+862    	; 0xf68 <process_sensor+0x5ac>
     c0a:	2c 91       	ld	r18, X
     c0c:	21 38       	cpi	r18, 0x81	; 129
     c0e:	10 f0       	brcs	.+4      	; 0xc14 <process_sensor+0x258>
     c10:	21 50       	subi	r18, 0x01	; 1
     c12:	2c 93       	st	X, r18
     c14:	fc 01       	movw	r30, r24
     c16:	e1 58       	subi	r30, 0x81	; 129
     c18:	fe 4d       	sbci	r31, 0xDE	; 222
     c1a:	80 81       	ld	r24, Z
     c1c:	87 fd       	sbrc	r24, 7
     c1e:	a4 c1       	rjmp	.+840    	; 0xf68 <process_sensor+0x5ac>
     c20:	8f 5f       	subi	r24, 0xFF	; 255
     c22:	67 c1       	rjmp	.+718    	; 0xef2 <process_sensor+0x536>
     c24:	c5 01       	movw	r24, r10
     c26:	b7 fe       	sbrs	r11, 7
     c28:	02 c0       	rjmp	.+4      	; 0xc2e <process_sensor+0x272>
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	90 e0       	ldi	r25, 0x00	; 0
     c2e:	f8 01       	movw	r30, r16
     c30:	ee 0f       	add	r30, r30
     c32:	ff 1f       	adc	r31, r31
     c34:	82 17       	cp	r24, r18
     c36:	93 07       	cpc	r25, r19
     c38:	08 f4       	brcc	.+2      	; 0xc3c <process_sensor+0x280>
     c3a:	8f c0       	rjmp	.+286    	; 0xd5a <process_sensor+0x39e>
     c3c:	80 91 47 21 	lds	r24, 0x2147
     c40:	80 93 7e 21 	sts	0x217E, r24
     c44:	9f 01       	movw	r18, r30
     c46:	20 0f       	add	r18, r16
     c48:	31 1f       	adc	r19, r17
     c4a:	22 0f       	add	r18, r18
     c4c:	33 1f       	adc	r19, r19
     c4e:	d9 01       	movw	r26, r18
     c50:	a9 59       	subi	r26, 0x99	; 153
     c52:	be 4d       	sbci	r27, 0xDE	; 222
     c54:	8c 91       	ld	r24, X
     c56:	8f 5f       	subi	r24, 0xFF	; 255
     c58:	8c 93       	st	X, r24
     c5a:	f9 01       	movw	r30, r18
     c5c:	eb 59       	subi	r30, 0x9B	; 155
     c5e:	fe 4d       	sbci	r31, 0xDE	; 222
     c60:	84 81       	ldd	r24, Z+4	; 0x04
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	88 73       	andi	r24, 0x38	; 56
     c66:	90 70       	andi	r25, 0x00	; 0
     c68:	23 e0       	ldi	r18, 0x03	; 3
     c6a:	96 95       	lsr	r25
     c6c:	87 95       	ror	r24
     c6e:	2a 95       	dec	r18
     c70:	e1 f7       	brne	.-8      	; 0xc6a <process_sensor+0x2ae>
     c72:	68 2e       	mov	r6, r24
     c74:	88 23       	and	r24, r24
     c76:	09 f4       	brne	.+2      	; 0xc7a <process_sensor+0x2be>
     c78:	3e c0       	rjmp	.+124    	; 0xcf6 <process_sensor+0x33a>
     c7a:	cc 24       	eor	r12, r12
     c7c:	dd 24       	eor	r13, r13
     c7e:	7f 01       	movw	r14, r30
     c80:	83 e0       	ldi	r24, 0x03	; 3
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	e8 0e       	add	r14, r24
     c86:	f9 1e       	adc	r15, r25
     c88:	4d 01       	movw	r8, r26
     c8a:	2f c0       	rjmp	.+94     	; 0xcea <process_sensor+0x32e>
     c8c:	d7 14       	cp	r13, r7
     c8e:	61 f1       	breq	.+88     	; 0xce8 <process_sensor+0x32c>
     c90:	8d 2d       	mov	r24, r13
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	ec 01       	movw	r28, r24
     c96:	cc 0f       	add	r28, r28
     c98:	dd 1f       	adc	r29, r29
     c9a:	c8 0f       	add	r28, r24
     c9c:	d9 1f       	adc	r29, r25
     c9e:	cc 0f       	add	r28, r28
     ca0:	dd 1f       	adc	r29, r29
     ca2:	cb 59       	subi	r28, 0x9B	; 155
     ca4:	de 4d       	sbci	r29, 0xDE	; 222
     ca6:	8c 81       	ldd	r24, Y+4	; 0x04
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	88 73       	andi	r24, 0x38	; 56
     cac:	90 70       	andi	r25, 0x00	; 0
     cae:	73 e0       	ldi	r23, 0x03	; 3
     cb0:	96 95       	lsr	r25
     cb2:	87 95       	ror	r24
     cb4:	7a 95       	dec	r23
     cb6:	e1 f7       	brne	.-8      	; 0xcb0 <process_sensor+0x2f4>
     cb8:	68 16       	cp	r6, r24
     cba:	b1 f4       	brne	.+44     	; 0xce8 <process_sensor+0x32c>
     cbc:	8d 2d       	mov	r24, r13
     cbe:	26 dd       	rcall	.-1460   	; 0x70c <qt_get_sensor_delta>
     cc0:	2b 81       	ldd	r18, Y+3	; 0x03
     cc2:	82 1b       	sub	r24, r18
     cc4:	91 09       	sbc	r25, r1
     cc6:	f7 01       	movw	r30, r14
     cc8:	20 81       	ld	r18, Z
     cca:	a5 01       	movw	r20, r10
     ccc:	42 1b       	sub	r20, r18
     cce:	51 09       	sbc	r21, r1
     cd0:	48 17       	cp	r20, r24
     cd2:	59 07       	cpc	r21, r25
     cd4:	2c f0       	brlt	.+10     	; 0xce0 <process_sensor+0x324>
     cd6:	88 81       	ld	r24, Y
     cd8:	80 31       	cpi	r24, 0x10	; 16
     cda:	11 f0       	breq	.+4      	; 0xce0 <process_sensor+0x324>
     cdc:	88 30       	cpi	r24, 0x08	; 8
     cde:	21 f4       	brne	.+8      	; 0xce8 <process_sensor+0x32c>
     ce0:	f4 01       	movw	r30, r8
     ce2:	10 82       	st	Z, r1
     ce4:	cc 24       	eor	r12, r12
     ce6:	c3 94       	inc	r12
     ce8:	d3 94       	inc	r13
     cea:	80 91 7d 21 	lds	r24, 0x217D
     cee:	d8 16       	cp	r13, r24
     cf0:	68 f2       	brcs	.-102    	; 0xc8c <process_sensor+0x2d0>
     cf2:	cc 20       	and	r12, r12
     cf4:	79 f4       	brne	.+30     	; 0xd14 <process_sensor+0x358>
     cf6:	80 91 46 21 	lds	r24, 0x2146
     cfa:	88 23       	and	r24, r24
     cfc:	59 f0       	breq	.+22     	; 0xd14 <process_sensor+0x358>
     cfe:	80 91 5d 21 	lds	r24, 0x215D
     d02:	90 91 5e 21 	lds	r25, 0x215E
     d06:	98 60       	ori	r25, 0x08	; 8
     d08:	80 93 5d 21 	sts	0x215D, r24
     d0c:	90 93 5e 21 	sts	0x215E, r25
     d10:	41 e0       	ldi	r20, 0x01	; 1
     d12:	01 c0       	rjmp	.+2      	; 0xd16 <process_sensor+0x35a>
     d14:	40 e0       	ldi	r20, 0x00	; 0
     d16:	98 01       	movw	r18, r16
     d18:	22 0f       	add	r18, r18
     d1a:	33 1f       	adc	r19, r19
     d1c:	20 0f       	add	r18, r16
     d1e:	31 1f       	adc	r19, r17
     d20:	f9 01       	movw	r30, r18
     d22:	ee 0f       	add	r30, r30
     d24:	ff 1f       	adc	r31, r31
     d26:	e9 59       	subi	r30, 0x99	; 153
     d28:	fe 4d       	sbci	r31, 0xDE	; 222
     d2a:	90 81       	ld	r25, Z
     d2c:	80 91 46 21 	lds	r24, 0x2146
     d30:	98 17       	cp	r25, r24
     d32:	08 f4       	brcc	.+2      	; 0xd36 <process_sensor+0x37a>
     d34:	1a c1       	rjmp	.+564    	; 0xf6a <process_sensor+0x5ae>
     d36:	80 91 5d 21 	lds	r24, 0x215D
     d3a:	90 91 5e 21 	lds	r25, 0x215E
     d3e:	83 60       	ori	r24, 0x03	; 3
     d40:	80 93 5d 21 	sts	0x215D, r24
     d44:	90 93 5e 21 	sts	0x215E, r25
     d48:	f9 01       	movw	r30, r18
     d4a:	ee 0f       	add	r30, r30
     d4c:	ff 1f       	adc	r31, r31
     d4e:	eb 59       	subi	r30, 0x9B	; 155
     d50:	fe 4d       	sbci	r31, 0xDE	; 222
     d52:	80 e1       	ldi	r24, 0x10	; 16
     d54:	80 83       	st	Z, r24
     d56:	11 82       	std	Z+1, r1	; 0x01
     d58:	08 c1       	rjmp	.+528    	; 0xf6a <process_sensor+0x5ae>
     d5a:	e0 0f       	add	r30, r16
     d5c:	f1 1f       	adc	r31, r17
     d5e:	ee 0f       	add	r30, r30
     d60:	ff 1f       	adc	r31, r31
     d62:	df 01       	movw	r26, r30
     d64:	ab 59       	subi	r26, 0x9B	; 155
     d66:	be 4d       	sbci	r27, 0xDE	; 222
     d68:	15 96       	adiw	r26, 0x05	; 5
     d6a:	2c 91       	ld	r18, X
     d6c:	15 97       	sbiw	r26, 0x05	; 5
     d6e:	82 e0       	ldi	r24, 0x02	; 2
     d70:	8c 93       	st	X, r24
     d72:	80 91 5d 21 	lds	r24, 0x215D
     d76:	90 91 5e 21 	lds	r25, 0x215E
     d7a:	82 60       	ori	r24, 0x02	; 2
     d7c:	80 93 5d 21 	sts	0x215D, r24
     d80:	90 93 5e 21 	sts	0x215E, r25
     d84:	e9 59       	subi	r30, 0x99	; 153
     d86:	fe 4d       	sbci	r31, 0xDE	; 222
     d88:	10 82       	st	Z, r1
     d8a:	e2 2f       	mov	r30, r18
     d8c:	ae c0       	rjmp	.+348    	; 0xeea <process_sensor+0x52e>
     d8e:	52 ff       	sbrs	r21, 2
     d90:	0e c0       	rjmp	.+28     	; 0xdae <process_sensor+0x3f2>
     d92:	ed 81       	ldd	r30, Y+5	; 0x05
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	e1 58       	subi	r30, 0x81	; 129
     d98:	fe 4d       	sbci	r31, 0xDE	; 222
     d9a:	80 e8       	ldi	r24, 0x80	; 128
     d9c:	80 83       	st	Z, r24
     d9e:	80 e2       	ldi	r24, 0x20	; 32
     da0:	88 83       	st	Y, r24
     da2:	80 91 5d 21 	lds	r24, 0x215D
     da6:	90 91 5e 21 	lds	r25, 0x215E
     daa:	90 61       	ori	r25, 0x10	; 16
     dac:	4a c0       	rjmp	.+148    	; 0xe42 <process_sensor+0x486>
     dae:	c5 01       	movw	r24, r10
     db0:	b7 fe       	sbrs	r11, 7
     db2:	02 c0       	rjmp	.+4      	; 0xdb8 <process_sensor+0x3fc>
     db4:	80 e0       	ldi	r24, 0x00	; 0
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	f8 01       	movw	r30, r16
     dba:	ee 0f       	add	r30, r30
     dbc:	ff 1f       	adc	r31, r31
     dbe:	40 91 5d 21 	lds	r20, 0x215D
     dc2:	50 91 5e 21 	lds	r21, 0x215E
     dc6:	86 17       	cp	r24, r22
     dc8:	97 07       	cpc	r25, r23
     dca:	70 f4       	brcc	.+28     	; 0xde8 <process_sensor+0x42c>
     dcc:	e0 0f       	add	r30, r16
     dce:	f1 1f       	adc	r31, r17
     dd0:	ee 0f       	add	r30, r30
     dd2:	ff 1f       	adc	r31, r31
     dd4:	eb 59       	subi	r30, 0x9B	; 155
     dd6:	fe 4d       	sbci	r31, 0xDE	; 222
     dd8:	88 e0       	ldi	r24, 0x08	; 8
     dda:	80 83       	st	Z, r24
     ddc:	54 60       	ori	r21, 0x04	; 4
     dde:	40 93 5d 21 	sts	0x215D, r20
     de2:	50 93 5e 21 	sts	0x215E, r21
     de6:	31 c0       	rjmp	.+98     	; 0xe4a <process_sensor+0x48e>
     de8:	41 60       	ori	r20, 0x01	; 1
     dea:	40 93 5d 21 	sts	0x215D, r20
     dee:	50 93 5e 21 	sts	0x215E, r21
     df2:	e0 0f       	add	r30, r16
     df4:	f1 1f       	adc	r31, r17
     df6:	ee 0f       	add	r30, r30
     df8:	ff 1f       	adc	r31, r31
     dfa:	e9 59       	subi	r30, 0x99	; 153
     dfc:	fe 4d       	sbci	r31, 0xDE	; 222
     dfe:	90 81       	ld	r25, Z
     e00:	80 91 46 21 	lds	r24, 0x2146
     e04:	98 17       	cp	r25, r24
     e06:	10 f4       	brcc	.+4      	; 0xe0c <process_sensor+0x450>
     e08:	9f 5f       	subi	r25, 0xFF	; 255
     e0a:	90 83       	st	Z, r25
     e0c:	90 91 48 21 	lds	r25, 0x2148
     e10:	99 23       	and	r25, r25
     e12:	71 f0       	breq	.+28     	; 0xe30 <process_sensor+0x474>
     e14:	f8 01       	movw	r30, r16
     e16:	ee 0f       	add	r30, r30
     e18:	ff 1f       	adc	r31, r31
     e1a:	e0 0f       	add	r30, r16
     e1c:	f1 1f       	adc	r31, r17
     e1e:	ee 0f       	add	r30, r30
     e20:	ff 1f       	adc	r31, r31
     e22:	eb 59       	subi	r30, 0x9B	; 155
     e24:	fe 4d       	sbci	r31, 0xDE	; 222
     e26:	81 81       	ldd	r24, Z+1	; 0x01
     e28:	89 17       	cp	r24, r25
     e2a:	20 f4       	brcc	.+8      	; 0xe34 <process_sensor+0x478>
     e2c:	8f 0d       	add	r24, r15
     e2e:	81 83       	std	Z+1, r24	; 0x01
     e30:	40 e0       	ldi	r20, 0x00	; 0
     e32:	0c c0       	rjmp	.+24     	; 0xe4c <process_sensor+0x490>
     e34:	87 2d       	mov	r24, r7
     e36:	81 dd       	rcall	.-1278   	; 0x93a <start_cal_sensor>
     e38:	80 91 5d 21 	lds	r24, 0x215D
     e3c:	90 91 5e 21 	lds	r25, 0x215E
     e40:	92 60       	ori	r25, 0x02	; 2
     e42:	80 93 5d 21 	sts	0x215D, r24
     e46:	90 93 5e 21 	sts	0x215E, r25
     e4a:	41 e0       	ldi	r20, 0x01	; 1
     e4c:	80 91 47 21 	lds	r24, 0x2147
     e50:	80 93 7e 21 	sts	0x217E, r24
     e54:	8a c0       	rjmp	.+276    	; 0xf6a <process_sensor+0x5ae>
     e56:	80 91 47 21 	lds	r24, 0x2147
     e5a:	80 93 7e 21 	sts	0x217E, r24
     e5e:	df 01       	movw	r26, r30
     e60:	aa 0f       	add	r26, r26
     e62:	bb 1f       	adc	r27, r27
     e64:	a9 59       	subi	r26, 0x99	; 153
     e66:	be 4d       	sbci	r27, 0xDE	; 222
     e68:	8c 91       	ld	r24, X
     e6a:	88 23       	and	r24, r24
     e6c:	89 f1       	breq	.+98     	; 0xed0 <process_sensor+0x514>
     e6e:	c5 01       	movw	r24, r10
     e70:	b7 fe       	sbrs	r11, 7
     e72:	02 c0       	rjmp	.+4      	; 0xe78 <process_sensor+0x4bc>
     e74:	80 e0       	ldi	r24, 0x00	; 0
     e76:	90 e0       	ldi	r25, 0x00	; 0
     e78:	40 91 5d 21 	lds	r20, 0x215D
     e7c:	50 91 5e 21 	lds	r21, 0x215E
     e80:	68 17       	cp	r22, r24
     e82:	79 07       	cpc	r23, r25
     e84:	90 f4       	brcc	.+36     	; 0xeaa <process_sensor+0x4ee>
     e86:	f8 01       	movw	r30, r16
     e88:	ee 0f       	add	r30, r30
     e8a:	ff 1f       	adc	r31, r31
     e8c:	e0 0f       	add	r30, r16
     e8e:	f1 1f       	adc	r31, r17
     e90:	ee 0f       	add	r30, r30
     e92:	ff 1f       	adc	r31, r31
     e94:	eb 59       	subi	r30, 0x9B	; 155
     e96:	fe 4d       	sbci	r31, 0xDE	; 222
     e98:	80 e1       	ldi	r24, 0x10	; 16
     e9a:	80 83       	st	Z, r24
     e9c:	41 60       	ori	r20, 0x01	; 1
     e9e:	40 93 5d 21 	sts	0x215D, r20
     ea2:	50 93 5e 21 	sts	0x215E, r21
     ea6:	40 e0       	ldi	r20, 0x00	; 0
     ea8:	06 c0       	rjmp	.+12     	; 0xeb6 <process_sensor+0x4fa>
     eaa:	54 60       	ori	r21, 0x04	; 4
     eac:	40 93 5d 21 	sts	0x215D, r20
     eb0:	50 93 5e 21 	sts	0x215E, r21
     eb4:	41 e0       	ldi	r20, 0x01	; 1
     eb6:	f8 01       	movw	r30, r16
     eb8:	ee 0f       	add	r30, r30
     eba:	ff 1f       	adc	r31, r31
     ebc:	e0 0f       	add	r30, r16
     ebe:	f1 1f       	adc	r31, r17
     ec0:	ee 0f       	add	r30, r30
     ec2:	ff 1f       	adc	r31, r31
     ec4:	e9 59       	subi	r30, 0x99	; 153
     ec6:	fe 4d       	sbci	r31, 0xDE	; 222
     ec8:	80 81       	ld	r24, Z
     eca:	81 50       	subi	r24, 0x01	; 1
     ecc:	80 83       	st	Z, r24
     ece:	4d c0       	rjmp	.+154    	; 0xf6a <process_sensor+0x5ae>
     ed0:	ed 81       	ldd	r30, Y+5	; 0x05
     ed2:	82 e0       	ldi	r24, 0x02	; 2
     ed4:	88 83       	st	Y, r24
     ed6:	80 91 5d 21 	lds	r24, 0x215D
     eda:	90 91 5e 21 	lds	r25, 0x215E
     ede:	82 60       	ori	r24, 0x02	; 2
     ee0:	80 93 5d 21 	sts	0x215D, r24
     ee4:	90 93 5e 21 	sts	0x215E, r25
     ee8:	1c 92       	st	X, r1
     eea:	f0 e0       	ldi	r31, 0x00	; 0
     eec:	e1 58       	subi	r30, 0x81	; 129
     eee:	fe 4d       	sbci	r31, 0xDE	; 222
     ef0:	80 e8       	ldi	r24, 0x80	; 128
     ef2:	80 83       	st	Z, r24
     ef4:	39 c0       	rjmp	.+114    	; 0xf68 <process_sensor+0x5ac>
     ef6:	8d 81       	ldd	r24, Y+5	; 0x05
     ef8:	a8 2f       	mov	r26, r24
     efa:	b0 e0       	ldi	r27, 0x00	; 0
     efc:	a1 58       	subi	r26, 0x81	; 129
     efe:	be 4d       	sbci	r27, 0xDE	; 222
     f00:	9c 91       	ld	r25, X
     f02:	9f 5f       	subi	r25, 0xFF	; 255
     f04:	9c 93       	st	X, r25
     f06:	52 fd       	sbrc	r21, 2
     f08:	18 c0       	rjmp	.+48     	; 0xf3a <process_sensor+0x57e>
     f0a:	97 ff       	sbrs	r25, 7
     f0c:	03 c0       	rjmp	.+6      	; 0xf14 <process_sensor+0x558>
     f0e:	80 e1       	ldi	r24, 0x10	; 16
     f10:	88 83       	st	Y, r24
     f12:	2a c0       	rjmp	.+84     	; 0xf68 <process_sensor+0x5ac>
     f14:	82 e0       	ldi	r24, 0x02	; 2
     f16:	88 83       	st	Y, r24
     f18:	80 91 5d 21 	lds	r24, 0x215D
     f1c:	90 91 5e 21 	lds	r25, 0x215E
     f20:	82 60       	ori	r24, 0x02	; 2
     f22:	80 93 5d 21 	sts	0x215D, r24
     f26:	90 93 5e 21 	sts	0x215E, r25
     f2a:	ee 0f       	add	r30, r30
     f2c:	ff 1f       	adc	r31, r31
     f2e:	e9 59       	subi	r30, 0x99	; 153
     f30:	fe 4d       	sbci	r31, 0xDE	; 222
     f32:	10 82       	st	Z, r1
     f34:	80 e8       	ldi	r24, 0x80	; 128
     f36:	8c 93       	st	X, r24
     f38:	17 c0       	rjmp	.+46     	; 0xf68 <process_sensor+0x5ac>
     f3a:	80 91 4b 21 	lds	r24, 0x214B
     f3e:	98 17       	cp	r25, r24
     f40:	40 f0       	brcs	.+16     	; 0xf52 <process_sensor+0x596>
     f42:	87 2d       	mov	r24, r7
     f44:	fa dc       	rcall	.-1548   	; 0x93a <start_cal_sensor>
     f46:	80 91 5d 21 	lds	r24, 0x215D
     f4a:	90 91 5e 21 	lds	r25, 0x215E
     f4e:	90 61       	ori	r25, 0x10	; 16
     f50:	05 c0       	rjmp	.+10     	; 0xf5c <process_sensor+0x5a0>
     f52:	80 91 5d 21 	lds	r24, 0x215D
     f56:	90 91 5e 21 	lds	r25, 0x215E
     f5a:	94 60       	ori	r25, 0x04	; 4
     f5c:	80 93 5d 21 	sts	0x215D, r24
     f60:	90 93 5e 21 	sts	0x215E, r25
     f64:	41 e0       	ldi	r20, 0x01	; 1
     f66:	01 c0       	rjmp	.+2      	; 0xf6a <process_sensor+0x5ae>
     f68:	40 e0       	ldi	r20, 0x00	; 0
     f6a:	84 2f       	mov	r24, r20
     f6c:	cd b7       	in	r28, 0x3d	; 61
     f6e:	de b7       	in	r29, 0x3e	; 62
     f70:	ee e0       	ldi	r30, 0x0E	; 14
     f72:	0c 94 ff 1c 	jmp	0x39fe	; 0x39fe <__epilogue_restores__+0x8>

00000f76 <burst_init>:
     f76:	fc 01       	movw	r30, r24
     f78:	00 97       	sbiw	r24, 0x00	; 0
     f7a:	09 f0       	breq	.+2      	; 0xf7e <burst_init+0x8>
     f7c:	19 95       	eicall
     f7e:	08 95       	ret

00000f80 <burst_reset>:
     f80:	10 92 83 21 	sts	0x2183, r1
     f84:	10 92 84 21 	sts	0x2184, r1
     f88:	10 92 87 21 	sts	0x2187, r1
     f8c:	10 92 88 21 	sts	0x2188, r1
     f90:	10 92 85 21 	sts	0x2185, r1
     f94:	10 92 86 21 	sts	0x2186, r1
     f98:	10 92 89 21 	sts	0x2189, r1
     f9c:	10 92 8a 21 	sts	0x218A, r1
     fa0:	08 95       	ret

00000fa2 <burst>:
     fa2:	80 91 85 21 	lds	r24, 0x2185
     fa6:	90 91 83 21 	lds	r25, 0x2183
     faa:	89 2b       	or	r24, r25
     fac:	41 f0       	breq	.+16     	; 0xfbe <burst+0x1c>
     fae:	e0 91 43 21 	lds	r30, 0x2143
     fb2:	f0 91 44 21 	lds	r31, 0x2144
     fb6:	30 97       	sbiw	r30, 0x00	; 0
     fb8:	11 f0       	breq	.+4      	; 0xfbe <burst+0x1c>
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	19 95       	eicall
     fbe:	80 91 86 21 	lds	r24, 0x2186
     fc2:	90 91 84 21 	lds	r25, 0x2184
     fc6:	89 2b       	or	r24, r25
     fc8:	41 f0       	breq	.+16     	; 0xfda <burst+0x38>
     fca:	e0 91 43 21 	lds	r30, 0x2143
     fce:	f0 91 44 21 	lds	r31, 0x2144
     fd2:	30 97       	sbiw	r30, 0x00	; 0
     fd4:	11 f0       	breq	.+4      	; 0xfda <burst+0x38>
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	19 95       	eicall
     fda:	08 95       	ret

00000fdc <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     fdc:	bf 92       	push	r11
     fde:	cf 92       	push	r12
     fe0:	df 92       	push	r13
     fe2:	ef 92       	push	r14
     fe4:	ff 92       	push	r15
     fe6:	0f 93       	push	r16
     fe8:	1f 93       	push	r17
     fea:	cf 93       	push	r28
     fec:	df 93       	push	r29
     fee:	1f 92       	push	r1
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     ff4:	88 e0       	ldi	r24, 0x08	; 8
     ff6:	e0 e0       	ldi	r30, 0x00	; 0
     ff8:	f6 e0       	ldi	r31, 0x06	; 6
     ffa:	86 83       	std	Z+6, r24	; 0x06
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     ffc:	85 83       	std	Z+5, r24	; 0x05
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     ffe:	0f 2e       	mov	r0, r31
    1000:	fb e2       	ldi	r31, 0x2B	; 43
    1002:	bf 2e       	mov	r11, r31
    1004:	f0 2d       	mov	r31, r0
    1006:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
    1008:	80 ea       	ldi	r24, 0xA0	; 160
    100a:	99 e0       	ldi	r25, 0x09	; 9
    100c:	0e 94 2e 11 	call	0x225c	; 0x225c <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
    1010:	c1 2c       	mov	r12, r1
    1012:	d1 2c       	mov	r13, r1
    1014:	76 01       	movw	r14, r12
    1016:	00 e4       	ldi	r16, 0x40	; 64
    1018:	12 e4       	ldi	r17, 0x42	; 66
    101a:	2f e0       	ldi	r18, 0x0F	; 15
    101c:	30 e0       	ldi	r19, 0x00	; 0
    101e:	43 e0       	ldi	r20, 0x03	; 3
    1020:	be 01       	movw	r22, r28
    1022:	6f 5f       	subi	r22, 0xFF	; 255
    1024:	7f 4f       	sbci	r23, 0xFF	; 255
    1026:	80 ea       	ldi	r24, 0xA0	; 160
    1028:	99 e0       	ldi	r25, 0x09	; 9
    102a:	0e 94 5d 11 	call	0x22ba	; 0x22ba <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    102e:	00 e6       	ldi	r16, 0x60	; 96
    1030:	16 e0       	ldi	r17, 0x06	; 6
    1032:	ff 24       	eor	r15, r15
    1034:	f3 94       	inc	r15
    1036:	f8 01       	movw	r30, r16
    1038:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    103a:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    103c:	be 01       	movw	r22, r28
    103e:	6f 5f       	subi	r22, 0xFF	; 255
    1040:	7f 4f       	sbci	r23, 0xFF	; 255
    1042:	80 ea       	ldi	r24, 0xA0	; 160
    1044:	99 e0       	ldi	r25, 0x09	; 9
    1046:	0e 94 77 11 	call	0x22ee	; 0x22ee <usart_spi_select_device>
    104a:	f8 01       	movw	r30, r16
    104c:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    104e:	e0 ea       	ldi	r30, 0xA0	; 160
    1050:	f9 e0       	ldi	r31, 0x09	; 9
    1052:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1054:	85 ff       	sbrs	r24, 5
    1056:	fd cf       	rjmp	.-6      	; 0x1052 <st7565r_init+0x76>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1058:	80 ea       	ldi	r24, 0xA0	; 160
    105a:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    105e:	e0 ea       	ldi	r30, 0xA0	; 160
    1060:	f9 e0       	ldi	r31, 0x09	; 9
    1062:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1064:	86 ff       	sbrs	r24, 6
    1066:	fd cf       	rjmp	.-6      	; 0x1062 <st7565r_init+0x86>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1068:	e0 ea       	ldi	r30, 0xA0	; 160
    106a:	f9 e0       	ldi	r31, 0x09	; 9
    106c:	80 e4       	ldi	r24, 0x40	; 64
    106e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1070:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1072:	be 01       	movw	r22, r28
    1074:	6f 5f       	subi	r22, 0xFF	; 255
    1076:	7f 4f       	sbci	r23, 0xFF	; 255
    1078:	80 ea       	ldi	r24, 0xA0	; 160
    107a:	99 e0       	ldi	r25, 0x09	; 9
    107c:	0e 94 8d 11 	call	0x231a	; 0x231a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1080:	8b e2       	ldi	r24, 0x2B	; 43
    1082:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1084:	be 01       	movw	r22, r28
    1086:	6f 5f       	subi	r22, 0xFF	; 255
    1088:	7f 4f       	sbci	r23, 0xFF	; 255
    108a:	80 ea       	ldi	r24, 0xA0	; 160
    108c:	99 e0       	ldi	r25, 0x09	; 9
    108e:	0e 94 77 11 	call	0x22ee	; 0x22ee <usart_spi_select_device>
    1092:	81 e0       	ldi	r24, 0x01	; 1
    1094:	e0 e6       	ldi	r30, 0x60	; 96
    1096:	f6 e0       	ldi	r31, 0x06	; 6
    1098:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    109a:	e0 ea       	ldi	r30, 0xA0	; 160
    109c:	f9 e0       	ldi	r31, 0x09	; 9
    109e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    10a0:	85 ff       	sbrs	r24, 5
    10a2:	fd cf       	rjmp	.-6      	; 0x109e <st7565r_init+0xc2>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    10a4:	86 ea       	ldi	r24, 0xA6	; 166
    10a6:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    10aa:	e0 ea       	ldi	r30, 0xA0	; 160
    10ac:	f9 e0       	ldi	r31, 0x09	; 9
    10ae:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    10b0:	86 ff       	sbrs	r24, 6
    10b2:	fd cf       	rjmp	.-6      	; 0x10ae <st7565r_init+0xd2>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    10b4:	e0 ea       	ldi	r30, 0xA0	; 160
    10b6:	f9 e0       	ldi	r31, 0x09	; 9
    10b8:	80 e4       	ldi	r24, 0x40	; 64
    10ba:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    10bc:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    10be:	be 01       	movw	r22, r28
    10c0:	6f 5f       	subi	r22, 0xFF	; 255
    10c2:	7f 4f       	sbci	r23, 0xFF	; 255
    10c4:	80 ea       	ldi	r24, 0xA0	; 160
    10c6:	99 e0       	ldi	r25, 0x09	; 9
    10c8:	0e 94 8d 11 	call	0x231a	; 0x231a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    10cc:	8b e2       	ldi	r24, 0x2B	; 43
    10ce:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    10d0:	be 01       	movw	r22, r28
    10d2:	6f 5f       	subi	r22, 0xFF	; 255
    10d4:	7f 4f       	sbci	r23, 0xFF	; 255
    10d6:	80 ea       	ldi	r24, 0xA0	; 160
    10d8:	99 e0       	ldi	r25, 0x09	; 9
    10da:	0e 94 77 11 	call	0x22ee	; 0x22ee <usart_spi_select_device>
    10de:	81 e0       	ldi	r24, 0x01	; 1
    10e0:	e0 e6       	ldi	r30, 0x60	; 96
    10e2:	f6 e0       	ldi	r31, 0x06	; 6
    10e4:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    10e6:	e0 ea       	ldi	r30, 0xA0	; 160
    10e8:	f9 e0       	ldi	r31, 0x09	; 9
    10ea:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    10ec:	85 ff       	sbrs	r24, 5
    10ee:	fd cf       	rjmp	.-6      	; 0x10ea <st7565r_init+0x10e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    10f0:	88 ec       	ldi	r24, 0xC8	; 200
    10f2:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    10f6:	e0 ea       	ldi	r30, 0xA0	; 160
    10f8:	f9 e0       	ldi	r31, 0x09	; 9
    10fa:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    10fc:	86 ff       	sbrs	r24, 6
    10fe:	fd cf       	rjmp	.-6      	; 0x10fa <st7565r_init+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1100:	e0 ea       	ldi	r30, 0xA0	; 160
    1102:	f9 e0       	ldi	r31, 0x09	; 9
    1104:	80 e4       	ldi	r24, 0x40	; 64
    1106:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1108:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    110a:	be 01       	movw	r22, r28
    110c:	6f 5f       	subi	r22, 0xFF	; 255
    110e:	7f 4f       	sbci	r23, 0xFF	; 255
    1110:	80 ea       	ldi	r24, 0xA0	; 160
    1112:	99 e0       	ldi	r25, 0x09	; 9
    1114:	0e 94 8d 11 	call	0x231a	; 0x231a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1118:	8b e2       	ldi	r24, 0x2B	; 43
    111a:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    111c:	be 01       	movw	r22, r28
    111e:	6f 5f       	subi	r22, 0xFF	; 255
    1120:	7f 4f       	sbci	r23, 0xFF	; 255
    1122:	80 ea       	ldi	r24, 0xA0	; 160
    1124:	99 e0       	ldi	r25, 0x09	; 9
    1126:	0e 94 77 11 	call	0x22ee	; 0x22ee <usart_spi_select_device>
    112a:	81 e0       	ldi	r24, 0x01	; 1
    112c:	e0 e6       	ldi	r30, 0x60	; 96
    112e:	f6 e0       	ldi	r31, 0x06	; 6
    1130:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1132:	e0 ea       	ldi	r30, 0xA0	; 160
    1134:	f9 e0       	ldi	r31, 0x09	; 9
    1136:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1138:	85 ff       	sbrs	r24, 5
    113a:	fd cf       	rjmp	.-6      	; 0x1136 <st7565r_init+0x15a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    113c:	82 ea       	ldi	r24, 0xA2	; 162
    113e:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1142:	e0 ea       	ldi	r30, 0xA0	; 160
    1144:	f9 e0       	ldi	r31, 0x09	; 9
    1146:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1148:	86 ff       	sbrs	r24, 6
    114a:	fd cf       	rjmp	.-6      	; 0x1146 <st7565r_init+0x16a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    114c:	e0 ea       	ldi	r30, 0xA0	; 160
    114e:	f9 e0       	ldi	r31, 0x09	; 9
    1150:	80 e4       	ldi	r24, 0x40	; 64
    1152:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1154:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1156:	be 01       	movw	r22, r28
    1158:	6f 5f       	subi	r22, 0xFF	; 255
    115a:	7f 4f       	sbci	r23, 0xFF	; 255
    115c:	80 ea       	ldi	r24, 0xA0	; 160
    115e:	99 e0       	ldi	r25, 0x09	; 9
    1160:	0e 94 8d 11 	call	0x231a	; 0x231a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1164:	8b e2       	ldi	r24, 0x2B	; 43
    1166:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1168:	be 01       	movw	r22, r28
    116a:	6f 5f       	subi	r22, 0xFF	; 255
    116c:	7f 4f       	sbci	r23, 0xFF	; 255
    116e:	80 ea       	ldi	r24, 0xA0	; 160
    1170:	99 e0       	ldi	r25, 0x09	; 9
    1172:	0e 94 77 11 	call	0x22ee	; 0x22ee <usart_spi_select_device>
    1176:	81 e0       	ldi	r24, 0x01	; 1
    1178:	e0 e6       	ldi	r30, 0x60	; 96
    117a:	f6 e0       	ldi	r31, 0x06	; 6
    117c:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    117e:	e0 ea       	ldi	r30, 0xA0	; 160
    1180:	f9 e0       	ldi	r31, 0x09	; 9
    1182:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1184:	85 ff       	sbrs	r24, 5
    1186:	fd cf       	rjmp	.-6      	; 0x1182 <st7565r_init+0x1a6>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1188:	8f e2       	ldi	r24, 0x2F	; 47
    118a:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    118e:	e0 ea       	ldi	r30, 0xA0	; 160
    1190:	f9 e0       	ldi	r31, 0x09	; 9
    1192:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1194:	86 ff       	sbrs	r24, 6
    1196:	fd cf       	rjmp	.-6      	; 0x1192 <st7565r_init+0x1b6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1198:	e0 ea       	ldi	r30, 0xA0	; 160
    119a:	f9 e0       	ldi	r31, 0x09	; 9
    119c:	80 e4       	ldi	r24, 0x40	; 64
    119e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    11a0:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    11a2:	be 01       	movw	r22, r28
    11a4:	6f 5f       	subi	r22, 0xFF	; 255
    11a6:	7f 4f       	sbci	r23, 0xFF	; 255
    11a8:	80 ea       	ldi	r24, 0xA0	; 160
    11aa:	99 e0       	ldi	r25, 0x09	; 9
    11ac:	0e 94 8d 11 	call	0x231a	; 0x231a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    11b0:	8b e2       	ldi	r24, 0x2B	; 43
    11b2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    11b4:	be 01       	movw	r22, r28
    11b6:	6f 5f       	subi	r22, 0xFF	; 255
    11b8:	7f 4f       	sbci	r23, 0xFF	; 255
    11ba:	80 ea       	ldi	r24, 0xA0	; 160
    11bc:	99 e0       	ldi	r25, 0x09	; 9
    11be:	0e 94 77 11 	call	0x22ee	; 0x22ee <usart_spi_select_device>
    11c2:	81 e0       	ldi	r24, 0x01	; 1
    11c4:	e0 e6       	ldi	r30, 0x60	; 96
    11c6:	f6 e0       	ldi	r31, 0x06	; 6
    11c8:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    11ca:	e0 ea       	ldi	r30, 0xA0	; 160
    11cc:	f9 e0       	ldi	r31, 0x09	; 9
    11ce:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    11d0:	85 ff       	sbrs	r24, 5
    11d2:	fd cf       	rjmp	.-6      	; 0x11ce <st7565r_init+0x1f2>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    11d4:	88 ef       	ldi	r24, 0xF8	; 248
    11d6:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    11da:	e0 ea       	ldi	r30, 0xA0	; 160
    11dc:	f9 e0       	ldi	r31, 0x09	; 9
    11de:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    11e0:	86 ff       	sbrs	r24, 6
    11e2:	fd cf       	rjmp	.-6      	; 0x11de <st7565r_init+0x202>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    11e4:	e0 ea       	ldi	r30, 0xA0	; 160
    11e6:	f9 e0       	ldi	r31, 0x09	; 9
    11e8:	80 e4       	ldi	r24, 0x40	; 64
    11ea:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    11ec:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    11ee:	be 01       	movw	r22, r28
    11f0:	6f 5f       	subi	r22, 0xFF	; 255
    11f2:	7f 4f       	sbci	r23, 0xFF	; 255
    11f4:	80 ea       	ldi	r24, 0xA0	; 160
    11f6:	99 e0       	ldi	r25, 0x09	; 9
    11f8:	0e 94 8d 11 	call	0x231a	; 0x231a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    11fc:	8b e2       	ldi	r24, 0x2B	; 43
    11fe:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1200:	be 01       	movw	r22, r28
    1202:	6f 5f       	subi	r22, 0xFF	; 255
    1204:	7f 4f       	sbci	r23, 0xFF	; 255
    1206:	80 ea       	ldi	r24, 0xA0	; 160
    1208:	99 e0       	ldi	r25, 0x09	; 9
    120a:	0e 94 77 11 	call	0x22ee	; 0x22ee <usart_spi_select_device>
    120e:	81 e0       	ldi	r24, 0x01	; 1
    1210:	e0 e6       	ldi	r30, 0x60	; 96
    1212:	f6 e0       	ldi	r31, 0x06	; 6
    1214:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1216:	e0 ea       	ldi	r30, 0xA0	; 160
    1218:	f9 e0       	ldi	r31, 0x09	; 9
    121a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    121c:	85 ff       	sbrs	r24, 5
    121e:	fd cf       	rjmp	.-6      	; 0x121a <st7565r_init+0x23e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1220:	10 92 a0 09 	sts	0x09A0, r1
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1224:	e0 ea       	ldi	r30, 0xA0	; 160
    1226:	f9 e0       	ldi	r31, 0x09	; 9
    1228:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    122a:	86 ff       	sbrs	r24, 6
    122c:	fd cf       	rjmp	.-6      	; 0x1228 <st7565r_init+0x24c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    122e:	e0 ea       	ldi	r30, 0xA0	; 160
    1230:	f9 e0       	ldi	r31, 0x09	; 9
    1232:	80 e4       	ldi	r24, 0x40	; 64
    1234:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1236:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1238:	be 01       	movw	r22, r28
    123a:	6f 5f       	subi	r22, 0xFF	; 255
    123c:	7f 4f       	sbci	r23, 0xFF	; 255
    123e:	80 ea       	ldi	r24, 0xA0	; 160
    1240:	99 e0       	ldi	r25, 0x09	; 9
    1242:	0e 94 8d 11 	call	0x231a	; 0x231a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1246:	8b e2       	ldi	r24, 0x2B	; 43
    1248:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    124a:	be 01       	movw	r22, r28
    124c:	6f 5f       	subi	r22, 0xFF	; 255
    124e:	7f 4f       	sbci	r23, 0xFF	; 255
    1250:	80 ea       	ldi	r24, 0xA0	; 160
    1252:	99 e0       	ldi	r25, 0x09	; 9
    1254:	0e 94 77 11 	call	0x22ee	; 0x22ee <usart_spi_select_device>
    1258:	81 e0       	ldi	r24, 0x01	; 1
    125a:	e0 e6       	ldi	r30, 0x60	; 96
    125c:	f6 e0       	ldi	r31, 0x06	; 6
    125e:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1260:	e0 ea       	ldi	r30, 0xA0	; 160
    1262:	f9 e0       	ldi	r31, 0x09	; 9
    1264:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1266:	85 ff       	sbrs	r24, 5
    1268:	fd cf       	rjmp	.-6      	; 0x1264 <st7565r_init+0x288>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    126a:	81 e2       	ldi	r24, 0x21	; 33
    126c:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1270:	e0 ea       	ldi	r30, 0xA0	; 160
    1272:	f9 e0       	ldi	r31, 0x09	; 9
    1274:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1276:	86 ff       	sbrs	r24, 6
    1278:	fd cf       	rjmp	.-6      	; 0x1274 <st7565r_init+0x298>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    127a:	e0 ea       	ldi	r30, 0xA0	; 160
    127c:	f9 e0       	ldi	r31, 0x09	; 9
    127e:	80 e4       	ldi	r24, 0x40	; 64
    1280:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1282:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1284:	be 01       	movw	r22, r28
    1286:	6f 5f       	subi	r22, 0xFF	; 255
    1288:	7f 4f       	sbci	r23, 0xFF	; 255
    128a:	80 ea       	ldi	r24, 0xA0	; 160
    128c:	99 e0       	ldi	r25, 0x09	; 9
    128e:	0e 94 8d 11 	call	0x231a	; 0x231a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1292:	8b e2       	ldi	r24, 0x2B	; 43
    1294:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1296:	be 01       	movw	r22, r28
    1298:	6f 5f       	subi	r22, 0xFF	; 255
    129a:	7f 4f       	sbci	r23, 0xFF	; 255
    129c:	80 ea       	ldi	r24, 0xA0	; 160
    129e:	99 e0       	ldi	r25, 0x09	; 9
    12a0:	0e 94 77 11 	call	0x22ee	; 0x22ee <usart_spi_select_device>
    12a4:	81 e0       	ldi	r24, 0x01	; 1
    12a6:	e0 e6       	ldi	r30, 0x60	; 96
    12a8:	f6 e0       	ldi	r31, 0x06	; 6
    12aa:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    12ac:	e0 ea       	ldi	r30, 0xA0	; 160
    12ae:	f9 e0       	ldi	r31, 0x09	; 9
    12b0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    12b2:	85 ff       	sbrs	r24, 5
    12b4:	fd cf       	rjmp	.-6      	; 0x12b0 <st7565r_init+0x2d4>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    12b6:	81 e8       	ldi	r24, 0x81	; 129
    12b8:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    12bc:	e0 ea       	ldi	r30, 0xA0	; 160
    12be:	f9 e0       	ldi	r31, 0x09	; 9
    12c0:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    12c2:	86 ff       	sbrs	r24, 6
    12c4:	fd cf       	rjmp	.-6      	; 0x12c0 <st7565r_init+0x2e4>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    12c6:	e0 ea       	ldi	r30, 0xA0	; 160
    12c8:	f9 e0       	ldi	r31, 0x09	; 9
    12ca:	80 e4       	ldi	r24, 0x40	; 64
    12cc:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    12ce:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    12d0:	be 01       	movw	r22, r28
    12d2:	6f 5f       	subi	r22, 0xFF	; 255
    12d4:	7f 4f       	sbci	r23, 0xFF	; 255
    12d6:	80 ea       	ldi	r24, 0xA0	; 160
    12d8:	99 e0       	ldi	r25, 0x09	; 9
    12da:	0e 94 8d 11 	call	0x231a	; 0x231a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    12de:	8b e2       	ldi	r24, 0x2B	; 43
    12e0:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    12e2:	be 01       	movw	r22, r28
    12e4:	6f 5f       	subi	r22, 0xFF	; 255
    12e6:	7f 4f       	sbci	r23, 0xFF	; 255
    12e8:	80 ea       	ldi	r24, 0xA0	; 160
    12ea:	99 e0       	ldi	r25, 0x09	; 9
    12ec:	0e 94 77 11 	call	0x22ee	; 0x22ee <usart_spi_select_device>
    12f0:	81 e0       	ldi	r24, 0x01	; 1
    12f2:	e0 e6       	ldi	r30, 0x60	; 96
    12f4:	f6 e0       	ldi	r31, 0x06	; 6
    12f6:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    12f8:	e0 ea       	ldi	r30, 0xA0	; 160
    12fa:	f9 e0       	ldi	r31, 0x09	; 9
    12fc:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    12fe:	85 ff       	sbrs	r24, 5
    1300:	fd cf       	rjmp	.-6      	; 0x12fc <st7565r_init+0x320>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1302:	81 e2       	ldi	r24, 0x21	; 33
    1304:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1308:	e0 ea       	ldi	r30, 0xA0	; 160
    130a:	f9 e0       	ldi	r31, 0x09	; 9
    130c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    130e:	86 ff       	sbrs	r24, 6
    1310:	fd cf       	rjmp	.-6      	; 0x130c <st7565r_init+0x330>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1312:	e0 ea       	ldi	r30, 0xA0	; 160
    1314:	f9 e0       	ldi	r31, 0x09	; 9
    1316:	80 e4       	ldi	r24, 0x40	; 64
    1318:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    131a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    131c:	be 01       	movw	r22, r28
    131e:	6f 5f       	subi	r22, 0xFF	; 255
    1320:	7f 4f       	sbci	r23, 0xFF	; 255
    1322:	80 ea       	ldi	r24, 0xA0	; 160
    1324:	99 e0       	ldi	r25, 0x09	; 9
    1326:	f9 d7       	rcall	.+4082   	; 0x231a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1328:	8b e2       	ldi	r24, 0x2B	; 43
    132a:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    132c:	be 01       	movw	r22, r28
    132e:	6f 5f       	subi	r22, 0xFF	; 255
    1330:	7f 4f       	sbci	r23, 0xFF	; 255
    1332:	80 ea       	ldi	r24, 0xA0	; 160
    1334:	99 e0       	ldi	r25, 0x09	; 9
    1336:	db d7       	rcall	.+4022   	; 0x22ee <usart_spi_select_device>
    1338:	81 e0       	ldi	r24, 0x01	; 1
    133a:	e0 e6       	ldi	r30, 0x60	; 96
    133c:	f6 e0       	ldi	r31, 0x06	; 6
    133e:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1340:	e0 ea       	ldi	r30, 0xA0	; 160
    1342:	f9 e0       	ldi	r31, 0x09	; 9
    1344:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1346:	85 ff       	sbrs	r24, 5
    1348:	fd cf       	rjmp	.-6      	; 0x1344 <st7565r_init+0x368>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    134a:	8f ea       	ldi	r24, 0xAF	; 175
    134c:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1350:	e0 ea       	ldi	r30, 0xA0	; 160
    1352:	f9 e0       	ldi	r31, 0x09	; 9
    1354:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1356:	86 ff       	sbrs	r24, 6
    1358:	fd cf       	rjmp	.-6      	; 0x1354 <st7565r_init+0x378>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    135a:	e0 ea       	ldi	r30, 0xA0	; 160
    135c:	f9 e0       	ldi	r31, 0x09	; 9
    135e:	80 e4       	ldi	r24, 0x40	; 64
    1360:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1362:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1364:	be 01       	movw	r22, r28
    1366:	6f 5f       	subi	r22, 0xFF	; 255
    1368:	7f 4f       	sbci	r23, 0xFF	; 255
    136a:	80 ea       	ldi	r24, 0xA0	; 160
    136c:	99 e0       	ldi	r25, 0x09	; 9
    136e:	d5 d7       	rcall	.+4010   	; 0x231a <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
    1370:	0f 90       	pop	r0
    1372:	df 91       	pop	r29
    1374:	cf 91       	pop	r28
    1376:	1f 91       	pop	r17
    1378:	0f 91       	pop	r16
    137a:	ff 90       	pop	r15
    137c:	ef 90       	pop	r14
    137e:	df 90       	pop	r13
    1380:	cf 90       	pop	r12
    1382:	bf 90       	pop	r11
    1384:	08 95       	ret

00001386 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
    1386:	ff 92       	push	r15
    1388:	0f 93       	push	r16
    138a:	1f 93       	push	r17
    138c:	cf 93       	push	r28
    138e:	df 93       	push	r29
    1390:	1f 92       	push	r1
    1392:	cd b7       	in	r28, 0x3d	; 61
    1394:	de b7       	in	r29, 0x3e	; 62
    1396:	f8 2e       	mov	r15, r24
    1398:	06 2f       	mov	r16, r22
    139a:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
    139c:	d9 d7       	rcall	.+4018   	; 0x2350 <gfx_mono_framebuffer_put_byte>
 * \param address the page address
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
    139e:	8f 2d       	mov	r24, r15
    13a0:	8f 70       	andi	r24, 0x0F	; 15
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
    13a2:	80 6b       	ori	r24, 0xB0	; 176
    13a4:	f8 2e       	mov	r15, r24
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    13a6:	8b e2       	ldi	r24, 0x2B	; 43
    13a8:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    13aa:	be 01       	movw	r22, r28
    13ac:	6f 5f       	subi	r22, 0xFF	; 255
    13ae:	7f 4f       	sbci	r23, 0xFF	; 255
    13b0:	80 ea       	ldi	r24, 0xA0	; 160
    13b2:	99 e0       	ldi	r25, 0x09	; 9
    13b4:	9c d7       	rcall	.+3896   	; 0x22ee <usart_spi_select_device>
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	e0 e6       	ldi	r30, 0x60	; 96
    13ba:	f6 e0       	ldi	r31, 0x06	; 6
    13bc:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    13be:	e0 ea       	ldi	r30, 0xA0	; 160
    13c0:	f9 e0       	ldi	r31, 0x09	; 9
    13c2:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    13c4:	95 ff       	sbrs	r25, 5
    13c6:	fd cf       	rjmp	.-6      	; 0x13c2 <gfx_mono_st7565r_put_byte+0x3c>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    13c8:	f0 92 a0 09 	sts	0x09A0, r15
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    13cc:	e0 ea       	ldi	r30, 0xA0	; 160
    13ce:	f9 e0       	ldi	r31, 0x09	; 9
    13d0:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    13d2:	86 ff       	sbrs	r24, 6
    13d4:	fd cf       	rjmp	.-6      	; 0x13d0 <gfx_mono_st7565r_put_byte+0x4a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    13d6:	e0 ea       	ldi	r30, 0xA0	; 160
    13d8:	f9 e0       	ldi	r31, 0x09	; 9
    13da:	80 e4       	ldi	r24, 0x40	; 64
    13dc:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    13de:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    13e0:	be 01       	movw	r22, r28
    13e2:	6f 5f       	subi	r22, 0xFF	; 255
    13e4:	7f 4f       	sbci	r23, 0xFF	; 255
    13e6:	80 ea       	ldi	r24, 0xA0	; 160
    13e8:	99 e0       	ldi	r25, 0x09	; 9
    13ea:	97 d7       	rcall	.+3886   	; 0x231a <usart_spi_deselect_device>
 * \param address the column address
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
    13ec:	80 2f       	mov	r24, r16
    13ee:	8f 77       	andi	r24, 0x7F	; 127
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
    13f0:	82 95       	swap	r24
    13f2:	8f 70       	andi	r24, 0x0F	; 15
    13f4:	80 61       	ori	r24, 0x10	; 16
    13f6:	f8 2e       	mov	r15, r24
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    13f8:	8b e2       	ldi	r24, 0x2B	; 43
    13fa:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    13fc:	be 01       	movw	r22, r28
    13fe:	6f 5f       	subi	r22, 0xFF	; 255
    1400:	7f 4f       	sbci	r23, 0xFF	; 255
    1402:	80 ea       	ldi	r24, 0xA0	; 160
    1404:	99 e0       	ldi	r25, 0x09	; 9
    1406:	73 d7       	rcall	.+3814   	; 0x22ee <usart_spi_select_device>
    1408:	81 e0       	ldi	r24, 0x01	; 1
    140a:	e0 e6       	ldi	r30, 0x60	; 96
    140c:	f6 e0       	ldi	r31, 0x06	; 6
    140e:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1410:	e0 ea       	ldi	r30, 0xA0	; 160
    1412:	f9 e0       	ldi	r31, 0x09	; 9
    1414:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1416:	85 ff       	sbrs	r24, 5
    1418:	fd cf       	rjmp	.-6      	; 0x1414 <gfx_mono_st7565r_put_byte+0x8e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    141a:	f0 92 a0 09 	sts	0x09A0, r15
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    141e:	e0 ea       	ldi	r30, 0xA0	; 160
    1420:	f9 e0       	ldi	r31, 0x09	; 9
    1422:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1424:	86 ff       	sbrs	r24, 6
    1426:	fd cf       	rjmp	.-6      	; 0x1422 <gfx_mono_st7565r_put_byte+0x9c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1428:	e0 ea       	ldi	r30, 0xA0	; 160
    142a:	f9 e0       	ldi	r31, 0x09	; 9
    142c:	80 e4       	ldi	r24, 0x40	; 64
    142e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1430:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1432:	be 01       	movw	r22, r28
    1434:	6f 5f       	subi	r22, 0xFF	; 255
    1436:	7f 4f       	sbci	r23, 0xFF	; 255
    1438:	80 ea       	ldi	r24, 0xA0	; 160
    143a:	99 e0       	ldi	r25, 0x09	; 9
    143c:	6e d7       	rcall	.+3804   	; 0x231a <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
    143e:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1440:	8b e2       	ldi	r24, 0x2B	; 43
    1442:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1444:	be 01       	movw	r22, r28
    1446:	6f 5f       	subi	r22, 0xFF	; 255
    1448:	7f 4f       	sbci	r23, 0xFF	; 255
    144a:	80 ea       	ldi	r24, 0xA0	; 160
    144c:	99 e0       	ldi	r25, 0x09	; 9
    144e:	4f d7       	rcall	.+3742   	; 0x22ee <usart_spi_select_device>
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	e0 e6       	ldi	r30, 0x60	; 96
    1454:	f6 e0       	ldi	r31, 0x06	; 6
    1456:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1458:	e0 ea       	ldi	r30, 0xA0	; 160
    145a:	f9 e0       	ldi	r31, 0x09	; 9
    145c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    145e:	85 ff       	sbrs	r24, 5
    1460:	fd cf       	rjmp	.-6      	; 0x145c <gfx_mono_st7565r_put_byte+0xd6>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1462:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1466:	e0 ea       	ldi	r30, 0xA0	; 160
    1468:	f9 e0       	ldi	r31, 0x09	; 9
    146a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    146c:	86 ff       	sbrs	r24, 6
    146e:	fd cf       	rjmp	.-6      	; 0x146a <gfx_mono_st7565r_put_byte+0xe4>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1470:	e0 ea       	ldi	r30, 0xA0	; 160
    1472:	f9 e0       	ldi	r31, 0x09	; 9
    1474:	80 e4       	ldi	r24, 0x40	; 64
    1476:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1478:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    147a:	be 01       	movw	r22, r28
    147c:	6f 5f       	subi	r22, 0xFF	; 255
    147e:	7f 4f       	sbci	r23, 0xFF	; 255
    1480:	80 ea       	ldi	r24, 0xA0	; 160
    1482:	99 e0       	ldi	r25, 0x09	; 9
    1484:	4a d7       	rcall	.+3732   	; 0x231a <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1486:	8b e2       	ldi	r24, 0x2B	; 43
    1488:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    148a:	be 01       	movw	r22, r28
    148c:	6f 5f       	subi	r22, 0xFF	; 255
    148e:	7f 4f       	sbci	r23, 0xFF	; 255
    1490:	80 ea       	ldi	r24, 0xA0	; 160
    1492:	99 e0       	ldi	r25, 0x09	; 9
    1494:	2c d7       	rcall	.+3672   	; 0x22ee <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1496:	81 e0       	ldi	r24, 0x01	; 1
    1498:	e0 e6       	ldi	r30, 0x60	; 96
    149a:	f6 e0       	ldi	r31, 0x06	; 6
    149c:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    149e:	e0 ea       	ldi	r30, 0xA0	; 160
    14a0:	f9 e0       	ldi	r31, 0x09	; 9
    14a2:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    14a4:	85 ff       	sbrs	r24, 5
    14a6:	fd cf       	rjmp	.-6      	; 0x14a2 <gfx_mono_st7565r_put_byte+0x11c>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    14a8:	10 93 a0 09 	sts	0x09A0, r17
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    14ac:	e0 ea       	ldi	r30, 0xA0	; 160
    14ae:	f9 e0       	ldi	r31, 0x09	; 9
    14b0:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    14b2:	86 ff       	sbrs	r24, 6
    14b4:	fd cf       	rjmp	.-6      	; 0x14b0 <gfx_mono_st7565r_put_byte+0x12a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    14b6:	e0 ea       	ldi	r30, 0xA0	; 160
    14b8:	f9 e0       	ldi	r31, 0x09	; 9
    14ba:	80 e4       	ldi	r24, 0x40	; 64
    14bc:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    14be:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    14c0:	81 e0       	ldi	r24, 0x01	; 1
    14c2:	e0 e6       	ldi	r30, 0x60	; 96
    14c4:	f6 e0       	ldi	r31, 0x06	; 6
    14c6:	86 83       	std	Z+6, r24	; 0x06
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    14c8:	be 01       	movw	r22, r28
    14ca:	6f 5f       	subi	r22, 0xFF	; 255
    14cc:	7f 4f       	sbci	r23, 0xFF	; 255
    14ce:	80 ea       	ldi	r24, 0xA0	; 160
    14d0:	99 e0       	ldi	r25, 0x09	; 9
    14d2:	23 d7       	rcall	.+3654   	; 0x231a <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
    14d4:	0f 90       	pop	r0
    14d6:	df 91       	pop	r29
    14d8:	cf 91       	pop	r28
    14da:	1f 91       	pop	r17
    14dc:	0f 91       	pop	r16
    14de:	ff 90       	pop	r15
    14e0:	08 95       	ret

000014e2 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
    14e2:	0f 93       	push	r16
    14e4:	1f 93       	push	r17
    14e6:	cf 93       	push	r28
    14e8:	df 93       	push	r29
    14ea:	1f 92       	push	r1
    14ec:	cd b7       	in	r28, 0x3d	; 61
    14ee:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
    14f0:	8b e8       	ldi	r24, 0x8B	; 139
    14f2:	91 e2       	ldi	r25, 0x21	; 33
    14f4:	28 d7       	rcall	.+3664   	; 0x2346 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
    14f6:	72 dd       	rcall	.-1308   	; 0xfdc <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    14f8:	8b e2       	ldi	r24, 0x2B	; 43
    14fa:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    14fc:	be 01       	movw	r22, r28
    14fe:	6f 5f       	subi	r22, 0xFF	; 255
    1500:	7f 4f       	sbci	r23, 0xFF	; 255
    1502:	80 ea       	ldi	r24, 0xA0	; 160
    1504:	99 e0       	ldi	r25, 0x09	; 9
    1506:	f3 d6       	rcall	.+3558   	; 0x22ee <usart_spi_select_device>
    1508:	81 e0       	ldi	r24, 0x01	; 1
    150a:	e0 e6       	ldi	r30, 0x60	; 96
    150c:	f6 e0       	ldi	r31, 0x06	; 6
    150e:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1510:	e0 ea       	ldi	r30, 0xA0	; 160
    1512:	f9 e0       	ldi	r31, 0x09	; 9
    1514:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1516:	85 ff       	sbrs	r24, 5
    1518:	fd cf       	rjmp	.-6      	; 0x1514 <gfx_mono_st7565r_init+0x32>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    151a:	80 e4       	ldi	r24, 0x40	; 64
    151c:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1520:	e0 ea       	ldi	r30, 0xA0	; 160
    1522:	f9 e0       	ldi	r31, 0x09	; 9
    1524:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1526:	86 ff       	sbrs	r24, 6
    1528:	fd cf       	rjmp	.-6      	; 0x1524 <gfx_mono_st7565r_init+0x42>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    152a:	e0 ea       	ldi	r30, 0xA0	; 160
    152c:	f9 e0       	ldi	r31, 0x09	; 9
    152e:	80 e4       	ldi	r24, 0x40	; 64
    1530:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1532:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1534:	be 01       	movw	r22, r28
    1536:	6f 5f       	subi	r22, 0xFF	; 255
    1538:	7f 4f       	sbci	r23, 0xFF	; 255
    153a:	80 ea       	ldi	r24, 0xA0	; 160
    153c:	99 e0       	ldi	r25, 0x09	; 9
    153e:	ed d6       	rcall	.+3546   	; 0x231a <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    1540:	00 e0       	ldi	r16, 0x00	; 0
    1542:	0a c0       	rjmp	.+20     	; 0x1558 <gfx_mono_st7565r_init+0x76>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
    1544:	40 e0       	ldi	r20, 0x00	; 0
    1546:	61 2f       	mov	r22, r17
    1548:	80 2f       	mov	r24, r16
    154a:	1d df       	rcall	.-454    	; 0x1386 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
    154c:	1f 5f       	subi	r17, 0xFF	; 255
    154e:	10 38       	cpi	r17, 0x80	; 128
    1550:	c9 f7       	brne	.-14     	; 0x1544 <gfx_mono_st7565r_init+0x62>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    1552:	0f 5f       	subi	r16, 0xFF	; 255
    1554:	04 30       	cpi	r16, 0x04	; 4
    1556:	11 f0       	breq	.+4      	; 0x155c <gfx_mono_st7565r_init+0x7a>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
    1558:	10 e0       	ldi	r17, 0x00	; 0
    155a:	f4 cf       	rjmp	.-24     	; 0x1544 <gfx_mono_st7565r_init+0x62>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
    155c:	0f 90       	pop	r0
    155e:	df 91       	pop	r29
    1560:	cf 91       	pop	r28
    1562:	1f 91       	pop	r17
    1564:	0f 91       	pop	r16
    1566:	08 95       	ret

00001568 <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
    1568:	ff 92       	push	r15
    156a:	0f 93       	push	r16
    156c:	1f 93       	push	r17
    156e:	cf 93       	push	r28
    1570:	df 93       	push	r29
    1572:	18 2f       	mov	r17, r24
    1574:	04 2f       	mov	r16, r20
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
    1576:	88 23       	and	r24, r24
    1578:	74 f1       	brlt	.+92     	; 0x15d6 <gfx_mono_st7565r_draw_pixel+0x6e>
    157a:	60 32       	cpi	r22, 0x20	; 32
    157c:	60 f5       	brcc	.+88     	; 0x15d6 <gfx_mono_st7565r_draw_pixel+0x6e>
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
    157e:	f6 2e       	mov	r15, r22
    1580:	f6 94       	lsr	r15
    1582:	f6 94       	lsr	r15
    1584:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
    1586:	2f 2d       	mov	r18, r15
    1588:	30 e0       	ldi	r19, 0x00	; 0
    158a:	31 95       	neg	r19
    158c:	21 95       	neg	r18
    158e:	31 09       	sbc	r19, r1
    1590:	22 0f       	add	r18, r18
    1592:	33 1f       	adc	r19, r19
    1594:	22 0f       	add	r18, r18
    1596:	33 1f       	adc	r19, r19
    1598:	22 0f       	add	r18, r18
    159a:	33 1f       	adc	r19, r19
    159c:	26 0f       	add	r18, r22
    159e:	31 1d       	adc	r19, r1
    15a0:	e1 e0       	ldi	r30, 0x01	; 1
    15a2:	f0 e0       	ldi	r31, 0x00	; 0
    15a4:	ef 01       	movw	r28, r30
    15a6:	02 c0       	rjmp	.+4      	; 0x15ac <gfx_mono_st7565r_draw_pixel+0x44>
    15a8:	cc 0f       	add	r28, r28
    15aa:	dd 1f       	adc	r29, r29
    15ac:	2a 95       	dec	r18
    15ae:	e2 f7       	brpl	.-8      	; 0x15a8 <gfx_mono_st7565r_draw_pixel+0x40>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
    15b0:	68 2f       	mov	r22, r24
    15b2:	8f 2d       	mov	r24, r15
    15b4:	dc d6       	rcall	.+3512   	; 0x236e <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
    15b6:	01 30       	cpi	r16, 0x01	; 1
    15b8:	21 f0       	breq	.+8      	; 0x15c2 <gfx_mono_st7565r_draw_pixel+0x5a>
    15ba:	28 f0       	brcs	.+10     	; 0x15c6 <gfx_mono_st7565r_draw_pixel+0x5e>
    15bc:	02 30       	cpi	r16, 0x02	; 2
    15be:	31 f0       	breq	.+12     	; 0x15cc <gfx_mono_st7565r_draw_pixel+0x64>
    15c0:	06 c0       	rjmp	.+12     	; 0x15ce <gfx_mono_st7565r_draw_pixel+0x66>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
    15c2:	8c 2b       	or	r24, r28
		break;
    15c4:	04 c0       	rjmp	.+8      	; 0x15ce <gfx_mono_st7565r_draw_pixel+0x66>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
    15c6:	c0 95       	com	r28
    15c8:	8c 23       	and	r24, r28
		break;
    15ca:	01 c0       	rjmp	.+2      	; 0x15ce <gfx_mono_st7565r_draw_pixel+0x66>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
    15cc:	8c 27       	eor	r24, r28

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
    15ce:	48 2f       	mov	r20, r24
    15d0:	61 2f       	mov	r22, r17
    15d2:	8f 2d       	mov	r24, r15
    15d4:	d8 de       	rcall	.-592    	; 0x1386 <gfx_mono_st7565r_put_byte>
}
    15d6:	df 91       	pop	r29
    15d8:	cf 91       	pop	r28
    15da:	1f 91       	pop	r17
    15dc:	0f 91       	pop	r16
    15de:	ff 90       	pop	r15
    15e0:	08 95       	ret

000015e2 <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
    15e2:	c5 c6       	rjmp	.+3466   	; 0x236e <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
    15e4:	08 95       	ret

000015e6 <tb_init>:


uint16_t qt_measurement_period_msec = 25;

void tb_init(void) {
	qt_config_data.qt_di				= DEF_QT_DI;
    15e6:	84 e0       	ldi	r24, 0x04	; 4
    15e8:	80 93 46 21 	sts	0x2146, r24
	qt_config_data.qt_neg_drift_rate	= DEF_QT_NEG_DRIFT_RATE;
    15ec:	84 e1       	ldi	r24, 0x14	; 20
    15ee:	80 93 49 21 	sts	0x2149, r24
	qt_config_data.qt_pos_drift_rate	= DEF_QT_POS_DRIFT_RATE;
    15f2:	95 e0       	ldi	r25, 0x05	; 5
    15f4:	90 93 4a 21 	sts	0x214A, r25
	qt_config_data.qt_max_on_duration	= DEF_QT_MAX_ON_DURATION;
    15f8:	10 92 48 21 	sts	0x2148, r1
	qt_config_data.qt_drift_hold_time	= DEF_QT_DRIFT_HOLD_TIME;
    15fc:	80 93 47 21 	sts	0x2147, r24
	qt_config_data.qt_recal_threshold	= DEF_QT_RECAL_THRESHOLD;
    1600:	81 e0       	ldi	r24, 0x01	; 1
    1602:	80 93 45 21 	sts	0x2145, r24
	qt_config_data.qt_pos_recal_delay	= DEF_QT_POS_RECAL_DELAY;
    1606:	83 e0       	ldi	r24, 0x03	; 3
    1608:	80 93 4b 21 	sts	0x214B, r24
	qt_filter_callback					= 0;
    160c:	10 92 5f 21 	sts	0x215F, r1
    1610:	10 92 60 21 	sts	0x2160, r1


	#ifdef QTOUCH_STUDIO_MASKS
		SNS_array[0][0] = 0x40;
    1614:	80 e4       	ldi	r24, 0x40	; 64
    1616:	80 93 83 21 	sts	0x2183, r24
		SNS_array[0][1] = 0x0;
    161a:	10 92 84 21 	sts	0x2184, r1
		SNS_array[1][0] = 0x0;
    161e:	10 92 85 21 	sts	0x2185, r1
		SNS_array[1][1] = 0x0;
    1622:	10 92 86 21 	sts	0x2186, r1

		SNSK_array[0][0] = 0x80;
    1626:	80 e8       	ldi	r24, 0x80	; 128
    1628:	80 93 87 21 	sts	0x2187, r24
		SNSK_array[0][1] = 0x0;
    162c:	10 92 88 21 	sts	0x2188, r1
		SNSK_array[1][0] = 0x0;
    1630:	10 92 89 21 	sts	0x2189, r1
		SNSK_array[1][1] = 0x0;
    1634:	10 92 8a 21 	sts	0x218A, r1
	 * When using "pin configurability" this will result in channel 0
	 * because it is the first and only channel that is used.
	 * For the standard qtouch library setup we would need to use
	 * channel 3 since we are using the last two pins on the port.
	 */
	qt_enable_key(CHANNEL_0, NO_AKS_GROUP, 10, HYST_6_25);
    1638:	23 e0       	ldi	r18, 0x03	; 3
    163a:	4a e0       	ldi	r20, 0x0A	; 10
    163c:	60 e0       	ldi	r22, 0x00	; 0
    163e:	80 e0       	ldi	r24, 0x00	; 0
    1640:	4b d8       	rcall	.-3946   	; 0x6d8 <qt_enable_key>

	qt_init_sensing();
    1642:	60 e0       	ldi	r22, 0x00	; 0
    1644:	70 e0       	ldi	r23, 0x00	; 0
    1646:	87 e8       	ldi	r24, 0x87	; 135
    1648:	92 e0       	ldi	r25, 0x02	; 2
    164a:	57 c9       	rjmp	.-3410   	; 0x8fa <qt_init_sensing_with_burst>
    164c:	08 95       	ret

0000164e <tb_is_touched>:
}


bool tb_is_touched(void) {
    164e:	cf 93       	push	r28
    1650:	df 93       	push	r29
	
	static int16_t last = 0;
	int16_t now = getUptimeMs();
    1652:	0e 94 56 16 	call	0x2cac	; 0x2cac <xTaskGetTickCount>
    1656:	ec 01       	movw	r28, r24
    1658:	cc 0f       	add	r28, r28
    165a:	dd 1f       	adc	r29, r29
	
	if(now - last >= 25) {
    165c:	80 91 8b 23 	lds	r24, 0x238B
    1660:	90 91 8c 23 	lds	r25, 0x238C
    1664:	9e 01       	movw	r18, r28
    1666:	28 1b       	sub	r18, r24
    1668:	39 0b       	sbc	r19, r25
    166a:	29 31       	cpi	r18, 0x19	; 25
    166c:	31 05       	cpc	r19, r1
    166e:	5c f0       	brlt	.+22     	; 0x1686 <tb_is_touched+0x38>
		while(qt_measure_sensors(getUptimeMs()) & QTLIB_BURST_AGAIN);
    1670:	0e 94 56 16 	call	0x2cac	; 0x2cac <xTaskGetTickCount>
    1674:	88 0f       	add	r24, r24
    1676:	99 1f       	adc	r25, r25
    1678:	9f d8       	rcall	.-3778   	; 0x7b8 <qt_measure_sensors>
    167a:	90 fd       	sbrc	r25, 0
    167c:	f9 cf       	rjmp	.-14     	; 0x1670 <tb_is_touched+0x22>
		last = now;
    167e:	c0 93 8b 23 	sts	0x238B, r28
    1682:	d0 93 8c 23 	sts	0x238C, r29
	}
	
	if (GET_SENSOR_STATE(0)) {
    1686:	80 91 5c 21 	lds	r24, 0x215C
    168a:	80 95       	com	r24
		return 0;
	} else {
		return 1;
	}
    168c:	81 70       	andi	r24, 0x01	; 1
    168e:	df 91       	pop	r29
    1690:	cf 91       	pop	r28
    1692:	08 95       	ret

00001694 <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
    1694:	1f 92       	push	r1
    1696:	0f 92       	push	r0
    1698:	0f b6       	in	r0, 0x3f	; 63
    169a:	0f 92       	push	r0
    169c:	11 24       	eor	r1, r1
    169e:	0b b6       	in	r0, 0x3b	; 59
    16a0:	0f 92       	push	r0
    16a2:	2f 93       	push	r18
    16a4:	3f 93       	push	r19
    16a6:	4f 93       	push	r20
    16a8:	5f 93       	push	r21
    16aa:	6f 93       	push	r22
    16ac:	7f 93       	push	r23
    16ae:	8f 93       	push	r24
    16b0:	9f 93       	push	r25
    16b2:	af 93       	push	r26
    16b4:	bf 93       	push	r27
    16b6:	ef 93       	push	r30
    16b8:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
    16ba:	e0 e0       	ldi	r30, 0x00	; 0
    16bc:	f2 e0       	ldi	r31, 0x02	; 2
    16be:	44 a1       	ldd	r20, Z+36	; 0x24
    16c0:	55 a1       	ldd	r21, Z+37	; 0x25
    16c2:	e0 91 b7 24 	lds	r30, 0x24B7
    16c6:	f0 91 b8 24 	lds	r31, 0x24B8
    16ca:	61 e0       	ldi	r22, 0x01	; 1
    16cc:	80 e0       	ldi	r24, 0x00	; 0
    16ce:	92 e0       	ldi	r25, 0x02	; 2
    16d0:	19 95       	eicall
}
    16d2:	ff 91       	pop	r31
    16d4:	ef 91       	pop	r30
    16d6:	bf 91       	pop	r27
    16d8:	af 91       	pop	r26
    16da:	9f 91       	pop	r25
    16dc:	8f 91       	pop	r24
    16de:	7f 91       	pop	r23
    16e0:	6f 91       	pop	r22
    16e2:	5f 91       	pop	r21
    16e4:	4f 91       	pop	r20
    16e6:	3f 91       	pop	r19
    16e8:	2f 91       	pop	r18
    16ea:	0f 90       	pop	r0
    16ec:	0b be       	out	0x3b, r0	; 59
    16ee:	0f 90       	pop	r0
    16f0:	0f be       	out	0x3f, r0	; 63
    16f2:	0f 90       	pop	r0
    16f4:	1f 90       	pop	r1
    16f6:	18 95       	reti

000016f8 <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
    16f8:	1f 92       	push	r1
    16fa:	0f 92       	push	r0
    16fc:	0f b6       	in	r0, 0x3f	; 63
    16fe:	0f 92       	push	r0
    1700:	11 24       	eor	r1, r1
    1702:	0b b6       	in	r0, 0x3b	; 59
    1704:	0f 92       	push	r0
    1706:	2f 93       	push	r18
    1708:	3f 93       	push	r19
    170a:	4f 93       	push	r20
    170c:	5f 93       	push	r21
    170e:	6f 93       	push	r22
    1710:	7f 93       	push	r23
    1712:	8f 93       	push	r24
    1714:	9f 93       	push	r25
    1716:	af 93       	push	r26
    1718:	bf 93       	push	r27
    171a:	ef 93       	push	r30
    171c:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
    171e:	e8 e2       	ldi	r30, 0x28	; 40
    1720:	f2 e0       	ldi	r31, 0x02	; 2
    1722:	44 81       	ldd	r20, Z+4	; 0x04
    1724:	55 81       	ldd	r21, Z+5	; 0x05
    1726:	e0 91 b7 24 	lds	r30, 0x24B7
    172a:	f0 91 b8 24 	lds	r31, 0x24B8
    172e:	62 e0       	ldi	r22, 0x02	; 2
    1730:	80 e0       	ldi	r24, 0x00	; 0
    1732:	92 e0       	ldi	r25, 0x02	; 2
    1734:	19 95       	eicall
}
    1736:	ff 91       	pop	r31
    1738:	ef 91       	pop	r30
    173a:	bf 91       	pop	r27
    173c:	af 91       	pop	r26
    173e:	9f 91       	pop	r25
    1740:	8f 91       	pop	r24
    1742:	7f 91       	pop	r23
    1744:	6f 91       	pop	r22
    1746:	5f 91       	pop	r21
    1748:	4f 91       	pop	r20
    174a:	3f 91       	pop	r19
    174c:	2f 91       	pop	r18
    174e:	0f 90       	pop	r0
    1750:	0b be       	out	0x3b, r0	; 59
    1752:	0f 90       	pop	r0
    1754:	0f be       	out	0x3f, r0	; 63
    1756:	0f 90       	pop	r0
    1758:	1f 90       	pop	r1
    175a:	18 95       	reti

0000175c <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
    175c:	1f 92       	push	r1
    175e:	0f 92       	push	r0
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	0f 92       	push	r0
    1764:	11 24       	eor	r1, r1
    1766:	0b b6       	in	r0, 0x3b	; 59
    1768:	0f 92       	push	r0
    176a:	2f 93       	push	r18
    176c:	3f 93       	push	r19
    176e:	4f 93       	push	r20
    1770:	5f 93       	push	r21
    1772:	6f 93       	push	r22
    1774:	7f 93       	push	r23
    1776:	8f 93       	push	r24
    1778:	9f 93       	push	r25
    177a:	af 93       	push	r26
    177c:	bf 93       	push	r27
    177e:	ef 93       	push	r30
    1780:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
    1782:	e0 e3       	ldi	r30, 0x30	; 48
    1784:	f2 e0       	ldi	r31, 0x02	; 2
    1786:	44 81       	ldd	r20, Z+4	; 0x04
    1788:	55 81       	ldd	r21, Z+5	; 0x05
    178a:	e0 91 b7 24 	lds	r30, 0x24B7
    178e:	f0 91 b8 24 	lds	r31, 0x24B8
    1792:	64 e0       	ldi	r22, 0x04	; 4
    1794:	80 e0       	ldi	r24, 0x00	; 0
    1796:	92 e0       	ldi	r25, 0x02	; 2
    1798:	19 95       	eicall
}
    179a:	ff 91       	pop	r31
    179c:	ef 91       	pop	r30
    179e:	bf 91       	pop	r27
    17a0:	af 91       	pop	r26
    17a2:	9f 91       	pop	r25
    17a4:	8f 91       	pop	r24
    17a6:	7f 91       	pop	r23
    17a8:	6f 91       	pop	r22
    17aa:	5f 91       	pop	r21
    17ac:	4f 91       	pop	r20
    17ae:	3f 91       	pop	r19
    17b0:	2f 91       	pop	r18
    17b2:	0f 90       	pop	r0
    17b4:	0b be       	out	0x3b, r0	; 59
    17b6:	0f 90       	pop	r0
    17b8:	0f be       	out	0x3f, r0	; 63
    17ba:	0f 90       	pop	r0
    17bc:	1f 90       	pop	r1
    17be:	18 95       	reti

000017c0 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    17c0:	1f 92       	push	r1
    17c2:	0f 92       	push	r0
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	0f 92       	push	r0
    17c8:	11 24       	eor	r1, r1
    17ca:	0b b6       	in	r0, 0x3b	; 59
    17cc:	0f 92       	push	r0
    17ce:	2f 93       	push	r18
    17d0:	3f 93       	push	r19
    17d2:	4f 93       	push	r20
    17d4:	5f 93       	push	r21
    17d6:	6f 93       	push	r22
    17d8:	7f 93       	push	r23
    17da:	8f 93       	push	r24
    17dc:	9f 93       	push	r25
    17de:	af 93       	push	r26
    17e0:	bf 93       	push	r27
    17e2:	ef 93       	push	r30
    17e4:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    17e6:	e8 e3       	ldi	r30, 0x38	; 56
    17e8:	f2 e0       	ldi	r31, 0x02	; 2
    17ea:	44 81       	ldd	r20, Z+4	; 0x04
    17ec:	55 81       	ldd	r21, Z+5	; 0x05
    17ee:	e0 91 b7 24 	lds	r30, 0x24B7
    17f2:	f0 91 b8 24 	lds	r31, 0x24B8
    17f6:	68 e0       	ldi	r22, 0x08	; 8
    17f8:	80 e0       	ldi	r24, 0x00	; 0
    17fa:	92 e0       	ldi	r25, 0x02	; 2
    17fc:	19 95       	eicall
}
    17fe:	ff 91       	pop	r31
    1800:	ef 91       	pop	r30
    1802:	bf 91       	pop	r27
    1804:	af 91       	pop	r26
    1806:	9f 91       	pop	r25
    1808:	8f 91       	pop	r24
    180a:	7f 91       	pop	r23
    180c:	6f 91       	pop	r22
    180e:	5f 91       	pop	r21
    1810:	4f 91       	pop	r20
    1812:	3f 91       	pop	r19
    1814:	2f 91       	pop	r18
    1816:	0f 90       	pop	r0
    1818:	0b be       	out	0x3b, r0	; 59
    181a:	0f 90       	pop	r0
    181c:	0f be       	out	0x3f, r0	; 63
    181e:	0f 90       	pop	r0
    1820:	1f 90       	pop	r1
    1822:	18 95       	reti

00001824 <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    1824:	1f 92       	push	r1
    1826:	0f 92       	push	r0
    1828:	0f b6       	in	r0, 0x3f	; 63
    182a:	0f 92       	push	r0
    182c:	11 24       	eor	r1, r1
    182e:	0b b6       	in	r0, 0x3b	; 59
    1830:	0f 92       	push	r0
    1832:	2f 93       	push	r18
    1834:	3f 93       	push	r19
    1836:	4f 93       	push	r20
    1838:	5f 93       	push	r21
    183a:	6f 93       	push	r22
    183c:	7f 93       	push	r23
    183e:	8f 93       	push	r24
    1840:	9f 93       	push	r25
    1842:	af 93       	push	r26
    1844:	bf 93       	push	r27
    1846:	ef 93       	push	r30
    1848:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    184a:	e0 e4       	ldi	r30, 0x40	; 64
    184c:	f2 e0       	ldi	r31, 0x02	; 2
    184e:	44 a1       	ldd	r20, Z+36	; 0x24
    1850:	55 a1       	ldd	r21, Z+37	; 0x25
    1852:	e0 91 b5 24 	lds	r30, 0x24B5
    1856:	f0 91 b6 24 	lds	r31, 0x24B6
    185a:	61 e0       	ldi	r22, 0x01	; 1
    185c:	80 e4       	ldi	r24, 0x40	; 64
    185e:	92 e0       	ldi	r25, 0x02	; 2
    1860:	19 95       	eicall
}
    1862:	ff 91       	pop	r31
    1864:	ef 91       	pop	r30
    1866:	bf 91       	pop	r27
    1868:	af 91       	pop	r26
    186a:	9f 91       	pop	r25
    186c:	8f 91       	pop	r24
    186e:	7f 91       	pop	r23
    1870:	6f 91       	pop	r22
    1872:	5f 91       	pop	r21
    1874:	4f 91       	pop	r20
    1876:	3f 91       	pop	r19
    1878:	2f 91       	pop	r18
    187a:	0f 90       	pop	r0
    187c:	0b be       	out	0x3b, r0	; 59
    187e:	0f 90       	pop	r0
    1880:	0f be       	out	0x3f, r0	; 63
    1882:	0f 90       	pop	r0
    1884:	1f 90       	pop	r1
    1886:	18 95       	reti

00001888 <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    1888:	1f 92       	push	r1
    188a:	0f 92       	push	r0
    188c:	0f b6       	in	r0, 0x3f	; 63
    188e:	0f 92       	push	r0
    1890:	11 24       	eor	r1, r1
    1892:	0b b6       	in	r0, 0x3b	; 59
    1894:	0f 92       	push	r0
    1896:	2f 93       	push	r18
    1898:	3f 93       	push	r19
    189a:	4f 93       	push	r20
    189c:	5f 93       	push	r21
    189e:	6f 93       	push	r22
    18a0:	7f 93       	push	r23
    18a2:	8f 93       	push	r24
    18a4:	9f 93       	push	r25
    18a6:	af 93       	push	r26
    18a8:	bf 93       	push	r27
    18aa:	ef 93       	push	r30
    18ac:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    18ae:	e8 e6       	ldi	r30, 0x68	; 104
    18b0:	f2 e0       	ldi	r31, 0x02	; 2
    18b2:	44 81       	ldd	r20, Z+4	; 0x04
    18b4:	55 81       	ldd	r21, Z+5	; 0x05
    18b6:	e0 91 b5 24 	lds	r30, 0x24B5
    18ba:	f0 91 b6 24 	lds	r31, 0x24B6
    18be:	62 e0       	ldi	r22, 0x02	; 2
    18c0:	80 e4       	ldi	r24, 0x40	; 64
    18c2:	92 e0       	ldi	r25, 0x02	; 2
    18c4:	19 95       	eicall
}
    18c6:	ff 91       	pop	r31
    18c8:	ef 91       	pop	r30
    18ca:	bf 91       	pop	r27
    18cc:	af 91       	pop	r26
    18ce:	9f 91       	pop	r25
    18d0:	8f 91       	pop	r24
    18d2:	7f 91       	pop	r23
    18d4:	6f 91       	pop	r22
    18d6:	5f 91       	pop	r21
    18d8:	4f 91       	pop	r20
    18da:	3f 91       	pop	r19
    18dc:	2f 91       	pop	r18
    18de:	0f 90       	pop	r0
    18e0:	0b be       	out	0x3b, r0	; 59
    18e2:	0f 90       	pop	r0
    18e4:	0f be       	out	0x3f, r0	; 63
    18e6:	0f 90       	pop	r0
    18e8:	1f 90       	pop	r1
    18ea:	18 95       	reti

000018ec <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    18ec:	1f 92       	push	r1
    18ee:	0f 92       	push	r0
    18f0:	0f b6       	in	r0, 0x3f	; 63
    18f2:	0f 92       	push	r0
    18f4:	11 24       	eor	r1, r1
    18f6:	0b b6       	in	r0, 0x3b	; 59
    18f8:	0f 92       	push	r0
    18fa:	2f 93       	push	r18
    18fc:	3f 93       	push	r19
    18fe:	4f 93       	push	r20
    1900:	5f 93       	push	r21
    1902:	6f 93       	push	r22
    1904:	7f 93       	push	r23
    1906:	8f 93       	push	r24
    1908:	9f 93       	push	r25
    190a:	af 93       	push	r26
    190c:	bf 93       	push	r27
    190e:	ef 93       	push	r30
    1910:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    1912:	e0 e7       	ldi	r30, 0x70	; 112
    1914:	f2 e0       	ldi	r31, 0x02	; 2
    1916:	44 81       	ldd	r20, Z+4	; 0x04
    1918:	55 81       	ldd	r21, Z+5	; 0x05
    191a:	e0 91 b5 24 	lds	r30, 0x24B5
    191e:	f0 91 b6 24 	lds	r31, 0x24B6
    1922:	64 e0       	ldi	r22, 0x04	; 4
    1924:	80 e4       	ldi	r24, 0x40	; 64
    1926:	92 e0       	ldi	r25, 0x02	; 2
    1928:	19 95       	eicall
}
    192a:	ff 91       	pop	r31
    192c:	ef 91       	pop	r30
    192e:	bf 91       	pop	r27
    1930:	af 91       	pop	r26
    1932:	9f 91       	pop	r25
    1934:	8f 91       	pop	r24
    1936:	7f 91       	pop	r23
    1938:	6f 91       	pop	r22
    193a:	5f 91       	pop	r21
    193c:	4f 91       	pop	r20
    193e:	3f 91       	pop	r19
    1940:	2f 91       	pop	r18
    1942:	0f 90       	pop	r0
    1944:	0b be       	out	0x3b, r0	; 59
    1946:	0f 90       	pop	r0
    1948:	0f be       	out	0x3f, r0	; 63
    194a:	0f 90       	pop	r0
    194c:	1f 90       	pop	r1
    194e:	18 95       	reti

00001950 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1950:	1f 92       	push	r1
    1952:	0f 92       	push	r0
    1954:	0f b6       	in	r0, 0x3f	; 63
    1956:	0f 92       	push	r0
    1958:	11 24       	eor	r1, r1
    195a:	0b b6       	in	r0, 0x3b	; 59
    195c:	0f 92       	push	r0
    195e:	2f 93       	push	r18
    1960:	3f 93       	push	r19
    1962:	4f 93       	push	r20
    1964:	5f 93       	push	r21
    1966:	6f 93       	push	r22
    1968:	7f 93       	push	r23
    196a:	8f 93       	push	r24
    196c:	9f 93       	push	r25
    196e:	af 93       	push	r26
    1970:	bf 93       	push	r27
    1972:	ef 93       	push	r30
    1974:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    1976:	e8 e7       	ldi	r30, 0x78	; 120
    1978:	f2 e0       	ldi	r31, 0x02	; 2
    197a:	44 81       	ldd	r20, Z+4	; 0x04
    197c:	55 81       	ldd	r21, Z+5	; 0x05
    197e:	e0 91 b5 24 	lds	r30, 0x24B5
    1982:	f0 91 b6 24 	lds	r31, 0x24B6
    1986:	68 e0       	ldi	r22, 0x08	; 8
    1988:	80 e4       	ldi	r24, 0x40	; 64
    198a:	92 e0       	ldi	r25, 0x02	; 2
    198c:	19 95       	eicall
}
    198e:	ff 91       	pop	r31
    1990:	ef 91       	pop	r30
    1992:	bf 91       	pop	r27
    1994:	af 91       	pop	r26
    1996:	9f 91       	pop	r25
    1998:	8f 91       	pop	r24
    199a:	7f 91       	pop	r23
    199c:	6f 91       	pop	r22
    199e:	5f 91       	pop	r21
    19a0:	4f 91       	pop	r20
    19a2:	3f 91       	pop	r19
    19a4:	2f 91       	pop	r18
    19a6:	0f 90       	pop	r0
    19a8:	0b be       	out	0x3b, r0	; 59
    19aa:	0f 90       	pop	r0
    19ac:	0f be       	out	0x3f, r0	; 63
    19ae:	0f 90       	pop	r0
    19b0:	1f 90       	pop	r1
    19b2:	18 95       	reti

000019b4 <usart_putchar>:

	if (baud_offset != USART_BAUD_UNDEFINED) {
		(usart)->BAUDCTRLB = (uint8_t)((uint16_t)baudctrl);
		(usart)->BAUDCTRLA = (uint8_t)((uint16_t)baudctrl >> 8);
	}
}
    19b4:	fc 01       	movw	r30, r24
    19b6:	81 81       	ldd	r24, Z+1	; 0x01
    19b8:	85 ff       	sbrs	r24, 5
    19ba:	fd cf       	rjmp	.-6      	; 0x19b6 <usart_putchar+0x2>
    19bc:	60 83       	st	Z, r22
    19be:	80 e0       	ldi	r24, 0x00	; 0
    19c0:	90 e0       	ldi	r25, 0x00	; 0
    19c2:	08 95       	ret

000019c4 <usart_getchar>:
    19c4:	fc 01       	movw	r30, r24
    19c6:	81 81       	ldd	r24, Z+1	; 0x01
    19c8:	88 23       	and	r24, r24
    19ca:	ec f7       	brge	.-6      	; 0x19c6 <usart_getchar+0x2>
    19cc:	80 81       	ld	r24, Z
    19ce:	08 95       	ret

000019d0 <usart_set_baudrate>:
 * \retval true if the hardware supports the baud rate
 * \retval false if the hardware does not support the baud rate (i.e. it's
 *               either too high or too low.)
 */
bool usart_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    19d0:	4f 92       	push	r4
    19d2:	5f 92       	push	r5
    19d4:	6f 92       	push	r6
    19d6:	7f 92       	push	r7
    19d8:	8f 92       	push	r8
    19da:	9f 92       	push	r9
    19dc:	af 92       	push	r10
    19de:	bf 92       	push	r11
    19e0:	cf 92       	push	r12
    19e2:	df 92       	push	r13
    19e4:	ef 92       	push	r14
    19e6:	ff 92       	push	r15
    19e8:	0f 93       	push	r16
    19ea:	1f 93       	push	r17
    19ec:	cf 93       	push	r28
    19ee:	df 93       	push	r29
    19f0:	ec 01       	movw	r28, r24
    19f2:	4a 01       	movw	r8, r20
    19f4:	5b 01       	movw	r10, r22
    19f6:	28 01       	movw	r4, r16
    19f8:	39 01       	movw	r6, r18

	/*
	 * Check if the hardware supports the given baud rate
	 */
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
    19fa:	d9 01       	movw	r26, r18
    19fc:	c8 01       	movw	r24, r16
    19fe:	68 94       	set
    1a00:	12 f8       	bld	r1, 2
    1a02:	b6 95       	lsr	r27
    1a04:	a7 95       	ror	r26
    1a06:	97 95       	ror	r25
    1a08:	87 95       	ror	r24
    1a0a:	16 94       	lsr	r1
    1a0c:	d1 f7       	brne	.-12     	; 0x1a02 <usart_set_baudrate+0x32>
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;
    1a0e:	b9 01       	movw	r22, r18
    1a10:	a8 01       	movw	r20, r16
    1a12:	03 2e       	mov	r0, r19
    1a14:	36 e1       	ldi	r19, 0x16	; 22
    1a16:	76 95       	lsr	r23
    1a18:	67 95       	ror	r22
    1a1a:	57 95       	ror	r21
    1a1c:	47 95       	ror	r20
    1a1e:	3a 95       	dec	r19
    1a20:	d1 f7       	brne	.-12     	; 0x1a16 <usart_set_baudrate+0x46>
    1a22:	30 2d       	mov	r19, r0

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    1a24:	2c 81       	ldd	r18, Y+4	; 0x04
    1a26:	22 fd       	sbrc	r18, 2
    1a28:	08 c0       	rjmp	.+16     	; 0x1a3a <usart_set_baudrate+0x6a>
		max_rate /= 2;
    1a2a:	b6 95       	lsr	r27
    1a2c:	a7 95       	ror	r26
    1a2e:	97 95       	ror	r25
    1a30:	87 95       	ror	r24
		min_rate /= 2;
    1a32:	76 95       	lsr	r23
    1a34:	67 95       	ror	r22
    1a36:	57 95       	ror	r21
    1a38:	47 95       	ror	r20
	}

	if ((baud > max_rate) || (baud < min_rate)) {
    1a3a:	88 15       	cp	r24, r8
    1a3c:	99 05       	cpc	r25, r9
    1a3e:	aa 05       	cpc	r26, r10
    1a40:	bb 05       	cpc	r27, r11
    1a42:	08 f4       	brcc	.+2      	; 0x1a46 <usart_set_baudrate+0x76>
    1a44:	a6 c0       	rjmp	.+332    	; 0x1b92 <usart_set_baudrate+0x1c2>
    1a46:	84 16       	cp	r8, r20
    1a48:	95 06       	cpc	r9, r21
    1a4a:	a6 06       	cpc	r10, r22
    1a4c:	b7 06       	cpc	r11, r23
    1a4e:	08 f4       	brcc	.+2      	; 0x1a52 <usart_set_baudrate+0x82>
    1a50:	a2 c0       	rjmp	.+324    	; 0x1b96 <usart_set_baudrate+0x1c6>
		return false;
	}

	/* Check if double speed is enabled. */
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    1a52:	8c 81       	ldd	r24, Y+4	; 0x04
    1a54:	82 fd       	sbrc	r24, 2
    1a56:	04 c0       	rjmp	.+8      	; 0x1a60 <usart_set_baudrate+0x90>
		baud *= 2;
    1a58:	88 0c       	add	r8, r8
    1a5a:	99 1c       	adc	r9, r9
    1a5c:	aa 1c       	adc	r10, r10
    1a5e:	bb 1c       	adc	r11, r11
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;
    1a60:	c3 01       	movw	r24, r6
    1a62:	b2 01       	movw	r22, r4
    1a64:	a5 01       	movw	r20, r10
    1a66:	94 01       	movw	r18, r8
    1a68:	0e 94 c0 1c 	call	0x3980	; 0x3980 <__udivmodsi4>

	for (exp = -7; exp < 7; exp++) {
		if (ratio < limit) {
    1a6c:	2f 3f       	cpi	r18, 0xFF	; 255
    1a6e:	31 05       	cpc	r19, r1
    1a70:	41 05       	cpc	r20, r1
    1a72:	51 05       	cpc	r21, r1
    1a74:	08 f4       	brcc	.+2      	; 0x1a78 <usart_set_baudrate+0xa8>
    1a76:	91 c0       	rjmp	.+290    	; 0x1b9a <usart_set_baudrate+0x1ca>
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
		baud *= 2;
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
    1a78:	c1 2c       	mov	r12, r1
    1a7a:	d1 2c       	mov	r13, r1
    1a7c:	76 01       	movw	r14, r12
    1a7e:	ca 94       	dec	r12
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    1a80:	19 ef       	ldi	r17, 0xF9	; 249
    1a82:	05 c0       	rjmp	.+10     	; 0x1a8e <usart_set_baudrate+0xbe>
		if (ratio < limit) {
    1a84:	2c 15       	cp	r18, r12
    1a86:	3d 05       	cpc	r19, r13
    1a88:	4e 05       	cpc	r20, r14
    1a8a:	5f 05       	cpc	r21, r15
    1a8c:	68 f0       	brcs	.+26     	; 0x1aa8 <usart_set_baudrate+0xd8>
			break;
		}

		limit <<= 1;
    1a8e:	cc 0c       	add	r12, r12
    1a90:	dd 1c       	adc	r13, r13
    1a92:	ee 1c       	adc	r14, r14
    1a94:	ff 1c       	adc	r15, r15

		if (exp < -3) {
    1a96:	1d 3f       	cpi	r17, 0xFD	; 253
    1a98:	14 f4       	brge	.+4      	; 0x1a9e <usart_set_baudrate+0xce>
			limit |= 1;
    1a9a:	68 94       	set
    1a9c:	c0 f8       	bld	r12, 0

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    1a9e:	1f 5f       	subi	r17, 0xFF	; 255
    1aa0:	17 30       	cpi	r17, 0x07	; 7
    1aa2:	81 f7       	brne	.-32     	; 0x1a84 <usart_set_baudrate+0xb4>
    1aa4:	21 2f       	mov	r18, r17
    1aa6:	50 c0       	rjmp	.+160    	; 0x1b48 <usart_set_baudrate+0x178>
    1aa8:	21 2f       	mov	r18, r17
	 * point.
	 *
	 * The formula for calculating BSEL is slightly different when exp is
	 * negative than it is when exp is positive.
	 */
	if (exp < 0) {
    1aaa:	11 23       	and	r17, r17
    1aac:	0c f0       	brlt	.+2      	; 0x1ab0 <usart_set_baudrate+0xe0>
    1aae:	4c c0       	rjmp	.+152    	; 0x1b48 <usart_set_baudrate+0x178>
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    1ab0:	d5 01       	movw	r26, r10
    1ab2:	c4 01       	movw	r24, r8
    1ab4:	88 0f       	add	r24, r24
    1ab6:	99 1f       	adc	r25, r25
    1ab8:	aa 1f       	adc	r26, r26
    1aba:	bb 1f       	adc	r27, r27
    1abc:	88 0f       	add	r24, r24
    1abe:	99 1f       	adc	r25, r25
    1ac0:	aa 1f       	adc	r26, r26
    1ac2:	bb 1f       	adc	r27, r27
    1ac4:	88 0f       	add	r24, r24
    1ac6:	99 1f       	adc	r25, r25
    1ac8:	aa 1f       	adc	r26, r26
    1aca:	bb 1f       	adc	r27, r27
    1acc:	48 1a       	sub	r4, r24
    1ace:	59 0a       	sbc	r5, r25
    1ad0:	6a 0a       	sbc	r6, r26
    1ad2:	7b 0a       	sbc	r7, r27
		/* If we end up with a left-shift after taking the final
		 * divide-by-8 into account, do the shift before the divide.
		 * Otherwise, left-shift the denominator instead (effectively
		 * resulting in an overall right shift.)
		 */
		if (exp <= -3) {
    1ad4:	1e 3f       	cpi	r17, 0xFE	; 254
    1ad6:	f4 f4       	brge	.+60     	; 0x1b14 <usart_set_baudrate+0x144>
			div = ((cpu_hz << (-exp - 3)) + baud / 2) / baud;
    1ad8:	6d ef       	ldi	r22, 0xFD	; 253
    1ada:	7f ef       	ldi	r23, 0xFF	; 255
    1adc:	61 1b       	sub	r22, r17
    1ade:	71 09       	sbc	r23, r1
    1ae0:	17 fd       	sbrc	r17, 7
    1ae2:	73 95       	inc	r23
    1ae4:	04 c0       	rjmp	.+8      	; 0x1aee <usart_set_baudrate+0x11e>
    1ae6:	44 0c       	add	r4, r4
    1ae8:	55 1c       	adc	r5, r5
    1aea:	66 1c       	adc	r6, r6
    1aec:	77 1c       	adc	r7, r7
    1aee:	6a 95       	dec	r22
    1af0:	d2 f7       	brpl	.-12     	; 0x1ae6 <usart_set_baudrate+0x116>
    1af2:	d5 01       	movw	r26, r10
    1af4:	c4 01       	movw	r24, r8
    1af6:	b6 95       	lsr	r27
    1af8:	a7 95       	ror	r26
    1afa:	97 95       	ror	r25
    1afc:	87 95       	ror	r24
    1afe:	bc 01       	movw	r22, r24
    1b00:	cd 01       	movw	r24, r26
    1b02:	64 0d       	add	r22, r4
    1b04:	75 1d       	adc	r23, r5
    1b06:	86 1d       	adc	r24, r6
    1b08:	97 1d       	adc	r25, r7
    1b0a:	a5 01       	movw	r20, r10
    1b0c:	94 01       	movw	r18, r8
    1b0e:	0e 94 c0 1c 	call	0x3980	; 0x3980 <__udivmodsi4>
    1b12:	36 c0       	rjmp	.+108    	; 0x1b80 <usart_set_baudrate+0x1b0>
		} else {
			baud <<= exp + 3;
    1b14:	23 e0       	ldi	r18, 0x03	; 3
    1b16:	21 0f       	add	r18, r17
    1b18:	d5 01       	movw	r26, r10
    1b1a:	c4 01       	movw	r24, r8
    1b1c:	04 c0       	rjmp	.+8      	; 0x1b26 <usart_set_baudrate+0x156>
    1b1e:	88 0f       	add	r24, r24
    1b20:	99 1f       	adc	r25, r25
    1b22:	aa 1f       	adc	r26, r26
    1b24:	bb 1f       	adc	r27, r27
    1b26:	2a 95       	dec	r18
    1b28:	d2 f7       	brpl	.-12     	; 0x1b1e <usart_set_baudrate+0x14e>
    1b2a:	9c 01       	movw	r18, r24
    1b2c:	ad 01       	movw	r20, r26
			div = (cpu_hz + baud / 2) / baud;
    1b2e:	b6 95       	lsr	r27
    1b30:	a7 95       	ror	r26
    1b32:	97 95       	ror	r25
    1b34:	87 95       	ror	r24
    1b36:	bc 01       	movw	r22, r24
    1b38:	cd 01       	movw	r24, r26
    1b3a:	64 0d       	add	r22, r4
    1b3c:	75 1d       	adc	r23, r5
    1b3e:	86 1d       	adc	r24, r6
    1b40:	97 1d       	adc	r25, r7
    1b42:	0e 94 c0 1c 	call	0x3980	; 0x3980 <__udivmodsi4>
    1b46:	1c c0       	rjmp	.+56     	; 0x1b80 <usart_set_baudrate+0x1b0>
		}
	} else {
		/* We will always do a right shift in this case, but we need to
		 * shift three extra positions because of the divide-by-8.
		 */
		baud <<= exp + 3;
    1b48:	2d 5f       	subi	r18, 0xFD	; 253
    1b4a:	d5 01       	movw	r26, r10
    1b4c:	c4 01       	movw	r24, r8
    1b4e:	04 c0       	rjmp	.+8      	; 0x1b58 <usart_set_baudrate+0x188>
    1b50:	88 0f       	add	r24, r24
    1b52:	99 1f       	adc	r25, r25
    1b54:	aa 1f       	adc	r26, r26
    1b56:	bb 1f       	adc	r27, r27
    1b58:	2a 95       	dec	r18
    1b5a:	d2 f7       	brpl	.-12     	; 0x1b50 <usart_set_baudrate+0x180>
    1b5c:	9c 01       	movw	r18, r24
    1b5e:	ad 01       	movw	r20, r26
		div = (cpu_hz + baud / 2) / baud - 1;
    1b60:	b6 95       	lsr	r27
    1b62:	a7 95       	ror	r26
    1b64:	97 95       	ror	r25
    1b66:	87 95       	ror	r24
    1b68:	bc 01       	movw	r22, r24
    1b6a:	cd 01       	movw	r24, r26
    1b6c:	64 0d       	add	r22, r4
    1b6e:	75 1d       	adc	r23, r5
    1b70:	86 1d       	adc	r24, r6
    1b72:	97 1d       	adc	r25, r7
    1b74:	0e 94 c0 1c 	call	0x3980	; 0x3980 <__udivmodsi4>
    1b78:	21 50       	subi	r18, 0x01	; 1
    1b7a:	31 09       	sbc	r19, r1
    1b7c:	41 09       	sbc	r20, r1
    1b7e:	51 09       	sbc	r21, r1
	}

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
    1b80:	83 2f       	mov	r24, r19
    1b82:	8f 70       	andi	r24, 0x0F	; 15
    1b84:	12 95       	swap	r17
    1b86:	10 7f       	andi	r17, 0xF0	; 240
    1b88:	18 2b       	or	r17, r24
    1b8a:	1f 83       	std	Y+7, r17	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)div;
    1b8c:	2e 83       	std	Y+6, r18	; 0x06

	return true;
    1b8e:	81 e0       	ldi	r24, 0x01	; 1
    1b90:	18 c0       	rjmp	.+48     	; 0x1bc2 <usart_set_baudrate+0x1f2>
		max_rate /= 2;
		min_rate /= 2;
	}

	if ((baud > max_rate) || (baud < min_rate)) {
		return false;
    1b92:	80 e0       	ldi	r24, 0x00	; 0
    1b94:	16 c0       	rjmp	.+44     	; 0x1bc2 <usart_set_baudrate+0x1f2>
    1b96:	80 e0       	ldi	r24, 0x00	; 0
    1b98:	14 c0       	rjmp	.+40     	; 0x1bc2 <usart_set_baudrate+0x1f2>
	if (exp < 0) {
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    1b9a:	d5 01       	movw	r26, r10
    1b9c:	c4 01       	movw	r24, r8
    1b9e:	88 0f       	add	r24, r24
    1ba0:	99 1f       	adc	r25, r25
    1ba2:	aa 1f       	adc	r26, r26
    1ba4:	bb 1f       	adc	r27, r27
    1ba6:	88 0f       	add	r24, r24
    1ba8:	99 1f       	adc	r25, r25
    1baa:	aa 1f       	adc	r26, r26
    1bac:	bb 1f       	adc	r27, r27
    1bae:	88 0f       	add	r24, r24
    1bb0:	99 1f       	adc	r25, r25
    1bb2:	aa 1f       	adc	r26, r26
    1bb4:	bb 1f       	adc	r27, r27
    1bb6:	48 1a       	sub	r4, r24
    1bb8:	59 0a       	sbc	r5, r25
    1bba:	6a 0a       	sbc	r6, r26
    1bbc:	7b 0a       	sbc	r7, r27

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    1bbe:	19 ef       	ldi	r17, 0xF9	; 249
    1bc0:	8b cf       	rjmp	.-234    	; 0x1ad8 <usart_set_baudrate+0x108>

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
	(usart)->BAUDCTRLA = (uint8_t)div;

	return true;
}
    1bc2:	df 91       	pop	r29
    1bc4:	cf 91       	pop	r28
    1bc6:	1f 91       	pop	r17
    1bc8:	0f 91       	pop	r16
    1bca:	ff 90       	pop	r15
    1bcc:	ef 90       	pop	r14
    1bce:	df 90       	pop	r13
    1bd0:	cf 90       	pop	r12
    1bd2:	bf 90       	pop	r11
    1bd4:	af 90       	pop	r10
    1bd6:	9f 90       	pop	r9
    1bd8:	8f 90       	pop	r8
    1bda:	7f 90       	pop	r7
    1bdc:	6f 90       	pop	r6
    1bde:	5f 90       	pop	r5
    1be0:	4f 90       	pop	r4
    1be2:	08 95       	ret

00001be4 <usart_init_rs232>:
 *
 * \retval true if the initialization was successfull
 * \retval false if the initialization failed (error in baud rate calculation)
 */
bool usart_init_rs232(USART_t *usart, const usart_rs232_options_t *opt)
{
    1be4:	0f 93       	push	r16
    1be6:	1f 93       	push	r17
    1be8:	cf 93       	push	r28
    1bea:	df 93       	push	r29
    1bec:	ec 01       	movw	r28, r24
    1bee:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1bf0:	00 97       	sbiw	r24, 0x00	; 0
    1bf2:	09 f4       	brne	.+2      	; 0x1bf6 <usart_init_rs232+0x12>
    1bf4:	03 c1       	rjmp	.+518    	; 0x1dfc <usart_init_rs232+0x218>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1bf6:	80 3c       	cpi	r24, 0xC0	; 192
    1bf8:	91 05       	cpc	r25, r1
    1bfa:	29 f4       	brne	.+10     	; 0x1c06 <usart_init_rs232+0x22>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1bfc:	60 e1       	ldi	r22, 0x10	; 16
    1bfe:	80 e0       	ldi	r24, 0x00	; 0
    1c00:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1c04:	fb c0       	rjmp	.+502    	; 0x1dfc <usart_init_rs232+0x218>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1c06:	c0 38       	cpi	r28, 0x80	; 128
    1c08:	81 e0       	ldi	r24, 0x01	; 1
    1c0a:	d8 07       	cpc	r29, r24
    1c0c:	29 f4       	brne	.+10     	; 0x1c18 <usart_init_rs232+0x34>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1c0e:	62 e0       	ldi	r22, 0x02	; 2
    1c10:	80 e0       	ldi	r24, 0x00	; 0
    1c12:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1c16:	f2 c0       	rjmp	.+484    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1c18:	c1 15       	cp	r28, r1
    1c1a:	e1 e0       	ldi	r30, 0x01	; 1
    1c1c:	de 07       	cpc	r29, r30
    1c1e:	29 f4       	brne	.+10     	; 0x1c2a <usart_init_rs232+0x46>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1c20:	61 e0       	ldi	r22, 0x01	; 1
    1c22:	80 e0       	ldi	r24, 0x00	; 0
    1c24:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1c28:	e9 c0       	rjmp	.+466    	; 0x1dfc <usart_init_rs232+0x218>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1c2a:	c0 38       	cpi	r28, 0x80	; 128
    1c2c:	f3 e0       	ldi	r31, 0x03	; 3
    1c2e:	df 07       	cpc	r29, r31
    1c30:	29 f4       	brne	.+10     	; 0x1c3c <usart_init_rs232+0x58>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1c32:	61 e0       	ldi	r22, 0x01	; 1
    1c34:	81 e0       	ldi	r24, 0x01	; 1
    1c36:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1c3a:	e0 c0       	rjmp	.+448    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1c3c:	c0 39       	cpi	r28, 0x90	; 144
    1c3e:	83 e0       	ldi	r24, 0x03	; 3
    1c40:	d8 07       	cpc	r29, r24
    1c42:	29 f4       	brne	.+10     	; 0x1c4e <usart_init_rs232+0x6a>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1c44:	61 e0       	ldi	r22, 0x01	; 1
    1c46:	82 e0       	ldi	r24, 0x02	; 2
    1c48:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1c4c:	d7 c0       	rjmp	.+430    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    1c4e:	c1 15       	cp	r28, r1
    1c50:	e2 e0       	ldi	r30, 0x02	; 2
    1c52:	de 07       	cpc	r29, r30
    1c54:	29 f4       	brne	.+10     	; 0x1c60 <usart_init_rs232+0x7c>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1c56:	62 e0       	ldi	r22, 0x02	; 2
    1c58:	81 e0       	ldi	r24, 0x01	; 1
    1c5a:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1c5e:	ce c0       	rjmp	.+412    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    1c60:	c0 34       	cpi	r28, 0x40	; 64
    1c62:	f2 e0       	ldi	r31, 0x02	; 2
    1c64:	df 07       	cpc	r29, r31
    1c66:	29 f4       	brne	.+10     	; 0x1c72 <usart_init_rs232+0x8e>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1c68:	62 e0       	ldi	r22, 0x02	; 2
    1c6a:	82 e0       	ldi	r24, 0x02	; 2
    1c6c:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1c70:	c5 c0       	rjmp	.+394    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1c72:	c0 32       	cpi	r28, 0x20	; 32
    1c74:	83 e0       	ldi	r24, 0x03	; 3
    1c76:	d8 07       	cpc	r29, r24
    1c78:	29 f4       	brne	.+10     	; 0x1c84 <usart_init_rs232+0xa0>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1c7a:	64 e0       	ldi	r22, 0x04	; 4
    1c7c:	82 e0       	ldi	r24, 0x02	; 2
    1c7e:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1c82:	bc c0       	rjmp	.+376    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1c84:	c1 15       	cp	r28, r1
    1c86:	e8 e0       	ldi	r30, 0x08	; 8
    1c88:	de 07       	cpc	r29, r30
    1c8a:	29 f4       	brne	.+10     	; 0x1c96 <usart_init_rs232+0xb2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1c8c:	61 e0       	ldi	r22, 0x01	; 1
    1c8e:	83 e0       	ldi	r24, 0x03	; 3
    1c90:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1c94:	b3 c0       	rjmp	.+358    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1c96:	c1 15       	cp	r28, r1
    1c98:	f9 e0       	ldi	r31, 0x09	; 9
    1c9a:	df 07       	cpc	r29, r31
    1c9c:	29 f4       	brne	.+10     	; 0x1ca8 <usart_init_rs232+0xc4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1c9e:	61 e0       	ldi	r22, 0x01	; 1
    1ca0:	84 e0       	ldi	r24, 0x04	; 4
    1ca2:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1ca6:	aa c0       	rjmp	.+340    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1ca8:	c1 15       	cp	r28, r1
    1caa:	8a e0       	ldi	r24, 0x0A	; 10
    1cac:	d8 07       	cpc	r29, r24
    1cae:	29 f4       	brne	.+10     	; 0x1cba <usart_init_rs232+0xd6>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    1cb0:	61 e0       	ldi	r22, 0x01	; 1
    1cb2:	85 e0       	ldi	r24, 0x05	; 5
    1cb4:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1cb8:	a1 c0       	rjmp	.+322    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1cba:	c1 15       	cp	r28, r1
    1cbc:	eb e0       	ldi	r30, 0x0B	; 11
    1cbe:	de 07       	cpc	r29, r30
    1cc0:	29 f4       	brne	.+10     	; 0x1ccc <usart_init_rs232+0xe8>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1cc2:	61 e0       	ldi	r22, 0x01	; 1
    1cc4:	86 e0       	ldi	r24, 0x06	; 6
    1cc6:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1cca:	98 c0       	rjmp	.+304    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1ccc:	c0 34       	cpi	r28, 0x40	; 64
    1cce:	f8 e0       	ldi	r31, 0x08	; 8
    1cd0:	df 07       	cpc	r29, r31
    1cd2:	29 f4       	brne	.+10     	; 0x1cde <usart_init_rs232+0xfa>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1cd4:	62 e0       	ldi	r22, 0x02	; 2
    1cd6:	83 e0       	ldi	r24, 0x03	; 3
    1cd8:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1cdc:	8f c0       	rjmp	.+286    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1cde:	c0 34       	cpi	r28, 0x40	; 64
    1ce0:	89 e0       	ldi	r24, 0x09	; 9
    1ce2:	d8 07       	cpc	r29, r24
    1ce4:	29 f4       	brne	.+10     	; 0x1cf0 <usart_init_rs232+0x10c>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1ce6:	62 e0       	ldi	r22, 0x02	; 2
    1ce8:	84 e0       	ldi	r24, 0x04	; 4
    1cea:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1cee:	86 c0       	rjmp	.+268    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1cf0:	c0 34       	cpi	r28, 0x40	; 64
    1cf2:	ea e0       	ldi	r30, 0x0A	; 10
    1cf4:	de 07       	cpc	r29, r30
    1cf6:	29 f4       	brne	.+10     	; 0x1d02 <usart_init_rs232+0x11e>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1cf8:	62 e0       	ldi	r22, 0x02	; 2
    1cfa:	85 e0       	ldi	r24, 0x05	; 5
    1cfc:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1d00:	7d c0       	rjmp	.+250    	; 0x1dfc <usart_init_rs232+0x218>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1d02:	c0 39       	cpi	r28, 0x90	; 144
    1d04:	f8 e0       	ldi	r31, 0x08	; 8
    1d06:	df 07       	cpc	r29, r31
    1d08:	29 f4       	brne	.+10     	; 0x1d14 <usart_init_rs232+0x130>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1d0a:	64 e0       	ldi	r22, 0x04	; 4
    1d0c:	83 e0       	ldi	r24, 0x03	; 3
    1d0e:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1d12:	74 c0       	rjmp	.+232    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1d14:	c0 39       	cpi	r28, 0x90	; 144
    1d16:	89 e0       	ldi	r24, 0x09	; 9
    1d18:	d8 07       	cpc	r29, r24
    1d1a:	29 f4       	brne	.+10     	; 0x1d26 <usart_init_rs232+0x142>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1d1c:	64 e0       	ldi	r22, 0x04	; 4
    1d1e:	84 e0       	ldi	r24, 0x04	; 4
    1d20:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1d24:	6b c0       	rjmp	.+214    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1d26:	c0 39       	cpi	r28, 0x90	; 144
    1d28:	ea e0       	ldi	r30, 0x0A	; 10
    1d2a:	de 07       	cpc	r29, r30
    1d2c:	29 f4       	brne	.+10     	; 0x1d38 <usart_init_rs232+0x154>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1d2e:	64 e0       	ldi	r22, 0x04	; 4
    1d30:	85 e0       	ldi	r24, 0x05	; 5
    1d32:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1d36:	62 c0       	rjmp	.+196    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    1d38:	c0 39       	cpi	r28, 0x90	; 144
    1d3a:	fb e0       	ldi	r31, 0x0B	; 11
    1d3c:	df 07       	cpc	r29, r31
    1d3e:	29 f4       	brne	.+10     	; 0x1d4a <usart_init_rs232+0x166>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1d40:	64 e0       	ldi	r22, 0x04	; 4
    1d42:	86 e0       	ldi	r24, 0x06	; 6
    1d44:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1d48:	59 c0       	rjmp	.+178    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    1d4a:	c0 3c       	cpi	r28, 0xC0	; 192
    1d4c:	88 e0       	ldi	r24, 0x08	; 8
    1d4e:	d8 07       	cpc	r29, r24
    1d50:	29 f4       	brne	.+10     	; 0x1d5c <usart_init_rs232+0x178>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1d52:	68 e0       	ldi	r22, 0x08	; 8
    1d54:	83 e0       	ldi	r24, 0x03	; 3
    1d56:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1d5a:	50 c0       	rjmp	.+160    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    1d5c:	c0 3c       	cpi	r28, 0xC0	; 192
    1d5e:	e9 e0       	ldi	r30, 0x09	; 9
    1d60:	de 07       	cpc	r29, r30
    1d62:	29 f4       	brne	.+10     	; 0x1d6e <usart_init_rs232+0x18a>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1d64:	68 e0       	ldi	r22, 0x08	; 8
    1d66:	84 e0       	ldi	r24, 0x04	; 4
    1d68:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1d6c:	47 c0       	rjmp	.+142    	; 0x1dfc <usart_init_rs232+0x218>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1d6e:	c0 3a       	cpi	r28, 0xA0	; 160
    1d70:	f8 e0       	ldi	r31, 0x08	; 8
    1d72:	df 07       	cpc	r29, r31
    1d74:	29 f4       	brne	.+10     	; 0x1d80 <usart_init_rs232+0x19c>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1d76:	60 e1       	ldi	r22, 0x10	; 16
    1d78:	83 e0       	ldi	r24, 0x03	; 3
    1d7a:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1d7e:	3e c0       	rjmp	.+124    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1d80:	c0 3a       	cpi	r28, 0xA0	; 160
    1d82:	89 e0       	ldi	r24, 0x09	; 9
    1d84:	d8 07       	cpc	r29, r24
    1d86:	29 f4       	brne	.+10     	; 0x1d92 <usart_init_rs232+0x1ae>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1d88:	60 e1       	ldi	r22, 0x10	; 16
    1d8a:	84 e0       	ldi	r24, 0x04	; 4
    1d8c:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1d90:	35 c0       	rjmp	.+106    	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1d92:	c0 3a       	cpi	r28, 0xA0	; 160
    1d94:	ea e0       	ldi	r30, 0x0A	; 10
    1d96:	de 07       	cpc	r29, r30
    1d98:	29 f4       	brne	.+10     	; 0x1da4 <usart_init_rs232+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1d9a:	60 e1       	ldi	r22, 0x10	; 16
    1d9c:	85 e0       	ldi	r24, 0x05	; 5
    1d9e:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1da2:	2c c0       	rjmp	.+88     	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1da4:	c0 3a       	cpi	r28, 0xA0	; 160
    1da6:	fb e0       	ldi	r31, 0x0B	; 11
    1da8:	df 07       	cpc	r29, r31
    1daa:	29 f4       	brne	.+10     	; 0x1db6 <usart_init_rs232+0x1d2>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1dac:	60 e1       	ldi	r22, 0x10	; 16
    1dae:	86 e0       	ldi	r24, 0x06	; 6
    1db0:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1db4:	23 c0       	rjmp	.+70     	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1db6:	c0 3b       	cpi	r28, 0xB0	; 176
    1db8:	88 e0       	ldi	r24, 0x08	; 8
    1dba:	d8 07       	cpc	r29, r24
    1dbc:	29 f4       	brne	.+10     	; 0x1dc8 <usart_init_rs232+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1dbe:	60 e2       	ldi	r22, 0x20	; 32
    1dc0:	83 e0       	ldi	r24, 0x03	; 3
    1dc2:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1dc6:	1a c0       	rjmp	.+52     	; 0x1dfc <usart_init_rs232+0x218>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1dc8:	c0 3b       	cpi	r28, 0xB0	; 176
    1dca:	e9 e0       	ldi	r30, 0x09	; 9
    1dcc:	de 07       	cpc	r29, r30
    1dce:	29 f4       	brne	.+10     	; 0x1dda <usart_init_rs232+0x1f6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1dd0:	60 e2       	ldi	r22, 0x20	; 32
    1dd2:	84 e0       	ldi	r24, 0x04	; 4
    1dd4:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1dd8:	11 c0       	rjmp	.+34     	; 0x1dfc <usart_init_rs232+0x218>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1dda:	c0 38       	cpi	r28, 0x80	; 128
    1ddc:	f4 e0       	ldi	r31, 0x04	; 4
    1dde:	df 07       	cpc	r29, r31
    1de0:	29 f4       	brne	.+10     	; 0x1dec <usart_init_rs232+0x208>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1de2:	60 e4       	ldi	r22, 0x40	; 64
    1de4:	83 e0       	ldi	r24, 0x03	; 3
    1de6:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1dea:	08 c0       	rjmp	.+16     	; 0x1dfc <usart_init_rs232+0x218>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1dec:	c0 3a       	cpi	r28, 0xA0	; 160
    1dee:	84 e0       	ldi	r24, 0x04	; 4
    1df0:	d8 07       	cpc	r29, r24
    1df2:	21 f4       	brne	.+8      	; 0x1dfc <usart_init_rs232+0x218>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1df4:	60 e4       	ldi	r22, 0x40	; 64
    1df6:	85 e0       	ldi	r24, 0x05	; 5
    1df8:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1dfc:	8d 81       	ldd	r24, Y+5	; 0x05
    1dfe:	8f 73       	andi	r24, 0x3F	; 63
    1e00:	8d 83       	std	Y+5, r24	; 0x05
 *  \param twoStopBits Enable two stop bit mode. Use bool type.
 */
static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
		USART_PMODE_t parityMode, bool twoStopBits)
{
	(usart)->CTRLC = (uint8_t)charSize | parityMode
    1e02:	f8 01       	movw	r30, r16
    1e04:	94 81       	ldd	r25, Z+4	; 0x04
    1e06:	85 81       	ldd	r24, Z+5	; 0x05
    1e08:	89 2b       	or	r24, r25
    1e0a:	96 81       	ldd	r25, Z+6	; 0x06
    1e0c:	99 23       	and	r25, r25
    1e0e:	11 f0       	breq	.+4      	; 0x1e14 <usart_init_rs232+0x230>
    1e10:	98 e0       	ldi	r25, 0x08	; 8
    1e12:	01 c0       	rjmp	.+2      	; 0x1e16 <usart_init_rs232+0x232>
    1e14:	90 e0       	ldi	r25, 0x00	; 0
    1e16:	89 2b       	or	r24, r25
    1e18:	8d 83       	std	Y+5, r24	; 0x05
	bool result;
	sysclk_enable_peripheral_clock(usart);
	usart_set_mode(usart, USART_CMODE_ASYNCHRONOUS_gc);
	usart_format_set(usart, opt->charlength, opt->paritytype,
			opt->stopbits);
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1e1a:	f8 01       	movw	r30, r16
    1e1c:	40 81       	ld	r20, Z
    1e1e:	51 81       	ldd	r21, Z+1	; 0x01
    1e20:	62 81       	ldd	r22, Z+2	; 0x02
    1e22:	73 81       	ldd	r23, Z+3	; 0x03
    1e24:	00 e8       	ldi	r16, 0x80	; 128
    1e26:	14 e8       	ldi	r17, 0x84	; 132
    1e28:	2e e1       	ldi	r18, 0x1E	; 30
    1e2a:	30 e0       	ldi	r19, 0x00	; 0
    1e2c:	ce 01       	movw	r24, r28
    1e2e:	d0 dd       	rcall	.-1120   	; 0x19d0 <usart_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1e30:	9c 81       	ldd	r25, Y+4	; 0x04
    1e32:	98 60       	ori	r25, 0x08	; 8
    1e34:	9c 83       	std	Y+4, r25	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1e36:	9c 81       	ldd	r25, Y+4	; 0x04
    1e38:	90 61       	ori	r25, 0x10	; 16
    1e3a:	9c 83       	std	Y+4, r25	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
    1e3c:	df 91       	pop	r29
    1e3e:	cf 91       	pop	r28
    1e40:	1f 91       	pop	r17
    1e42:	0f 91       	pop	r16
    1e44:	08 95       	ret

00001e46 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1e46:	cf 92       	push	r12
    1e48:	df 92       	push	r13
    1e4a:	ef 92       	push	r14
    1e4c:	ff 92       	push	r15
    1e4e:	0f 93       	push	r16
    1e50:	1f 93       	push	r17
    1e52:	cf 93       	push	r28
    1e54:	df 93       	push	r29
    1e56:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    1e58:	68 01       	movw	r12, r16
    1e5a:	79 01       	movw	r14, r18
    1e5c:	f6 94       	lsr	r15
    1e5e:	e7 94       	ror	r14
    1e60:	d7 94       	ror	r13
    1e62:	c7 94       	ror	r12
    1e64:	4c 15       	cp	r20, r12
    1e66:	5d 05       	cpc	r21, r13
    1e68:	6e 05       	cpc	r22, r14
    1e6a:	7f 05       	cpc	r23, r15
    1e6c:	78 f4       	brcc	.+30     	; 0x1e8c <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1e6e:	6a 01       	movw	r12, r20
    1e70:	7b 01       	movw	r14, r22
    1e72:	cc 0c       	add	r12, r12
    1e74:	dd 1c       	adc	r13, r13
    1e76:	ee 1c       	adc	r14, r14
    1e78:	ff 1c       	adc	r15, r15
    1e7a:	c9 01       	movw	r24, r18
    1e7c:	b8 01       	movw	r22, r16
    1e7e:	a7 01       	movw	r20, r14
    1e80:	96 01       	movw	r18, r12
    1e82:	0e 94 c0 1c 	call	0x3980	; 0x3980 <__udivmodsi4>
    1e86:	21 50       	subi	r18, 0x01	; 1
    1e88:	31 09       	sbc	r19, r1
    1e8a:	02 c0       	rjmp	.+4      	; 0x1e90 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1e8c:	20 e0       	ldi	r18, 0x00	; 0
    1e8e:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1e90:	83 2f       	mov	r24, r19
    1e92:	8f 70       	andi	r24, 0x0F	; 15
    1e94:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1e96:	2e 83       	std	Y+6, r18	; 0x06
}
    1e98:	df 91       	pop	r29
    1e9a:	cf 91       	pop	r28
    1e9c:	1f 91       	pop	r17
    1e9e:	0f 91       	pop	r16
    1ea0:	ff 90       	pop	r15
    1ea2:	ef 90       	pop	r14
    1ea4:	df 90       	pop	r13
    1ea6:	cf 90       	pop	r12
    1ea8:	08 95       	ret

00001eaa <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1eaa:	ff 92       	push	r15
    1eac:	0f 93       	push	r16
    1eae:	1f 93       	push	r17
    1eb0:	cf 93       	push	r28
    1eb2:	df 93       	push	r29
    1eb4:	ec 01       	movw	r28, r24
    1eb6:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1eb8:	00 97       	sbiw	r24, 0x00	; 0
    1eba:	09 f4       	brne	.+2      	; 0x1ebe <usart_init_spi+0x14>
    1ebc:	b2 c1       	rjmp	.+868    	; 0x2222 <usart_init_spi+0x378>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1ebe:	80 3c       	cpi	r24, 0xC0	; 192
    1ec0:	91 05       	cpc	r25, r1
    1ec2:	29 f4       	brne	.+10     	; 0x1ece <usart_init_spi+0x24>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1ec4:	60 e1       	ldi	r22, 0x10	; 16
    1ec6:	80 e0       	ldi	r24, 0x00	; 0
    1ec8:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1ecc:	aa c1       	rjmp	.+852    	; 0x2222 <usart_init_spi+0x378>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1ece:	80 38       	cpi	r24, 0x80	; 128
    1ed0:	21 e0       	ldi	r18, 0x01	; 1
    1ed2:	92 07       	cpc	r25, r18
    1ed4:	29 f4       	brne	.+10     	; 0x1ee0 <usart_init_spi+0x36>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1ed6:	62 e0       	ldi	r22, 0x02	; 2
    1ed8:	80 e0       	ldi	r24, 0x00	; 0
    1eda:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1ede:	a1 c1       	rjmp	.+834    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1ee0:	c1 15       	cp	r28, r1
    1ee2:	81 e0       	ldi	r24, 0x01	; 1
    1ee4:	d8 07       	cpc	r29, r24
    1ee6:	29 f4       	brne	.+10     	; 0x1ef2 <usart_init_spi+0x48>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1ee8:	61 e0       	ldi	r22, 0x01	; 1
    1eea:	80 e0       	ldi	r24, 0x00	; 0
    1eec:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1ef0:	98 c1       	rjmp	.+816    	; 0x2222 <usart_init_spi+0x378>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1ef2:	c0 38       	cpi	r28, 0x80	; 128
    1ef4:	e3 e0       	ldi	r30, 0x03	; 3
    1ef6:	de 07       	cpc	r29, r30
    1ef8:	29 f4       	brne	.+10     	; 0x1f04 <usart_init_spi+0x5a>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1efa:	61 e0       	ldi	r22, 0x01	; 1
    1efc:	81 e0       	ldi	r24, 0x01	; 1
    1efe:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1f02:	8f c1       	rjmp	.+798    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1f04:	c0 39       	cpi	r28, 0x90	; 144
    1f06:	f3 e0       	ldi	r31, 0x03	; 3
    1f08:	df 07       	cpc	r29, r31
    1f0a:	29 f4       	brne	.+10     	; 0x1f16 <usart_init_spi+0x6c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1f0c:	61 e0       	ldi	r22, 0x01	; 1
    1f0e:	82 e0       	ldi	r24, 0x02	; 2
    1f10:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1f14:	86 c1       	rjmp	.+780    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    1f16:	c1 15       	cp	r28, r1
    1f18:	22 e0       	ldi	r18, 0x02	; 2
    1f1a:	d2 07       	cpc	r29, r18
    1f1c:	29 f4       	brne	.+10     	; 0x1f28 <usart_init_spi+0x7e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1f1e:	62 e0       	ldi	r22, 0x02	; 2
    1f20:	81 e0       	ldi	r24, 0x01	; 1
    1f22:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1f26:	7d c1       	rjmp	.+762    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    1f28:	c0 34       	cpi	r28, 0x40	; 64
    1f2a:	82 e0       	ldi	r24, 0x02	; 2
    1f2c:	d8 07       	cpc	r29, r24
    1f2e:	29 f4       	brne	.+10     	; 0x1f3a <usart_init_spi+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1f30:	62 e0       	ldi	r22, 0x02	; 2
    1f32:	82 e0       	ldi	r24, 0x02	; 2
    1f34:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1f38:	74 c1       	rjmp	.+744    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1f3a:	c0 32       	cpi	r28, 0x20	; 32
    1f3c:	e3 e0       	ldi	r30, 0x03	; 3
    1f3e:	de 07       	cpc	r29, r30
    1f40:	29 f4       	brne	.+10     	; 0x1f4c <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1f42:	64 e0       	ldi	r22, 0x04	; 4
    1f44:	82 e0       	ldi	r24, 0x02	; 2
    1f46:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1f4a:	6b c1       	rjmp	.+726    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1f4c:	c1 15       	cp	r28, r1
    1f4e:	f8 e0       	ldi	r31, 0x08	; 8
    1f50:	df 07       	cpc	r29, r31
    1f52:	29 f4       	brne	.+10     	; 0x1f5e <usart_init_spi+0xb4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1f54:	61 e0       	ldi	r22, 0x01	; 1
    1f56:	83 e0       	ldi	r24, 0x03	; 3
    1f58:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1f5c:	62 c1       	rjmp	.+708    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1f5e:	c1 15       	cp	r28, r1
    1f60:	29 e0       	ldi	r18, 0x09	; 9
    1f62:	d2 07       	cpc	r29, r18
    1f64:	29 f4       	brne	.+10     	; 0x1f70 <usart_init_spi+0xc6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1f66:	61 e0       	ldi	r22, 0x01	; 1
    1f68:	84 e0       	ldi	r24, 0x04	; 4
    1f6a:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1f6e:	59 c1       	rjmp	.+690    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1f70:	c1 15       	cp	r28, r1
    1f72:	8a e0       	ldi	r24, 0x0A	; 10
    1f74:	d8 07       	cpc	r29, r24
    1f76:	29 f4       	brne	.+10     	; 0x1f82 <usart_init_spi+0xd8>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    1f78:	61 e0       	ldi	r22, 0x01	; 1
    1f7a:	85 e0       	ldi	r24, 0x05	; 5
    1f7c:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1f80:	50 c1       	rjmp	.+672    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1f82:	c1 15       	cp	r28, r1
    1f84:	eb e0       	ldi	r30, 0x0B	; 11
    1f86:	de 07       	cpc	r29, r30
    1f88:	29 f4       	brne	.+10     	; 0x1f94 <usart_init_spi+0xea>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1f8a:	61 e0       	ldi	r22, 0x01	; 1
    1f8c:	86 e0       	ldi	r24, 0x06	; 6
    1f8e:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1f92:	47 c1       	rjmp	.+654    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1f94:	c0 34       	cpi	r28, 0x40	; 64
    1f96:	f8 e0       	ldi	r31, 0x08	; 8
    1f98:	df 07       	cpc	r29, r31
    1f9a:	29 f4       	brne	.+10     	; 0x1fa6 <usart_init_spi+0xfc>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1f9c:	62 e0       	ldi	r22, 0x02	; 2
    1f9e:	83 e0       	ldi	r24, 0x03	; 3
    1fa0:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1fa4:	3e c1       	rjmp	.+636    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1fa6:	c0 34       	cpi	r28, 0x40	; 64
    1fa8:	29 e0       	ldi	r18, 0x09	; 9
    1faa:	d2 07       	cpc	r29, r18
    1fac:	29 f4       	brne	.+10     	; 0x1fb8 <usart_init_spi+0x10e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1fae:	62 e0       	ldi	r22, 0x02	; 2
    1fb0:	84 e0       	ldi	r24, 0x04	; 4
    1fb2:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1fb6:	35 c1       	rjmp	.+618    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1fb8:	c0 34       	cpi	r28, 0x40	; 64
    1fba:	8a e0       	ldi	r24, 0x0A	; 10
    1fbc:	d8 07       	cpc	r29, r24
    1fbe:	29 f4       	brne	.+10     	; 0x1fca <usart_init_spi+0x120>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1fc0:	62 e0       	ldi	r22, 0x02	; 2
    1fc2:	85 e0       	ldi	r24, 0x05	; 5
    1fc4:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1fc8:	2c c1       	rjmp	.+600    	; 0x2222 <usart_init_spi+0x378>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1fca:	c0 39       	cpi	r28, 0x90	; 144
    1fcc:	e8 e0       	ldi	r30, 0x08	; 8
    1fce:	de 07       	cpc	r29, r30
    1fd0:	29 f4       	brne	.+10     	; 0x1fdc <usart_init_spi+0x132>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1fd2:	64 e0       	ldi	r22, 0x04	; 4
    1fd4:	83 e0       	ldi	r24, 0x03	; 3
    1fd6:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1fda:	23 c1       	rjmp	.+582    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1fdc:	c0 39       	cpi	r28, 0x90	; 144
    1fde:	f9 e0       	ldi	r31, 0x09	; 9
    1fe0:	df 07       	cpc	r29, r31
    1fe2:	29 f4       	brne	.+10     	; 0x1fee <usart_init_spi+0x144>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1fe4:	64 e0       	ldi	r22, 0x04	; 4
    1fe6:	84 e0       	ldi	r24, 0x04	; 4
    1fe8:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1fec:	1a c1       	rjmp	.+564    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1fee:	c0 39       	cpi	r28, 0x90	; 144
    1ff0:	2a e0       	ldi	r18, 0x0A	; 10
    1ff2:	d2 07       	cpc	r29, r18
    1ff4:	29 f4       	brne	.+10     	; 0x2000 <usart_init_spi+0x156>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1ff6:	64 e0       	ldi	r22, 0x04	; 4
    1ff8:	85 e0       	ldi	r24, 0x05	; 5
    1ffa:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    1ffe:	11 c1       	rjmp	.+546    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    2000:	c0 39       	cpi	r28, 0x90	; 144
    2002:	8b e0       	ldi	r24, 0x0B	; 11
    2004:	d8 07       	cpc	r29, r24
    2006:	29 f4       	brne	.+10     	; 0x2012 <usart_init_spi+0x168>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    2008:	64 e0       	ldi	r22, 0x04	; 4
    200a:	86 e0       	ldi	r24, 0x06	; 6
    200c:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    2010:	08 c1       	rjmp	.+528    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    2012:	c0 3c       	cpi	r28, 0xC0	; 192
    2014:	e8 e0       	ldi	r30, 0x08	; 8
    2016:	de 07       	cpc	r29, r30
    2018:	29 f4       	brne	.+10     	; 0x2024 <usart_init_spi+0x17a>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    201a:	68 e0       	ldi	r22, 0x08	; 8
    201c:	83 e0       	ldi	r24, 0x03	; 3
    201e:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    2022:	ff c0       	rjmp	.+510    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    2024:	c0 3c       	cpi	r28, 0xC0	; 192
    2026:	f9 e0       	ldi	r31, 0x09	; 9
    2028:	df 07       	cpc	r29, r31
    202a:	29 f4       	brne	.+10     	; 0x2036 <usart_init_spi+0x18c>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    202c:	68 e0       	ldi	r22, 0x08	; 8
    202e:	84 e0       	ldi	r24, 0x04	; 4
    2030:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    2034:	f6 c0       	rjmp	.+492    	; 0x2222 <usart_init_spi+0x378>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    2036:	c0 3a       	cpi	r28, 0xA0	; 160
    2038:	28 e0       	ldi	r18, 0x08	; 8
    203a:	d2 07       	cpc	r29, r18
    203c:	79 f4       	brne	.+30     	; 0x205c <usart_init_spi+0x1b2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    203e:	60 e1       	ldi	r22, 0x10	; 16
    2040:	83 e0       	ldi	r24, 0x03	; 3
    2042:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    2046:	e0 ea       	ldi	r30, 0xA0	; 160
    2048:	f8 e0       	ldi	r31, 0x08	; 8
    204a:	84 81       	ldd	r24, Z+4	; 0x04
    204c:	8f 7e       	andi	r24, 0xEF	; 239
    204e:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    2050:	f8 01       	movw	r30, r16
    2052:	34 81       	ldd	r19, Z+4	; 0x04
    2054:	32 50       	subi	r19, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    2056:	80 ea       	ldi	r24, 0xA0	; 160
    2058:	98 e0       	ldi	r25, 0x08	; 8
    205a:	44 c0       	rjmp	.+136    	; 0x20e4 <usart_init_spi+0x23a>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    205c:	c0 3a       	cpi	r28, 0xA0	; 160
    205e:	f9 e0       	ldi	r31, 0x09	; 9
    2060:	df 07       	cpc	r29, r31
    2062:	29 f4       	brne	.+10     	; 0x206e <usart_init_spi+0x1c4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    2064:	60 e1       	ldi	r22, 0x10	; 16
    2066:	84 e0       	ldi	r24, 0x04	; 4
    2068:	0e 94 3c 18 	call	0x3078	; 0x3078 <sysclk_enable_module>
    206c:	da c0       	rjmp	.+436    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    206e:	c0 3a       	cpi	r28, 0xA0	; 160
    2070:	2a e0       	ldi	r18, 0x0A	; 10
    2072:	d2 07       	cpc	r29, r18
    2074:	21 f4       	brne	.+8      	; 0x207e <usart_init_spi+0x1d4>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    2076:	60 e1       	ldi	r22, 0x10	; 16
    2078:	85 e0       	ldi	r24, 0x05	; 5
    207a:	fe d7       	rcall	.+4092   	; 0x3078 <sysclk_enable_module>
    207c:	d2 c0       	rjmp	.+420    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    207e:	c0 3a       	cpi	r28, 0xA0	; 160
    2080:	8b e0       	ldi	r24, 0x0B	; 11
    2082:	d8 07       	cpc	r29, r24
    2084:	21 f4       	brne	.+8      	; 0x208e <usart_init_spi+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    2086:	60 e1       	ldi	r22, 0x10	; 16
    2088:	86 e0       	ldi	r24, 0x06	; 6
    208a:	f6 d7       	rcall	.+4076   	; 0x3078 <sysclk_enable_module>
    208c:	ca c0       	rjmp	.+404    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    208e:	c0 3b       	cpi	r28, 0xB0	; 176
    2090:	e8 e0       	ldi	r30, 0x08	; 8
    2092:	de 07       	cpc	r29, r30
    2094:	21 f4       	brne	.+8      	; 0x209e <usart_init_spi+0x1f4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    2096:	60 e2       	ldi	r22, 0x20	; 32
    2098:	83 e0       	ldi	r24, 0x03	; 3
    209a:	ee d7       	rcall	.+4060   	; 0x3078 <sysclk_enable_module>
    209c:	c2 c0       	rjmp	.+388    	; 0x2222 <usart_init_spi+0x378>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    209e:	c0 3b       	cpi	r28, 0xB0	; 176
    20a0:	f9 e0       	ldi	r31, 0x09	; 9
    20a2:	df 07       	cpc	r29, r31
    20a4:	21 f4       	brne	.+8      	; 0x20ae <usart_init_spi+0x204>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    20a6:	60 e2       	ldi	r22, 0x20	; 32
    20a8:	84 e0       	ldi	r24, 0x04	; 4
    20aa:	e6 d7       	rcall	.+4044   	; 0x3078 <sysclk_enable_module>
    20ac:	ba c0       	rjmp	.+372    	; 0x2222 <usart_init_spi+0x378>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    20ae:	c0 38       	cpi	r28, 0x80	; 128
    20b0:	24 e0       	ldi	r18, 0x04	; 4
    20b2:	d2 07       	cpc	r29, r18
    20b4:	21 f4       	brne	.+8      	; 0x20be <usart_init_spi+0x214>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    20b6:	60 e4       	ldi	r22, 0x40	; 64
    20b8:	83 e0       	ldi	r24, 0x03	; 3
    20ba:	de d7       	rcall	.+4028   	; 0x3078 <sysclk_enable_module>
    20bc:	b2 c0       	rjmp	.+356    	; 0x2222 <usart_init_spi+0x378>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    20be:	c0 3a       	cpi	r28, 0xA0	; 160
    20c0:	84 e0       	ldi	r24, 0x04	; 4
    20c2:	d8 07       	cpc	r29, r24
    20c4:	21 f4       	brne	.+8      	; 0x20ce <usart_init_spi+0x224>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    20c6:	60 e4       	ldi	r22, 0x40	; 64
    20c8:	85 e0       	ldi	r24, 0x05	; 5
    20ca:	d6 d7       	rcall	.+4012   	; 0x3078 <sysclk_enable_module>
    20cc:	aa c0       	rjmp	.+340    	; 0x2222 <usart_init_spi+0x378>
    20ce:	8c 81       	ldd	r24, Y+4	; 0x04
    20d0:	8f 7e       	andi	r24, 0xEF	; 239
    20d2:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    20d4:	fb 01       	movw	r30, r22
    20d6:	34 81       	ldd	r19, Z+4	; 0x04
    20d8:	32 50       	subi	r19, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    20da:	ce 01       	movw	r24, r28
    20dc:	c0 3a       	cpi	r28, 0xA0	; 160
    20de:	f8 e0       	ldi	r31, 0x08	; 8
    20e0:	df 07       	cpc	r29, r31
    20e2:	51 f4       	brne	.+20     	; 0x20f8 <usart_init_spi+0x24e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    20e4:	e0 e4       	ldi	r30, 0x40	; 64
    20e6:	f6 e0       	ldi	r31, 0x06	; 6
    20e8:	26 85       	ldd	r18, Z+14	; 0x0e
    20ea:	24 fd       	sbrc	r18, 4
    20ec:	a2 c0       	rjmp	.+324    	; 0x2232 <usart_init_spi+0x388>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    20ee:	0f 2e       	mov	r0, r31
    20f0:	f1 e1       	ldi	r31, 0x11	; 17
    20f2:	ff 2e       	mov	r15, r31
    20f4:	f0 2d       	mov	r31, r0
    20f6:	04 c0       	rjmp	.+8      	; 0x2100 <usart_init_spi+0x256>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    20f8:	80 3b       	cpi	r24, 0xB0	; 176
    20fa:	28 e0       	ldi	r18, 0x08	; 8
    20fc:	92 07       	cpc	r25, r18
    20fe:	99 f0       	breq	.+38     	; 0x2126 <usart_init_spi+0x27c>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    2100:	80 3a       	cpi	r24, 0xA0	; 160
    2102:	e9 e0       	ldi	r30, 0x09	; 9
    2104:	9e 07       	cpc	r25, r30
    2106:	51 f4       	brne	.+20     	; 0x211c <usart_init_spi+0x272>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    2108:	e0 e6       	ldi	r30, 0x60	; 96
    210a:	f6 e0       	ldi	r31, 0x06	; 6
    210c:	26 85       	ldd	r18, Z+14	; 0x0e
    210e:	24 fd       	sbrc	r18, 4
    2110:	95 c0       	rjmp	.+298    	; 0x223c <usart_init_spi+0x392>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    2112:	0f 2e       	mov	r0, r31
    2114:	f9 e1       	ldi	r31, 0x19	; 25
    2116:	ff 2e       	mov	r15, r31
    2118:	f0 2d       	mov	r31, r0
    211a:	17 c0       	rjmp	.+46     	; 0x214a <usart_init_spi+0x2a0>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    211c:	80 3b       	cpi	r24, 0xB0	; 176
    211e:	f9 e0       	ldi	r31, 0x09	; 9
    2120:	9f 07       	cpc	r25, r31
    2122:	01 f1       	breq	.+64     	; 0x2164 <usart_init_spi+0x2ba>
    2124:	04 c0       	rjmp	.+8      	; 0x212e <usart_init_spi+0x284>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    2126:	0f 2e       	mov	r0, r31
    2128:	f5 e1       	ldi	r31, 0x15	; 21
    212a:	ff 2e       	mov	r15, r31
    212c:	f0 2d       	mov	r31, r0
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    212e:	80 3a       	cpi	r24, 0xA0	; 160
    2130:	2a e0       	ldi	r18, 0x0A	; 10
    2132:	92 07       	cpc	r25, r18
    2134:	51 f4       	brne	.+20     	; 0x214a <usart_init_spi+0x2a0>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    2136:	e0 e8       	ldi	r30, 0x80	; 128
    2138:	f6 e0       	ldi	r31, 0x06	; 6
    213a:	86 85       	ldd	r24, Z+14	; 0x0e
    213c:	84 fd       	sbrc	r24, 4
    213e:	83 c0       	rjmp	.+262    	; 0x2246 <usart_init_spi+0x39c>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    2140:	0f 2e       	mov	r0, r31
    2142:	f1 e2       	ldi	r31, 0x21	; 33
    2144:	ff 2e       	mov	r15, r31
    2146:	f0 2d       	mov	r31, r0
    2148:	16 c0       	rjmp	.+44     	; 0x2176 <usart_init_spi+0x2cc>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    214a:	80 3a       	cpi	r24, 0xA0	; 160
    214c:	9b 40       	sbci	r25, 0x0B	; 11
    214e:	99 f4       	brne	.+38     	; 0x2176 <usart_init_spi+0x2cc>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    2150:	e0 ea       	ldi	r30, 0xA0	; 160
    2152:	f6 e0       	ldi	r31, 0x06	; 6
    2154:	86 85       	ldd	r24, Z+14	; 0x0e
    2156:	84 ff       	sbrs	r24, 4
    2158:	0a c0       	rjmp	.+20     	; 0x216e <usart_init_spi+0x2c4>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    215a:	0f 2e       	mov	r0, r31
    215c:	fd e2       	ldi	r31, 0x2D	; 45
    215e:	ff 2e       	mov	r15, r31
    2160:	f0 2d       	mov	r31, r0
    2162:	09 c0       	rjmp	.+18     	; 0x2176 <usart_init_spi+0x2cc>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    2164:	0f 2e       	mov	r0, r31
    2166:	fd e1       	ldi	r31, 0x1D	; 29
    2168:	ff 2e       	mov	r15, r31
    216a:	f0 2d       	mov	r31, r0
    216c:	04 c0       	rjmp	.+8      	; 0x2176 <usart_init_spi+0x2cc>
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    216e:	0f 2e       	mov	r0, r31
    2170:	f9 e2       	ldi	r31, 0x29	; 41
    2172:	ff 2e       	mov	r15, r31
    2174:	f0 2d       	mov	r31, r0
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    2176:	af 2d       	mov	r26, r15
    2178:	a6 95       	lsr	r26
    217a:	a6 95       	lsr	r26
    217c:	a6 95       	lsr	r26
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    217e:	f0 e2       	ldi	r31, 0x20	; 32
    2180:	af 9f       	mul	r26, r31
    2182:	d0 01       	movw	r26, r0
    2184:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2186:	ba 5f       	subi	r27, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    2188:	2f 2d       	mov	r18, r15
    218a:	27 70       	andi	r18, 0x07	; 7
    218c:	81 e0       	ldi	r24, 0x01	; 1
    218e:	90 e0       	ldi	r25, 0x00	; 0
    2190:	02 2e       	mov	r0, r18
    2192:	02 c0       	rjmp	.+4      	; 0x2198 <usart_init_spi+0x2ee>
    2194:	88 0f       	add	r24, r24
    2196:	99 1f       	adc	r25, r25
    2198:	0a 94       	dec	r0
    219a:	e2 f7       	brpl	.-8      	; 0x2194 <usart_init_spi+0x2ea>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    219c:	11 96       	adiw	r26, 0x01	; 1
    219e:	8c 93       	st	X, r24
    21a0:	11 97       	sbiw	r26, 0x01	; 1
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    21a2:	32 30       	cpi	r19, 0x02	; 2
    21a4:	10 f4       	brcc	.+4      	; 0x21aa <usart_init_spi+0x300>
    21a6:	30 e4       	ldi	r19, 0x40	; 64
    21a8:	01 c0       	rjmp	.+2      	; 0x21ac <usart_init_spi+0x302>
    21aa:	30 e0       	ldi	r19, 0x00	; 0
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    21ac:	fd 01       	movw	r30, r26
    21ae:	70 96       	adiw	r30, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    21b0:	e2 0f       	add	r30, r18
    21b2:	f1 1d       	adc	r31, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    21b4:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    21b6:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    21b8:	20 81       	ld	r18, Z
    21ba:	27 70       	andi	r18, 0x07	; 7
    21bc:	20 83       	st	Z, r18
	*pin_ctrl |= mode;
    21be:	20 81       	ld	r18, Z
    21c0:	23 2b       	or	r18, r19
    21c2:	20 83       	st	Z, r18
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    21c4:	9f bf       	out	0x3f, r25	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    21c6:	15 96       	adiw	r26, 0x05	; 5
    21c8:	8c 93       	st	X, r24
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    21ca:	8d 81       	ldd	r24, Y+5	; 0x05
    21cc:	80 6c       	ori	r24, 0xC0	; 192
    21ce:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    21d0:	f8 01       	movw	r30, r16
    21d2:	84 81       	ldd	r24, Z+4	; 0x04
    21d4:	8d 7f       	andi	r24, 0xFD	; 253
    21d6:	81 30       	cpi	r24, 0x01	; 1
    21d8:	21 f4       	brne	.+8      	; 0x21e2 <usart_init_spi+0x338>
		usart->CTRLC |= USART_UCPHA_bm;
    21da:	8d 81       	ldd	r24, Y+5	; 0x05
    21dc:	82 60       	ori	r24, 0x02	; 2
    21de:	8d 83       	std	Y+5, r24	; 0x05
    21e0:	03 c0       	rjmp	.+6      	; 0x21e8 <usart_init_spi+0x33e>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    21e2:	8d 81       	ldd	r24, Y+5	; 0x05
    21e4:	8d 7f       	andi	r24, 0xFD	; 253
    21e6:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    21e8:	f8 01       	movw	r30, r16
    21ea:	85 81       	ldd	r24, Z+5	; 0x05
    21ec:	88 23       	and	r24, r24
    21ee:	21 f0       	breq	.+8      	; 0x21f8 <usart_init_spi+0x34e>
		(usart)->CTRLC |= USART_DORD_bm;
    21f0:	8d 81       	ldd	r24, Y+5	; 0x05
    21f2:	84 60       	ori	r24, 0x04	; 4
    21f4:	8d 83       	std	Y+5, r24	; 0x05
    21f6:	03 c0       	rjmp	.+6      	; 0x21fe <usart_init_spi+0x354>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    21f8:	8d 81       	ldd	r24, Y+5	; 0x05
    21fa:	8b 7f       	andi	r24, 0xFB	; 251
    21fc:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    21fe:	f8 01       	movw	r30, r16
    2200:	40 81       	ld	r20, Z
    2202:	51 81       	ldd	r21, Z+1	; 0x01
    2204:	62 81       	ldd	r22, Z+2	; 0x02
    2206:	73 81       	ldd	r23, Z+3	; 0x03
    2208:	00 e8       	ldi	r16, 0x80	; 128
    220a:	14 e8       	ldi	r17, 0x84	; 132
    220c:	2e e1       	ldi	r18, 0x1E	; 30
    220e:	30 e0       	ldi	r19, 0x00	; 0
    2210:	ce 01       	movw	r24, r28
    2212:	19 de       	rcall	.-974    	; 0x1e46 <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    2214:	8c 81       	ldd	r24, Y+4	; 0x04
    2216:	88 60       	ori	r24, 0x08	; 8
    2218:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    221a:	8c 81       	ldd	r24, Y+4	; 0x04
    221c:	80 61       	ori	r24, 0x10	; 16
    221e:	8c 83       	std	Y+4, r24	; 0x04
    2220:	17 c0       	rjmp	.+46     	; 0x2250 <usart_init_spi+0x3a6>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    2222:	8c 81       	ldd	r24, Y+4	; 0x04
    2224:	8f 7e       	andi	r24, 0xEF	; 239
    2226:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    2228:	f8 01       	movw	r30, r16
    222a:	34 81       	ldd	r19, Z+4	; 0x04
    222c:	32 50       	subi	r19, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    222e:	ce 01       	movw	r24, r28
    2230:	63 cf       	rjmp	.-314    	; 0x20f8 <usart_init_spi+0x24e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    2232:	0f 2e       	mov	r0, r31
    2234:	f5 e1       	ldi	r31, 0x15	; 21
    2236:	ff 2e       	mov	r15, r31
    2238:	f0 2d       	mov	r31, r0
    223a:	62 cf       	rjmp	.-316    	; 0x2100 <usart_init_spi+0x256>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    223c:	0f 2e       	mov	r0, r31
    223e:	fd e1       	ldi	r31, 0x1D	; 29
    2240:	ff 2e       	mov	r15, r31
    2242:	f0 2d       	mov	r31, r0
    2244:	82 cf       	rjmp	.-252    	; 0x214a <usart_init_spi+0x2a0>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    2246:	0f 2e       	mov	r0, r31
    2248:	f5 e2       	ldi	r31, 0x25	; 37
    224a:	ff 2e       	mov	r15, r31
    224c:	f0 2d       	mov	r31, r0
    224e:	93 cf       	rjmp	.-218    	; 0x2176 <usart_init_spi+0x2cc>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    2250:	df 91       	pop	r29
    2252:	cf 91       	pop	r28
    2254:	1f 91       	pop	r17
    2256:	0f 91       	pop	r16
    2258:	ff 90       	pop	r15
    225a:	08 95       	ret

0000225c <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
    225c:	80 3a       	cpi	r24, 0xA0	; 160
    225e:	28 e0       	ldi	r18, 0x08	; 8
    2260:	92 07       	cpc	r25, r18
    2262:	21 f4       	brne	.+8      	; 0x226c <usart_spi_init+0x10>
    2264:	60 e1       	ldi	r22, 0x10	; 16
    2266:	83 e0       	ldi	r24, 0x03	; 3
    2268:	07 c7       	rjmp	.+3598   	; 0x3078 <sysclk_enable_module>
    226a:	08 95       	ret
    226c:	80 3b       	cpi	r24, 0xB0	; 176
    226e:	28 e0       	ldi	r18, 0x08	; 8
    2270:	92 07       	cpc	r25, r18
    2272:	21 f4       	brne	.+8      	; 0x227c <usart_spi_init+0x20>
    2274:	60 e2       	ldi	r22, 0x20	; 32
    2276:	83 e0       	ldi	r24, 0x03	; 3
    2278:	ff c6       	rjmp	.+3582   	; 0x3078 <sysclk_enable_module>
    227a:	08 95       	ret
    227c:	80 3a       	cpi	r24, 0xA0	; 160
    227e:	29 e0       	ldi	r18, 0x09	; 9
    2280:	92 07       	cpc	r25, r18
    2282:	21 f4       	brne	.+8      	; 0x228c <usart_spi_init+0x30>
    2284:	60 e1       	ldi	r22, 0x10	; 16
    2286:	84 e0       	ldi	r24, 0x04	; 4
    2288:	f7 c6       	rjmp	.+3566   	; 0x3078 <sysclk_enable_module>
    228a:	08 95       	ret
    228c:	80 3b       	cpi	r24, 0xB0	; 176
    228e:	29 e0       	ldi	r18, 0x09	; 9
    2290:	92 07       	cpc	r25, r18
    2292:	21 f4       	brne	.+8      	; 0x229c <usart_spi_init+0x40>
    2294:	60 e2       	ldi	r22, 0x20	; 32
    2296:	84 e0       	ldi	r24, 0x04	; 4
    2298:	ef c6       	rjmp	.+3550   	; 0x3078 <sysclk_enable_module>
    229a:	08 95       	ret
    229c:	80 3a       	cpi	r24, 0xA0	; 160
    229e:	2a e0       	ldi	r18, 0x0A	; 10
    22a0:	92 07       	cpc	r25, r18
    22a2:	21 f4       	brne	.+8      	; 0x22ac <usart_spi_init+0x50>
    22a4:	60 e1       	ldi	r22, 0x10	; 16
    22a6:	85 e0       	ldi	r24, 0x05	; 5
    22a8:	e7 c6       	rjmp	.+3534   	; 0x3078 <sysclk_enable_module>
    22aa:	08 95       	ret
    22ac:	80 3a       	cpi	r24, 0xA0	; 160
    22ae:	9b 40       	sbci	r25, 0x0B	; 11
    22b0:	19 f4       	brne	.+6      	; 0x22b8 <usart_spi_init+0x5c>
    22b2:	60 e1       	ldi	r22, 0x10	; 16
    22b4:	86 e0       	ldi	r24, 0x06	; 6
    22b6:	e0 c6       	rjmp	.+3520   	; 0x3078 <sysclk_enable_module>
    22b8:	08 95       	ret

000022ba <usart_spi_setup_device>:
    22ba:	0f 93       	push	r16
    22bc:	1f 93       	push	r17
    22be:	cf 93       	push	r28
    22c0:	df 93       	push	r29
    22c2:	00 d0       	rcall	.+0      	; 0x22c4 <usart_spi_setup_device+0xa>
    22c4:	00 d0       	rcall	.+0      	; 0x22c6 <usart_spi_setup_device+0xc>
    22c6:	cd b7       	in	r28, 0x3d	; 61
    22c8:	de b7       	in	r29, 0x3e	; 62
    22ca:	09 83       	std	Y+1, r16	; 0x01
    22cc:	1a 83       	std	Y+2, r17	; 0x02
    22ce:	2b 83       	std	Y+3, r18	; 0x03
    22d0:	3c 83       	std	Y+4, r19	; 0x04
    22d2:	4d 83       	std	Y+5, r20	; 0x05
    22d4:	1e 82       	std	Y+6, r1	; 0x06
    22d6:	be 01       	movw	r22, r28
    22d8:	6f 5f       	subi	r22, 0xFF	; 255
    22da:	7f 4f       	sbci	r23, 0xFF	; 255
    22dc:	e6 dd       	rcall	.-1076   	; 0x1eaa <usart_init_spi>
    22de:	26 96       	adiw	r28, 0x06	; 6
    22e0:	cd bf       	out	0x3d, r28	; 61
    22e2:	de bf       	out	0x3e, r29	; 62
    22e4:	df 91       	pop	r29
    22e6:	cf 91       	pop	r28
    22e8:	1f 91       	pop	r17
    22ea:	0f 91       	pop	r16
    22ec:	08 95       	ret

000022ee <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
    22ee:	fb 01       	movw	r30, r22
    22f0:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    22f2:	e8 2f       	mov	r30, r24
    22f4:	e6 95       	lsr	r30
    22f6:	e6 95       	lsr	r30
    22f8:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    22fa:	40 e2       	ldi	r20, 0x20	; 32
    22fc:	e4 9f       	mul	r30, r20
    22fe:	f0 01       	movw	r30, r0
    2300:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2302:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    2304:	87 70       	andi	r24, 0x07	; 7
    2306:	21 e0       	ldi	r18, 0x01	; 1
    2308:	30 e0       	ldi	r19, 0x00	; 0
    230a:	a9 01       	movw	r20, r18
    230c:	02 c0       	rjmp	.+4      	; 0x2312 <usart_spi_select_device+0x24>
    230e:	44 0f       	add	r20, r20
    2310:	55 1f       	adc	r21, r21
    2312:	8a 95       	dec	r24
    2314:	e2 f7       	brpl	.-8      	; 0x230e <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    2316:	46 83       	std	Z+6, r20	; 0x06
    2318:	08 95       	ret

0000231a <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
    231a:	fb 01       	movw	r30, r22
    231c:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    231e:	e8 2f       	mov	r30, r24
    2320:	e6 95       	lsr	r30
    2322:	e6 95       	lsr	r30
    2324:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    2326:	40 e2       	ldi	r20, 0x20	; 32
    2328:	e4 9f       	mul	r30, r20
    232a:	f0 01       	movw	r30, r0
    232c:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    232e:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    2330:	87 70       	andi	r24, 0x07	; 7
    2332:	21 e0       	ldi	r18, 0x01	; 1
    2334:	30 e0       	ldi	r19, 0x00	; 0
    2336:	a9 01       	movw	r20, r18
    2338:	02 c0       	rjmp	.+4      	; 0x233e <usart_spi_deselect_device+0x24>
    233a:	44 0f       	add	r20, r20
    233c:	55 1f       	adc	r21, r21
    233e:	8a 95       	dec	r24
    2340:	e2 f7       	brpl	.-8      	; 0x233a <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2342:	45 83       	std	Z+5, r20	; 0x05
    2344:	08 95       	ret

00002346 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
    2346:	80 93 8d 23 	sts	0x238D, r24
    234a:	90 93 8e 23 	sts	0x238E, r25
    234e:	08 95       	ret

00002350 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    2350:	20 e8       	ldi	r18, 0x80	; 128
    2352:	82 9f       	mul	r24, r18
    2354:	c0 01       	movw	r24, r0
    2356:	11 24       	eor	r1, r1
    2358:	fc 01       	movw	r30, r24
    235a:	e6 0f       	add	r30, r22
    235c:	f1 1d       	adc	r31, r1
    235e:	80 91 8d 23 	lds	r24, 0x238D
    2362:	90 91 8e 23 	lds	r25, 0x238E
    2366:	e8 0f       	add	r30, r24
    2368:	f9 1f       	adc	r31, r25
    236a:	40 83       	st	Z, r20
    236c:	08 95       	ret

0000236e <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
    236e:	20 e8       	ldi	r18, 0x80	; 128
    2370:	82 9f       	mul	r24, r18
    2372:	c0 01       	movw	r24, r0
    2374:	11 24       	eor	r1, r1
    2376:	fc 01       	movw	r30, r24
    2378:	e6 0f       	add	r30, r22
    237a:	f1 1d       	adc	r31, r1
    237c:	80 91 8d 23 	lds	r24, 0x238D
    2380:	90 91 8e 23 	lds	r25, 0x238E
    2384:	e8 0f       	add	r30, r24
    2386:	f9 1f       	adc	r31, r25
}
    2388:	80 81       	ld	r24, Z
    238a:	08 95       	ret

0000238c <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
    238c:	ff 92       	push	r15
    238e:	0f 93       	push	r16
    2390:	1f 93       	push	r17
    2392:	cf 93       	push	r28
    2394:	df 93       	push	r29
    2396:	e4 2f       	mov	r30, r20
    2398:	f0 e0       	ldi	r31, 0x00	; 0
    239a:	e8 0f       	add	r30, r24
    239c:	f1 1d       	adc	r31, r1
    239e:	e1 38       	cpi	r30, 0x81	; 129
    23a0:	f1 05       	cpc	r31, r1
    23a2:	14 f0       	brlt	.+4      	; 0x23a8 <gfx_mono_generic_draw_horizontal_line+0x1c>
    23a4:	40 e8       	ldi	r20, 0x80	; 128
    23a6:	48 1b       	sub	r20, r24
    23a8:	44 23       	and	r20, r20
    23aa:	09 f4       	brne	.+2      	; 0x23ae <gfx_mono_generic_draw_horizontal_line+0x22>
    23ac:	5c c0       	rjmp	.+184    	; 0x2466 <gfx_mono_generic_draw_horizontal_line+0xda>
    23ae:	c6 2f       	mov	r28, r22
    23b0:	c6 95       	lsr	r28
    23b2:	c6 95       	lsr	r28
    23b4:	c6 95       	lsr	r28
    23b6:	ec 2f       	mov	r30, r28
    23b8:	f0 e0       	ldi	r31, 0x00	; 0
    23ba:	f1 95       	neg	r31
    23bc:	e1 95       	neg	r30
    23be:	f1 09       	sbc	r31, r1
    23c0:	ee 0f       	add	r30, r30
    23c2:	ff 1f       	adc	r31, r31
    23c4:	ee 0f       	add	r30, r30
    23c6:	ff 1f       	adc	r31, r31
    23c8:	ee 0f       	add	r30, r30
    23ca:	ff 1f       	adc	r31, r31
    23cc:	df 01       	movw	r26, r30
    23ce:	a6 0f       	add	r26, r22
    23d0:	b1 1d       	adc	r27, r1
    23d2:	bd 01       	movw	r22, r26
    23d4:	e1 e0       	ldi	r30, 0x01	; 1
    23d6:	f0 e0       	ldi	r31, 0x00	; 0
    23d8:	df 01       	movw	r26, r30
    23da:	02 c0       	rjmp	.+4      	; 0x23e0 <gfx_mono_generic_draw_horizontal_line+0x54>
    23dc:	aa 0f       	add	r26, r26
    23de:	bb 1f       	adc	r27, r27
    23e0:	6a 95       	dec	r22
    23e2:	e2 f7       	brpl	.-8      	; 0x23dc <gfx_mono_generic_draw_horizontal_line+0x50>
    23e4:	0a 2f       	mov	r16, r26
    23e6:	21 30       	cpi	r18, 0x01	; 1
    23e8:	49 f0       	breq	.+18     	; 0x23fc <gfx_mono_generic_draw_horizontal_line+0x70>
    23ea:	68 f0       	brcs	.+26     	; 0x2406 <gfx_mono_generic_draw_horizontal_line+0x7a>
    23ec:	22 30       	cpi	r18, 0x02	; 2
    23ee:	09 f0       	breq	.+2      	; 0x23f2 <gfx_mono_generic_draw_horizontal_line+0x66>
    23f0:	3a c0       	rjmp	.+116    	; 0x2466 <gfx_mono_generic_draw_horizontal_line+0xda>
    23f2:	d4 2f       	mov	r29, r20
    23f4:	ff 24       	eor	r15, r15
    23f6:	fa 94       	dec	r15
    23f8:	f8 0e       	add	r15, r24
    23fa:	28 c0       	rjmp	.+80     	; 0x244c <gfx_mono_generic_draw_horizontal_line+0xc0>
    23fc:	d4 2f       	mov	r29, r20
    23fe:	ff 24       	eor	r15, r15
    2400:	fa 94       	dec	r15
    2402:	f8 0e       	add	r15, r24
    2404:	07 c0       	rjmp	.+14     	; 0x2414 <gfx_mono_generic_draw_horizontal_line+0x88>
    2406:	d4 2f       	mov	r29, r20
    2408:	ff 24       	eor	r15, r15
    240a:	fa 94       	dec	r15
    240c:	f8 0e       	add	r15, r24
    240e:	0a 2f       	mov	r16, r26
    2410:	00 95       	com	r16
    2412:	0e c0       	rjmp	.+28     	; 0x2430 <gfx_mono_generic_draw_horizontal_line+0xa4>
    2414:	1f 2d       	mov	r17, r15
    2416:	1d 0f       	add	r17, r29
    2418:	61 2f       	mov	r22, r17
    241a:	8c 2f       	mov	r24, r28
    241c:	e2 d8       	rcall	.-3644   	; 0x15e2 <gfx_mono_st7565r_get_byte>
    241e:	48 2f       	mov	r20, r24
    2420:	40 2b       	or	r20, r16
    2422:	61 2f       	mov	r22, r17
    2424:	8c 2f       	mov	r24, r28
    2426:	0e 94 c3 09 	call	0x1386	; 0x1386 <gfx_mono_st7565r_put_byte>
    242a:	d1 50       	subi	r29, 0x01	; 1
    242c:	99 f7       	brne	.-26     	; 0x2414 <gfx_mono_generic_draw_horizontal_line+0x88>
    242e:	1b c0       	rjmp	.+54     	; 0x2466 <gfx_mono_generic_draw_horizontal_line+0xda>
    2430:	1f 2d       	mov	r17, r15
    2432:	1d 0f       	add	r17, r29
    2434:	61 2f       	mov	r22, r17
    2436:	8c 2f       	mov	r24, r28
    2438:	d4 d8       	rcall	.-3672   	; 0x15e2 <gfx_mono_st7565r_get_byte>
    243a:	48 2f       	mov	r20, r24
    243c:	40 23       	and	r20, r16
    243e:	61 2f       	mov	r22, r17
    2440:	8c 2f       	mov	r24, r28
    2442:	0e 94 c3 09 	call	0x1386	; 0x1386 <gfx_mono_st7565r_put_byte>
    2446:	d1 50       	subi	r29, 0x01	; 1
    2448:	99 f7       	brne	.-26     	; 0x2430 <gfx_mono_generic_draw_horizontal_line+0xa4>
    244a:	0d c0       	rjmp	.+26     	; 0x2466 <gfx_mono_generic_draw_horizontal_line+0xda>
    244c:	1f 2d       	mov	r17, r15
    244e:	1d 0f       	add	r17, r29
    2450:	61 2f       	mov	r22, r17
    2452:	8c 2f       	mov	r24, r28
    2454:	c6 d8       	rcall	.-3700   	; 0x15e2 <gfx_mono_st7565r_get_byte>
    2456:	48 2f       	mov	r20, r24
    2458:	40 27       	eor	r20, r16
    245a:	61 2f       	mov	r22, r17
    245c:	8c 2f       	mov	r24, r28
    245e:	0e 94 c3 09 	call	0x1386	; 0x1386 <gfx_mono_st7565r_put_byte>
    2462:	d1 50       	subi	r29, 0x01	; 1
    2464:	99 f7       	brne	.-26     	; 0x244c <gfx_mono_generic_draw_horizontal_line+0xc0>
    2466:	df 91       	pop	r29
    2468:	cf 91       	pop	r28
    246a:	1f 91       	pop	r17
    246c:	0f 91       	pop	r16
    246e:	ff 90       	pop	r15
    2470:	08 95       	ret

00002472 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
    2472:	ff 92       	push	r15
    2474:	0f 93       	push	r16
    2476:	1f 93       	push	r17
    2478:	cf 93       	push	r28
    247a:	df 93       	push	r29
    247c:	d8 2f       	mov	r29, r24
    247e:	14 2f       	mov	r17, r20
	if (height == 0) {
    2480:	22 23       	and	r18, r18
    2482:	61 f0       	breq	.+24     	; 0x249c <gfx_mono_generic_draw_filled_rect+0x2a>
    2484:	c2 2f       	mov	r28, r18
    2486:	ff 24       	eor	r15, r15
    2488:	fa 94       	dec	r15
    248a:	f6 0e       	add	r15, r22
    248c:	6f 2d       	mov	r22, r15
    248e:	6c 0f       	add	r22, r28
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
    2490:	20 2f       	mov	r18, r16
    2492:	41 2f       	mov	r20, r17
    2494:	8d 2f       	mov	r24, r29
    2496:	7a df       	rcall	.-268    	; 0x238c <gfx_mono_generic_draw_horizontal_line>
    2498:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
    249a:	c1 f7       	brne	.-16     	; 0x248c <gfx_mono_generic_draw_filled_rect+0x1a>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
    249c:	df 91       	pop	r29
    249e:	cf 91       	pop	r28
    24a0:	1f 91       	pop	r17
    24a2:	0f 91       	pop	r16
    24a4:	ff 90       	pop	r15
    24a6:	08 95       	ret

000024a8 <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
    24a8:	af 92       	push	r10
    24aa:	bf 92       	push	r11
    24ac:	cf 92       	push	r12
    24ae:	df 92       	push	r13
    24b0:	ef 92       	push	r14
    24b2:	ff 92       	push	r15
    24b4:	0f 93       	push	r16
    24b6:	1f 93       	push	r17
    24b8:	cf 93       	push	r28
    24ba:	df 93       	push	r29
    24bc:	c8 2f       	mov	r28, r24
    24be:	d6 2e       	mov	r13, r22
    24c0:	a4 2e       	mov	r10, r20
    24c2:	79 01       	movw	r14, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
    24c4:	00 e0       	ldi	r16, 0x00	; 0
    24c6:	f9 01       	movw	r30, r18
    24c8:	24 81       	ldd	r18, Z+4	; 0x04
    24ca:	43 81       	ldd	r20, Z+3	; 0x03
    24cc:	6a 2d       	mov	r22, r10
    24ce:	8d 2d       	mov	r24, r13
    24d0:	d0 df       	rcall	.-96     	; 0x2472 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
    24d2:	f7 01       	movw	r30, r14
    24d4:	90 81       	ld	r25, Z
    24d6:	91 11       	cpse	r25, r1
    24d8:	39 c0       	rjmp	.+114    	; 0x254c <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
    24da:	83 81       	ldd	r24, Z+3	; 0x03
    24dc:	a8 2f       	mov	r26, r24
    24de:	a6 95       	lsr	r26
    24e0:	a6 95       	lsr	r26
    24e2:	a6 95       	lsr	r26
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
    24e4:	87 70       	andi	r24, 0x07	; 7
    24e6:	09 f0       	breq	.+2      	; 0x24ea <gfx_mono_draw_char+0x42>
		char_row_size++;
    24e8:	af 5f       	subi	r26, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
    24ea:	f7 01       	movw	r30, r14
    24ec:	c4 80       	ldd	r12, Z+4	; 0x04
    24ee:	ac 9d       	mul	r26, r12
    24f0:	d0 01       	movw	r26, r0
    24f2:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
    24f4:	ec 2f       	mov	r30, r28
    24f6:	f0 e0       	ldi	r31, 0x00	; 0
    24f8:	e7 01       	movw	r28, r14
    24fa:	8d 81       	ldd	r24, Y+5	; 0x05
    24fc:	e8 1b       	sub	r30, r24
    24fe:	f1 09       	sbc	r31, r1
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
    2500:	ae 9f       	mul	r26, r30
    2502:	90 01       	movw	r18, r0
    2504:	af 9f       	mul	r26, r31
    2506:	30 0d       	add	r19, r0
    2508:	be 9f       	mul	r27, r30
    250a:	30 0d       	add	r19, r0
    250c:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
    250e:	09 80       	ldd	r0, Y+1	; 0x01
    2510:	da 81       	ldd	r29, Y+2	; 0x02
    2512:	c0 2d       	mov	r28, r0
    2514:	c2 0f       	add	r28, r18
    2516:	d3 1f       	adc	r29, r19
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
    2518:	f7 01       	movw	r30, r14
    251a:	b3 80       	ldd	r11, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
    251c:	bb 20       	and	r11, r11
    251e:	99 f0       	breq	.+38     	; 0x2546 <gfx_mono_draw_char+0x9e>
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
    2520:	00 e0       	ldi	r16, 0x00	; 0
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
    2522:	10 e0       	ldi	r17, 0x00	; 0
    2524:	81 2f       	mov	r24, r17
    2526:	8d 0d       	add	r24, r13
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
    2528:	91 2f       	mov	r25, r17
    252a:	97 70       	andi	r25, 0x07	; 7
    252c:	19 f4       	brne	.+6      	; 0x2534 <gfx_mono_draw_char+0x8c>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
    252e:	fe 01       	movw	r30, r28
    2530:	04 91       	lpm	r16, Z
				glyph_data++;
    2532:	21 96       	adiw	r28, 0x01	; 1
			}

			if ((glyph_byte & 0x80)) {
    2534:	00 23       	and	r16, r16
    2536:	1c f4       	brge	.+6      	; 0x253e <gfx_mono_draw_char+0x96>
				gfx_mono_draw_pixel(inc_x, inc_y,
    2538:	41 e0       	ldi	r20, 0x01	; 1
    253a:	6a 2d       	mov	r22, r10
    253c:	15 d8       	rcall	.-4054   	; 0x1568 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
    253e:	00 0f       	add	r16, r16

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
    2540:	1f 5f       	subi	r17, 0xFF	; 255
    2542:	1b 11       	cpse	r17, r11
    2544:	ef cf       	rjmp	.-34     	; 0x2524 <gfx_mono_draw_char+0x7c>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
    2546:	a3 94       	inc	r10
		inc_x = x;
		rows_left--;
    2548:	ca 94       	dec	r12
	} while (rows_left > 0);
    254a:	31 f7       	brne	.-52     	; 0x2518 <gfx_mono_draw_char+0x70>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
    254c:	df 91       	pop	r29
    254e:	cf 91       	pop	r28
    2550:	1f 91       	pop	r17
    2552:	0f 91       	pop	r16
    2554:	ff 90       	pop	r15
    2556:	ef 90       	pop	r14
    2558:	df 90       	pop	r13
    255a:	cf 90       	pop	r12
    255c:	bf 90       	pop	r11
    255e:	af 90       	pop	r10
    2560:	08 95       	ret

00002562 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
    2562:	df 92       	push	r13
    2564:	ef 92       	push	r14
    2566:	ff 92       	push	r15
    2568:	0f 93       	push	r16
    256a:	1f 93       	push	r17
    256c:	cf 93       	push	r28
    256e:	df 93       	push	r29
    2570:	e4 2e       	mov	r14, r20
    2572:	89 01       	movw	r16, r18
    2574:	ec 01       	movw	r28, r24
    2576:	f6 2e       	mov	r15, r22

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    2578:	d6 2e       	mov	r13, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
    257a:	89 91       	ld	r24, Y+
    257c:	8a 30       	cpi	r24, 0x0A	; 10
    257e:	31 f4       	brne	.+12     	; 0x258c <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
    2580:	f8 01       	movw	r30, r16
    2582:	84 81       	ldd	r24, Z+4	; 0x04
    2584:	8f 5f       	subi	r24, 0xFF	; 255
    2586:	e8 0e       	add	r14, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    2588:	fd 2c       	mov	r15, r13
    258a:	09 c0       	rjmp	.+18     	; 0x259e <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
    258c:	8d 30       	cpi	r24, 0x0D	; 13
    258e:	39 f0       	breq	.+14     	; 0x259e <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
    2590:	98 01       	movw	r18, r16
    2592:	4e 2d       	mov	r20, r14
    2594:	6f 2d       	mov	r22, r15
    2596:	88 df       	rcall	.-240    	; 0x24a8 <gfx_mono_draw_char>
			x += font->width;
    2598:	f8 01       	movw	r30, r16
    259a:	83 81       	ldd	r24, Z+3	; 0x03
    259c:	f8 0e       	add	r15, r24
		}
	} while (*(++str));
    259e:	88 81       	ld	r24, Y
    25a0:	81 11       	cpse	r24, r1
    25a2:	eb cf       	rjmp	.-42     	; 0x257a <gfx_mono_draw_string+0x18>
}
    25a4:	df 91       	pop	r29
    25a6:	cf 91       	pop	r28
    25a8:	1f 91       	pop	r17
    25aa:	0f 91       	pop	r16
    25ac:	ff 90       	pop	r15
    25ae:	ef 90       	pop	r14
    25b0:	df 90       	pop	r13
    25b2:	08 95       	ret

000025b4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    25b4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    25b6:	03 96       	adiw	r24, 0x03	; 3
    25b8:	81 83       	std	Z+1, r24	; 0x01
    25ba:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    25bc:	2f ef       	ldi	r18, 0xFF	; 255
    25be:	3f ef       	ldi	r19, 0xFF	; 255
    25c0:	23 83       	std	Z+3, r18	; 0x03
    25c2:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    25c4:	85 83       	std	Z+5, r24	; 0x05
    25c6:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    25c8:	87 83       	std	Z+7, r24	; 0x07
    25ca:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    25cc:	10 82       	st	Z, r1
    25ce:	08 95       	ret

000025d0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    25d0:	fc 01       	movw	r30, r24
    25d2:	10 86       	std	Z+8, r1	; 0x08
    25d4:	11 86       	std	Z+9, r1	; 0x09
    25d6:	08 95       	ret

000025d8 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    25d8:	cf 93       	push	r28
    25da:	df 93       	push	r29
    25dc:	9c 01       	movw	r18, r24
    25de:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    25e0:	dc 01       	movw	r26, r24
    25e2:	11 96       	adiw	r26, 0x01	; 1
    25e4:	cd 91       	ld	r28, X+
    25e6:	dc 91       	ld	r29, X
    25e8:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    25ea:	c2 83       	std	Z+2, r28	; 0x02
    25ec:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    25ee:	8c 81       	ldd	r24, Y+4	; 0x04
    25f0:	9d 81       	ldd	r25, Y+5	; 0x05
    25f2:	84 83       	std	Z+4, r24	; 0x04
    25f4:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    25f6:	8c 81       	ldd	r24, Y+4	; 0x04
    25f8:	9d 81       	ldd	r25, Y+5	; 0x05
    25fa:	dc 01       	movw	r26, r24
    25fc:	12 96       	adiw	r26, 0x02	; 2
    25fe:	6d 93       	st	X+, r22
    2600:	7c 93       	st	X, r23
    2602:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    2604:	6c 83       	std	Y+4, r22	; 0x04
    2606:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2608:	20 87       	std	Z+8, r18	; 0x08
    260a:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    260c:	f9 01       	movw	r30, r18
    260e:	80 81       	ld	r24, Z
    2610:	8f 5f       	subi	r24, 0xFF	; 255
    2612:	80 83       	st	Z, r24
}
    2614:	df 91       	pop	r29
    2616:	cf 91       	pop	r28
    2618:	08 95       	ret

0000261a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    261a:	cf 93       	push	r28
    261c:	df 93       	push	r29
    261e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2620:	48 81       	ld	r20, Y
    2622:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2624:	4f 3f       	cpi	r20, 0xFF	; 255
    2626:	2f ef       	ldi	r18, 0xFF	; 255
    2628:	52 07       	cpc	r21, r18
    262a:	21 f4       	brne	.+8      	; 0x2634 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    262c:	fc 01       	movw	r30, r24
    262e:	a7 81       	ldd	r26, Z+7	; 0x07
    2630:	b0 85       	ldd	r27, Z+8	; 0x08
    2632:	0d c0       	rjmp	.+26     	; 0x264e <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2634:	dc 01       	movw	r26, r24
    2636:	13 96       	adiw	r26, 0x03	; 3
    2638:	12 96       	adiw	r26, 0x02	; 2
    263a:	ed 91       	ld	r30, X+
    263c:	fc 91       	ld	r31, X
    263e:	13 97       	sbiw	r26, 0x03	; 3
    2640:	20 81       	ld	r18, Z
    2642:	31 81       	ldd	r19, Z+1	; 0x01
    2644:	42 17       	cp	r20, r18
    2646:	53 07       	cpc	r21, r19
    2648:	10 f0       	brcs	.+4      	; 0x264e <vListInsert+0x34>
    264a:	df 01       	movw	r26, r30
    264c:	f5 cf       	rjmp	.-22     	; 0x2638 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    264e:	12 96       	adiw	r26, 0x02	; 2
    2650:	ed 91       	ld	r30, X+
    2652:	fc 91       	ld	r31, X
    2654:	13 97       	sbiw	r26, 0x03	; 3
    2656:	ea 83       	std	Y+2, r30	; 0x02
    2658:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    265a:	c4 83       	std	Z+4, r28	; 0x04
    265c:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    265e:	ac 83       	std	Y+4, r26	; 0x04
    2660:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    2662:	12 96       	adiw	r26, 0x02	; 2
    2664:	cd 93       	st	X+, r28
    2666:	dc 93       	st	X, r29
    2668:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    266a:	88 87       	std	Y+8, r24	; 0x08
    266c:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    266e:	fc 01       	movw	r30, r24
    2670:	20 81       	ld	r18, Z
    2672:	2f 5f       	subi	r18, 0xFF	; 255
    2674:	20 83       	st	Z, r18
}
    2676:	df 91       	pop	r29
    2678:	cf 91       	pop	r28
    267a:	08 95       	ret

0000267c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    267c:	cf 93       	push	r28
    267e:	df 93       	push	r29
    2680:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    2682:	a0 85       	ldd	r26, Z+8	; 0x08
    2684:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2686:	c2 81       	ldd	r28, Z+2	; 0x02
    2688:	d3 81       	ldd	r29, Z+3	; 0x03
    268a:	84 81       	ldd	r24, Z+4	; 0x04
    268c:	95 81       	ldd	r25, Z+5	; 0x05
    268e:	8c 83       	std	Y+4, r24	; 0x04
    2690:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2692:	c4 81       	ldd	r28, Z+4	; 0x04
    2694:	d5 81       	ldd	r29, Z+5	; 0x05
    2696:	82 81       	ldd	r24, Z+2	; 0x02
    2698:	93 81       	ldd	r25, Z+3	; 0x03
    269a:	8a 83       	std	Y+2, r24	; 0x02
    269c:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    269e:	11 96       	adiw	r26, 0x01	; 1
    26a0:	cd 91       	ld	r28, X+
    26a2:	dc 91       	ld	r29, X
    26a4:	12 97       	sbiw	r26, 0x02	; 2
    26a6:	ce 17       	cp	r28, r30
    26a8:	df 07       	cpc	r29, r31
    26aa:	31 f4       	brne	.+12     	; 0x26b8 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    26ac:	8c 81       	ldd	r24, Y+4	; 0x04
    26ae:	9d 81       	ldd	r25, Y+5	; 0x05
    26b0:	11 96       	adiw	r26, 0x01	; 1
    26b2:	8d 93       	st	X+, r24
    26b4:	9c 93       	st	X, r25
    26b6:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    26b8:	10 86       	std	Z+8, r1	; 0x08
    26ba:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    26bc:	8c 91       	ld	r24, X
    26be:	81 50       	subi	r24, 0x01	; 1
    26c0:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    26c2:	df 91       	pop	r29
    26c4:	cf 91       	pop	r28
    26c6:	08 95       	ret

000026c8 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    26c8:	0f 93       	push	r16
    26ca:	1f 93       	push	r17
    26cc:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    26ce:	71 e1       	ldi	r23, 0x11	; 17
    26d0:	fc 01       	movw	r30, r24
    26d2:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    26d4:	31 97       	sbiw	r30, 0x01	; 1
    26d6:	62 e2       	ldi	r22, 0x22	; 34
    26d8:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    26da:	31 97       	sbiw	r30, 0x01	; 1
    26dc:	23 e3       	ldi	r18, 0x33	; 51
    26de:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    26e0:	22 27       	eor	r18, r18
    26e2:	17 fd       	sbrc	r17, 7
    26e4:	20 95       	com	r18
    26e6:	32 2f       	mov	r19, r18
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    26e8:	31 97       	sbiw	r30, 0x01	; 1
    26ea:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    26ec:	31 97       	sbiw	r30, 0x01	; 1
    26ee:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    26f0:	31 97       	sbiw	r30, 0x01	; 1
    26f2:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    26f4:	31 97       	sbiw	r30, 0x01	; 1
    26f6:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    26f8:	31 97       	sbiw	r30, 0x01	; 1
    26fa:	20 e8       	ldi	r18, 0x80	; 128
    26fc:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    26fe:	31 97       	sbiw	r30, 0x01	; 1
    2700:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    2702:	31 97       	sbiw	r30, 0x01	; 1
    2704:	22 e0       	ldi	r18, 0x02	; 2
    2706:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    2708:	31 97       	sbiw	r30, 0x01	; 1
    270a:	23 e0       	ldi	r18, 0x03	; 3
    270c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    270e:	31 97       	sbiw	r30, 0x01	; 1
    2710:	24 e0       	ldi	r18, 0x04	; 4
    2712:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    2714:	31 97       	sbiw	r30, 0x01	; 1
    2716:	25 e0       	ldi	r18, 0x05	; 5
    2718:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    271a:	31 97       	sbiw	r30, 0x01	; 1
    271c:	26 e0       	ldi	r18, 0x06	; 6
    271e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    2720:	31 97       	sbiw	r30, 0x01	; 1
    2722:	27 e0       	ldi	r18, 0x07	; 7
    2724:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    2726:	31 97       	sbiw	r30, 0x01	; 1
    2728:	28 e0       	ldi	r18, 0x08	; 8
    272a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    272c:	31 97       	sbiw	r30, 0x01	; 1
    272e:	29 e0       	ldi	r18, 0x09	; 9
    2730:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    2732:	31 97       	sbiw	r30, 0x01	; 1
    2734:	20 e1       	ldi	r18, 0x10	; 16
    2736:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    2738:	31 97       	sbiw	r30, 0x01	; 1
    273a:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    273c:	31 97       	sbiw	r30, 0x01	; 1
    273e:	22 e1       	ldi	r18, 0x12	; 18
    2740:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    2742:	31 97       	sbiw	r30, 0x01	; 1
    2744:	23 e1       	ldi	r18, 0x13	; 19
    2746:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    2748:	31 97       	sbiw	r30, 0x01	; 1
    274a:	24 e1       	ldi	r18, 0x14	; 20
    274c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    274e:	31 97       	sbiw	r30, 0x01	; 1
    2750:	25 e1       	ldi	r18, 0x15	; 21
    2752:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    2754:	31 97       	sbiw	r30, 0x01	; 1
    2756:	26 e1       	ldi	r18, 0x16	; 22
    2758:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    275a:	31 97       	sbiw	r30, 0x01	; 1
    275c:	27 e1       	ldi	r18, 0x17	; 23
    275e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    2760:	31 97       	sbiw	r30, 0x01	; 1
    2762:	28 e1       	ldi	r18, 0x18	; 24
    2764:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    2766:	31 97       	sbiw	r30, 0x01	; 1
    2768:	29 e1       	ldi	r18, 0x19	; 25
    276a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    276c:	31 97       	sbiw	r30, 0x01	; 1
    276e:	20 e2       	ldi	r18, 0x20	; 32
    2770:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    2772:	31 97       	sbiw	r30, 0x01	; 1
    2774:	21 e2       	ldi	r18, 0x21	; 33
    2776:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    2778:	31 97       	sbiw	r30, 0x01	; 1
    277a:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    277c:	31 97       	sbiw	r30, 0x01	; 1
    277e:	23 e2       	ldi	r18, 0x23	; 35
    2780:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    2782:	31 97       	sbiw	r30, 0x01	; 1
    2784:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    2786:	31 97       	sbiw	r30, 0x01	; 1
    2788:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    278a:	31 97       	sbiw	r30, 0x01	; 1
    278c:	26 e2       	ldi	r18, 0x26	; 38
    278e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    2790:	31 97       	sbiw	r30, 0x01	; 1
    2792:	27 e2       	ldi	r18, 0x27	; 39
    2794:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    2796:	31 97       	sbiw	r30, 0x01	; 1
    2798:	28 e2       	ldi	r18, 0x28	; 40
    279a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    279c:	31 97       	sbiw	r30, 0x01	; 1
    279e:	29 e2       	ldi	r18, 0x29	; 41
    27a0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    27a2:	31 97       	sbiw	r30, 0x01	; 1
    27a4:	20 e3       	ldi	r18, 0x30	; 48
    27a6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    27a8:	31 97       	sbiw	r30, 0x01	; 1
    27aa:	21 e3       	ldi	r18, 0x31	; 49
    27ac:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    27ae:	87 97       	sbiw	r24, 0x27	; 39
    27b0:	1f 91       	pop	r17
    27b2:	0f 91       	pop	r16
    27b4:	08 95       	ret

000027b6 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    27b6:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    27b8:	e0 e7       	ldi	r30, 0x70	; 112
    27ba:	f0 e0       	ldi	r31, 0x00	; 0
    27bc:	83 81       	ldd	r24, Z+3	; 0x03
    27be:	8a 7f       	andi	r24, 0xFA	; 250
    27c0:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    27c2:	e0 e0       	ldi	r30, 0x00	; 0
    27c4:	f8 e0       	ldi	r31, 0x08	; 8
    27c6:	80 ea       	ldi	r24, 0xA0	; 160
    27c8:	9f e0       	ldi	r25, 0x0F	; 15
    27ca:	86 a3       	std	Z+38, r24	; 0x26
    27cc:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    27ce:	81 e0       	ldi	r24, 0x01	; 1
    27d0:	86 83       	std	Z+6, r24	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    27d2:	a0 ea       	ldi	r26, 0xA0	; 160
    27d4:	b0 e0       	ldi	r27, 0x00	; 0
    27d6:	12 96       	adiw	r26, 0x02	; 2
    27d8:	9c 91       	ld	r25, X
    27da:	12 97       	sbiw	r26, 0x02	; 2
    27dc:	91 60       	ori	r25, 0x01	; 1
    27de:	12 96       	adiw	r26, 0x02	; 2
    27e0:	9c 93       	st	X, r25

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    27e2:	80 83       	st	Z, r24

    }

    // enable global interrupt
    sei();
    27e4:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    27e6:	a0 91 e5 23 	lds	r26, 0x23E5
    27ea:	b0 91 e6 23 	lds	r27, 0x23E6
    27ee:	0d 90       	ld	r0, X+
    27f0:	0d be       	out	0x3d, r0	; 61
    27f2:	0d 90       	ld	r0, X+
    27f4:	0e be       	out	0x3e, r0	; 62
    27f6:	ff 91       	pop	r31
    27f8:	ef 91       	pop	r30
    27fa:	df 91       	pop	r29
    27fc:	cf 91       	pop	r28
    27fe:	bf 91       	pop	r27
    2800:	af 91       	pop	r26
    2802:	9f 91       	pop	r25
    2804:	8f 91       	pop	r24
    2806:	7f 91       	pop	r23
    2808:	6f 91       	pop	r22
    280a:	5f 91       	pop	r21
    280c:	4f 91       	pop	r20
    280e:	3f 91       	pop	r19
    2810:	2f 91       	pop	r18
    2812:	1f 91       	pop	r17
    2814:	0f 91       	pop	r16
    2816:	ff 90       	pop	r15
    2818:	ef 90       	pop	r14
    281a:	df 90       	pop	r13
    281c:	cf 90       	pop	r12
    281e:	bf 90       	pop	r11
    2820:	af 90       	pop	r10
    2822:	9f 90       	pop	r9
    2824:	8f 90       	pop	r8
    2826:	7f 90       	pop	r7
    2828:	6f 90       	pop	r6
    282a:	5f 90       	pop	r5
    282c:	4f 90       	pop	r4
    282e:	3f 90       	pop	r3
    2830:	2f 90       	pop	r2
    2832:	1f 90       	pop	r1
    2834:	0f 90       	pop	r0
    2836:	0f be       	out	0x3f, r0	; 63
    2838:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    283a:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    283c:	08 95       	ret

0000283e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    283e:	0f 92       	push	r0
    2840:	0f b6       	in	r0, 0x3f	; 63
    2842:	f8 94       	cli
    2844:	0f 92       	push	r0
    2846:	1f 92       	push	r1
    2848:	11 24       	eor	r1, r1
    284a:	2f 92       	push	r2
    284c:	3f 92       	push	r3
    284e:	4f 92       	push	r4
    2850:	5f 92       	push	r5
    2852:	6f 92       	push	r6
    2854:	7f 92       	push	r7
    2856:	8f 92       	push	r8
    2858:	9f 92       	push	r9
    285a:	af 92       	push	r10
    285c:	bf 92       	push	r11
    285e:	cf 92       	push	r12
    2860:	df 92       	push	r13
    2862:	ef 92       	push	r14
    2864:	ff 92       	push	r15
    2866:	0f 93       	push	r16
    2868:	1f 93       	push	r17
    286a:	2f 93       	push	r18
    286c:	3f 93       	push	r19
    286e:	4f 93       	push	r20
    2870:	5f 93       	push	r21
    2872:	6f 93       	push	r22
    2874:	7f 93       	push	r23
    2876:	8f 93       	push	r24
    2878:	9f 93       	push	r25
    287a:	af 93       	push	r26
    287c:	bf 93       	push	r27
    287e:	cf 93       	push	r28
    2880:	df 93       	push	r29
    2882:	ef 93       	push	r30
    2884:	ff 93       	push	r31
    2886:	a0 91 e5 23 	lds	r26, 0x23E5
    288a:	b0 91 e6 23 	lds	r27, 0x23E6
    288e:	0d b6       	in	r0, 0x3d	; 61
    2890:	0d 92       	st	X+, r0
    2892:	0e b6       	in	r0, 0x3e	; 62
    2894:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    2896:	82 d3       	rcall	.+1796   	; 0x2f9c <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    2898:	a0 91 e5 23 	lds	r26, 0x23E5
    289c:	b0 91 e6 23 	lds	r27, 0x23E6
    28a0:	0d 90       	ld	r0, X+
    28a2:	0d be       	out	0x3d, r0	; 61
    28a4:	0d 90       	ld	r0, X+
    28a6:	0e be       	out	0x3e, r0	; 62
    28a8:	ff 91       	pop	r31
    28aa:	ef 91       	pop	r30
    28ac:	df 91       	pop	r29
    28ae:	cf 91       	pop	r28
    28b0:	bf 91       	pop	r27
    28b2:	af 91       	pop	r26
    28b4:	9f 91       	pop	r25
    28b6:	8f 91       	pop	r24
    28b8:	7f 91       	pop	r23
    28ba:	6f 91       	pop	r22
    28bc:	5f 91       	pop	r21
    28be:	4f 91       	pop	r20
    28c0:	3f 91       	pop	r19
    28c2:	2f 91       	pop	r18
    28c4:	1f 91       	pop	r17
    28c6:	0f 91       	pop	r16
    28c8:	ff 90       	pop	r15
    28ca:	ef 90       	pop	r14
    28cc:	df 90       	pop	r13
    28ce:	cf 90       	pop	r12
    28d0:	bf 90       	pop	r11
    28d2:	af 90       	pop	r10
    28d4:	9f 90       	pop	r9
    28d6:	8f 90       	pop	r8
    28d8:	7f 90       	pop	r7
    28da:	6f 90       	pop	r6
    28dc:	5f 90       	pop	r5
    28de:	4f 90       	pop	r4
    28e0:	3f 90       	pop	r3
    28e2:	2f 90       	pop	r2
    28e4:	1f 90       	pop	r1
    28e6:	0f 90       	pop	r0
    28e8:	0f be       	out	0x3f, r0	; 63
    28ea:	0f 90       	pop	r0

    asm volatile ( "ret" );
    28ec:	08 95       	ret

000028ee <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    28ee:	0f 92       	push	r0
    28f0:	0f b6       	in	r0, 0x3f	; 63
    28f2:	f8 94       	cli
    28f4:	0f 92       	push	r0
    28f6:	1f 92       	push	r1
    28f8:	11 24       	eor	r1, r1
    28fa:	2f 92       	push	r2
    28fc:	3f 92       	push	r3
    28fe:	4f 92       	push	r4
    2900:	5f 92       	push	r5
    2902:	6f 92       	push	r6
    2904:	7f 92       	push	r7
    2906:	8f 92       	push	r8
    2908:	9f 92       	push	r9
    290a:	af 92       	push	r10
    290c:	bf 92       	push	r11
    290e:	cf 92       	push	r12
    2910:	df 92       	push	r13
    2912:	ef 92       	push	r14
    2914:	ff 92       	push	r15
    2916:	0f 93       	push	r16
    2918:	1f 93       	push	r17
    291a:	2f 93       	push	r18
    291c:	3f 93       	push	r19
    291e:	4f 93       	push	r20
    2920:	5f 93       	push	r21
    2922:	6f 93       	push	r22
    2924:	7f 93       	push	r23
    2926:	8f 93       	push	r24
    2928:	9f 93       	push	r25
    292a:	af 93       	push	r26
    292c:	bf 93       	push	r27
    292e:	cf 93       	push	r28
    2930:	df 93       	push	r29
    2932:	ef 93       	push	r30
    2934:	ff 93       	push	r31
    2936:	a0 91 e5 23 	lds	r26, 0x23E5
    293a:	b0 91 e6 23 	lds	r27, 0x23E6
    293e:	0d b6       	in	r0, 0x3d	; 61
    2940:	0d 92       	st	X+, r0
    2942:	0e b6       	in	r0, 0x3e	; 62
    2944:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    2946:	bc d1       	rcall	.+888    	; 0x2cc0 <xTaskIncrementTick>
    2948:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    294a:	28 d3       	rcall	.+1616   	; 0x2f9c <vTaskSwitchContext>
        }
        portRESTORE_CONTEXT();
    294c:	a0 91 e5 23 	lds	r26, 0x23E5
    2950:	b0 91 e6 23 	lds	r27, 0x23E6
    2954:	0d 90       	ld	r0, X+
    2956:	0d be       	out	0x3d, r0	; 61
    2958:	0d 90       	ld	r0, X+
    295a:	0e be       	out	0x3e, r0	; 62
    295c:	ff 91       	pop	r31
    295e:	ef 91       	pop	r30
    2960:	df 91       	pop	r29
    2962:	cf 91       	pop	r28
    2964:	bf 91       	pop	r27
    2966:	af 91       	pop	r26
    2968:	9f 91       	pop	r25
    296a:	8f 91       	pop	r24
    296c:	7f 91       	pop	r23
    296e:	6f 91       	pop	r22
    2970:	5f 91       	pop	r21
    2972:	4f 91       	pop	r20
    2974:	3f 91       	pop	r19
    2976:	2f 91       	pop	r18
    2978:	1f 91       	pop	r17
    297a:	0f 91       	pop	r16
    297c:	ff 90       	pop	r15
    297e:	ef 90       	pop	r14
    2980:	df 90       	pop	r13
    2982:	cf 90       	pop	r12
    2984:	bf 90       	pop	r11
    2986:	af 90       	pop	r10
    2988:	9f 90       	pop	r9
    298a:	8f 90       	pop	r8
    298c:	7f 90       	pop	r7
    298e:	6f 90       	pop	r6
    2990:	5f 90       	pop	r5
    2992:	4f 90       	pop	r4
    2994:	3f 90       	pop	r3
    2996:	2f 90       	pop	r2
    2998:	1f 90       	pop	r1
    299a:	0f 90       	pop	r0
    299c:	0f be       	out	0x3f, r0	; 63
    299e:	0f 90       	pop	r0

        asm volatile ( "reti" );
    29a0:	18 95       	reti

000029a2 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    29a2:	cf 93       	push	r28
    29a4:	df 93       	push	r29
    29a6:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    29a8:	7b d1       	rcall	.+758    	; 0x2ca0 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    29aa:	ce 01       	movw	r24, r28
    29ac:	0e 94 13 1d 	call	0x3a26	; 0x3a26 <malloc>
    29b0:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    29b2:	5b d2       	rcall	.+1206   	; 0x2e6a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    29b4:	ce 01       	movw	r24, r28
    29b6:	df 91       	pop	r29
    29b8:	cf 91       	pop	r28
    29ba:	08 95       	ret

000029bc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    29bc:	cf 93       	push	r28
    29be:	df 93       	push	r29
    29c0:	ec 01       	movw	r28, r24
	if( pv )
    29c2:	00 97       	sbiw	r24, 0x00	; 0
    29c4:	29 f0       	breq	.+10     	; 0x29d0 <vPortFree+0x14>
	{
		vTaskSuspendAll();
    29c6:	6c d1       	rcall	.+728    	; 0x2ca0 <vTaskSuspendAll>
		{
			free( pv );
    29c8:	ce 01       	movw	r24, r28
    29ca:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    29ce:	4d d2       	rcall	.+1178   	; 0x2e6a <xTaskResumeAll>
	}
}
    29d0:	df 91       	pop	r29
    29d2:	cf 91       	pop	r28
    29d4:	08 95       	ret

000029d6 <prvIdleTask>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    29d6:	c8 eb       	ldi	r28, 0xB8	; 184
    29d8:	d3 e2       	ldi	r29, 0x23	; 35
    29da:	88 81       	ld	r24, Y
    29dc:	82 30       	cpi	r24, 0x02	; 2
    29de:	08 f4       	brcc	.+2      	; 0x29e2 <prvIdleTask+0xc>
    29e0:	ff cf       	rjmp	.-2      	; 0x29e0 <prvIdleTask+0xa>
    29e2:	2d df       	rcall	.-422    	; 0x283e <vPortYield>
    29e4:	fa cf       	rjmp	.-12     	; 0x29da <prvIdleTask+0x4>

000029e6 <prvAddCurrentTaskToDelayedList>:
    29e6:	cf 93       	push	r28
    29e8:	df 93       	push	r29
    29ea:	ec 01       	movw	r28, r24
    29ec:	e0 91 e5 23 	lds	r30, 0x23E5
    29f0:	f0 91 e6 23 	lds	r31, 0x23E6
    29f4:	82 83       	std	Z+2, r24	; 0x02
    29f6:	93 83       	std	Z+3, r25	; 0x03
    29f8:	80 91 96 23 	lds	r24, 0x2396
    29fc:	90 91 97 23 	lds	r25, 0x2397
    2a00:	c8 17       	cp	r28, r24
    2a02:	d9 07       	cpc	r29, r25
    2a04:	60 f4       	brcc	.+24     	; 0x2a1e <prvAddCurrentTaskToDelayedList+0x38>
    2a06:	60 91 e5 23 	lds	r22, 0x23E5
    2a0a:	70 91 e6 23 	lds	r23, 0x23E6
    2a0e:	80 91 a2 23 	lds	r24, 0x23A2
    2a12:	90 91 a3 23 	lds	r25, 0x23A3
    2a16:	6e 5f       	subi	r22, 0xFE	; 254
    2a18:	7f 4f       	sbci	r23, 0xFF	; 255
    2a1a:	ff dd       	rcall	.-1026   	; 0x261a <vListInsert>
    2a1c:	16 c0       	rjmp	.+44     	; 0x2a4a <prvAddCurrentTaskToDelayedList+0x64>
    2a1e:	60 91 e5 23 	lds	r22, 0x23E5
    2a22:	70 91 e6 23 	lds	r23, 0x23E6
    2a26:	80 91 a4 23 	lds	r24, 0x23A4
    2a2a:	90 91 a5 23 	lds	r25, 0x23A5
    2a2e:	6e 5f       	subi	r22, 0xFE	; 254
    2a30:	7f 4f       	sbci	r23, 0xFF	; 255
    2a32:	f3 dd       	rcall	.-1050   	; 0x261a <vListInsert>
    2a34:	80 91 0e 20 	lds	r24, 0x200E
    2a38:	90 91 0f 20 	lds	r25, 0x200F
    2a3c:	c8 17       	cp	r28, r24
    2a3e:	d9 07       	cpc	r29, r25
    2a40:	20 f4       	brcc	.+8      	; 0x2a4a <prvAddCurrentTaskToDelayedList+0x64>
    2a42:	c0 93 0e 20 	sts	0x200E, r28
    2a46:	d0 93 0f 20 	sts	0x200F, r29
    2a4a:	df 91       	pop	r29
    2a4c:	cf 91       	pop	r28
    2a4e:	08 95       	ret

00002a50 <xTaskGenericCreate>:
    2a50:	4f 92       	push	r4
    2a52:	5f 92       	push	r5
    2a54:	6f 92       	push	r6
    2a56:	7f 92       	push	r7
    2a58:	8f 92       	push	r8
    2a5a:	9f 92       	push	r9
    2a5c:	af 92       	push	r10
    2a5e:	bf 92       	push	r11
    2a60:	cf 92       	push	r12
    2a62:	df 92       	push	r13
    2a64:	ef 92       	push	r14
    2a66:	ff 92       	push	r15
    2a68:	0f 93       	push	r16
    2a6a:	1f 93       	push	r17
    2a6c:	cf 93       	push	r28
    2a6e:	df 93       	push	r29
    2a70:	4c 01       	movw	r8, r24
    2a72:	5b 01       	movw	r10, r22
    2a74:	2a 01       	movw	r4, r20
    2a76:	39 01       	movw	r6, r18
    2a78:	81 e2       	ldi	r24, 0x21	; 33
    2a7a:	90 e0       	ldi	r25, 0x00	; 0
    2a7c:	92 df       	rcall	.-220    	; 0x29a2 <pvPortMalloc>
    2a7e:	ec 01       	movw	r28, r24
    2a80:	00 97       	sbiw	r24, 0x00	; 0
    2a82:	09 f4       	brne	.+2      	; 0x2a86 <xTaskGenericCreate+0x36>
    2a84:	d2 c0       	rjmp	.+420    	; 0x2c2a <xTaskGenericCreate+0x1da>
    2a86:	c1 14       	cp	r12, r1
    2a88:	d1 04       	cpc	r13, r1
    2a8a:	09 f0       	breq	.+2      	; 0x2a8e <xTaskGenericCreate+0x3e>
    2a8c:	b7 c0       	rjmp	.+366    	; 0x2bfc <xTaskGenericCreate+0x1ac>
    2a8e:	c2 01       	movw	r24, r4
    2a90:	88 df       	rcall	.-240    	; 0x29a2 <pvPortMalloc>
    2a92:	8f 8b       	std	Y+23, r24	; 0x17
    2a94:	98 8f       	std	Y+24, r25	; 0x18
    2a96:	89 2b       	or	r24, r25
    2a98:	09 f0       	breq	.+2      	; 0x2a9c <xTaskGenericCreate+0x4c>
    2a9a:	b2 c0       	rjmp	.+356    	; 0x2c00 <xTaskGenericCreate+0x1b0>
    2a9c:	ce 01       	movw	r24, r28
    2a9e:	8e df       	rcall	.-228    	; 0x29bc <vPortFree>
    2aa0:	c4 c0       	rjmp	.+392    	; 0x2c2a <xTaskGenericCreate+0x1da>
    2aa2:	cf 01       	movw	r24, r30
    2aa4:	31 91       	ld	r19, Z+
    2aa6:	da 01       	movw	r26, r20
    2aa8:	3d 93       	st	X+, r19
    2aaa:	ad 01       	movw	r20, r26
    2aac:	dc 01       	movw	r26, r24
    2aae:	8c 91       	ld	r24, X
    2ab0:	88 23       	and	r24, r24
    2ab2:	11 f0       	breq	.+4      	; 0x2ab8 <xTaskGenericCreate+0x68>
    2ab4:	21 50       	subi	r18, 0x01	; 1
    2ab6:	a9 f7       	brne	.-22     	; 0x2aa2 <xTaskGenericCreate+0x52>
    2ab8:	18 a2       	std	Y+32, r1	; 0x20
    2aba:	10 2f       	mov	r17, r16
    2abc:	05 30       	cpi	r16, 0x05	; 5
    2abe:	08 f0       	brcs	.+2      	; 0x2ac2 <xTaskGenericCreate+0x72>
    2ac0:	14 e0       	ldi	r17, 0x04	; 4
    2ac2:	1e 8b       	std	Y+22, r17	; 0x16
    2ac4:	5e 01       	movw	r10, r28
    2ac6:	b2 e0       	ldi	r27, 0x02	; 2
    2ac8:	ab 0e       	add	r10, r27
    2aca:	b1 1c       	adc	r11, r1
    2acc:	c5 01       	movw	r24, r10
    2ace:	80 dd       	rcall	.-1280   	; 0x25d0 <vListInitialiseItem>
    2ad0:	ce 01       	movw	r24, r28
    2ad2:	0c 96       	adiw	r24, 0x0c	; 12
    2ad4:	7d dd       	rcall	.-1286   	; 0x25d0 <vListInitialiseItem>
    2ad6:	c8 87       	std	Y+8, r28	; 0x08
    2ad8:	d9 87       	std	Y+9, r29	; 0x09
    2ada:	85 e0       	ldi	r24, 0x05	; 5
    2adc:	90 e0       	ldi	r25, 0x00	; 0
    2ade:	81 1b       	sub	r24, r17
    2ae0:	91 09       	sbc	r25, r1
    2ae2:	8c 87       	std	Y+12, r24	; 0x0c
    2ae4:	9d 87       	std	Y+13, r25	; 0x0d
    2ae6:	ca 8b       	std	Y+18, r28	; 0x12
    2ae8:	db 8b       	std	Y+19, r29	; 0x13
    2aea:	a3 01       	movw	r20, r6
    2aec:	b4 01       	movw	r22, r8
    2aee:	c6 01       	movw	r24, r12
    2af0:	eb dd       	rcall	.-1066   	; 0x26c8 <pxPortInitialiseStack>
    2af2:	88 83       	st	Y, r24
    2af4:	99 83       	std	Y+1, r25	; 0x01
    2af6:	e1 14       	cp	r14, r1
    2af8:	f1 04       	cpc	r15, r1
    2afa:	19 f0       	breq	.+6      	; 0x2b02 <xTaskGenericCreate+0xb2>
    2afc:	f7 01       	movw	r30, r14
    2afe:	c0 83       	st	Z, r28
    2b00:	d1 83       	std	Z+1, r29	; 0x01
    2b02:	0f b6       	in	r0, 0x3f	; 63
    2b04:	f8 94       	cli
    2b06:	0f 92       	push	r0
    2b08:	80 91 98 23 	lds	r24, 0x2398
    2b0c:	8f 5f       	subi	r24, 0xFF	; 255
    2b0e:	80 93 98 23 	sts	0x2398, r24
    2b12:	80 91 e5 23 	lds	r24, 0x23E5
    2b16:	90 91 e6 23 	lds	r25, 0x23E6
    2b1a:	89 2b       	or	r24, r25
    2b1c:	91 f5       	brne	.+100    	; 0x2b82 <xTaskGenericCreate+0x132>
    2b1e:	c0 93 e5 23 	sts	0x23E5, r28
    2b22:	d0 93 e6 23 	sts	0x23E6, r29
    2b26:	80 91 98 23 	lds	r24, 0x2398
    2b2a:	81 30       	cpi	r24, 0x01	; 1
    2b2c:	c9 f5       	brne	.+114    	; 0x2ba0 <xTaskGenericCreate+0x150>
    2b2e:	0f 2e       	mov	r0, r31
    2b30:	f8 eb       	ldi	r31, 0xB8	; 184
    2b32:	ef 2e       	mov	r14, r31
    2b34:	f3 e2       	ldi	r31, 0x23	; 35
    2b36:	ff 2e       	mov	r15, r31
    2b38:	f0 2d       	mov	r31, r0
    2b3a:	0f 2e       	mov	r0, r31
    2b3c:	f5 ee       	ldi	r31, 0xE5	; 229
    2b3e:	cf 2e       	mov	r12, r31
    2b40:	f3 e2       	ldi	r31, 0x23	; 35
    2b42:	df 2e       	mov	r13, r31
    2b44:	f0 2d       	mov	r31, r0
    2b46:	c7 01       	movw	r24, r14
    2b48:	35 dd       	rcall	.-1430   	; 0x25b4 <vListInitialise>
    2b4a:	f9 e0       	ldi	r31, 0x09	; 9
    2b4c:	ef 0e       	add	r14, r31
    2b4e:	f1 1c       	adc	r15, r1
    2b50:	ec 14       	cp	r14, r12
    2b52:	fd 04       	cpc	r15, r13
    2b54:	c1 f7       	brne	.-16     	; 0x2b46 <xTaskGenericCreate+0xf6>
    2b56:	8f ea       	ldi	r24, 0xAF	; 175
    2b58:	93 e2       	ldi	r25, 0x23	; 35
    2b5a:	2c dd       	rcall	.-1448   	; 0x25b4 <vListInitialise>
    2b5c:	86 ea       	ldi	r24, 0xA6	; 166
    2b5e:	93 e2       	ldi	r25, 0x23	; 35
    2b60:	29 dd       	rcall	.-1454   	; 0x25b4 <vListInitialise>
    2b62:	89 e9       	ldi	r24, 0x99	; 153
    2b64:	93 e2       	ldi	r25, 0x23	; 35
    2b66:	26 dd       	rcall	.-1460   	; 0x25b4 <vListInitialise>
    2b68:	8f ea       	ldi	r24, 0xAF	; 175
    2b6a:	93 e2       	ldi	r25, 0x23	; 35
    2b6c:	80 93 a4 23 	sts	0x23A4, r24
    2b70:	90 93 a5 23 	sts	0x23A5, r25
    2b74:	86 ea       	ldi	r24, 0xA6	; 166
    2b76:	93 e2       	ldi	r25, 0x23	; 35
    2b78:	80 93 a2 23 	sts	0x23A2, r24
    2b7c:	90 93 a3 23 	sts	0x23A3, r25
    2b80:	0f c0       	rjmp	.+30     	; 0x2ba0 <xTaskGenericCreate+0x150>
    2b82:	80 91 94 23 	lds	r24, 0x2394
    2b86:	81 11       	cpse	r24, r1
    2b88:	0b c0       	rjmp	.+22     	; 0x2ba0 <xTaskGenericCreate+0x150>
    2b8a:	e0 91 e5 23 	lds	r30, 0x23E5
    2b8e:	f0 91 e6 23 	lds	r31, 0x23E6
    2b92:	86 89       	ldd	r24, Z+22	; 0x16
    2b94:	08 17       	cp	r16, r24
    2b96:	20 f0       	brcs	.+8      	; 0x2ba0 <xTaskGenericCreate+0x150>
    2b98:	c0 93 e5 23 	sts	0x23E5, r28
    2b9c:	d0 93 e6 23 	sts	0x23E6, r29
    2ba0:	80 91 90 23 	lds	r24, 0x2390
    2ba4:	8f 5f       	subi	r24, 0xFF	; 255
    2ba6:	80 93 90 23 	sts	0x2390, r24
    2baa:	8e 89       	ldd	r24, Y+22	; 0x16
    2bac:	90 91 95 23 	lds	r25, 0x2395
    2bb0:	98 17       	cp	r25, r24
    2bb2:	10 f4       	brcc	.+4      	; 0x2bb8 <xTaskGenericCreate+0x168>
    2bb4:	80 93 95 23 	sts	0x2395, r24
    2bb8:	90 e0       	ldi	r25, 0x00	; 0
    2bba:	9c 01       	movw	r18, r24
    2bbc:	22 0f       	add	r18, r18
    2bbe:	33 1f       	adc	r19, r19
    2bc0:	22 0f       	add	r18, r18
    2bc2:	33 1f       	adc	r19, r19
    2bc4:	22 0f       	add	r18, r18
    2bc6:	33 1f       	adc	r19, r19
    2bc8:	82 0f       	add	r24, r18
    2bca:	93 1f       	adc	r25, r19
    2bcc:	b5 01       	movw	r22, r10
    2bce:	88 54       	subi	r24, 0x48	; 72
    2bd0:	9c 4d       	sbci	r25, 0xDC	; 220
    2bd2:	02 dd       	rcall	.-1532   	; 0x25d8 <vListInsertEnd>
    2bd4:	0f 90       	pop	r0
    2bd6:	0f be       	out	0x3f, r0	; 63
    2bd8:	80 91 94 23 	lds	r24, 0x2394
    2bdc:	88 23       	and	r24, r24
    2bde:	51 f0       	breq	.+20     	; 0x2bf4 <xTaskGenericCreate+0x1a4>
    2be0:	e0 91 e5 23 	lds	r30, 0x23E5
    2be4:	f0 91 e6 23 	lds	r31, 0x23E6
    2be8:	86 89       	ldd	r24, Z+22	; 0x16
    2bea:	80 17       	cp	r24, r16
    2bec:	28 f4       	brcc	.+10     	; 0x2bf8 <xTaskGenericCreate+0x1a8>
    2bee:	27 de       	rcall	.-946    	; 0x283e <vPortYield>
    2bf0:	81 e0       	ldi	r24, 0x01	; 1
    2bf2:	1c c0       	rjmp	.+56     	; 0x2c2c <xTaskGenericCreate+0x1dc>
    2bf4:	81 e0       	ldi	r24, 0x01	; 1
    2bf6:	1a c0       	rjmp	.+52     	; 0x2c2c <xTaskGenericCreate+0x1dc>
    2bf8:	81 e0       	ldi	r24, 0x01	; 1
    2bfa:	18 c0       	rjmp	.+48     	; 0x2c2c <xTaskGenericCreate+0x1dc>
    2bfc:	cf 8a       	std	Y+23, r12	; 0x17
    2bfe:	d8 8e       	std	Y+24, r13	; 0x18
    2c00:	81 e0       	ldi	r24, 0x01	; 1
    2c02:	48 1a       	sub	r4, r24
    2c04:	51 08       	sbc	r5, r1
    2c06:	cf 88       	ldd	r12, Y+23	; 0x17
    2c08:	d8 8c       	ldd	r13, Y+24	; 0x18
    2c0a:	c4 0c       	add	r12, r4
    2c0c:	d5 1c       	adc	r13, r5
    2c0e:	d5 01       	movw	r26, r10
    2c10:	8c 91       	ld	r24, X
    2c12:	89 8f       	std	Y+25, r24	; 0x19
    2c14:	8c 91       	ld	r24, X
    2c16:	88 23       	and	r24, r24
    2c18:	09 f4       	brne	.+2      	; 0x2c1c <xTaskGenericCreate+0x1cc>
    2c1a:	4e cf       	rjmp	.-356    	; 0x2ab8 <xTaskGenericCreate+0x68>
    2c1c:	ae 01       	movw	r20, r28
    2c1e:	46 5e       	subi	r20, 0xE6	; 230
    2c20:	5f 4f       	sbci	r21, 0xFF	; 255
    2c22:	f5 01       	movw	r30, r10
    2c24:	31 96       	adiw	r30, 0x01	; 1
    2c26:	27 e0       	ldi	r18, 0x07	; 7
    2c28:	3c cf       	rjmp	.-392    	; 0x2aa2 <xTaskGenericCreate+0x52>
    2c2a:	8f ef       	ldi	r24, 0xFF	; 255
    2c2c:	df 91       	pop	r29
    2c2e:	cf 91       	pop	r28
    2c30:	1f 91       	pop	r17
    2c32:	0f 91       	pop	r16
    2c34:	ff 90       	pop	r15
    2c36:	ef 90       	pop	r14
    2c38:	df 90       	pop	r13
    2c3a:	cf 90       	pop	r12
    2c3c:	bf 90       	pop	r11
    2c3e:	af 90       	pop	r10
    2c40:	9f 90       	pop	r9
    2c42:	8f 90       	pop	r8
    2c44:	7f 90       	pop	r7
    2c46:	6f 90       	pop	r6
    2c48:	5f 90       	pop	r5
    2c4a:	4f 90       	pop	r4
    2c4c:	08 95       	ret

00002c4e <vTaskStartScheduler>:
    2c4e:	af 92       	push	r10
    2c50:	bf 92       	push	r11
    2c52:	cf 92       	push	r12
    2c54:	df 92       	push	r13
    2c56:	ef 92       	push	r14
    2c58:	ff 92       	push	r15
    2c5a:	0f 93       	push	r16
    2c5c:	a1 2c       	mov	r10, r1
    2c5e:	b1 2c       	mov	r11, r1
    2c60:	c1 2c       	mov	r12, r1
    2c62:	d1 2c       	mov	r13, r1
    2c64:	e1 2c       	mov	r14, r1
    2c66:	f1 2c       	mov	r15, r1
    2c68:	00 e0       	ldi	r16, 0x00	; 0
    2c6a:	20 e0       	ldi	r18, 0x00	; 0
    2c6c:	30 e0       	ldi	r19, 0x00	; 0
    2c6e:	45 e5       	ldi	r20, 0x55	; 85
    2c70:	50 e0       	ldi	r21, 0x00	; 0
    2c72:	6e e1       	ldi	r22, 0x1E	; 30
    2c74:	70 e2       	ldi	r23, 0x20	; 32
    2c76:	8b ee       	ldi	r24, 0xEB	; 235
    2c78:	94 e1       	ldi	r25, 0x14	; 20
    2c7a:	ea de       	rcall	.-556    	; 0x2a50 <xTaskGenericCreate>
    2c7c:	81 30       	cpi	r24, 0x01	; 1
    2c7e:	41 f4       	brne	.+16     	; 0x2c90 <vTaskStartScheduler+0x42>
    2c80:	f8 94       	cli
    2c82:	80 93 94 23 	sts	0x2394, r24
    2c86:	10 92 96 23 	sts	0x2396, r1
    2c8a:	10 92 97 23 	sts	0x2397, r1
    2c8e:	93 dd       	rcall	.-1242   	; 0x27b6 <xPortStartScheduler>
    2c90:	0f 91       	pop	r16
    2c92:	ff 90       	pop	r15
    2c94:	ef 90       	pop	r14
    2c96:	df 90       	pop	r13
    2c98:	cf 90       	pop	r12
    2c9a:	bf 90       	pop	r11
    2c9c:	af 90       	pop	r10
    2c9e:	08 95       	ret

00002ca0 <vTaskSuspendAll>:
    2ca0:	80 91 8f 23 	lds	r24, 0x238F
    2ca4:	8f 5f       	subi	r24, 0xFF	; 255
    2ca6:	80 93 8f 23 	sts	0x238F, r24
    2caa:	08 95       	ret

00002cac <xTaskGetTickCount>:
    2cac:	0f b6       	in	r0, 0x3f	; 63
    2cae:	f8 94       	cli
    2cb0:	0f 92       	push	r0
    2cb2:	80 91 96 23 	lds	r24, 0x2396
    2cb6:	90 91 97 23 	lds	r25, 0x2397
    2cba:	0f 90       	pop	r0
    2cbc:	0f be       	out	0x3f, r0	; 63
    2cbe:	08 95       	ret

00002cc0 <xTaskIncrementTick>:
    2cc0:	df 92       	push	r13
    2cc2:	ef 92       	push	r14
    2cc4:	ff 92       	push	r15
    2cc6:	0f 93       	push	r16
    2cc8:	1f 93       	push	r17
    2cca:	cf 93       	push	r28
    2ccc:	df 93       	push	r29
    2cce:	80 91 8f 23 	lds	r24, 0x238F
    2cd2:	81 11       	cpse	r24, r1
    2cd4:	b2 c0       	rjmp	.+356    	; 0x2e3a <xTaskIncrementTick+0x17a>
    2cd6:	80 91 96 23 	lds	r24, 0x2396
    2cda:	90 91 97 23 	lds	r25, 0x2397
    2cde:	01 96       	adiw	r24, 0x01	; 1
    2ce0:	80 93 96 23 	sts	0x2396, r24
    2ce4:	90 93 97 23 	sts	0x2397, r25
    2ce8:	e0 90 96 23 	lds	r14, 0x2396
    2cec:	f0 90 97 23 	lds	r15, 0x2397
    2cf0:	e1 14       	cp	r14, r1
    2cf2:	f1 04       	cpc	r15, r1
    2cf4:	99 f5       	brne	.+102    	; 0x2d5c <xTaskIncrementTick+0x9c>
    2cf6:	80 91 a4 23 	lds	r24, 0x23A4
    2cfa:	90 91 a5 23 	lds	r25, 0x23A5
    2cfe:	20 91 a2 23 	lds	r18, 0x23A2
    2d02:	30 91 a3 23 	lds	r19, 0x23A3
    2d06:	20 93 a4 23 	sts	0x23A4, r18
    2d0a:	30 93 a5 23 	sts	0x23A5, r19
    2d0e:	80 93 a2 23 	sts	0x23A2, r24
    2d12:	90 93 a3 23 	sts	0x23A3, r25
    2d16:	80 91 91 23 	lds	r24, 0x2391
    2d1a:	8f 5f       	subi	r24, 0xFF	; 255
    2d1c:	80 93 91 23 	sts	0x2391, r24
    2d20:	e0 91 a4 23 	lds	r30, 0x23A4
    2d24:	f0 91 a5 23 	lds	r31, 0x23A5
    2d28:	80 81       	ld	r24, Z
    2d2a:	81 11       	cpse	r24, r1
    2d2c:	07 c0       	rjmp	.+14     	; 0x2d3c <xTaskIncrementTick+0x7c>
    2d2e:	8f ef       	ldi	r24, 0xFF	; 255
    2d30:	9f ef       	ldi	r25, 0xFF	; 255
    2d32:	80 93 0e 20 	sts	0x200E, r24
    2d36:	90 93 0f 20 	sts	0x200F, r25
    2d3a:	10 c0       	rjmp	.+32     	; 0x2d5c <xTaskIncrementTick+0x9c>
    2d3c:	e0 91 a4 23 	lds	r30, 0x23A4
    2d40:	f0 91 a5 23 	lds	r31, 0x23A5
    2d44:	05 80       	ldd	r0, Z+5	; 0x05
    2d46:	f6 81       	ldd	r31, Z+6	; 0x06
    2d48:	e0 2d       	mov	r30, r0
    2d4a:	06 80       	ldd	r0, Z+6	; 0x06
    2d4c:	f7 81       	ldd	r31, Z+7	; 0x07
    2d4e:	e0 2d       	mov	r30, r0
    2d50:	82 81       	ldd	r24, Z+2	; 0x02
    2d52:	93 81       	ldd	r25, Z+3	; 0x03
    2d54:	80 93 0e 20 	sts	0x200E, r24
    2d58:	90 93 0f 20 	sts	0x200F, r25
    2d5c:	80 91 0e 20 	lds	r24, 0x200E
    2d60:	90 91 0f 20 	lds	r25, 0x200F
    2d64:	e8 16       	cp	r14, r24
    2d66:	f9 06       	cpc	r15, r25
    2d68:	08 f4       	brcc	.+2      	; 0x2d6c <xTaskIncrementTick+0xac>
    2d6a:	50 c0       	rjmp	.+160    	; 0x2e0c <xTaskIncrementTick+0x14c>
    2d6c:	d1 2c       	mov	r13, r1
    2d6e:	02 c0       	rjmp	.+4      	; 0x2d74 <xTaskIncrementTick+0xb4>
    2d70:	dd 24       	eor	r13, r13
    2d72:	d3 94       	inc	r13
    2d74:	e0 91 a4 23 	lds	r30, 0x23A4
    2d78:	f0 91 a5 23 	lds	r31, 0x23A5
    2d7c:	80 81       	ld	r24, Z
    2d7e:	81 11       	cpse	r24, r1
    2d80:	07 c0       	rjmp	.+14     	; 0x2d90 <xTaskIncrementTick+0xd0>
    2d82:	8f ef       	ldi	r24, 0xFF	; 255
    2d84:	9f ef       	ldi	r25, 0xFF	; 255
    2d86:	80 93 0e 20 	sts	0x200E, r24
    2d8a:	90 93 0f 20 	sts	0x200F, r25
    2d8e:	3f c0       	rjmp	.+126    	; 0x2e0e <xTaskIncrementTick+0x14e>
    2d90:	e0 91 a4 23 	lds	r30, 0x23A4
    2d94:	f0 91 a5 23 	lds	r31, 0x23A5
    2d98:	05 80       	ldd	r0, Z+5	; 0x05
    2d9a:	f6 81       	ldd	r31, Z+6	; 0x06
    2d9c:	e0 2d       	mov	r30, r0
    2d9e:	c6 81       	ldd	r28, Z+6	; 0x06
    2da0:	d7 81       	ldd	r29, Z+7	; 0x07
    2da2:	2a 81       	ldd	r18, Y+2	; 0x02
    2da4:	3b 81       	ldd	r19, Y+3	; 0x03
    2da6:	e2 16       	cp	r14, r18
    2da8:	f3 06       	cpc	r15, r19
    2daa:	28 f4       	brcc	.+10     	; 0x2db6 <xTaskIncrementTick+0xf6>
    2dac:	20 93 0e 20 	sts	0x200E, r18
    2db0:	30 93 0f 20 	sts	0x200F, r19
    2db4:	2c c0       	rjmp	.+88     	; 0x2e0e <xTaskIncrementTick+0x14e>
    2db6:	8e 01       	movw	r16, r28
    2db8:	0e 5f       	subi	r16, 0xFE	; 254
    2dba:	1f 4f       	sbci	r17, 0xFF	; 255
    2dbc:	c8 01       	movw	r24, r16
    2dbe:	5e dc       	rcall	.-1860   	; 0x267c <uxListRemove>
    2dc0:	8c 89       	ldd	r24, Y+20	; 0x14
    2dc2:	9d 89       	ldd	r25, Y+21	; 0x15
    2dc4:	89 2b       	or	r24, r25
    2dc6:	19 f0       	breq	.+6      	; 0x2dce <xTaskIncrementTick+0x10e>
    2dc8:	ce 01       	movw	r24, r28
    2dca:	0c 96       	adiw	r24, 0x0c	; 12
    2dcc:	57 dc       	rcall	.-1874   	; 0x267c <uxListRemove>
    2dce:	2e 89       	ldd	r18, Y+22	; 0x16
    2dd0:	80 91 95 23 	lds	r24, 0x2395
    2dd4:	82 17       	cp	r24, r18
    2dd6:	10 f4       	brcc	.+4      	; 0x2ddc <xTaskIncrementTick+0x11c>
    2dd8:	20 93 95 23 	sts	0x2395, r18
    2ddc:	30 e0       	ldi	r19, 0x00	; 0
    2dde:	c9 01       	movw	r24, r18
    2de0:	88 0f       	add	r24, r24
    2de2:	99 1f       	adc	r25, r25
    2de4:	88 0f       	add	r24, r24
    2de6:	99 1f       	adc	r25, r25
    2de8:	88 0f       	add	r24, r24
    2dea:	99 1f       	adc	r25, r25
    2dec:	82 0f       	add	r24, r18
    2dee:	93 1f       	adc	r25, r19
    2df0:	b8 01       	movw	r22, r16
    2df2:	88 54       	subi	r24, 0x48	; 72
    2df4:	9c 4d       	sbci	r25, 0xDC	; 220
    2df6:	f0 db       	rcall	.-2080   	; 0x25d8 <vListInsertEnd>
    2df8:	e0 91 e5 23 	lds	r30, 0x23E5
    2dfc:	f0 91 e6 23 	lds	r31, 0x23E6
    2e00:	9e 89       	ldd	r25, Y+22	; 0x16
    2e02:	86 89       	ldd	r24, Z+22	; 0x16
    2e04:	98 17       	cp	r25, r24
    2e06:	08 f0       	brcs	.+2      	; 0x2e0a <xTaskIncrementTick+0x14a>
    2e08:	b3 cf       	rjmp	.-154    	; 0x2d70 <xTaskIncrementTick+0xb0>
    2e0a:	b4 cf       	rjmp	.-152    	; 0x2d74 <xTaskIncrementTick+0xb4>
    2e0c:	d1 2c       	mov	r13, r1
    2e0e:	e0 91 e5 23 	lds	r30, 0x23E5
    2e12:	f0 91 e6 23 	lds	r31, 0x23E6
    2e16:	86 89       	ldd	r24, Z+22	; 0x16
    2e18:	90 e0       	ldi	r25, 0x00	; 0
    2e1a:	fc 01       	movw	r30, r24
    2e1c:	ee 0f       	add	r30, r30
    2e1e:	ff 1f       	adc	r31, r31
    2e20:	ee 0f       	add	r30, r30
    2e22:	ff 1f       	adc	r31, r31
    2e24:	ee 0f       	add	r30, r30
    2e26:	ff 1f       	adc	r31, r31
    2e28:	8e 0f       	add	r24, r30
    2e2a:	9f 1f       	adc	r25, r31
    2e2c:	fc 01       	movw	r30, r24
    2e2e:	e8 54       	subi	r30, 0x48	; 72
    2e30:	fc 4d       	sbci	r31, 0xDC	; 220
    2e32:	80 81       	ld	r24, Z
    2e34:	82 30       	cpi	r24, 0x02	; 2
    2e36:	40 f4       	brcc	.+16     	; 0x2e48 <xTaskIncrementTick+0x188>
    2e38:	09 c0       	rjmp	.+18     	; 0x2e4c <xTaskIncrementTick+0x18c>
    2e3a:	80 91 93 23 	lds	r24, 0x2393
    2e3e:	8f 5f       	subi	r24, 0xFF	; 255
    2e40:	80 93 93 23 	sts	0x2393, r24
    2e44:	d1 2c       	mov	r13, r1
    2e46:	02 c0       	rjmp	.+4      	; 0x2e4c <xTaskIncrementTick+0x18c>
    2e48:	dd 24       	eor	r13, r13
    2e4a:	d3 94       	inc	r13
    2e4c:	80 91 92 23 	lds	r24, 0x2392
    2e50:	88 23       	and	r24, r24
    2e52:	11 f0       	breq	.+4      	; 0x2e58 <xTaskIncrementTick+0x198>
    2e54:	dd 24       	eor	r13, r13
    2e56:	d3 94       	inc	r13
    2e58:	8d 2d       	mov	r24, r13
    2e5a:	df 91       	pop	r29
    2e5c:	cf 91       	pop	r28
    2e5e:	1f 91       	pop	r17
    2e60:	0f 91       	pop	r16
    2e62:	ff 90       	pop	r15
    2e64:	ef 90       	pop	r14
    2e66:	df 90       	pop	r13
    2e68:	08 95       	ret

00002e6a <xTaskResumeAll>:
    2e6a:	df 92       	push	r13
    2e6c:	ef 92       	push	r14
    2e6e:	ff 92       	push	r15
    2e70:	0f 93       	push	r16
    2e72:	1f 93       	push	r17
    2e74:	cf 93       	push	r28
    2e76:	df 93       	push	r29
    2e78:	0f b6       	in	r0, 0x3f	; 63
    2e7a:	f8 94       	cli
    2e7c:	0f 92       	push	r0
    2e7e:	80 91 8f 23 	lds	r24, 0x238F
    2e82:	81 50       	subi	r24, 0x01	; 1
    2e84:	80 93 8f 23 	sts	0x238F, r24
    2e88:	80 91 8f 23 	lds	r24, 0x238F
    2e8c:	81 11       	cpse	r24, r1
    2e8e:	5c c0       	rjmp	.+184    	; 0x2f48 <xTaskResumeAll+0xde>
    2e90:	80 91 98 23 	lds	r24, 0x2398
    2e94:	88 23       	and	r24, r24
    2e96:	09 f4       	brne	.+2      	; 0x2e9a <xTaskResumeAll+0x30>
    2e98:	59 c0       	rjmp	.+178    	; 0x2f4c <xTaskResumeAll+0xe2>
    2e9a:	0f 2e       	mov	r0, r31
    2e9c:	f9 e9       	ldi	r31, 0x99	; 153
    2e9e:	ef 2e       	mov	r14, r31
    2ea0:	f3 e2       	ldi	r31, 0x23	; 35
    2ea2:	ff 2e       	mov	r15, r31
    2ea4:	f0 2d       	mov	r31, r0
    2ea6:	dd 24       	eor	r13, r13
    2ea8:	d3 94       	inc	r13
    2eaa:	2d c0       	rjmp	.+90     	; 0x2f06 <xTaskResumeAll+0x9c>
    2eac:	e0 91 9e 23 	lds	r30, 0x239E
    2eb0:	f0 91 9f 23 	lds	r31, 0x239F
    2eb4:	c6 81       	ldd	r28, Z+6	; 0x06
    2eb6:	d7 81       	ldd	r29, Z+7	; 0x07
    2eb8:	ce 01       	movw	r24, r28
    2eba:	0c 96       	adiw	r24, 0x0c	; 12
    2ebc:	df db       	rcall	.-2114   	; 0x267c <uxListRemove>
    2ebe:	8e 01       	movw	r16, r28
    2ec0:	0e 5f       	subi	r16, 0xFE	; 254
    2ec2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ec4:	c8 01       	movw	r24, r16
    2ec6:	da db       	rcall	.-2124   	; 0x267c <uxListRemove>
    2ec8:	8e 89       	ldd	r24, Y+22	; 0x16
    2eca:	90 91 95 23 	lds	r25, 0x2395
    2ece:	98 17       	cp	r25, r24
    2ed0:	10 f4       	brcc	.+4      	; 0x2ed6 <xTaskResumeAll+0x6c>
    2ed2:	80 93 95 23 	sts	0x2395, r24
    2ed6:	90 e0       	ldi	r25, 0x00	; 0
    2ed8:	9c 01       	movw	r18, r24
    2eda:	22 0f       	add	r18, r18
    2edc:	33 1f       	adc	r19, r19
    2ede:	22 0f       	add	r18, r18
    2ee0:	33 1f       	adc	r19, r19
    2ee2:	22 0f       	add	r18, r18
    2ee4:	33 1f       	adc	r19, r19
    2ee6:	82 0f       	add	r24, r18
    2ee8:	93 1f       	adc	r25, r19
    2eea:	b8 01       	movw	r22, r16
    2eec:	88 54       	subi	r24, 0x48	; 72
    2eee:	9c 4d       	sbci	r25, 0xDC	; 220
    2ef0:	73 db       	rcall	.-2330   	; 0x25d8 <vListInsertEnd>
    2ef2:	e0 91 e5 23 	lds	r30, 0x23E5
    2ef6:	f0 91 e6 23 	lds	r31, 0x23E6
    2efa:	9e 89       	ldd	r25, Y+22	; 0x16
    2efc:	86 89       	ldd	r24, Z+22	; 0x16
    2efe:	98 17       	cp	r25, r24
    2f00:	10 f0       	brcs	.+4      	; 0x2f06 <xTaskResumeAll+0x9c>
    2f02:	d0 92 92 23 	sts	0x2392, r13
    2f06:	f7 01       	movw	r30, r14
    2f08:	80 81       	ld	r24, Z
    2f0a:	81 11       	cpse	r24, r1
    2f0c:	cf cf       	rjmp	.-98     	; 0x2eac <xTaskResumeAll+0x42>
    2f0e:	80 91 93 23 	lds	r24, 0x2393
    2f12:	88 23       	and	r24, r24
    2f14:	91 f0       	breq	.+36     	; 0x2f3a <xTaskResumeAll+0xd0>
    2f16:	80 91 93 23 	lds	r24, 0x2393
    2f1a:	88 23       	and	r24, r24
    2f1c:	71 f0       	breq	.+28     	; 0x2f3a <xTaskResumeAll+0xd0>
    2f1e:	c1 e0       	ldi	r28, 0x01	; 1
    2f20:	cf de       	rcall	.-610    	; 0x2cc0 <xTaskIncrementTick>
    2f22:	81 11       	cpse	r24, r1
    2f24:	c0 93 92 23 	sts	0x2392, r28
    2f28:	80 91 93 23 	lds	r24, 0x2393
    2f2c:	81 50       	subi	r24, 0x01	; 1
    2f2e:	80 93 93 23 	sts	0x2393, r24
    2f32:	80 91 93 23 	lds	r24, 0x2393
    2f36:	81 11       	cpse	r24, r1
    2f38:	f3 cf       	rjmp	.-26     	; 0x2f20 <xTaskResumeAll+0xb6>
    2f3a:	80 91 92 23 	lds	r24, 0x2392
    2f3e:	81 30       	cpi	r24, 0x01	; 1
    2f40:	39 f4       	brne	.+14     	; 0x2f50 <xTaskResumeAll+0xe6>
    2f42:	7d dc       	rcall	.-1798   	; 0x283e <vPortYield>
    2f44:	81 e0       	ldi	r24, 0x01	; 1
    2f46:	05 c0       	rjmp	.+10     	; 0x2f52 <xTaskResumeAll+0xe8>
    2f48:	80 e0       	ldi	r24, 0x00	; 0
    2f4a:	03 c0       	rjmp	.+6      	; 0x2f52 <xTaskResumeAll+0xe8>
    2f4c:	80 e0       	ldi	r24, 0x00	; 0
    2f4e:	01 c0       	rjmp	.+2      	; 0x2f52 <xTaskResumeAll+0xe8>
    2f50:	80 e0       	ldi	r24, 0x00	; 0
    2f52:	0f 90       	pop	r0
    2f54:	0f be       	out	0x3f, r0	; 63
    2f56:	df 91       	pop	r29
    2f58:	cf 91       	pop	r28
    2f5a:	1f 91       	pop	r17
    2f5c:	0f 91       	pop	r16
    2f5e:	ff 90       	pop	r15
    2f60:	ef 90       	pop	r14
    2f62:	df 90       	pop	r13
    2f64:	08 95       	ret

00002f66 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2f66:	cf 93       	push	r28
    2f68:	df 93       	push	r29
    2f6a:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2f6c:	00 97       	sbiw	r24, 0x00	; 0
    2f6e:	91 f0       	breq	.+36     	; 0x2f94 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2f70:	97 de       	rcall	.-722    	; 0x2ca0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2f72:	80 91 96 23 	lds	r24, 0x2396
    2f76:	90 91 97 23 	lds	r25, 0x2397
    2f7a:	c8 0f       	add	r28, r24
    2f7c:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2f7e:	80 91 e5 23 	lds	r24, 0x23E5
    2f82:	90 91 e6 23 	lds	r25, 0x23E6
    2f86:	02 96       	adiw	r24, 0x02	; 2
    2f88:	79 db       	rcall	.-2318   	; 0x267c <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2f8a:	ce 01       	movw	r24, r28
    2f8c:	2c dd       	rcall	.-1448   	; 0x29e6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2f8e:	6d df       	rcall	.-294    	; 0x2e6a <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2f90:	81 11       	cpse	r24, r1
    2f92:	01 c0       	rjmp	.+2      	; 0x2f96 <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    2f94:	54 dc       	rcall	.-1880   	; 0x283e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2f96:	df 91       	pop	r29
    2f98:	cf 91       	pop	r28
    2f9a:	08 95       	ret

00002f9c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2f9c:	80 91 8f 23 	lds	r24, 0x238F
    2fa0:	88 23       	and	r24, r24
    2fa2:	21 f0       	breq	.+8      	; 0x2fac <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2fa4:	81 e0       	ldi	r24, 0x01	; 1
    2fa6:	80 93 92 23 	sts	0x2392, r24
    2faa:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    2fac:	10 92 92 23 	sts	0x2392, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2fb0:	80 91 95 23 	lds	r24, 0x2395
    2fb4:	90 e0       	ldi	r25, 0x00	; 0
    2fb6:	fc 01       	movw	r30, r24
    2fb8:	ee 0f       	add	r30, r30
    2fba:	ff 1f       	adc	r31, r31
    2fbc:	ee 0f       	add	r30, r30
    2fbe:	ff 1f       	adc	r31, r31
    2fc0:	ee 0f       	add	r30, r30
    2fc2:	ff 1f       	adc	r31, r31
    2fc4:	8e 0f       	add	r24, r30
    2fc6:	9f 1f       	adc	r25, r31
    2fc8:	fc 01       	movw	r30, r24
    2fca:	e8 54       	subi	r30, 0x48	; 72
    2fcc:	fc 4d       	sbci	r31, 0xDC	; 220
    2fce:	80 81       	ld	r24, Z
    2fd0:	81 11       	cpse	r24, r1
    2fd2:	17 c0       	rjmp	.+46     	; 0x3002 <vTaskSwitchContext+0x66>
    2fd4:	80 91 95 23 	lds	r24, 0x2395
    2fd8:	81 50       	subi	r24, 0x01	; 1
    2fda:	80 93 95 23 	sts	0x2395, r24
    2fde:	80 91 95 23 	lds	r24, 0x2395
    2fe2:	90 e0       	ldi	r25, 0x00	; 0
    2fe4:	fc 01       	movw	r30, r24
    2fe6:	ee 0f       	add	r30, r30
    2fe8:	ff 1f       	adc	r31, r31
    2fea:	ee 0f       	add	r30, r30
    2fec:	ff 1f       	adc	r31, r31
    2fee:	ee 0f       	add	r30, r30
    2ff0:	ff 1f       	adc	r31, r31
    2ff2:	8e 0f       	add	r24, r30
    2ff4:	9f 1f       	adc	r25, r31
    2ff6:	fc 01       	movw	r30, r24
    2ff8:	e8 54       	subi	r30, 0x48	; 72
    2ffa:	fc 4d       	sbci	r31, 0xDC	; 220
    2ffc:	80 81       	ld	r24, Z
    2ffe:	88 23       	and	r24, r24
    3000:	49 f3       	breq	.-46     	; 0x2fd4 <vTaskSwitchContext+0x38>
    3002:	e0 91 95 23 	lds	r30, 0x2395
    3006:	f0 e0       	ldi	r31, 0x00	; 0
    3008:	cf 01       	movw	r24, r30
    300a:	88 0f       	add	r24, r24
    300c:	99 1f       	adc	r25, r25
    300e:	88 0f       	add	r24, r24
    3010:	99 1f       	adc	r25, r25
    3012:	88 0f       	add	r24, r24
    3014:	99 1f       	adc	r25, r25
    3016:	e8 0f       	add	r30, r24
    3018:	f9 1f       	adc	r31, r25
    301a:	e8 54       	subi	r30, 0x48	; 72
    301c:	fc 4d       	sbci	r31, 0xDC	; 220
    301e:	a1 81       	ldd	r26, Z+1	; 0x01
    3020:	b2 81       	ldd	r27, Z+2	; 0x02
    3022:	12 96       	adiw	r26, 0x02	; 2
    3024:	0d 90       	ld	r0, X+
    3026:	bc 91       	ld	r27, X
    3028:	a0 2d       	mov	r26, r0
    302a:	a1 83       	std	Z+1, r26	; 0x01
    302c:	b2 83       	std	Z+2, r27	; 0x02
    302e:	cf 01       	movw	r24, r30
    3030:	03 96       	adiw	r24, 0x03	; 3
    3032:	a8 17       	cp	r26, r24
    3034:	b9 07       	cpc	r27, r25
    3036:	31 f4       	brne	.+12     	; 0x3044 <vTaskSwitchContext+0xa8>
    3038:	12 96       	adiw	r26, 0x02	; 2
    303a:	8d 91       	ld	r24, X+
    303c:	9c 91       	ld	r25, X
    303e:	13 97       	sbiw	r26, 0x03	; 3
    3040:	81 83       	std	Z+1, r24	; 0x01
    3042:	92 83       	std	Z+2, r25	; 0x02
    3044:	01 80       	ldd	r0, Z+1	; 0x01
    3046:	f2 81       	ldd	r31, Z+2	; 0x02
    3048:	e0 2d       	mov	r30, r0
    304a:	86 81       	ldd	r24, Z+6	; 0x06
    304c:	97 81       	ldd	r25, Z+7	; 0x07
    304e:	80 93 e5 23 	sts	0x23E5, r24
    3052:	90 93 e6 23 	sts	0x23E6, r25
    3056:	08 95       	ret

00003058 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
    3058:	8f ef       	ldi	r24, 0xFF	; 255
    305a:	80 93 70 00 	sts	0x0070, r24
    305e:	80 93 71 00 	sts	0x0071, r24
    3062:	80 93 72 00 	sts	0x0072, r24
    3066:	80 93 73 00 	sts	0x0073, r24
    306a:	80 93 74 00 	sts	0x0074, r24
    306e:	80 93 75 00 	sts	0x0075, r24
    3072:	80 93 76 00 	sts	0x0076, r24
    3076:	08 95       	ret

00003078 <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    3078:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    307a:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    307c:	e8 2f       	mov	r30, r24
    307e:	f0 e0       	ldi	r31, 0x00	; 0
    3080:	e0 59       	subi	r30, 0x90	; 144
    3082:	ff 4f       	sbci	r31, 0xFF	; 255
    3084:	60 95       	com	r22
    3086:	80 81       	ld	r24, Z
    3088:	68 23       	and	r22, r24
    308a:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    308c:	9f bf       	out	0x3f, r25	; 63
    308e:	08 95       	ret

00003090 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    3090:	cf 93       	push	r28
    3092:	df 93       	push	r29
    3094:	fc 01       	movw	r30, r24
    3096:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3098:	20 e0       	ldi	r18, 0x00	; 0
    309a:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    309c:	c6 2f       	mov	r28, r22
    309e:	d0 e0       	ldi	r29, 0x00	; 0
    30a0:	de 01       	movw	r26, r28
    30a2:	02 2e       	mov	r0, r18
    30a4:	02 c0       	rjmp	.+4      	; 0x30aa <ioport_configure_port_pin+0x1a>
    30a6:	b5 95       	asr	r27
    30a8:	a7 95       	ror	r26
    30aa:	0a 94       	dec	r0
    30ac:	e2 f7       	brpl	.-8      	; 0x30a6 <ioport_configure_port_pin+0x16>
    30ae:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    30b0:	50 83       	st	Z, r21
    30b2:	2f 5f       	subi	r18, 0xFF	; 255
    30b4:	3f 4f       	sbci	r19, 0xFF	; 255
    30b6:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    30b8:	28 30       	cpi	r18, 0x08	; 8
    30ba:	31 05       	cpc	r19, r1
    30bc:	89 f7       	brne	.-30     	; 0x30a0 <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    30be:	40 ff       	sbrs	r20, 0
    30c0:	0a c0       	rjmp	.+20     	; 0x30d6 <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
    30c2:	41 ff       	sbrs	r20, 1
    30c4:	03 c0       	rjmp	.+6      	; 0x30cc <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    30c6:	fc 01       	movw	r30, r24
    30c8:	65 83       	std	Z+5, r22	; 0x05
    30ca:	02 c0       	rjmp	.+4      	; 0x30d0 <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    30cc:	fc 01       	movw	r30, r24
    30ce:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    30d0:	fc 01       	movw	r30, r24
    30d2:	61 83       	std	Z+1, r22	; 0x01
    30d4:	02 c0       	rjmp	.+4      	; 0x30da <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    30d6:	fc 01       	movw	r30, r24
    30d8:	62 83       	std	Z+2, r22	; 0x02
	}
}
    30da:	df 91       	pop	r29
    30dc:	cf 91       	pop	r28
    30de:	08 95       	ret

000030e0 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    30e0:	43 e0       	ldi	r20, 0x03	; 3
    30e2:	50 e0       	ldi	r21, 0x00	; 0
    30e4:	61 e0       	ldi	r22, 0x01	; 1
    30e6:	80 ee       	ldi	r24, 0xE0	; 224
    30e8:	97 e0       	ldi	r25, 0x07	; 7
    30ea:	d2 df       	rcall	.-92     	; 0x3090 <ioport_configure_port_pin>
    30ec:	43 e0       	ldi	r20, 0x03	; 3
    30ee:	50 e0       	ldi	r21, 0x00	; 0
    30f0:	62 e0       	ldi	r22, 0x02	; 2
    30f2:	80 ee       	ldi	r24, 0xE0	; 224
    30f4:	97 e0       	ldi	r25, 0x07	; 7
    30f6:	cc df       	rcall	.-104    	; 0x3090 <ioport_configure_port_pin>
    30f8:	43 e0       	ldi	r20, 0x03	; 3
    30fa:	50 e0       	ldi	r21, 0x00	; 0
    30fc:	60 e1       	ldi	r22, 0x10	; 16
    30fe:	80 e6       	ldi	r24, 0x60	; 96
    3100:	96 e0       	ldi	r25, 0x06	; 6
    3102:	c6 df       	rcall	.-116    	; 0x3090 <ioport_configure_port_pin>
    3104:	41 e0       	ldi	r20, 0x01	; 1
    3106:	50 e4       	ldi	r21, 0x40	; 64
    3108:	60 e2       	ldi	r22, 0x20	; 32
    310a:	80 e6       	ldi	r24, 0x60	; 96
    310c:	96 e0       	ldi	r25, 0x06	; 6
    310e:	c0 df       	rcall	.-128    	; 0x3090 <ioport_configure_port_pin>
    3110:	40 e0       	ldi	r20, 0x00	; 0
    3112:	5b e1       	ldi	r21, 0x1B	; 27
    3114:	60 e2       	ldi	r22, 0x20	; 32
    3116:	80 e8       	ldi	r24, 0x80	; 128
    3118:	96 e0       	ldi	r25, 0x06	; 6
    311a:	ba df       	rcall	.-140    	; 0x3090 <ioport_configure_port_pin>
    311c:	40 e0       	ldi	r20, 0x00	; 0
    311e:	5b e1       	ldi	r21, 0x1B	; 27
    3120:	62 e0       	ldi	r22, 0x02	; 2
    3122:	80 ea       	ldi	r24, 0xA0	; 160
    3124:	96 e0       	ldi	r25, 0x06	; 6
    3126:	b4 df       	rcall	.-152    	; 0x3090 <ioport_configure_port_pin>
    3128:	40 e0       	ldi	r20, 0x00	; 0
    312a:	5b e1       	ldi	r21, 0x1B	; 27
    312c:	64 e0       	ldi	r22, 0x04	; 4
    312e:	80 ea       	ldi	r24, 0xA0	; 160
    3130:	96 e0       	ldi	r25, 0x06	; 6
    3132:	ae df       	rcall	.-164    	; 0x3090 <ioport_configure_port_pin>
    3134:	43 e0       	ldi	r20, 0x03	; 3
    3136:	50 e0       	ldi	r21, 0x00	; 0
    3138:	62 e0       	ldi	r22, 0x02	; 2
    313a:	80 e6       	ldi	r24, 0x60	; 96
    313c:	96 e0       	ldi	r25, 0x06	; 6
    313e:	a8 df       	rcall	.-176    	; 0x3090 <ioport_configure_port_pin>
    3140:	43 e0       	ldi	r20, 0x03	; 3
    3142:	50 e0       	ldi	r21, 0x00	; 0
    3144:	68 e0       	ldi	r22, 0x08	; 8
    3146:	80 e6       	ldi	r24, 0x60	; 96
    3148:	96 e0       	ldi	r25, 0x06	; 6
    314a:	a2 df       	rcall	.-188    	; 0x3090 <ioport_configure_port_pin>
    314c:	43 e0       	ldi	r20, 0x03	; 3
    314e:	50 e0       	ldi	r21, 0x00	; 0
    3150:	68 e0       	ldi	r22, 0x08	; 8
    3152:	80 ea       	ldi	r24, 0xA0	; 160
    3154:	96 e0       	ldi	r25, 0x06	; 6
    3156:	9c df       	rcall	.-200    	; 0x3090 <ioport_configure_port_pin>
    3158:	43 e0       	ldi	r20, 0x03	; 3
    315a:	50 e0       	ldi	r21, 0x00	; 0
    315c:	61 e0       	ldi	r22, 0x01	; 1
    315e:	80 e6       	ldi	r24, 0x60	; 96
    3160:	96 e0       	ldi	r25, 0x06	; 6
    3162:	96 df       	rcall	.-212    	; 0x3090 <ioport_configure_port_pin>
    3164:	43 e0       	ldi	r20, 0x03	; 3
    3166:	50 e0       	ldi	r21, 0x00	; 0
    3168:	68 e0       	ldi	r22, 0x08	; 8
    316a:	80 e0       	ldi	r24, 0x00	; 0
    316c:	96 e0       	ldi	r25, 0x06	; 6
    316e:	90 df       	rcall	.-224    	; 0x3090 <ioport_configure_port_pin>
    3170:	41 e0       	ldi	r20, 0x01	; 1
    3172:	50 e0       	ldi	r21, 0x00	; 0
    3174:	60 e1       	ldi	r22, 0x10	; 16
    3176:	80 e8       	ldi	r24, 0x80	; 128
    3178:	96 e0       	ldi	r25, 0x06	; 6
    317a:	8a cf       	rjmp	.-236    	; 0x3090 <ioport_configure_port_pin>
    317c:	08 95       	ret

0000317e <commGate_SIG>:
	}*/
}

void switchDisplay(int dest){
	menuSelected = dest;
	switchDisp = true;
    317e:	60 91 ec 23 	lds	r22, 0x23EC
    3182:	45 e5       	ldi	r20, 0x55	; 85
    3184:	56 e0       	ldi	r21, 0x06	; 6
    3186:	81 e0       	ldi	r24, 0x01	; 1
    3188:	90 e0       	ldi	r25, 0x00	; 0
    318a:	c4 e5       	ldi	r28, 0x54	; 84
    318c:	d6 e0       	ldi	r29, 0x06	; 6
    318e:	e0 ee       	ldi	r30, 0xE0	; 224
    3190:	f7 e0       	ldi	r31, 0x07	; 7
    3192:	12 e0       	ldi	r17, 0x02	; 2
    3194:	da 01       	movw	r26, r20
    3196:	2c 91       	ld	r18, X
    3198:	a2 2f       	mov	r26, r18
    319a:	a6 95       	lsr	r26
    319c:	a6 95       	lsr	r26
    319e:	a6 95       	lsr	r26
    31a0:	30 e2       	ldi	r19, 0x20	; 32
    31a2:	a3 9f       	mul	r26, r19
    31a4:	d0 01       	movw	r26, r0
    31a6:	11 24       	eor	r1, r1
    31a8:	ba 5f       	subi	r27, 0xFA	; 250
    31aa:	66 23       	and	r22, r22
    31ac:	51 f0       	breq	.+20     	; 0x31c2 <commGate_SIG+0x44>
    31ae:	27 70       	andi	r18, 0x07	; 7
    31b0:	7c 01       	movw	r14, r24
    31b2:	02 c0       	rjmp	.+4      	; 0x31b8 <commGate_SIG+0x3a>
    31b4:	ee 0c       	add	r14, r14
    31b6:	ff 1c       	adc	r15, r15
    31b8:	2a 95       	dec	r18
    31ba:	e2 f7       	brpl	.-8      	; 0x31b4 <commGate_SIG+0x36>
    31bc:	15 96       	adiw	r26, 0x05	; 5
    31be:	ec 92       	st	X, r14
    31c0:	09 c0       	rjmp	.+18     	; 0x31d4 <commGate_SIG+0x56>
    31c2:	27 70       	andi	r18, 0x07	; 7
    31c4:	7c 01       	movw	r14, r24
    31c6:	02 c0       	rjmp	.+4      	; 0x31cc <commGate_SIG+0x4e>
    31c8:	ee 0c       	add	r14, r14
    31ca:	ff 1c       	adc	r15, r15
    31cc:	2a 95       	dec	r18
    31ce:	e2 f7       	brpl	.-8      	; 0x31c8 <commGate_SIG+0x4a>
    31d0:	16 96       	adiw	r26, 0x06	; 6
    31d2:	ec 92       	st	X, r14
    31d4:	38 81       	ld	r19, Y
    31d6:	a3 2f       	mov	r26, r19
    31d8:	a6 95       	lsr	r26
    31da:	a6 95       	lsr	r26
    31dc:	a6 95       	lsr	r26
    31de:	20 e2       	ldi	r18, 0x20	; 32
    31e0:	a2 9f       	mul	r26, r18
    31e2:	d0 01       	movw	r26, r0
    31e4:	11 24       	eor	r1, r1
    31e6:	ba 5f       	subi	r27, 0xFA	; 250
    31e8:	18 96       	adiw	r26, 0x08	; 8
    31ea:	7c 91       	ld	r23, X
    31ec:	37 70       	andi	r19, 0x07	; 7
    31ee:	dc 01       	movw	r26, r24
    31f0:	02 c0       	rjmp	.+4      	; 0x31f6 <commGate_SIG+0x78>
    31f2:	aa 0f       	add	r26, r26
    31f4:	bb 1f       	adc	r27, r27
    31f6:	3a 95       	dec	r19
    31f8:	e2 f7       	brpl	.-8      	; 0x31f2 <commGate_SIG+0x74>
    31fa:	9d 01       	movw	r18, r26
    31fc:	27 23       	and	r18, r23
    31fe:	31 e0       	ldi	r19, 0x01	; 1
    3200:	09 f4       	brne	.+2      	; 0x3204 <commGate_SIG+0x86>
    3202:	30 e0       	ldi	r19, 0x00	; 0
    3204:	30 93 eb 23 	sts	0x23EB, r19
    3208:	66 23       	and	r22, r22
    320a:	19 f0       	breq	.+6      	; 0x3212 <commGate_SIG+0x94>
    320c:	21 e0       	ldi	r18, 0x01	; 1
    320e:	25 83       	std	Z+5, r18	; 0x05
    3210:	02 c0       	rjmp	.+4      	; 0x3216 <commGate_SIG+0x98>
    3212:	21 e0       	ldi	r18, 0x01	; 1
    3214:	26 83       	std	Z+6, r18	; 0x06
    3216:	33 23       	and	r19, r19
    3218:	11 f0       	breq	.+4      	; 0x321e <commGate_SIG+0xa0>
    321a:	15 83       	std	Z+5, r17	; 0x05
    321c:	bb cf       	rjmp	.-138    	; 0x3194 <commGate_SIG+0x16>
    321e:	16 83       	std	Z+6, r17	; 0x06
    3220:	b9 cf       	rjmp	.-142    	; 0x3194 <commGate_SIG+0x16>

00003222 <button>:
    3222:	c0 e8       	ldi	r28, 0x80	; 128
    3224:	d6 e0       	ldi	r29, 0x06	; 6
    3226:	00 ea       	ldi	r16, 0xA0	; 160
    3228:	16 e0       	ldi	r17, 0x06	; 6
    322a:	0f 2e       	mov	r0, r31
    322c:	f0 e6       	ldi	r31, 0x60	; 96
    322e:	cf 2e       	mov	r12, r31
    3230:	f6 e0       	ldi	r31, 0x06	; 6
    3232:	df 2e       	mov	r13, r31
    3234:	f0 2d       	mov	r31, r0
    3236:	68 94       	set
    3238:	33 24       	eor	r3, r3
    323a:	35 f8       	bld	r3, 5
    323c:	68 94       	set
    323e:	44 24       	eor	r4, r4
    3240:	44 f8       	bld	r4, 4
    3242:	0f 2e       	mov	r0, r31
    3244:	f0 ee       	ldi	r31, 0xE0	; 224
    3246:	ef 2e       	mov	r14, r31
    3248:	f7 e0       	ldi	r31, 0x07	; 7
    324a:	ff 2e       	mov	r15, r31
    324c:	f0 2d       	mov	r31, r0
    324e:	55 24       	eor	r5, r5
    3250:	53 94       	inc	r5
    3252:	0f 2e       	mov	r0, r31
    3254:	f3 e0       	ldi	r31, 0x03	; 3
    3256:	6f 2e       	mov	r6, r31
    3258:	71 2c       	mov	r7, r1
    325a:	f0 2d       	mov	r31, r0
    325c:	68 94       	set
    325e:	88 24       	eor	r8, r8
    3260:	81 f8       	bld	r8, 1
    3262:	91 2c       	mov	r9, r1
    3264:	aa 24       	eor	r10, r10
    3266:	a3 94       	inc	r10
    3268:	b1 2c       	mov	r11, r1
    326a:	82 e3       	ldi	r24, 0x32	; 50
    326c:	90 e0       	ldi	r25, 0x00	; 0
    326e:	7b de       	rcall	.-778    	; 0x2f66 <vTaskDelay>
    3270:	88 85       	ldd	r24, Y+8	; 0x08
    3272:	85 fd       	sbrc	r24, 5
    3274:	07 c0       	rjmp	.+14     	; 0x3284 <button+0x62>
    3276:	f7 01       	movw	r30, r14
    3278:	56 82       	std	Z+6, r5	; 0x06
    327a:	10 92 b2 24 	sts	0x24B2, r1
    327e:	10 92 b3 24 	sts	0x24B3, r1
    3282:	f3 cf       	rjmp	.-26     	; 0x326a <button+0x48>
    3284:	f8 01       	movw	r30, r16
    3286:	80 85       	ldd	r24, Z+8	; 0x08
    3288:	81 fd       	sbrc	r24, 1
    328a:	07 c0       	rjmp	.+14     	; 0x329a <button+0x78>
    328c:	f6 01       	movw	r30, r12
    328e:	46 82       	std	Z+6, r4	; 0x06
    3290:	a0 92 b2 24 	sts	0x24B2, r10
    3294:	b0 92 b3 24 	sts	0x24B3, r11
    3298:	e8 cf       	rjmp	.-48     	; 0x326a <button+0x48>
    329a:	f8 01       	movw	r30, r16
    329c:	80 85       	ldd	r24, Z+8	; 0x08
    329e:	82 fd       	sbrc	r24, 2
    32a0:	07 c0       	rjmp	.+14     	; 0x32b0 <button+0x8e>
    32a2:	f6 01       	movw	r30, r12
    32a4:	36 82       	std	Z+6, r3	; 0x06
    32a6:	80 92 b2 24 	sts	0x24B2, r8
    32aa:	90 92 b3 24 	sts	0x24B3, r9
    32ae:	dd cf       	rjmp	.-70     	; 0x326a <button+0x48>
    32b0:	f8 01       	movw	r30, r16
    32b2:	80 85       	ldd	r24, Z+8	; 0x08
    32b4:	81 ff       	sbrs	r24, 1
    32b6:	d9 cf       	rjmp	.-78     	; 0x326a <button+0x48>
    32b8:	80 85       	ldd	r24, Z+8	; 0x08
    32ba:	82 ff       	sbrs	r24, 2
    32bc:	d6 cf       	rjmp	.-84     	; 0x326a <button+0x48>
    32be:	88 85       	ldd	r24, Y+8	; 0x08
    32c0:	85 ff       	sbrs	r24, 5
    32c2:	d3 cf       	rjmp	.-90     	; 0x326a <button+0x48>
    32c4:	f6 01       	movw	r30, r12
    32c6:	35 82       	std	Z+5, r3	; 0x05
    32c8:	45 82       	std	Z+5, r4	; 0x05
    32ca:	f7 01       	movw	r30, r14
    32cc:	55 82       	std	Z+5, r5	; 0x05
    32ce:	60 92 b2 24 	sts	0x24B2, r6
    32d2:	70 92 b3 24 	sts	0x24B3, r7
    32d6:	c9 cf       	rjmp	.-110    	; 0x326a <button+0x48>

000032d8 <Touch>:
    32d8:	01 e0       	ldi	r16, 0x01	; 1
    32da:	c0 ee       	ldi	r28, 0xE0	; 224
    32dc:	d7 e0       	ldi	r29, 0x07	; 7
    32de:	12 e0       	ldi	r17, 0x02	; 2
    32e0:	0e 94 27 0b 	call	0x164e	; 0x164e <tb_is_touched>
    32e4:	80 27       	eor	r24, r16
    32e6:	80 93 b4 24 	sts	0x24B4, r24
    32ea:	82 e3       	ldi	r24, 0x32	; 50
    32ec:	90 e0       	ldi	r25, 0x00	; 0
    32ee:	3b de       	rcall	.-906    	; 0x2f66 <vTaskDelay>
    32f0:	80 91 b4 24 	lds	r24, 0x24B4
    32f4:	88 23       	and	r24, r24
    32f6:	11 f0       	breq	.+4      	; 0x32fc <Touch+0x24>
    32f8:	1e 83       	std	Y+6, r17	; 0x06
    32fa:	f2 cf       	rjmp	.-28     	; 0x32e0 <Touch+0x8>
    32fc:	1d 83       	std	Y+5, r17	; 0x05
    32fe:	f0 cf       	rjmp	.-32     	; 0x32e0 <Touch+0x8>

00003300 <menuNav>:
    3300:	bb 24       	eor	r11, r11
    3302:	b3 94       	inc	r11
    3304:	0f 2e       	mov	r0, r31
    3306:	f4 e1       	ldi	r31, 0x14	; 20
    3308:	af 2e       	mov	r10, r31
    330a:	f0 2d       	mov	r31, r0
    330c:	0f 2e       	mov	r0, r31
    330e:	f5 e1       	ldi	r31, 0x15	; 21
    3310:	9f 2e       	mov	r9, r31
    3312:	f0 2d       	mov	r31, r0
    3314:	02 e0       	ldi	r16, 0x02	; 2
    3316:	10 e0       	ldi	r17, 0x00	; 0
    3318:	68 94       	set
    331a:	cc 24       	eor	r12, r12
    331c:	c2 f8       	bld	r12, 2
    331e:	d1 2c       	mov	r13, r1
    3320:	0f 2e       	mov	r0, r31
    3322:	f3 e0       	ldi	r31, 0x03	; 3
    3324:	ef 2e       	mov	r14, r31
    3326:	f1 2c       	mov	r15, r1
    3328:	f0 2d       	mov	r31, r0
    332a:	c1 e0       	ldi	r28, 0x01	; 1
    332c:	d0 e0       	ldi	r29, 0x00	; 0
    332e:	82 e3       	ldi	r24, 0x32	; 50
    3330:	90 e0       	ldi	r25, 0x00	; 0
    3332:	19 de       	rcall	.-974    	; 0x2f66 <vTaskDelay>
    3334:	80 91 1c 20 	lds	r24, 0x201C
    3338:	90 91 1d 20 	lds	r25, 0x201D
    333c:	00 97       	sbiw	r24, 0x00	; 0
    333e:	89 f5       	brne	.+98     	; 0x33a2 <menuNav+0xa2>
    3340:	80 91 b2 24 	lds	r24, 0x24B2
    3344:	90 91 b3 24 	lds	r25, 0x24B3
    3348:	89 2b       	or	r24, r25
    334a:	39 f4       	brne	.+14     	; 0x335a <menuNav+0x5a>
    334c:	c0 93 1c 20 	sts	0x201C, r28
    3350:	d0 93 1d 20 	sts	0x201D, r29
    3354:	b0 92 17 20 	sts	0x2017, r11
    3358:	19 c0       	rjmp	.+50     	; 0x338c <menuNav+0x8c>
    335a:	80 91 b2 24 	lds	r24, 0x24B2
    335e:	90 91 b3 24 	lds	r25, 0x24B3
    3362:	01 97       	sbiw	r24, 0x01	; 1
    3364:	39 f4       	brne	.+14     	; 0x3374 <menuNav+0x74>
    3366:	e0 92 1c 20 	sts	0x201C, r14
    336a:	f0 92 1d 20 	sts	0x201D, r15
    336e:	b0 92 17 20 	sts	0x2017, r11
    3372:	0c c0       	rjmp	.+24     	; 0x338c <menuNav+0x8c>
    3374:	80 91 b2 24 	lds	r24, 0x24B2
    3378:	90 91 b3 24 	lds	r25, 0x24B3
    337c:	02 97       	sbiw	r24, 0x02	; 2
    337e:	31 f4       	brne	.+12     	; 0x338c <menuNav+0x8c>
    3380:	c0 92 1c 20 	sts	0x201C, r12
    3384:	d0 92 1d 20 	sts	0x201D, r13
    3388:	b0 92 17 20 	sts	0x2017, r11
    338c:	80 91 b4 24 	lds	r24, 0x24B4
    3390:	88 23       	and	r24, r24
    3392:	69 f2       	breq	.-102    	; 0x332e <menuNav+0x2e>
    3394:	00 93 1c 20 	sts	0x201C, r16
    3398:	10 93 1d 20 	sts	0x201D, r17
    339c:	b0 92 17 20 	sts	0x2017, r11
    33a0:	c6 cf       	rjmp	.-116    	; 0x332e <menuNav+0x2e>
    33a2:	81 30       	cpi	r24, 0x01	; 1
    33a4:	91 05       	cpc	r25, r1
    33a6:	09 f0       	breq	.+2      	; 0x33aa <menuNav+0xaa>
    33a8:	3f c0       	rjmp	.+126    	; 0x3428 <menuNav+0x128>
    33aa:	80 91 b2 24 	lds	r24, 0x24B2
    33ae:	90 91 b3 24 	lds	r25, 0x24B3
    33b2:	89 2b       	or	r24, r25
    33b4:	39 f4       	brne	.+14     	; 0x33c4 <menuNav+0xc4>
    33b6:	10 92 1c 20 	sts	0x201C, r1
    33ba:	10 92 1d 20 	sts	0x201D, r1
    33be:	b0 92 17 20 	sts	0x2017, r11
    33c2:	2f c0       	rjmp	.+94     	; 0x3422 <menuNav+0x122>
    33c4:	80 91 b2 24 	lds	r24, 0x24B2
    33c8:	90 91 b3 24 	lds	r25, 0x24B3
    33cc:	01 97       	sbiw	r24, 0x01	; 1
    33ce:	51 f4       	brne	.+20     	; 0x33e4 <menuNav+0xe4>
    33d0:	e3 e2       	ldi	r30, 0x23	; 35
    33d2:	f0 e2       	ldi	r31, 0x20	; 32
    33d4:	a8 e5       	ldi	r26, 0x58	; 88
    33d6:	b4 e2       	ldi	r27, 0x24	; 36
    33d8:	8a 2d       	mov	r24, r10
    33da:	01 90       	ld	r0, Z+
    33dc:	0d 92       	st	X+, r0
    33de:	8a 95       	dec	r24
    33e0:	e1 f7       	brne	.-8      	; 0x33da <menuNav+0xda>
    33e2:	1f c0       	rjmp	.+62     	; 0x3422 <menuNav+0x122>
    33e4:	80 91 b2 24 	lds	r24, 0x24B2
    33e8:	90 91 b3 24 	lds	r25, 0x24B3
    33ec:	02 97       	sbiw	r24, 0x02	; 2
    33ee:	51 f4       	brne	.+20     	; 0x3404 <menuNav+0x104>
    33f0:	e7 e3       	ldi	r30, 0x37	; 55
    33f2:	f0 e2       	ldi	r31, 0x20	; 32
    33f4:	a8 e5       	ldi	r26, 0x58	; 88
    33f6:	b4 e2       	ldi	r27, 0x24	; 36
    33f8:	89 2d       	mov	r24, r9
    33fa:	01 90       	ld	r0, Z+
    33fc:	0d 92       	st	X+, r0
    33fe:	8a 95       	dec	r24
    3400:	e1 f7       	brne	.-8      	; 0x33fa <menuNav+0xfa>
    3402:	0f c0       	rjmp	.+30     	; 0x3422 <menuNav+0x122>
    3404:	80 91 b2 24 	lds	r24, 0x24B2
    3408:	90 91 b3 24 	lds	r25, 0x24B3
    340c:	03 97       	sbiw	r24, 0x03	; 3
    340e:	49 f4       	brne	.+18     	; 0x3422 <menuNav+0x122>
    3410:	ec e4       	ldi	r30, 0x4C	; 76
    3412:	f0 e2       	ldi	r31, 0x20	; 32
    3414:	a8 e5       	ldi	r26, 0x58	; 88
    3416:	b4 e2       	ldi	r27, 0x24	; 36
    3418:	8a 2d       	mov	r24, r10
    341a:	01 90       	ld	r0, Z+
    341c:	0d 92       	st	X+, r0
    341e:	8a 95       	dec	r24
    3420:	e1 f7       	brne	.-8      	; 0x341a <menuNav+0x11a>
    3422:	80 91 b4 24 	lds	r24, 0x24B4
    3426:	83 cf       	rjmp	.-250    	; 0x332e <menuNav+0x2e>
    3428:	82 30       	cpi	r24, 0x02	; 2
    342a:	91 05       	cpc	r25, r1
    342c:	d1 f4       	brne	.+52     	; 0x3462 <menuNav+0x162>
    342e:	80 91 b2 24 	lds	r24, 0x24B2
    3432:	90 91 b3 24 	lds	r25, 0x24B3
    3436:	89 2b       	or	r24, r25
    3438:	39 f4       	brne	.+14     	; 0x3448 <menuNav+0x148>
    343a:	10 92 1c 20 	sts	0x201C, r1
    343e:	10 92 1d 20 	sts	0x201D, r1
    3442:	b0 92 17 20 	sts	0x2017, r11
    3446:	0a c0       	rjmp	.+20     	; 0x345c <menuNav+0x15c>
    3448:	80 91 b2 24 	lds	r24, 0x24B2
    344c:	90 91 b3 24 	lds	r25, 0x24B3
    3450:	01 97       	sbiw	r24, 0x01	; 1
    3452:	21 f0       	breq	.+8      	; 0x345c <menuNav+0x15c>
    3454:	80 91 b2 24 	lds	r24, 0x24B2
    3458:	90 91 b3 24 	lds	r25, 0x24B3
    345c:	80 91 b4 24 	lds	r24, 0x24B4
    3460:	66 cf       	rjmp	.-308    	; 0x332e <menuNav+0x2e>
    3462:	83 30       	cpi	r24, 0x03	; 3
    3464:	91 05       	cpc	r25, r1
    3466:	09 f0       	breq	.+2      	; 0x346a <menuNav+0x16a>
    3468:	45 c0       	rjmp	.+138    	; 0x34f4 <menuNav+0x1f4>
    346a:	80 91 e9 23 	lds	r24, 0x23E9
    346e:	90 91 ea 23 	lds	r25, 0x23EA
    3472:	fc 01       	movw	r30, r24
    3474:	e7 50       	subi	r30, 0x07	; 7
    3476:	fc 4d       	sbci	r31, 0xDC	; 220
    3478:	40 81       	ld	r20, Z
    347a:	20 91 b2 24 	lds	r18, 0x24B2
    347e:	30 91 b3 24 	lds	r19, 0x24B3
    3482:	23 2b       	or	r18, r19
    3484:	39 f4       	brne	.+14     	; 0x3494 <menuNav+0x194>
    3486:	10 92 1c 20 	sts	0x201C, r1
    348a:	10 92 1d 20 	sts	0x201D, r1
    348e:	b0 92 17 20 	sts	0x2017, r11
    3492:	19 c0       	rjmp	.+50     	; 0x34c6 <menuNav+0x1c6>
    3494:	20 91 b2 24 	lds	r18, 0x24B2
    3498:	30 91 b3 24 	lds	r19, 0x24B3
    349c:	21 30       	cpi	r18, 0x01	; 1
    349e:	31 05       	cpc	r19, r1
    34a0:	31 f4       	brne	.+12     	; 0x34ae <menuNav+0x1ae>
    34a2:	01 97       	sbiw	r24, 0x01	; 1
    34a4:	80 93 e9 23 	sts	0x23E9, r24
    34a8:	90 93 ea 23 	sts	0x23EA, r25
    34ac:	0c c0       	rjmp	.+24     	; 0x34c6 <menuNav+0x1c6>
    34ae:	20 91 b2 24 	lds	r18, 0x24B2
    34b2:	30 91 b3 24 	lds	r19, 0x24B3
    34b6:	22 30       	cpi	r18, 0x02	; 2
    34b8:	31 05       	cpc	r19, r1
    34ba:	29 f4       	brne	.+10     	; 0x34c6 <menuNav+0x1c6>
    34bc:	01 96       	adiw	r24, 0x01	; 1
    34be:	80 93 e9 23 	sts	0x23E9, r24
    34c2:	90 93 ea 23 	sts	0x23EA, r25
    34c6:	80 91 b4 24 	lds	r24, 0x24B4
    34ca:	88 23       	and	r24, r24
    34cc:	09 f4       	brne	.+2      	; 0x34d0 <menuNav+0x1d0>
    34ce:	2f cf       	rjmp	.-418    	; 0x332e <menuNav+0x2e>
    34d0:	44 23       	and	r20, r20
    34d2:	41 f0       	breq	.+16     	; 0x34e4 <menuNav+0x1e4>
    34d4:	e0 91 e9 23 	lds	r30, 0x23E9
    34d8:	f0 91 ea 23 	lds	r31, 0x23EA
    34dc:	e7 50       	subi	r30, 0x07	; 7
    34de:	fc 4d       	sbci	r31, 0xDC	; 220
    34e0:	10 82       	st	Z, r1
    34e2:	25 cf       	rjmp	.-438    	; 0x332e <menuNav+0x2e>
    34e4:	e0 91 e9 23 	lds	r30, 0x23E9
    34e8:	f0 91 ea 23 	lds	r31, 0x23EA
    34ec:	e7 50       	subi	r30, 0x07	; 7
    34ee:	fc 4d       	sbci	r31, 0xDC	; 220
    34f0:	b0 82       	st	Z, r11
    34f2:	1d cf       	rjmp	.-454    	; 0x332e <menuNav+0x2e>
    34f4:	04 97       	sbiw	r24, 0x04	; 4
    34f6:	09 f0       	breq	.+2      	; 0x34fa <menuNav+0x1fa>
    34f8:	1a cf       	rjmp	.-460    	; 0x332e <menuNav+0x2e>
    34fa:	80 91 b2 24 	lds	r24, 0x24B2
    34fe:	90 91 b3 24 	lds	r25, 0x24B3
    3502:	89 2b       	or	r24, r25
    3504:	39 f4       	brne	.+14     	; 0x3514 <menuNav+0x214>
    3506:	10 92 1c 20 	sts	0x201C, r1
    350a:	10 92 1d 20 	sts	0x201D, r1
    350e:	b0 92 17 20 	sts	0x2017, r11
    3512:	0a c0       	rjmp	.+20     	; 0x3528 <menuNav+0x228>
    3514:	80 91 b2 24 	lds	r24, 0x24B2
    3518:	90 91 b3 24 	lds	r25, 0x24B3
    351c:	01 97       	sbiw	r24, 0x01	; 1
    351e:	21 f0       	breq	.+8      	; 0x3528 <menuNav+0x228>
    3520:	80 91 b2 24 	lds	r24, 0x24B2
    3524:	90 91 b3 24 	lds	r25, 0x24B3
    3528:	80 91 b4 24 	lds	r24, 0x24B4
    352c:	00 cf       	rjmp	.-512    	; 0x332e <menuNav+0x2e>

0000352e <sendString>:
    352e:	cf 93       	push	r28
    3530:	df 93       	push	r29
    3532:	21 e0       	ldi	r18, 0x01	; 1
    3534:	20 93 ec 23 	sts	0x23EC, r18
    3538:	fc 01       	movw	r30, r24
    353a:	60 81       	ld	r22, Z
    353c:	66 23       	and	r22, r22
    353e:	49 f0       	breq	.+18     	; 0x3552 <sendString+0x24>
    3540:	ec 01       	movw	r28, r24
    3542:	21 96       	adiw	r28, 0x01	; 1
    3544:	80 ea       	ldi	r24, 0xA0	; 160
    3546:	98 e0       	ldi	r25, 0x08	; 8
    3548:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <usart_putchar>
    354c:	69 91       	ld	r22, Y+
    354e:	61 11       	cpse	r22, r1
    3550:	f9 cf       	rjmp	.-14     	; 0x3544 <sendString+0x16>
    3552:	10 92 ec 23 	sts	0x23EC, r1
    3556:	df 91       	pop	r29
    3558:	cf 91       	pop	r28
    355a:	08 95       	ret

0000355c <commGate_OUT>:
    355c:	80 e0       	ldi	r24, 0x00	; 0
    355e:	90 e0       	ldi	r25, 0x00	; 0
    3560:	02 dd       	rcall	.-1532   	; 0x2f66 <vTaskDelay>
    3562:	88 e5       	ldi	r24, 0x58	; 88
    3564:	94 e2       	ldi	r25, 0x24	; 36
    3566:	e3 df       	rcall	.-58     	; 0x352e <sendString>
    3568:	f9 cf       	rjmp	.-14     	; 0x355c <commGate_OUT>

0000356a <receiveString>:
    356a:	cf 93       	push	r28
    356c:	df 93       	push	r29
    356e:	c6 e2       	ldi	r28, 0x26	; 38
    3570:	d4 e2       	ldi	r29, 0x24	; 36
    3572:	80 ea       	ldi	r24, 0xA0	; 160
    3574:	98 e0       	ldi	r25, 0x08	; 8
    3576:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <usart_getchar>
    357a:	8a 30       	cpi	r24, 0x0A	; 10
    357c:	11 f0       	breq	.+4      	; 0x3582 <receiveString+0x18>
    357e:	89 93       	st	Y+, r24
    3580:	f8 cf       	rjmp	.-16     	; 0x3572 <receiveString+0x8>
    3582:	df 91       	pop	r29
    3584:	cf 91       	pop	r28
    3586:	08 95       	ret

00003588 <commGate_IN>:
    3588:	80 e0       	ldi	r24, 0x00	; 0
    358a:	90 e0       	ldi	r25, 0x00	; 0
    358c:	ec dc       	rcall	.-1576   	; 0x2f66 <vTaskDelay>
    358e:	ed df       	rcall	.-38     	; 0x356a <receiveString>
    3590:	fb cf       	rjmp	.-10     	; 0x3588 <commGate_IN>

00003592 <initMenu>:
}

void initMenu(void){
    3592:	9f 92       	push	r9
    3594:	af 92       	push	r10
    3596:	bf 92       	push	r11
    3598:	cf 92       	push	r12
    359a:	df 92       	push	r13
    359c:	ef 92       	push	r14
    359e:	ff 92       	push	r15
    35a0:	0f 93       	push	r16
    35a2:	1f 93       	push	r17
    35a4:	cf 93       	push	r28
    35a6:	df 93       	push	r29
	
	int nn;
	for(nn=0; nn<=maxFeature; nn++){
    35a8:	80 91 1a 20 	lds	r24, 0x201A
    35ac:	90 91 1b 20 	lds	r25, 0x201B
    35b0:	99 23       	and	r25, r25
    35b2:	bc f1       	brlt	.+110    	; 0x3622 <initMenu+0x90>
    35b4:	0f 2e       	mov	r0, r31
    35b6:	f8 e0       	ldi	r31, 0x08	; 8
    35b8:	af 2e       	mov	r10, r31
    35ba:	f4 e2       	ldi	r31, 0x24	; 36
    35bc:	bf 2e       	mov	r11, r31
    35be:	f0 2d       	mov	r31, r0
    35c0:	0f 2e       	mov	r0, r31
    35c2:	f9 ef       	ldi	r31, 0xF9	; 249
    35c4:	cf 2e       	mov	r12, r31
    35c6:	f3 e2       	ldi	r31, 0x23	; 35
    35c8:	df 2e       	mov	r13, r31
    35ca:	f0 2d       	mov	r31, r0
    35cc:	c0 e0       	ldi	r28, 0x00	; 0
    35ce:	d0 e0       	ldi	r29, 0x00	; 0
		//inisialisasi fitur, awalnya empty
		snprintf(strbuf_in, sizeof(strbuf_in),"empty", nn);
    35d0:	0f 2e       	mov	r0, r31
    35d2:	f0 e6       	ldi	r31, 0x60	; 96
    35d4:	ef 2e       	mov	r14, r31
    35d6:	f0 e2       	ldi	r31, 0x20	; 32
    35d8:	ff 2e       	mov	r15, r31
    35da:	f0 2d       	mov	r31, r0
    35dc:	0f 2e       	mov	r0, r31
    35de:	f4 e1       	ldi	r31, 0x14	; 20
    35e0:	9f 2e       	mov	r9, r31
    35e2:	f0 2d       	mov	r31, r0
    35e4:	0a e8       	ldi	r16, 0x8A	; 138
    35e6:	14 e2       	ldi	r17, 0x24	; 36
    35e8:	df 93       	push	r29
    35ea:	cf 93       	push	r28
    35ec:	ff 92       	push	r15
    35ee:	ef 92       	push	r14
    35f0:	1f 92       	push	r1
    35f2:	9f 92       	push	r9
    35f4:	1f 93       	push	r17
    35f6:	0f 93       	push	r16
    35f8:	3d d3       	rcall	.+1658   	; 0x3c74 <snprintf>
		featureList[nn] = strbuf_in;
    35fa:	f5 01       	movw	r30, r10
    35fc:	01 93       	st	Z+, r16
    35fe:	11 93       	st	Z+, r17
    3600:	5f 01       	movw	r10, r30
		featureStat[nn] = false;
    3602:	f6 01       	movw	r30, r12
    3604:	11 92       	st	Z+, r1
    3606:	6f 01       	movw	r12, r30
}

void initMenu(void){
	
	int nn;
	for(nn=0; nn<=maxFeature; nn++){
    3608:	21 96       	adiw	r28, 0x01	; 1
    360a:	8d b7       	in	r24, 0x3d	; 61
    360c:	9e b7       	in	r25, 0x3e	; 62
    360e:	08 96       	adiw	r24, 0x08	; 8
    3610:	8d bf       	out	0x3d, r24	; 61
    3612:	9e bf       	out	0x3e, r25	; 62
    3614:	80 91 1a 20 	lds	r24, 0x201A
    3618:	90 91 1b 20 	lds	r25, 0x201B
    361c:	8c 17       	cp	r24, r28
    361e:	9d 07       	cpc	r25, r29
    3620:	1c f7       	brge	.-58     	; 0x35e8 <initMenu+0x56>
		//inisialisasi fitur, awalnya empty
		snprintf(strbuf_in, sizeof(strbuf_in),"empty", nn);
		featureList[nn] = strbuf_in;
		featureStat[nn] = false;
	}
	for(nn=0; nn<=maxStatus; nn++){
    3622:	20 91 18 20 	lds	r18, 0x2018
    3626:	30 91 19 20 	lds	r19, 0x2019
    362a:	33 23       	and	r19, r19
    362c:	64 f0       	brlt	.+24     	; 0x3646 <initMenu+0xb4>
    362e:	ed ee       	ldi	r30, 0xED	; 237
    3630:	f3 e2       	ldi	r31, 0x23	; 35
    3632:	80 e0       	ldi	r24, 0x00	; 0
    3634:	90 e0       	ldi	r25, 0x00	; 0
		statusList[nn]="...";
    3636:	46 e6       	ldi	r20, 0x66	; 102
    3638:	50 e2       	ldi	r21, 0x20	; 32
    363a:	41 93       	st	Z+, r20
    363c:	51 93       	st	Z+, r21
		//inisialisasi fitur, awalnya empty
		snprintf(strbuf_in, sizeof(strbuf_in),"empty", nn);
		featureList[nn] = strbuf_in;
		featureStat[nn] = false;
	}
	for(nn=0; nn<=maxStatus; nn++){
    363e:	01 96       	adiw	r24, 0x01	; 1
    3640:	28 17       	cp	r18, r24
    3642:	39 07       	cpc	r19, r25
    3644:	d4 f7       	brge	.-12     	; 0x363a <initMenu+0xa8>
		statusList[nn]="...";
	}
}
    3646:	df 91       	pop	r29
    3648:	cf 91       	pop	r28
    364a:	1f 91       	pop	r17
    364c:	0f 91       	pop	r16
    364e:	ff 90       	pop	r15
    3650:	ef 90       	pop	r14
    3652:	df 90       	pop	r13
    3654:	cf 90       	pop	r12
    3656:	bf 90       	pop	r11
    3658:	af 90       	pop	r10
    365a:	9f 90       	pop	r9
    365c:	08 95       	ret

0000365e <printLCD>:
    365e:	80 e1       	ldi	r24, 0x10	; 16
    3660:	e0 e8       	ldi	r30, 0x80	; 128
    3662:	f6 e0       	ldi	r31, 0x06	; 6
    3664:	85 83       	std	Z+5, r24	; 0x05
	vTaskStartScheduler();
}

static portTASK_FUNCTION(printLCD, p_){
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	initMenu();
    3666:	95 df       	rcall	.-214    	; 0x3592 <initMenu>
			if(feature_selected<0) feature_selected=maxFeature;
			else if (feature_selected>maxFeature) feature_selected=0;
			
			gfx_mono_draw_string("==  Features Menu  ==",0,0,&sysfont);
			
			snprintf(strbuf_menu, sizeof(strbuf_menu), "Feature No.%2d", feature_selected+1);
    3668:	0f 2e       	mov	r0, r31
    366a:	f4 e0       	ldi	r31, 0x04	; 4
    366c:	ef 2e       	mov	r14, r31
    366e:	f1 e2       	ldi	r31, 0x21	; 33
    3670:	ff 2e       	mov	r15, r31
    3672:	f0 2d       	mov	r31, r0
    3674:	14 e1       	ldi	r17, 0x14	; 20
    3676:	ce e9       	ldi	r28, 0x9E	; 158
    3678:	d4 e2       	ldi	r29, 0x24	; 36
static portTASK_FUNCTION(printLCD, p_){
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	initMenu();
	while(1){
		
		if(switchDisp){
    367a:	80 91 17 20 	lds	r24, 0x2017
    367e:	88 23       	and	r24, r24
    3680:	89 f0       	breq	.+34     	; 0x36a4 <printLCD+0x46>
			portENTER_CRITICAL();
    3682:	0f b6       	in	r0, 0x3f	; 63
    3684:	f8 94       	cli
    3686:	0f 92       	push	r0
			gfx_mono_generic_draw_filled_rect(0,0,128,32,GFX_PIXEL_CLR);
    3688:	00 e0       	ldi	r16, 0x00	; 0
    368a:	20 e2       	ldi	r18, 0x20	; 32
    368c:	40 e8       	ldi	r20, 0x80	; 128
    368e:	60 e0       	ldi	r22, 0x00	; 0
    3690:	80 e0       	ldi	r24, 0x00	; 0
    3692:	0e 94 39 12 	call	0x2472	; 0x2472 <gfx_mono_generic_draw_filled_rect>
			vTaskDelay(200/portTICK_PERIOD_MS);
    3696:	84 e6       	ldi	r24, 0x64	; 100
    3698:	90 e0       	ldi	r25, 0x00	; 0
    369a:	65 dc       	rcall	.-1846   	; 0x2f66 <vTaskDelay>
			portEXIT_CRITICAL();
    369c:	0f 90       	pop	r0
    369e:	0f be       	out	0x3f, r0	; 63
			switchDisp = false;
    36a0:	10 92 17 20 	sts	0x2017, r1
		}
		
		//main menu
		if(menuSelected==0){
    36a4:	20 91 1c 20 	lds	r18, 0x201C
    36a8:	30 91 1d 20 	lds	r19, 0x201D
    36ac:	21 15       	cp	r18, r1
    36ae:	31 05       	cpc	r19, r1
    36b0:	09 f5       	brne	.+66     	; 0x36f4 <printLCD+0x96>
			
			//snprintf(strbuf_menu, sizeof(strbuf_menu), "Menu %d", menuSelected);
			//gfx_mono_draw_string(strbuf_menu,0, 0, &sysfont);
			gfx_mono_draw_string("==GH Control Center==",0,0,&sysfont);
    36b2:	27 e0       	ldi	r18, 0x07	; 7
    36b4:	30 e2       	ldi	r19, 0x20	; 32
    36b6:	40 e0       	ldi	r20, 0x00	; 0
    36b8:	60 e0       	ldi	r22, 0x00	; 0
    36ba:	8a e6       	ldi	r24, 0x6A	; 106
    36bc:	90 e2       	ldi	r25, 0x20	; 32
    36be:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
			gfx_mono_draw_string("---------------------",0,(SYSFONT_HEIGHT*1)+1,&sysfont);
    36c2:	27 e0       	ldi	r18, 0x07	; 7
    36c4:	30 e2       	ldi	r19, 0x20	; 32
    36c6:	48 e0       	ldi	r20, 0x08	; 8
    36c8:	60 e0       	ldi	r22, 0x00	; 0
    36ca:	80 e8       	ldi	r24, 0x80	; 128
    36cc:	90 e2       	ldi	r25, 0x20	; 32
    36ce:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
			gfx_mono_draw_string("Ping         Features",0,(SYSFONT_HEIGHT*2)+1,&sysfont);
    36d2:	27 e0       	ldi	r18, 0x07	; 7
    36d4:	30 e2       	ldi	r19, 0x20	; 32
    36d6:	4f e0       	ldi	r20, 0x0F	; 15
    36d8:	60 e0       	ldi	r22, 0x00	; 0
    36da:	86 e9       	ldi	r24, 0x96	; 150
    36dc:	90 e2       	ldi	r25, 0x20	; 32
    36de:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
			gfx_mono_draw_string("PingBrst    StatsDisp",0,(SYSFONT_HEIGHT*3)+2,&sysfont);	
    36e2:	27 e0       	ldi	r18, 0x07	; 7
    36e4:	30 e2       	ldi	r19, 0x20	; 32
    36e6:	47 e1       	ldi	r20, 0x17	; 23
    36e8:	60 e0       	ldi	r22, 0x00	; 0
    36ea:	8c ea       	ldi	r24, 0xAC	; 172
    36ec:	90 e2       	ldi	r25, 0x20	; 32
    36ee:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
    36f2:	c2 c0       	rjmp	.+388    	; 0x3878 <printLCD+0x21a>
		}
		//ping
		else if(menuSelected==1){
    36f4:	21 30       	cpi	r18, 0x01	; 1
    36f6:	31 05       	cpc	r19, r1
    36f8:	c9 f4       	brne	.+50     	; 0x372c <printLCD+0xce>
			gfx_mono_draw_string("==    Ping Menu    ==",0,0,&sysfont);
    36fa:	27 e0       	ldi	r18, 0x07	; 7
    36fc:	30 e2       	ldi	r19, 0x20	; 32
    36fe:	40 e0       	ldi	r20, 0x00	; 0
    3700:	60 e0       	ldi	r22, 0x00	; 0
    3702:	82 ec       	ldi	r24, 0xC2	; 194
    3704:	90 e2       	ldi	r25, 0x20	; 32
    3706:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
			//if(still==still) gfx_mono_draw_string("still",0,(SYSFONT_HEIGHT*1)+1,&sysfont);
			gfx_mono_draw_string(strbuf_read,0,(SYSFONT_HEIGHT*1)+1,&sysfont);
    370a:	27 e0       	ldi	r18, 0x07	; 7
    370c:	30 e2       	ldi	r19, 0x20	; 32
    370e:	48 e0       	ldi	r20, 0x08	; 8
    3710:	60 e0       	ldi	r22, 0x00	; 0
    3712:	86 e2       	ldi	r24, 0x26	; 38
    3714:	94 e2       	ldi	r25, 0x24	; 36
    3716:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
			gfx_mono_draw_string(strbuf_send,0,(SYSFONT_HEIGHT*2)+1,&sysfont);
    371a:	27 e0       	ldi	r18, 0x07	; 7
    371c:	30 e2       	ldi	r19, 0x20	; 32
    371e:	4f e0       	ldi	r20, 0x0F	; 15
    3720:	60 e0       	ldi	r22, 0x00	; 0
    3722:	88 e5       	ldi	r24, 0x58	; 88
    3724:	94 e2       	ldi	r25, 0x24	; 36
    3726:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
    372a:	a6 c0       	rjmp	.+332    	; 0x3878 <printLCD+0x21a>
		}
		//ping burst
		else if(menuSelected==2){
    372c:	22 30       	cpi	r18, 0x02	; 2
    372e:	31 05       	cpc	r19, r1
    3730:	49 f4       	brne	.+18     	; 0x3744 <printLCD+0xe6>
			gfx_mono_draw_string("==  PingBrst Menu  ==",0,0,&sysfont);
    3732:	27 e0       	ldi	r18, 0x07	; 7
    3734:	30 e2       	ldi	r19, 0x20	; 32
    3736:	40 e0       	ldi	r20, 0x00	; 0
    3738:	60 e0       	ldi	r22, 0x00	; 0
    373a:	88 ed       	ldi	r24, 0xD8	; 216
    373c:	90 e2       	ldi	r25, 0x20	; 32
    373e:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
    3742:	9a c0       	rjmp	.+308    	; 0x3878 <printLCD+0x21a>
		}
		//features
		else if(menuSelected==3){
    3744:	23 30       	cpi	r18, 0x03	; 3
    3746:	31 05       	cpc	r19, r1
    3748:	09 f0       	breq	.+2      	; 0x374c <printLCD+0xee>
    374a:	6d c0       	rjmp	.+218    	; 0x3826 <printLCD+0x1c8>
			
			if(feature_selected<0) feature_selected=maxFeature;
    374c:	80 91 e9 23 	lds	r24, 0x23E9
    3750:	90 91 ea 23 	lds	r25, 0x23EA
    3754:	99 23       	and	r25, r25
    3756:	4c f4       	brge	.+18     	; 0x376a <printLCD+0x10c>
    3758:	80 91 1a 20 	lds	r24, 0x201A
    375c:	90 91 1b 20 	lds	r25, 0x201B
    3760:	80 93 e9 23 	sts	0x23E9, r24
    3764:	90 93 ea 23 	sts	0x23EA, r25
    3768:	0b c0       	rjmp	.+22     	; 0x3780 <printLCD+0x122>
			else if (feature_selected>maxFeature) feature_selected=0;
    376a:	20 91 1a 20 	lds	r18, 0x201A
    376e:	30 91 1b 20 	lds	r19, 0x201B
    3772:	28 17       	cp	r18, r24
    3774:	39 07       	cpc	r19, r25
    3776:	24 f4       	brge	.+8      	; 0x3780 <printLCD+0x122>
    3778:	10 92 e9 23 	sts	0x23E9, r1
    377c:	10 92 ea 23 	sts	0x23EA, r1
			
			gfx_mono_draw_string("==  Features Menu  ==",0,0,&sysfont);
    3780:	27 e0       	ldi	r18, 0x07	; 7
    3782:	30 e2       	ldi	r19, 0x20	; 32
    3784:	40 e0       	ldi	r20, 0x00	; 0
    3786:	60 e0       	ldi	r22, 0x00	; 0
    3788:	8e ee       	ldi	r24, 0xEE	; 238
    378a:	90 e2       	ldi	r25, 0x20	; 32
    378c:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
			
			snprintf(strbuf_menu, sizeof(strbuf_menu), "Feature No.%2d", feature_selected+1);
    3790:	80 91 e9 23 	lds	r24, 0x23E9
    3794:	90 91 ea 23 	lds	r25, 0x23EA
    3798:	01 96       	adiw	r24, 0x01	; 1
    379a:	9f 93       	push	r25
    379c:	8f 93       	push	r24
    379e:	ff 92       	push	r15
    37a0:	ef 92       	push	r14
    37a2:	1f 92       	push	r1
    37a4:	1f 93       	push	r17
    37a6:	df 93       	push	r29
    37a8:	cf 93       	push	r28
    37aa:	64 d2       	rcall	.+1224   	; 0x3c74 <snprintf>
			gfx_mono_draw_string(strbuf_menu,0, (SYSFONT_HEIGHT)+1, &sysfont);
    37ac:	27 e0       	ldi	r18, 0x07	; 7
    37ae:	30 e2       	ldi	r19, 0x20	; 32
    37b0:	48 e0       	ldi	r20, 0x08	; 8
    37b2:	60 e0       	ldi	r22, 0x00	; 0
    37b4:	ce 01       	movw	r24, r28
    37b6:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
			gfx_mono_draw_string(featureList[feature_selected],0, (SYSFONT_HEIGHT*2)+1, &sysfont);
    37ba:	e0 91 e9 23 	lds	r30, 0x23E9
    37be:	f0 91 ea 23 	lds	r31, 0x23EA
    37c2:	ee 0f       	add	r30, r30
    37c4:	ff 1f       	adc	r31, r31
    37c6:	e8 5f       	subi	r30, 0xF8	; 248
    37c8:	fb 4d       	sbci	r31, 0xDB	; 219
    37ca:	27 e0       	ldi	r18, 0x07	; 7
    37cc:	30 e2       	ldi	r19, 0x20	; 32
    37ce:	4f e0       	ldi	r20, 0x0F	; 15
    37d0:	60 e0       	ldi	r22, 0x00	; 0
    37d2:	80 81       	ld	r24, Z
    37d4:	91 81       	ldd	r25, Z+1	; 0x01
    37d6:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
			gfx_mono_draw_string("   A             B   ",0, (SYSFONT_HEIGHT*3)+3, &sysfont);
    37da:	27 e0       	ldi	r18, 0x07	; 7
    37dc:	30 e2       	ldi	r19, 0x20	; 32
    37de:	48 e1       	ldi	r20, 0x18	; 24
    37e0:	60 e0       	ldi	r22, 0x00	; 0
    37e2:	83 e1       	ldi	r24, 0x13	; 19
    37e4:	91 e2       	ldi	r25, 0x21	; 33
    37e6:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
			if(!featureStat[feature_selected]){
    37ea:	e0 91 e9 23 	lds	r30, 0x23E9
    37ee:	f0 91 ea 23 	lds	r31, 0x23EA
    37f2:	e7 50       	subi	r30, 0x07	; 7
    37f4:	fc 4d       	sbci	r31, 0xDC	; 220
    37f6:	8d b7       	in	r24, 0x3d	; 61
    37f8:	9e b7       	in	r25, 0x3e	; 62
    37fa:	08 96       	adiw	r24, 0x08	; 8
    37fc:	8d bf       	out	0x3d, r24	; 61
    37fe:	9e bf       	out	0x3e, r25	; 62
    3800:	80 81       	ld	r24, Z
    3802:	81 11       	cpse	r24, r1
    3804:	08 c0       	rjmp	.+16     	; 0x3816 <printLCD+0x1b8>
				gfx_mono_generic_draw_filled_rect((SYSFONT_WIDTH*2)-1,(SYSFONT_HEIGHT*3)+2,SYSFONT_WIDTH*3,SYSFONT_HEIGHT+2,GFX_PIXEL_XOR);
    3806:	02 e0       	ldi	r16, 0x02	; 2
    3808:	29 e0       	ldi	r18, 0x09	; 9
    380a:	42 e1       	ldi	r20, 0x12	; 18
    380c:	67 e1       	ldi	r22, 0x17	; 23
    380e:	8b e0       	ldi	r24, 0x0B	; 11
    3810:	0e 94 39 12 	call	0x2472	; 0x2472 <gfx_mono_generic_draw_filled_rect>
    3814:	31 c0       	rjmp	.+98     	; 0x3878 <printLCD+0x21a>
			}else{
				gfx_mono_generic_draw_filled_rect((SYSFONT_WIDTH*16)-1,(SYSFONT_HEIGHT*3)+2,SYSFONT_WIDTH*3,SYSFONT_HEIGHT+2,GFX_PIXEL_XOR);
    3816:	02 e0       	ldi	r16, 0x02	; 2
    3818:	29 e0       	ldi	r18, 0x09	; 9
    381a:	42 e1       	ldi	r20, 0x12	; 18
    381c:	67 e1       	ldi	r22, 0x17	; 23
    381e:	8f e5       	ldi	r24, 0x5F	; 95
    3820:	0e 94 39 12 	call	0x2472	; 0x2472 <gfx_mono_generic_draw_filled_rect>
    3824:	29 c0       	rjmp	.+82     	; 0x3878 <printLCD+0x21a>
			}
		}
		//status display
		else if(menuSelected==4){
    3826:	24 30       	cpi	r18, 0x04	; 4
    3828:	31 05       	cpc	r19, r1
    382a:	31 f5       	brne	.+76     	; 0x3878 <printLCD+0x21a>
			gfx_mono_draw_string("==   SD's Status   ==",0,0,&sysfont);
    382c:	27 e0       	ldi	r18, 0x07	; 7
    382e:	30 e2       	ldi	r19, 0x20	; 32
    3830:	40 e0       	ldi	r20, 0x00	; 0
    3832:	60 e0       	ldi	r22, 0x00	; 0
    3834:	89 e2       	ldi	r24, 0x29	; 41
    3836:	91 e2       	ldi	r25, 0x21	; 33
    3838:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
			int jj;
			for(jj=0; jj<maxStatus; jj++){
    383c:	40 91 18 20 	lds	r20, 0x2018
    3840:	50 91 19 20 	lds	r21, 0x2019
    3844:	14 16       	cp	r1, r20
    3846:	15 06       	cpc	r1, r21
    3848:	3c f4       	brge	.+14     	; 0x3858 <printLCD+0x1fa>
    384a:	20 e0       	ldi	r18, 0x00	; 0
    384c:	30 e0       	ldi	r19, 0x00	; 0
    384e:	2f 5f       	subi	r18, 0xFF	; 255
    3850:	3f 4f       	sbci	r19, 0xFF	; 255
    3852:	24 17       	cp	r18, r20
    3854:	35 07       	cpc	r19, r21
    3856:	d9 f7       	brne	.-10     	; 0x384e <printLCD+0x1f0>
				
			}
			gfx_mono_draw_string(statusList[status_displayed],0, (SYSFONT_HEIGHT)+1, &sysfont);
    3858:	e0 91 e7 23 	lds	r30, 0x23E7
    385c:	f0 91 e8 23 	lds	r31, 0x23E8
    3860:	ee 0f       	add	r30, r30
    3862:	ff 1f       	adc	r31, r31
    3864:	e3 51       	subi	r30, 0x13	; 19
    3866:	fc 4d       	sbci	r31, 0xDC	; 220
    3868:	27 e0       	ldi	r18, 0x07	; 7
    386a:	30 e2       	ldi	r19, 0x20	; 32
    386c:	48 e0       	ldi	r20, 0x08	; 8
    386e:	60 e0       	ldi	r22, 0x00	; 0
    3870:	80 81       	ld	r24, Z
    3872:	91 81       	ldd	r25, Z+1	; 0x01
    3874:	0e 94 b1 12 	call	0x2562	; 0x2562 <gfx_mono_draw_string>
		//snprintf(strbuf_menu, sizeof(strbuf_menu), "%d",selected_menu);
		//gfx_mono_draw_string(strbuf_menu,0, 0, &sysfont);
		//vTaskDelay(10/portTICK_PERIOD_MS);
		//gfx_mono_generic_draw_filled_rect(0,selected_menu*10,128,32,GFX_PIXEL_XOR);
		//vTaskDelay(1000/portTICK_PERIOD_MS);
		vTaskDelay(50/portTICK_PERIOD_MS);
    3878:	89 e1       	ldi	r24, 0x19	; 25
    387a:	90 e0       	ldi	r25, 0x00	; 0
    387c:	74 db       	rcall	.-2328   	; 0x2f66 <vTaskDelay>
		//gfx_mono_generic_draw_filled_rect(111,0,8,32,GFX_PIXEL_CLR);

	}
    387e:	fd ce       	rjmp	.-518    	; 0x367a <printLCD+0x1c>

00003880 <main>:

/************************************************************************/
/* Main                                                                     */
/************************************************************************/
int main (void)
{
    3880:	af 92       	push	r10
    3882:	bf 92       	push	r11
    3884:	cf 92       	push	r12
    3886:	df 92       	push	r13
    3888:	ef 92       	push	r14
    388a:	ff 92       	push	r15
    388c:	0f 93       	push	r16
    388e:	cf 93       	push	r28
    3890:	df 93       	push	r29
	sysclk_init();
    3892:	e2 db       	rcall	.-2108   	; 0x3058 <sysclk_init>
	board_init();
    3894:	25 dc       	rcall	.-1974   	; 0x30e0 <board_init>

	gfx_mono_init();
    3896:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <gfx_mono_st7565r_init>
	tb_init();
    389a:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <tb_init>
	//adc_sensors_init();
	
	usart_init_rs232(USART_SERIAL_EXAMPLE, &USART_SERIAL_OPTIONS);
    389e:	60 e1       	ldi	r22, 0x10	; 16
    38a0:	70 e2       	ldi	r23, 0x20	; 32
    38a2:	80 ea       	ldi	r24, 0xA0	; 160
    38a4:	98 e0       	ldi	r25, 0x08	; 8
    38a6:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <usart_init_rs232>
	//usart_set_mode(USART_SERIAL_EXAMPLE,USART_CMODE_SYNCHRONOUS_gc);
	
	PORTC_OUTCLR = PIN2_bm; //PC2 as RX
    38aa:	86 e4       	ldi	r24, 0x46	; 70
    38ac:	96 e0       	ldi	r25, 0x06	; 6
    38ae:	24 e0       	ldi	r18, 0x04	; 4
    38b0:	fc 01       	movw	r30, r24
    38b2:	20 83       	st	Z, r18
	PORTC_DIRCLR = PIN2_bm; //RX pin as input
    38b4:	c2 e4       	ldi	r28, 0x42	; 66
    38b6:	d6 e0       	ldi	r29, 0x06	; 6
    38b8:	28 83       	st	Y, r18
	
	PORTC_OUTSET = PIN3_bm; //PC3 as TX
    38ba:	a5 e4       	ldi	r26, 0x45	; 69
    38bc:	b6 e0       	ldi	r27, 0x06	; 6
    38be:	28 e0       	ldi	r18, 0x08	; 8
    38c0:	2c 93       	st	X, r18
	PORTC_DIRSET = PIN3_bm; //TX pin as output
    38c2:	41 e4       	ldi	r20, 0x41	; 65
    38c4:	56 e0       	ldi	r21, 0x06	; 6
    38c6:	fa 01       	movw	r30, r20
    38c8:	20 83       	st	Z, r18
	
	PORTC_OUTCLR = PIN4_bm; //PC4 as sig-in
    38ca:	30 e1       	ldi	r19, 0x10	; 16
    38cc:	fc 01       	movw	r30, r24
    38ce:	30 83       	st	Z, r19
	PORTC_DIRCLR = PIN4_bm; //PC4 pin as input
    38d0:	38 83       	st	Y, r19
	
	PORTC_OUTSET = PIN3_bm; //PC5 as sig-out
    38d2:	2c 93       	st	X, r18
	PORTC_DIRSET = PIN3_bm; //PC5 pin as output
    38d4:	fa 01       	movw	r30, r20
    38d6:	20 83       	st	Z, r18

	//setUpSerial();
	
	xTaskCreate(printLCD,"",500,NULL,1,NULL);
    38d8:	a1 2c       	mov	r10, r1
    38da:	b1 2c       	mov	r11, r1
    38dc:	c1 2c       	mov	r12, r1
    38de:	d1 2c       	mov	r13, r1
    38e0:	e1 2c       	mov	r14, r1
    38e2:	f1 2c       	mov	r15, r1
    38e4:	01 e0       	ldi	r16, 0x01	; 1
    38e6:	20 e0       	ldi	r18, 0x00	; 0
    38e8:	30 e0       	ldi	r19, 0x00	; 0
    38ea:	44 ef       	ldi	r20, 0xF4	; 244
    38ec:	51 e0       	ldi	r21, 0x01	; 1
    38ee:	6b e4       	ldi	r22, 0x4B	; 75
    38f0:	70 e2       	ldi	r23, 0x20	; 32
    38f2:	8f e2       	ldi	r24, 0x2F	; 47
    38f4:	9b e1       	ldi	r25, 0x1B	; 27
    38f6:	ac d8       	rcall	.-3752   	; 0x2a50 <xTaskGenericCreate>
	xTaskCreate(button,"",500,NULL,1,NULL);
    38f8:	20 e0       	ldi	r18, 0x00	; 0
    38fa:	30 e0       	ldi	r19, 0x00	; 0
    38fc:	44 ef       	ldi	r20, 0xF4	; 244
    38fe:	51 e0       	ldi	r21, 0x01	; 1
    3900:	6b e4       	ldi	r22, 0x4B	; 75
    3902:	70 e2       	ldi	r23, 0x20	; 32
    3904:	81 e1       	ldi	r24, 0x11	; 17
    3906:	99 e1       	ldi	r25, 0x19	; 25
    3908:	a3 d8       	rcall	.-3770   	; 0x2a50 <xTaskGenericCreate>
	xTaskCreate(menuNav,"",500,NULL,1,NULL);
    390a:	20 e0       	ldi	r18, 0x00	; 0
    390c:	30 e0       	ldi	r19, 0x00	; 0
    390e:	44 ef       	ldi	r20, 0xF4	; 244
    3910:	51 e0       	ldi	r21, 0x01	; 1
    3912:	6b e4       	ldi	r22, 0x4B	; 75
    3914:	70 e2       	ldi	r23, 0x20	; 32
    3916:	80 e8       	ldi	r24, 0x80	; 128
    3918:	99 e1       	ldi	r25, 0x19	; 25
    391a:	9a d8       	rcall	.-3788   	; 0x2a50 <xTaskGenericCreate>
	xTaskCreate(Touch, "", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
    391c:	20 e0       	ldi	r18, 0x00	; 0
    391e:	30 e0       	ldi	r19, 0x00	; 0
    3920:	45 e5       	ldi	r20, 0x55	; 85
    3922:	50 e0       	ldi	r21, 0x00	; 0
    3924:	6b e4       	ldi	r22, 0x4B	; 75
    3926:	70 e2       	ldi	r23, 0x20	; 32
    3928:	8c e6       	ldi	r24, 0x6C	; 108
    392a:	99 e1       	ldi	r25, 0x19	; 25
    392c:	91 d8       	rcall	.-3806   	; 0x2a50 <xTaskGenericCreate>
	xTaskCreate(commGate_IN, "",500, NULL, 0, NULL);
    392e:	00 e0       	ldi	r16, 0x00	; 0
    3930:	20 e0       	ldi	r18, 0x00	; 0
    3932:	30 e0       	ldi	r19, 0x00	; 0
    3934:	44 ef       	ldi	r20, 0xF4	; 244
    3936:	51 e0       	ldi	r21, 0x01	; 1
    3938:	6b e4       	ldi	r22, 0x4B	; 75
    393a:	70 e2       	ldi	r23, 0x20	; 32
    393c:	84 ec       	ldi	r24, 0xC4	; 196
    393e:	9a e1       	ldi	r25, 0x1A	; 26
    3940:	87 d8       	rcall	.-3826   	; 0x2a50 <xTaskGenericCreate>
	xTaskCreate(commGate_OUT, "", 500, NULL, 0, NULL);
    3942:	20 e0       	ldi	r18, 0x00	; 0
    3944:	30 e0       	ldi	r19, 0x00	; 0
    3946:	44 ef       	ldi	r20, 0xF4	; 244
    3948:	51 e0       	ldi	r21, 0x01	; 1
    394a:	6b e4       	ldi	r22, 0x4B	; 75
    394c:	70 e2       	ldi	r23, 0x20	; 32
    394e:	8e ea       	ldi	r24, 0xAE	; 174
    3950:	9a e1       	ldi	r25, 0x1A	; 26
    3952:	7e d8       	rcall	.-3844   	; 0x2a50 <xTaskGenericCreate>
	xTaskCreate(commGate_SIG, "", 500, NULL, 0, NULL);
    3954:	20 e0       	ldi	r18, 0x00	; 0
    3956:	30 e0       	ldi	r19, 0x00	; 0
    3958:	44 ef       	ldi	r20, 0xF4	; 244
    395a:	51 e0       	ldi	r21, 0x01	; 1
    395c:	6b e4       	ldi	r22, 0x4B	; 75
    395e:	70 e2       	ldi	r23, 0x20	; 32
    3960:	8f eb       	ldi	r24, 0xBF	; 191
    3962:	98 e1       	ldi	r25, 0x18	; 24
    3964:	75 d8       	rcall	.-3862   	; 0x2a50 <xTaskGenericCreate>

	
	vTaskStartScheduler();
    3966:	73 d9       	rcall	.-3354   	; 0x2c4e <vTaskStartScheduler>
}
    3968:	80 e0       	ldi	r24, 0x00	; 0
    396a:	90 e0       	ldi	r25, 0x00	; 0
    396c:	df 91       	pop	r29
    396e:	cf 91       	pop	r28
    3970:	0f 91       	pop	r16
    3972:	ff 90       	pop	r15
    3974:	ef 90       	pop	r14
    3976:	df 90       	pop	r13
    3978:	cf 90       	pop	r12
    397a:	bf 90       	pop	r11
    397c:	af 90       	pop	r10
    397e:	08 95       	ret

00003980 <__udivmodsi4>:
    3980:	a1 e2       	ldi	r26, 0x21	; 33
    3982:	1a 2e       	mov	r1, r26
    3984:	aa 1b       	sub	r26, r26
    3986:	bb 1b       	sub	r27, r27
    3988:	fd 01       	movw	r30, r26
    398a:	0d c0       	rjmp	.+26     	; 0x39a6 <__udivmodsi4_ep>

0000398c <__udivmodsi4_loop>:
    398c:	aa 1f       	adc	r26, r26
    398e:	bb 1f       	adc	r27, r27
    3990:	ee 1f       	adc	r30, r30
    3992:	ff 1f       	adc	r31, r31
    3994:	a2 17       	cp	r26, r18
    3996:	b3 07       	cpc	r27, r19
    3998:	e4 07       	cpc	r30, r20
    399a:	f5 07       	cpc	r31, r21
    399c:	20 f0       	brcs	.+8      	; 0x39a6 <__udivmodsi4_ep>
    399e:	a2 1b       	sub	r26, r18
    39a0:	b3 0b       	sbc	r27, r19
    39a2:	e4 0b       	sbc	r30, r20
    39a4:	f5 0b       	sbc	r31, r21

000039a6 <__udivmodsi4_ep>:
    39a6:	66 1f       	adc	r22, r22
    39a8:	77 1f       	adc	r23, r23
    39aa:	88 1f       	adc	r24, r24
    39ac:	99 1f       	adc	r25, r25
    39ae:	1a 94       	dec	r1
    39b0:	69 f7       	brne	.-38     	; 0x398c <__udivmodsi4_loop>
    39b2:	60 95       	com	r22
    39b4:	70 95       	com	r23
    39b6:	80 95       	com	r24
    39b8:	90 95       	com	r25
    39ba:	9b 01       	movw	r18, r22
    39bc:	ac 01       	movw	r20, r24
    39be:	bd 01       	movw	r22, r26
    39c0:	cf 01       	movw	r24, r30
    39c2:	08 95       	ret

000039c4 <__prologue_saves__>:
    39c4:	2f 92       	push	r2
    39c6:	3f 92       	push	r3
    39c8:	4f 92       	push	r4
    39ca:	5f 92       	push	r5
    39cc:	6f 92       	push	r6
    39ce:	7f 92       	push	r7
    39d0:	8f 92       	push	r8
    39d2:	9f 92       	push	r9
    39d4:	af 92       	push	r10
    39d6:	bf 92       	push	r11
    39d8:	cf 92       	push	r12
    39da:	df 92       	push	r13
    39dc:	ef 92       	push	r14
    39de:	ff 92       	push	r15
    39e0:	0f 93       	push	r16
    39e2:	1f 93       	push	r17
    39e4:	cf 93       	push	r28
    39e6:	df 93       	push	r29
    39e8:	cd b7       	in	r28, 0x3d	; 61
    39ea:	de b7       	in	r29, 0x3e	; 62
    39ec:	ca 1b       	sub	r28, r26
    39ee:	db 0b       	sbc	r29, r27
    39f0:	cd bf       	out	0x3d, r28	; 61
    39f2:	de bf       	out	0x3e, r29	; 62
    39f4:	19 94       	eijmp

000039f6 <__epilogue_restores__>:
    39f6:	2a 88       	ldd	r2, Y+18	; 0x12
    39f8:	39 88       	ldd	r3, Y+17	; 0x11
    39fa:	48 88       	ldd	r4, Y+16	; 0x10
    39fc:	5f 84       	ldd	r5, Y+15	; 0x0f
    39fe:	6e 84       	ldd	r6, Y+14	; 0x0e
    3a00:	7d 84       	ldd	r7, Y+13	; 0x0d
    3a02:	8c 84       	ldd	r8, Y+12	; 0x0c
    3a04:	9b 84       	ldd	r9, Y+11	; 0x0b
    3a06:	aa 84       	ldd	r10, Y+10	; 0x0a
    3a08:	b9 84       	ldd	r11, Y+9	; 0x09
    3a0a:	c8 84       	ldd	r12, Y+8	; 0x08
    3a0c:	df 80       	ldd	r13, Y+7	; 0x07
    3a0e:	ee 80       	ldd	r14, Y+6	; 0x06
    3a10:	fd 80       	ldd	r15, Y+5	; 0x05
    3a12:	0c 81       	ldd	r16, Y+4	; 0x04
    3a14:	1b 81       	ldd	r17, Y+3	; 0x03
    3a16:	aa 81       	ldd	r26, Y+2	; 0x02
    3a18:	b9 81       	ldd	r27, Y+1	; 0x01
    3a1a:	ce 0f       	add	r28, r30
    3a1c:	d1 1d       	adc	r29, r1
    3a1e:	cd bf       	out	0x3d, r28	; 61
    3a20:	de bf       	out	0x3e, r29	; 62
    3a22:	ed 01       	movw	r28, r26
    3a24:	08 95       	ret

00003a26 <malloc>:
    3a26:	cf 93       	push	r28
    3a28:	df 93       	push	r29
    3a2a:	82 30       	cpi	r24, 0x02	; 2
    3a2c:	91 05       	cpc	r25, r1
    3a2e:	10 f4       	brcc	.+4      	; 0x3a34 <malloc+0xe>
    3a30:	82 e0       	ldi	r24, 0x02	; 2
    3a32:	90 e0       	ldi	r25, 0x00	; 0
    3a34:	e0 91 bb 24 	lds	r30, 0x24BB
    3a38:	f0 91 bc 24 	lds	r31, 0x24BC
    3a3c:	20 e0       	ldi	r18, 0x00	; 0
    3a3e:	30 e0       	ldi	r19, 0x00	; 0
    3a40:	a0 e0       	ldi	r26, 0x00	; 0
    3a42:	b0 e0       	ldi	r27, 0x00	; 0
    3a44:	30 97       	sbiw	r30, 0x00	; 0
    3a46:	39 f1       	breq	.+78     	; 0x3a96 <malloc+0x70>
    3a48:	40 81       	ld	r20, Z
    3a4a:	51 81       	ldd	r21, Z+1	; 0x01
    3a4c:	48 17       	cp	r20, r24
    3a4e:	59 07       	cpc	r21, r25
    3a50:	b8 f0       	brcs	.+46     	; 0x3a80 <malloc+0x5a>
    3a52:	48 17       	cp	r20, r24
    3a54:	59 07       	cpc	r21, r25
    3a56:	71 f4       	brne	.+28     	; 0x3a74 <malloc+0x4e>
    3a58:	82 81       	ldd	r24, Z+2	; 0x02
    3a5a:	93 81       	ldd	r25, Z+3	; 0x03
    3a5c:	10 97       	sbiw	r26, 0x00	; 0
    3a5e:	29 f0       	breq	.+10     	; 0x3a6a <malloc+0x44>
    3a60:	12 96       	adiw	r26, 0x02	; 2
    3a62:	8d 93       	st	X+, r24
    3a64:	9c 93       	st	X, r25
    3a66:	13 97       	sbiw	r26, 0x03	; 3
    3a68:	2c c0       	rjmp	.+88     	; 0x3ac2 <malloc+0x9c>
    3a6a:	80 93 bb 24 	sts	0x24BB, r24
    3a6e:	90 93 bc 24 	sts	0x24BC, r25
    3a72:	27 c0       	rjmp	.+78     	; 0x3ac2 <malloc+0x9c>
    3a74:	21 15       	cp	r18, r1
    3a76:	31 05       	cpc	r19, r1
    3a78:	31 f0       	breq	.+12     	; 0x3a86 <malloc+0x60>
    3a7a:	42 17       	cp	r20, r18
    3a7c:	53 07       	cpc	r21, r19
    3a7e:	18 f0       	brcs	.+6      	; 0x3a86 <malloc+0x60>
    3a80:	a9 01       	movw	r20, r18
    3a82:	db 01       	movw	r26, r22
    3a84:	01 c0       	rjmp	.+2      	; 0x3a88 <malloc+0x62>
    3a86:	ef 01       	movw	r28, r30
    3a88:	9a 01       	movw	r18, r20
    3a8a:	bd 01       	movw	r22, r26
    3a8c:	df 01       	movw	r26, r30
    3a8e:	02 80       	ldd	r0, Z+2	; 0x02
    3a90:	f3 81       	ldd	r31, Z+3	; 0x03
    3a92:	e0 2d       	mov	r30, r0
    3a94:	d7 cf       	rjmp	.-82     	; 0x3a44 <malloc+0x1e>
    3a96:	21 15       	cp	r18, r1
    3a98:	31 05       	cpc	r19, r1
    3a9a:	f9 f0       	breq	.+62     	; 0x3ada <malloc+0xb4>
    3a9c:	28 1b       	sub	r18, r24
    3a9e:	39 0b       	sbc	r19, r25
    3aa0:	24 30       	cpi	r18, 0x04	; 4
    3aa2:	31 05       	cpc	r19, r1
    3aa4:	80 f4       	brcc	.+32     	; 0x3ac6 <malloc+0xa0>
    3aa6:	8a 81       	ldd	r24, Y+2	; 0x02
    3aa8:	9b 81       	ldd	r25, Y+3	; 0x03
    3aaa:	61 15       	cp	r22, r1
    3aac:	71 05       	cpc	r23, r1
    3aae:	21 f0       	breq	.+8      	; 0x3ab8 <malloc+0x92>
    3ab0:	fb 01       	movw	r30, r22
    3ab2:	82 83       	std	Z+2, r24	; 0x02
    3ab4:	93 83       	std	Z+3, r25	; 0x03
    3ab6:	04 c0       	rjmp	.+8      	; 0x3ac0 <malloc+0x9a>
    3ab8:	80 93 bb 24 	sts	0x24BB, r24
    3abc:	90 93 bc 24 	sts	0x24BC, r25
    3ac0:	fe 01       	movw	r30, r28
    3ac2:	32 96       	adiw	r30, 0x02	; 2
    3ac4:	44 c0       	rjmp	.+136    	; 0x3b4e <malloc+0x128>
    3ac6:	fe 01       	movw	r30, r28
    3ac8:	e2 0f       	add	r30, r18
    3aca:	f3 1f       	adc	r31, r19
    3acc:	81 93       	st	Z+, r24
    3ace:	91 93       	st	Z+, r25
    3ad0:	22 50       	subi	r18, 0x02	; 2
    3ad2:	31 09       	sbc	r19, r1
    3ad4:	28 83       	st	Y, r18
    3ad6:	39 83       	std	Y+1, r19	; 0x01
    3ad8:	3a c0       	rjmp	.+116    	; 0x3b4e <malloc+0x128>
    3ada:	20 91 b9 24 	lds	r18, 0x24B9
    3ade:	30 91 ba 24 	lds	r19, 0x24BA
    3ae2:	23 2b       	or	r18, r19
    3ae4:	41 f4       	brne	.+16     	; 0x3af6 <malloc+0xd0>
    3ae6:	20 91 03 20 	lds	r18, 0x2003
    3aea:	30 91 04 20 	lds	r19, 0x2004
    3aee:	20 93 b9 24 	sts	0x24B9, r18
    3af2:	30 93 ba 24 	sts	0x24BA, r19
    3af6:	20 91 01 20 	lds	r18, 0x2001
    3afa:	30 91 02 20 	lds	r19, 0x2002
    3afe:	21 15       	cp	r18, r1
    3b00:	31 05       	cpc	r19, r1
    3b02:	41 f4       	brne	.+16     	; 0x3b14 <malloc+0xee>
    3b04:	2d b7       	in	r18, 0x3d	; 61
    3b06:	3e b7       	in	r19, 0x3e	; 62
    3b08:	40 91 05 20 	lds	r20, 0x2005
    3b0c:	50 91 06 20 	lds	r21, 0x2006
    3b10:	24 1b       	sub	r18, r20
    3b12:	35 0b       	sbc	r19, r21
    3b14:	e0 91 b9 24 	lds	r30, 0x24B9
    3b18:	f0 91 ba 24 	lds	r31, 0x24BA
    3b1c:	e2 17       	cp	r30, r18
    3b1e:	f3 07       	cpc	r31, r19
    3b20:	a0 f4       	brcc	.+40     	; 0x3b4a <malloc+0x124>
    3b22:	2e 1b       	sub	r18, r30
    3b24:	3f 0b       	sbc	r19, r31
    3b26:	28 17       	cp	r18, r24
    3b28:	39 07       	cpc	r19, r25
    3b2a:	78 f0       	brcs	.+30     	; 0x3b4a <malloc+0x124>
    3b2c:	ac 01       	movw	r20, r24
    3b2e:	4e 5f       	subi	r20, 0xFE	; 254
    3b30:	5f 4f       	sbci	r21, 0xFF	; 255
    3b32:	24 17       	cp	r18, r20
    3b34:	35 07       	cpc	r19, r21
    3b36:	48 f0       	brcs	.+18     	; 0x3b4a <malloc+0x124>
    3b38:	4e 0f       	add	r20, r30
    3b3a:	5f 1f       	adc	r21, r31
    3b3c:	40 93 b9 24 	sts	0x24B9, r20
    3b40:	50 93 ba 24 	sts	0x24BA, r21
    3b44:	81 93       	st	Z+, r24
    3b46:	91 93       	st	Z+, r25
    3b48:	02 c0       	rjmp	.+4      	; 0x3b4e <malloc+0x128>
    3b4a:	e0 e0       	ldi	r30, 0x00	; 0
    3b4c:	f0 e0       	ldi	r31, 0x00	; 0
    3b4e:	cf 01       	movw	r24, r30
    3b50:	df 91       	pop	r29
    3b52:	cf 91       	pop	r28
    3b54:	08 95       	ret

00003b56 <free>:
    3b56:	cf 93       	push	r28
    3b58:	df 93       	push	r29
    3b5a:	00 97       	sbiw	r24, 0x00	; 0
    3b5c:	09 f4       	brne	.+2      	; 0x3b60 <free+0xa>
    3b5e:	87 c0       	rjmp	.+270    	; 0x3c6e <free+0x118>
    3b60:	fc 01       	movw	r30, r24
    3b62:	32 97       	sbiw	r30, 0x02	; 2
    3b64:	12 82       	std	Z+2, r1	; 0x02
    3b66:	13 82       	std	Z+3, r1	; 0x03
    3b68:	c0 91 bb 24 	lds	r28, 0x24BB
    3b6c:	d0 91 bc 24 	lds	r29, 0x24BC
    3b70:	20 97       	sbiw	r28, 0x00	; 0
    3b72:	81 f4       	brne	.+32     	; 0x3b94 <free+0x3e>
    3b74:	20 81       	ld	r18, Z
    3b76:	31 81       	ldd	r19, Z+1	; 0x01
    3b78:	28 0f       	add	r18, r24
    3b7a:	39 1f       	adc	r19, r25
    3b7c:	80 91 b9 24 	lds	r24, 0x24B9
    3b80:	90 91 ba 24 	lds	r25, 0x24BA
    3b84:	82 17       	cp	r24, r18
    3b86:	93 07       	cpc	r25, r19
    3b88:	79 f5       	brne	.+94     	; 0x3be8 <free+0x92>
    3b8a:	e0 93 b9 24 	sts	0x24B9, r30
    3b8e:	f0 93 ba 24 	sts	0x24BA, r31
    3b92:	6d c0       	rjmp	.+218    	; 0x3c6e <free+0x118>
    3b94:	de 01       	movw	r26, r28
    3b96:	20 e0       	ldi	r18, 0x00	; 0
    3b98:	30 e0       	ldi	r19, 0x00	; 0
    3b9a:	ae 17       	cp	r26, r30
    3b9c:	bf 07       	cpc	r27, r31
    3b9e:	50 f4       	brcc	.+20     	; 0x3bb4 <free+0x5e>
    3ba0:	12 96       	adiw	r26, 0x02	; 2
    3ba2:	4d 91       	ld	r20, X+
    3ba4:	5c 91       	ld	r21, X
    3ba6:	13 97       	sbiw	r26, 0x03	; 3
    3ba8:	9d 01       	movw	r18, r26
    3baa:	41 15       	cp	r20, r1
    3bac:	51 05       	cpc	r21, r1
    3bae:	09 f1       	breq	.+66     	; 0x3bf2 <free+0x9c>
    3bb0:	da 01       	movw	r26, r20
    3bb2:	f3 cf       	rjmp	.-26     	; 0x3b9a <free+0x44>
    3bb4:	a2 83       	std	Z+2, r26	; 0x02
    3bb6:	b3 83       	std	Z+3, r27	; 0x03
    3bb8:	40 81       	ld	r20, Z
    3bba:	51 81       	ldd	r21, Z+1	; 0x01
    3bbc:	84 0f       	add	r24, r20
    3bbe:	95 1f       	adc	r25, r21
    3bc0:	8a 17       	cp	r24, r26
    3bc2:	9b 07       	cpc	r25, r27
    3bc4:	71 f4       	brne	.+28     	; 0x3be2 <free+0x8c>
    3bc6:	8d 91       	ld	r24, X+
    3bc8:	9c 91       	ld	r25, X
    3bca:	11 97       	sbiw	r26, 0x01	; 1
    3bcc:	84 0f       	add	r24, r20
    3bce:	95 1f       	adc	r25, r21
    3bd0:	02 96       	adiw	r24, 0x02	; 2
    3bd2:	80 83       	st	Z, r24
    3bd4:	91 83       	std	Z+1, r25	; 0x01
    3bd6:	12 96       	adiw	r26, 0x02	; 2
    3bd8:	8d 91       	ld	r24, X+
    3bda:	9c 91       	ld	r25, X
    3bdc:	13 97       	sbiw	r26, 0x03	; 3
    3bde:	82 83       	std	Z+2, r24	; 0x02
    3be0:	93 83       	std	Z+3, r25	; 0x03
    3be2:	21 15       	cp	r18, r1
    3be4:	31 05       	cpc	r19, r1
    3be6:	29 f4       	brne	.+10     	; 0x3bf2 <free+0x9c>
    3be8:	e0 93 bb 24 	sts	0x24BB, r30
    3bec:	f0 93 bc 24 	sts	0x24BC, r31
    3bf0:	3e c0       	rjmp	.+124    	; 0x3c6e <free+0x118>
    3bf2:	d9 01       	movw	r26, r18
    3bf4:	12 96       	adiw	r26, 0x02	; 2
    3bf6:	ed 93       	st	X+, r30
    3bf8:	fc 93       	st	X, r31
    3bfa:	13 97       	sbiw	r26, 0x03	; 3
    3bfc:	4d 91       	ld	r20, X+
    3bfe:	5d 91       	ld	r21, X+
    3c00:	a4 0f       	add	r26, r20
    3c02:	b5 1f       	adc	r27, r21
    3c04:	ea 17       	cp	r30, r26
    3c06:	fb 07       	cpc	r31, r27
    3c08:	79 f4       	brne	.+30     	; 0x3c28 <free+0xd2>
    3c0a:	80 81       	ld	r24, Z
    3c0c:	91 81       	ldd	r25, Z+1	; 0x01
    3c0e:	84 0f       	add	r24, r20
    3c10:	95 1f       	adc	r25, r21
    3c12:	02 96       	adiw	r24, 0x02	; 2
    3c14:	d9 01       	movw	r26, r18
    3c16:	8d 93       	st	X+, r24
    3c18:	9c 93       	st	X, r25
    3c1a:	11 97       	sbiw	r26, 0x01	; 1
    3c1c:	82 81       	ldd	r24, Z+2	; 0x02
    3c1e:	93 81       	ldd	r25, Z+3	; 0x03
    3c20:	12 96       	adiw	r26, 0x02	; 2
    3c22:	8d 93       	st	X+, r24
    3c24:	9c 93       	st	X, r25
    3c26:	13 97       	sbiw	r26, 0x03	; 3
    3c28:	e0 e0       	ldi	r30, 0x00	; 0
    3c2a:	f0 e0       	ldi	r31, 0x00	; 0
    3c2c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c2e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c30:	00 97       	sbiw	r24, 0x00	; 0
    3c32:	19 f0       	breq	.+6      	; 0x3c3a <free+0xe4>
    3c34:	fe 01       	movw	r30, r28
    3c36:	ec 01       	movw	r28, r24
    3c38:	f9 cf       	rjmp	.-14     	; 0x3c2c <free+0xd6>
    3c3a:	ce 01       	movw	r24, r28
    3c3c:	02 96       	adiw	r24, 0x02	; 2
    3c3e:	28 81       	ld	r18, Y
    3c40:	39 81       	ldd	r19, Y+1	; 0x01
    3c42:	82 0f       	add	r24, r18
    3c44:	93 1f       	adc	r25, r19
    3c46:	20 91 b9 24 	lds	r18, 0x24B9
    3c4a:	30 91 ba 24 	lds	r19, 0x24BA
    3c4e:	28 17       	cp	r18, r24
    3c50:	39 07       	cpc	r19, r25
    3c52:	69 f4       	brne	.+26     	; 0x3c6e <free+0x118>
    3c54:	30 97       	sbiw	r30, 0x00	; 0
    3c56:	29 f4       	brne	.+10     	; 0x3c62 <free+0x10c>
    3c58:	10 92 bb 24 	sts	0x24BB, r1
    3c5c:	10 92 bc 24 	sts	0x24BC, r1
    3c60:	02 c0       	rjmp	.+4      	; 0x3c66 <free+0x110>
    3c62:	12 82       	std	Z+2, r1	; 0x02
    3c64:	13 82       	std	Z+3, r1	; 0x03
    3c66:	c0 93 b9 24 	sts	0x24B9, r28
    3c6a:	d0 93 ba 24 	sts	0x24BA, r29
    3c6e:	df 91       	pop	r29
    3c70:	cf 91       	pop	r28
    3c72:	08 95       	ret

00003c74 <snprintf>:
    3c74:	0f 93       	push	r16
    3c76:	1f 93       	push	r17
    3c78:	cf 93       	push	r28
    3c7a:	df 93       	push	r29
    3c7c:	cd b7       	in	r28, 0x3d	; 61
    3c7e:	de b7       	in	r29, 0x3e	; 62
    3c80:	2e 97       	sbiw	r28, 0x0e	; 14
    3c82:	cd bf       	out	0x3d, r28	; 61
    3c84:	de bf       	out	0x3e, r29	; 62
    3c86:	0e 89       	ldd	r16, Y+22	; 0x16
    3c88:	1f 89       	ldd	r17, Y+23	; 0x17
    3c8a:	88 8d       	ldd	r24, Y+24	; 0x18
    3c8c:	99 8d       	ldd	r25, Y+25	; 0x19
    3c8e:	26 e0       	ldi	r18, 0x06	; 6
    3c90:	2c 83       	std	Y+4, r18	; 0x04
    3c92:	09 83       	std	Y+1, r16	; 0x01
    3c94:	1a 83       	std	Y+2, r17	; 0x02
    3c96:	97 ff       	sbrs	r25, 7
    3c98:	02 c0       	rjmp	.+4      	; 0x3c9e <snprintf+0x2a>
    3c9a:	80 e0       	ldi	r24, 0x00	; 0
    3c9c:	90 e8       	ldi	r25, 0x80	; 128
    3c9e:	01 97       	sbiw	r24, 0x01	; 1
    3ca0:	8d 83       	std	Y+5, r24	; 0x05
    3ca2:	9e 83       	std	Y+6, r25	; 0x06
    3ca4:	ae 01       	movw	r20, r28
    3ca6:	44 5e       	subi	r20, 0xE4	; 228
    3ca8:	5f 4f       	sbci	r21, 0xFF	; 255
    3caa:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3cac:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3cae:	ce 01       	movw	r24, r28
    3cb0:	01 96       	adiw	r24, 0x01	; 1
    3cb2:	16 d0       	rcall	.+44     	; 0x3ce0 <vfprintf>
    3cb4:	4d 81       	ldd	r20, Y+5	; 0x05
    3cb6:	5e 81       	ldd	r21, Y+6	; 0x06
    3cb8:	57 fd       	sbrc	r21, 7
    3cba:	0a c0       	rjmp	.+20     	; 0x3cd0 <snprintf+0x5c>
    3cbc:	2f 81       	ldd	r18, Y+7	; 0x07
    3cbe:	38 85       	ldd	r19, Y+8	; 0x08
    3cc0:	42 17       	cp	r20, r18
    3cc2:	53 07       	cpc	r21, r19
    3cc4:	0c f4       	brge	.+2      	; 0x3cc8 <snprintf+0x54>
    3cc6:	9a 01       	movw	r18, r20
    3cc8:	f8 01       	movw	r30, r16
    3cca:	e2 0f       	add	r30, r18
    3ccc:	f3 1f       	adc	r31, r19
    3cce:	10 82       	st	Z, r1
    3cd0:	2e 96       	adiw	r28, 0x0e	; 14
    3cd2:	cd bf       	out	0x3d, r28	; 61
    3cd4:	de bf       	out	0x3e, r29	; 62
    3cd6:	df 91       	pop	r29
    3cd8:	cf 91       	pop	r28
    3cda:	1f 91       	pop	r17
    3cdc:	0f 91       	pop	r16
    3cde:	08 95       	ret

00003ce0 <vfprintf>:
    3ce0:	2f 92       	push	r2
    3ce2:	3f 92       	push	r3
    3ce4:	4f 92       	push	r4
    3ce6:	5f 92       	push	r5
    3ce8:	6f 92       	push	r6
    3cea:	7f 92       	push	r7
    3cec:	8f 92       	push	r8
    3cee:	9f 92       	push	r9
    3cf0:	af 92       	push	r10
    3cf2:	bf 92       	push	r11
    3cf4:	cf 92       	push	r12
    3cf6:	df 92       	push	r13
    3cf8:	ef 92       	push	r14
    3cfa:	ff 92       	push	r15
    3cfc:	0f 93       	push	r16
    3cfe:	1f 93       	push	r17
    3d00:	cf 93       	push	r28
    3d02:	df 93       	push	r29
    3d04:	cd b7       	in	r28, 0x3d	; 61
    3d06:	de b7       	in	r29, 0x3e	; 62
    3d08:	2c 97       	sbiw	r28, 0x0c	; 12
    3d0a:	cd bf       	out	0x3d, r28	; 61
    3d0c:	de bf       	out	0x3e, r29	; 62
    3d0e:	7c 01       	movw	r14, r24
    3d10:	6b 01       	movw	r12, r22
    3d12:	8a 01       	movw	r16, r20
    3d14:	fc 01       	movw	r30, r24
    3d16:	16 82       	std	Z+6, r1	; 0x06
    3d18:	17 82       	std	Z+7, r1	; 0x07
    3d1a:	83 81       	ldd	r24, Z+3	; 0x03
    3d1c:	81 ff       	sbrs	r24, 1
    3d1e:	b0 c1       	rjmp	.+864    	; 0x4080 <vfprintf+0x3a0>
    3d20:	ce 01       	movw	r24, r28
    3d22:	01 96       	adiw	r24, 0x01	; 1
    3d24:	4c 01       	movw	r8, r24
    3d26:	f7 01       	movw	r30, r14
    3d28:	93 81       	ldd	r25, Z+3	; 0x03
    3d2a:	f6 01       	movw	r30, r12
    3d2c:	93 fd       	sbrc	r25, 3
    3d2e:	85 91       	lpm	r24, Z+
    3d30:	93 ff       	sbrs	r25, 3
    3d32:	81 91       	ld	r24, Z+
    3d34:	6f 01       	movw	r12, r30
    3d36:	88 23       	and	r24, r24
    3d38:	09 f4       	brne	.+2      	; 0x3d3c <vfprintf+0x5c>
    3d3a:	9e c1       	rjmp	.+828    	; 0x4078 <vfprintf+0x398>
    3d3c:	85 32       	cpi	r24, 0x25	; 37
    3d3e:	39 f4       	brne	.+14     	; 0x3d4e <vfprintf+0x6e>
    3d40:	93 fd       	sbrc	r25, 3
    3d42:	85 91       	lpm	r24, Z+
    3d44:	93 ff       	sbrs	r25, 3
    3d46:	81 91       	ld	r24, Z+
    3d48:	6f 01       	movw	r12, r30
    3d4a:	85 32       	cpi	r24, 0x25	; 37
    3d4c:	21 f4       	brne	.+8      	; 0x3d56 <vfprintf+0x76>
    3d4e:	b7 01       	movw	r22, r14
    3d50:	90 e0       	ldi	r25, 0x00	; 0
    3d52:	c4 d1       	rcall	.+904    	; 0x40dc <fputc>
    3d54:	e8 cf       	rjmp	.-48     	; 0x3d26 <vfprintf+0x46>
    3d56:	51 2c       	mov	r5, r1
    3d58:	31 2c       	mov	r3, r1
    3d5a:	20 e0       	ldi	r18, 0x00	; 0
    3d5c:	20 32       	cpi	r18, 0x20	; 32
    3d5e:	a0 f4       	brcc	.+40     	; 0x3d88 <vfprintf+0xa8>
    3d60:	8b 32       	cpi	r24, 0x2B	; 43
    3d62:	69 f0       	breq	.+26     	; 0x3d7e <vfprintf+0x9e>
    3d64:	30 f4       	brcc	.+12     	; 0x3d72 <vfprintf+0x92>
    3d66:	80 32       	cpi	r24, 0x20	; 32
    3d68:	59 f0       	breq	.+22     	; 0x3d80 <vfprintf+0xa0>
    3d6a:	83 32       	cpi	r24, 0x23	; 35
    3d6c:	69 f4       	brne	.+26     	; 0x3d88 <vfprintf+0xa8>
    3d6e:	20 61       	ori	r18, 0x10	; 16
    3d70:	2c c0       	rjmp	.+88     	; 0x3dca <vfprintf+0xea>
    3d72:	8d 32       	cpi	r24, 0x2D	; 45
    3d74:	39 f0       	breq	.+14     	; 0x3d84 <vfprintf+0xa4>
    3d76:	80 33       	cpi	r24, 0x30	; 48
    3d78:	39 f4       	brne	.+14     	; 0x3d88 <vfprintf+0xa8>
    3d7a:	21 60       	ori	r18, 0x01	; 1
    3d7c:	26 c0       	rjmp	.+76     	; 0x3dca <vfprintf+0xea>
    3d7e:	22 60       	ori	r18, 0x02	; 2
    3d80:	24 60       	ori	r18, 0x04	; 4
    3d82:	23 c0       	rjmp	.+70     	; 0x3dca <vfprintf+0xea>
    3d84:	28 60       	ori	r18, 0x08	; 8
    3d86:	21 c0       	rjmp	.+66     	; 0x3dca <vfprintf+0xea>
    3d88:	27 fd       	sbrc	r18, 7
    3d8a:	27 c0       	rjmp	.+78     	; 0x3dda <vfprintf+0xfa>
    3d8c:	30 ed       	ldi	r19, 0xD0	; 208
    3d8e:	38 0f       	add	r19, r24
    3d90:	3a 30       	cpi	r19, 0x0A	; 10
    3d92:	78 f4       	brcc	.+30     	; 0x3db2 <vfprintf+0xd2>
    3d94:	26 ff       	sbrs	r18, 6
    3d96:	06 c0       	rjmp	.+12     	; 0x3da4 <vfprintf+0xc4>
    3d98:	fa e0       	ldi	r31, 0x0A	; 10
    3d9a:	5f 9e       	mul	r5, r31
    3d9c:	30 0d       	add	r19, r0
    3d9e:	11 24       	eor	r1, r1
    3da0:	53 2e       	mov	r5, r19
    3da2:	13 c0       	rjmp	.+38     	; 0x3dca <vfprintf+0xea>
    3da4:	8a e0       	ldi	r24, 0x0A	; 10
    3da6:	38 9e       	mul	r3, r24
    3da8:	30 0d       	add	r19, r0
    3daa:	11 24       	eor	r1, r1
    3dac:	33 2e       	mov	r3, r19
    3dae:	20 62       	ori	r18, 0x20	; 32
    3db0:	0c c0       	rjmp	.+24     	; 0x3dca <vfprintf+0xea>
    3db2:	8e 32       	cpi	r24, 0x2E	; 46
    3db4:	21 f4       	brne	.+8      	; 0x3dbe <vfprintf+0xde>
    3db6:	26 fd       	sbrc	r18, 6
    3db8:	5f c1       	rjmp	.+702    	; 0x4078 <vfprintf+0x398>
    3dba:	20 64       	ori	r18, 0x40	; 64
    3dbc:	06 c0       	rjmp	.+12     	; 0x3dca <vfprintf+0xea>
    3dbe:	8c 36       	cpi	r24, 0x6C	; 108
    3dc0:	11 f4       	brne	.+4      	; 0x3dc6 <vfprintf+0xe6>
    3dc2:	20 68       	ori	r18, 0x80	; 128
    3dc4:	02 c0       	rjmp	.+4      	; 0x3dca <vfprintf+0xea>
    3dc6:	88 36       	cpi	r24, 0x68	; 104
    3dc8:	41 f4       	brne	.+16     	; 0x3dda <vfprintf+0xfa>
    3dca:	f6 01       	movw	r30, r12
    3dcc:	93 fd       	sbrc	r25, 3
    3dce:	85 91       	lpm	r24, Z+
    3dd0:	93 ff       	sbrs	r25, 3
    3dd2:	81 91       	ld	r24, Z+
    3dd4:	6f 01       	movw	r12, r30
    3dd6:	81 11       	cpse	r24, r1
    3dd8:	c1 cf       	rjmp	.-126    	; 0x3d5c <vfprintf+0x7c>
    3dda:	98 2f       	mov	r25, r24
    3ddc:	9f 7d       	andi	r25, 0xDF	; 223
    3dde:	95 54       	subi	r25, 0x45	; 69
    3de0:	93 30       	cpi	r25, 0x03	; 3
    3de2:	28 f4       	brcc	.+10     	; 0x3dee <vfprintf+0x10e>
    3de4:	0c 5f       	subi	r16, 0xFC	; 252
    3de6:	1f 4f       	sbci	r17, 0xFF	; 255
    3de8:	ff e3       	ldi	r31, 0x3F	; 63
    3dea:	f9 83       	std	Y+1, r31	; 0x01
    3dec:	0d c0       	rjmp	.+26     	; 0x3e08 <vfprintf+0x128>
    3dee:	83 36       	cpi	r24, 0x63	; 99
    3df0:	31 f0       	breq	.+12     	; 0x3dfe <vfprintf+0x11e>
    3df2:	83 37       	cpi	r24, 0x73	; 115
    3df4:	71 f0       	breq	.+28     	; 0x3e12 <vfprintf+0x132>
    3df6:	83 35       	cpi	r24, 0x53	; 83
    3df8:	09 f0       	breq	.+2      	; 0x3dfc <vfprintf+0x11c>
    3dfa:	57 c0       	rjmp	.+174    	; 0x3eaa <vfprintf+0x1ca>
    3dfc:	21 c0       	rjmp	.+66     	; 0x3e40 <vfprintf+0x160>
    3dfe:	f8 01       	movw	r30, r16
    3e00:	80 81       	ld	r24, Z
    3e02:	89 83       	std	Y+1, r24	; 0x01
    3e04:	0e 5f       	subi	r16, 0xFE	; 254
    3e06:	1f 4f       	sbci	r17, 0xFF	; 255
    3e08:	44 24       	eor	r4, r4
    3e0a:	43 94       	inc	r4
    3e0c:	51 2c       	mov	r5, r1
    3e0e:	54 01       	movw	r10, r8
    3e10:	14 c0       	rjmp	.+40     	; 0x3e3a <vfprintf+0x15a>
    3e12:	38 01       	movw	r6, r16
    3e14:	f2 e0       	ldi	r31, 0x02	; 2
    3e16:	6f 0e       	add	r6, r31
    3e18:	71 1c       	adc	r7, r1
    3e1a:	f8 01       	movw	r30, r16
    3e1c:	a0 80       	ld	r10, Z
    3e1e:	b1 80       	ldd	r11, Z+1	; 0x01
    3e20:	26 ff       	sbrs	r18, 6
    3e22:	03 c0       	rjmp	.+6      	; 0x3e2a <vfprintf+0x14a>
    3e24:	65 2d       	mov	r22, r5
    3e26:	70 e0       	ldi	r23, 0x00	; 0
    3e28:	02 c0       	rjmp	.+4      	; 0x3e2e <vfprintf+0x14e>
    3e2a:	6f ef       	ldi	r22, 0xFF	; 255
    3e2c:	7f ef       	ldi	r23, 0xFF	; 255
    3e2e:	c5 01       	movw	r24, r10
    3e30:	2c 87       	std	Y+12, r18	; 0x0c
    3e32:	49 d1       	rcall	.+658    	; 0x40c6 <strnlen>
    3e34:	2c 01       	movw	r4, r24
    3e36:	83 01       	movw	r16, r6
    3e38:	2c 85       	ldd	r18, Y+12	; 0x0c
    3e3a:	2f 77       	andi	r18, 0x7F	; 127
    3e3c:	22 2e       	mov	r2, r18
    3e3e:	16 c0       	rjmp	.+44     	; 0x3e6c <vfprintf+0x18c>
    3e40:	38 01       	movw	r6, r16
    3e42:	f2 e0       	ldi	r31, 0x02	; 2
    3e44:	6f 0e       	add	r6, r31
    3e46:	71 1c       	adc	r7, r1
    3e48:	f8 01       	movw	r30, r16
    3e4a:	a0 80       	ld	r10, Z
    3e4c:	b1 80       	ldd	r11, Z+1	; 0x01
    3e4e:	26 ff       	sbrs	r18, 6
    3e50:	03 c0       	rjmp	.+6      	; 0x3e58 <vfprintf+0x178>
    3e52:	65 2d       	mov	r22, r5
    3e54:	70 e0       	ldi	r23, 0x00	; 0
    3e56:	02 c0       	rjmp	.+4      	; 0x3e5c <vfprintf+0x17c>
    3e58:	6f ef       	ldi	r22, 0xFF	; 255
    3e5a:	7f ef       	ldi	r23, 0xFF	; 255
    3e5c:	c5 01       	movw	r24, r10
    3e5e:	2c 87       	std	Y+12, r18	; 0x0c
    3e60:	27 d1       	rcall	.+590    	; 0x40b0 <strnlen_P>
    3e62:	2c 01       	movw	r4, r24
    3e64:	2c 85       	ldd	r18, Y+12	; 0x0c
    3e66:	20 68       	ori	r18, 0x80	; 128
    3e68:	22 2e       	mov	r2, r18
    3e6a:	83 01       	movw	r16, r6
    3e6c:	23 fc       	sbrc	r2, 3
    3e6e:	19 c0       	rjmp	.+50     	; 0x3ea2 <vfprintf+0x1c2>
    3e70:	83 2d       	mov	r24, r3
    3e72:	90 e0       	ldi	r25, 0x00	; 0
    3e74:	48 16       	cp	r4, r24
    3e76:	59 06       	cpc	r5, r25
    3e78:	a0 f4       	brcc	.+40     	; 0x3ea2 <vfprintf+0x1c2>
    3e7a:	b7 01       	movw	r22, r14
    3e7c:	80 e2       	ldi	r24, 0x20	; 32
    3e7e:	90 e0       	ldi	r25, 0x00	; 0
    3e80:	2d d1       	rcall	.+602    	; 0x40dc <fputc>
    3e82:	3a 94       	dec	r3
    3e84:	f5 cf       	rjmp	.-22     	; 0x3e70 <vfprintf+0x190>
    3e86:	f5 01       	movw	r30, r10
    3e88:	27 fc       	sbrc	r2, 7
    3e8a:	85 91       	lpm	r24, Z+
    3e8c:	27 fe       	sbrs	r2, 7
    3e8e:	81 91       	ld	r24, Z+
    3e90:	5f 01       	movw	r10, r30
    3e92:	b7 01       	movw	r22, r14
    3e94:	90 e0       	ldi	r25, 0x00	; 0
    3e96:	22 d1       	rcall	.+580    	; 0x40dc <fputc>
    3e98:	31 10       	cpse	r3, r1
    3e9a:	3a 94       	dec	r3
    3e9c:	f1 e0       	ldi	r31, 0x01	; 1
    3e9e:	4f 1a       	sub	r4, r31
    3ea0:	51 08       	sbc	r5, r1
    3ea2:	41 14       	cp	r4, r1
    3ea4:	51 04       	cpc	r5, r1
    3ea6:	79 f7       	brne	.-34     	; 0x3e86 <vfprintf+0x1a6>
    3ea8:	de c0       	rjmp	.+444    	; 0x4066 <vfprintf+0x386>
    3eaa:	84 36       	cpi	r24, 0x64	; 100
    3eac:	11 f0       	breq	.+4      	; 0x3eb2 <vfprintf+0x1d2>
    3eae:	89 36       	cpi	r24, 0x69	; 105
    3eb0:	31 f5       	brne	.+76     	; 0x3efe <vfprintf+0x21e>
    3eb2:	f8 01       	movw	r30, r16
    3eb4:	27 ff       	sbrs	r18, 7
    3eb6:	07 c0       	rjmp	.+14     	; 0x3ec6 <vfprintf+0x1e6>
    3eb8:	60 81       	ld	r22, Z
    3eba:	71 81       	ldd	r23, Z+1	; 0x01
    3ebc:	82 81       	ldd	r24, Z+2	; 0x02
    3ebe:	93 81       	ldd	r25, Z+3	; 0x03
    3ec0:	0c 5f       	subi	r16, 0xFC	; 252
    3ec2:	1f 4f       	sbci	r17, 0xFF	; 255
    3ec4:	08 c0       	rjmp	.+16     	; 0x3ed6 <vfprintf+0x1f6>
    3ec6:	60 81       	ld	r22, Z
    3ec8:	71 81       	ldd	r23, Z+1	; 0x01
    3eca:	88 27       	eor	r24, r24
    3ecc:	77 fd       	sbrc	r23, 7
    3ece:	80 95       	com	r24
    3ed0:	98 2f       	mov	r25, r24
    3ed2:	0e 5f       	subi	r16, 0xFE	; 254
    3ed4:	1f 4f       	sbci	r17, 0xFF	; 255
    3ed6:	2f 76       	andi	r18, 0x6F	; 111
    3ed8:	b2 2e       	mov	r11, r18
    3eda:	97 ff       	sbrs	r25, 7
    3edc:	09 c0       	rjmp	.+18     	; 0x3ef0 <vfprintf+0x210>
    3ede:	90 95       	com	r25
    3ee0:	80 95       	com	r24
    3ee2:	70 95       	com	r23
    3ee4:	61 95       	neg	r22
    3ee6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ee8:	8f 4f       	sbci	r24, 0xFF	; 255
    3eea:	9f 4f       	sbci	r25, 0xFF	; 255
    3eec:	20 68       	ori	r18, 0x80	; 128
    3eee:	b2 2e       	mov	r11, r18
    3ef0:	2a e0       	ldi	r18, 0x0A	; 10
    3ef2:	30 e0       	ldi	r19, 0x00	; 0
    3ef4:	a4 01       	movw	r20, r8
    3ef6:	24 d1       	rcall	.+584    	; 0x4140 <__ultoa_invert>
    3ef8:	a8 2e       	mov	r10, r24
    3efa:	a8 18       	sub	r10, r8
    3efc:	43 c0       	rjmp	.+134    	; 0x3f84 <vfprintf+0x2a4>
    3efe:	85 37       	cpi	r24, 0x75	; 117
    3f00:	29 f4       	brne	.+10     	; 0x3f0c <vfprintf+0x22c>
    3f02:	2f 7e       	andi	r18, 0xEF	; 239
    3f04:	b2 2e       	mov	r11, r18
    3f06:	2a e0       	ldi	r18, 0x0A	; 10
    3f08:	30 e0       	ldi	r19, 0x00	; 0
    3f0a:	25 c0       	rjmp	.+74     	; 0x3f56 <vfprintf+0x276>
    3f0c:	f2 2f       	mov	r31, r18
    3f0e:	f9 7f       	andi	r31, 0xF9	; 249
    3f10:	bf 2e       	mov	r11, r31
    3f12:	8f 36       	cpi	r24, 0x6F	; 111
    3f14:	c1 f0       	breq	.+48     	; 0x3f46 <vfprintf+0x266>
    3f16:	18 f4       	brcc	.+6      	; 0x3f1e <vfprintf+0x23e>
    3f18:	88 35       	cpi	r24, 0x58	; 88
    3f1a:	79 f0       	breq	.+30     	; 0x3f3a <vfprintf+0x25a>
    3f1c:	ad c0       	rjmp	.+346    	; 0x4078 <vfprintf+0x398>
    3f1e:	80 37       	cpi	r24, 0x70	; 112
    3f20:	19 f0       	breq	.+6      	; 0x3f28 <vfprintf+0x248>
    3f22:	88 37       	cpi	r24, 0x78	; 120
    3f24:	21 f0       	breq	.+8      	; 0x3f2e <vfprintf+0x24e>
    3f26:	a8 c0       	rjmp	.+336    	; 0x4078 <vfprintf+0x398>
    3f28:	2f 2f       	mov	r18, r31
    3f2a:	20 61       	ori	r18, 0x10	; 16
    3f2c:	b2 2e       	mov	r11, r18
    3f2e:	b4 fe       	sbrs	r11, 4
    3f30:	0d c0       	rjmp	.+26     	; 0x3f4c <vfprintf+0x26c>
    3f32:	8b 2d       	mov	r24, r11
    3f34:	84 60       	ori	r24, 0x04	; 4
    3f36:	b8 2e       	mov	r11, r24
    3f38:	09 c0       	rjmp	.+18     	; 0x3f4c <vfprintf+0x26c>
    3f3a:	24 ff       	sbrs	r18, 4
    3f3c:	0a c0       	rjmp	.+20     	; 0x3f52 <vfprintf+0x272>
    3f3e:	9f 2f       	mov	r25, r31
    3f40:	96 60       	ori	r25, 0x06	; 6
    3f42:	b9 2e       	mov	r11, r25
    3f44:	06 c0       	rjmp	.+12     	; 0x3f52 <vfprintf+0x272>
    3f46:	28 e0       	ldi	r18, 0x08	; 8
    3f48:	30 e0       	ldi	r19, 0x00	; 0
    3f4a:	05 c0       	rjmp	.+10     	; 0x3f56 <vfprintf+0x276>
    3f4c:	20 e1       	ldi	r18, 0x10	; 16
    3f4e:	30 e0       	ldi	r19, 0x00	; 0
    3f50:	02 c0       	rjmp	.+4      	; 0x3f56 <vfprintf+0x276>
    3f52:	20 e1       	ldi	r18, 0x10	; 16
    3f54:	32 e0       	ldi	r19, 0x02	; 2
    3f56:	f8 01       	movw	r30, r16
    3f58:	b7 fe       	sbrs	r11, 7
    3f5a:	07 c0       	rjmp	.+14     	; 0x3f6a <vfprintf+0x28a>
    3f5c:	60 81       	ld	r22, Z
    3f5e:	71 81       	ldd	r23, Z+1	; 0x01
    3f60:	82 81       	ldd	r24, Z+2	; 0x02
    3f62:	93 81       	ldd	r25, Z+3	; 0x03
    3f64:	0c 5f       	subi	r16, 0xFC	; 252
    3f66:	1f 4f       	sbci	r17, 0xFF	; 255
    3f68:	06 c0       	rjmp	.+12     	; 0x3f76 <vfprintf+0x296>
    3f6a:	60 81       	ld	r22, Z
    3f6c:	71 81       	ldd	r23, Z+1	; 0x01
    3f6e:	80 e0       	ldi	r24, 0x00	; 0
    3f70:	90 e0       	ldi	r25, 0x00	; 0
    3f72:	0e 5f       	subi	r16, 0xFE	; 254
    3f74:	1f 4f       	sbci	r17, 0xFF	; 255
    3f76:	a4 01       	movw	r20, r8
    3f78:	e3 d0       	rcall	.+454    	; 0x4140 <__ultoa_invert>
    3f7a:	a8 2e       	mov	r10, r24
    3f7c:	a8 18       	sub	r10, r8
    3f7e:	fb 2d       	mov	r31, r11
    3f80:	ff 77       	andi	r31, 0x7F	; 127
    3f82:	bf 2e       	mov	r11, r31
    3f84:	b6 fe       	sbrs	r11, 6
    3f86:	0b c0       	rjmp	.+22     	; 0x3f9e <vfprintf+0x2be>
    3f88:	2b 2d       	mov	r18, r11
    3f8a:	2e 7f       	andi	r18, 0xFE	; 254
    3f8c:	a5 14       	cp	r10, r5
    3f8e:	50 f4       	brcc	.+20     	; 0x3fa4 <vfprintf+0x2c4>
    3f90:	b4 fe       	sbrs	r11, 4
    3f92:	0a c0       	rjmp	.+20     	; 0x3fa8 <vfprintf+0x2c8>
    3f94:	b2 fc       	sbrc	r11, 2
    3f96:	08 c0       	rjmp	.+16     	; 0x3fa8 <vfprintf+0x2c8>
    3f98:	2b 2d       	mov	r18, r11
    3f9a:	2e 7e       	andi	r18, 0xEE	; 238
    3f9c:	05 c0       	rjmp	.+10     	; 0x3fa8 <vfprintf+0x2c8>
    3f9e:	7a 2c       	mov	r7, r10
    3fa0:	2b 2d       	mov	r18, r11
    3fa2:	03 c0       	rjmp	.+6      	; 0x3faa <vfprintf+0x2ca>
    3fa4:	7a 2c       	mov	r7, r10
    3fa6:	01 c0       	rjmp	.+2      	; 0x3faa <vfprintf+0x2ca>
    3fa8:	75 2c       	mov	r7, r5
    3faa:	24 ff       	sbrs	r18, 4
    3fac:	0d c0       	rjmp	.+26     	; 0x3fc8 <vfprintf+0x2e8>
    3fae:	fe 01       	movw	r30, r28
    3fb0:	ea 0d       	add	r30, r10
    3fb2:	f1 1d       	adc	r31, r1
    3fb4:	80 81       	ld	r24, Z
    3fb6:	80 33       	cpi	r24, 0x30	; 48
    3fb8:	11 f4       	brne	.+4      	; 0x3fbe <vfprintf+0x2de>
    3fba:	29 7e       	andi	r18, 0xE9	; 233
    3fbc:	09 c0       	rjmp	.+18     	; 0x3fd0 <vfprintf+0x2f0>
    3fbe:	22 ff       	sbrs	r18, 2
    3fc0:	06 c0       	rjmp	.+12     	; 0x3fce <vfprintf+0x2ee>
    3fc2:	73 94       	inc	r7
    3fc4:	73 94       	inc	r7
    3fc6:	04 c0       	rjmp	.+8      	; 0x3fd0 <vfprintf+0x2f0>
    3fc8:	82 2f       	mov	r24, r18
    3fca:	86 78       	andi	r24, 0x86	; 134
    3fcc:	09 f0       	breq	.+2      	; 0x3fd0 <vfprintf+0x2f0>
    3fce:	73 94       	inc	r7
    3fd0:	23 fd       	sbrc	r18, 3
    3fd2:	12 c0       	rjmp	.+36     	; 0x3ff8 <vfprintf+0x318>
    3fd4:	20 ff       	sbrs	r18, 0
    3fd6:	06 c0       	rjmp	.+12     	; 0x3fe4 <vfprintf+0x304>
    3fd8:	5a 2c       	mov	r5, r10
    3fda:	73 14       	cp	r7, r3
    3fdc:	18 f4       	brcc	.+6      	; 0x3fe4 <vfprintf+0x304>
    3fde:	53 0c       	add	r5, r3
    3fe0:	57 18       	sub	r5, r7
    3fe2:	73 2c       	mov	r7, r3
    3fe4:	73 14       	cp	r7, r3
    3fe6:	60 f4       	brcc	.+24     	; 0x4000 <vfprintf+0x320>
    3fe8:	b7 01       	movw	r22, r14
    3fea:	80 e2       	ldi	r24, 0x20	; 32
    3fec:	90 e0       	ldi	r25, 0x00	; 0
    3fee:	2c 87       	std	Y+12, r18	; 0x0c
    3ff0:	75 d0       	rcall	.+234    	; 0x40dc <fputc>
    3ff2:	73 94       	inc	r7
    3ff4:	2c 85       	ldd	r18, Y+12	; 0x0c
    3ff6:	f6 cf       	rjmp	.-20     	; 0x3fe4 <vfprintf+0x304>
    3ff8:	73 14       	cp	r7, r3
    3ffa:	10 f4       	brcc	.+4      	; 0x4000 <vfprintf+0x320>
    3ffc:	37 18       	sub	r3, r7
    3ffe:	01 c0       	rjmp	.+2      	; 0x4002 <vfprintf+0x322>
    4000:	31 2c       	mov	r3, r1
    4002:	24 ff       	sbrs	r18, 4
    4004:	11 c0       	rjmp	.+34     	; 0x4028 <vfprintf+0x348>
    4006:	b7 01       	movw	r22, r14
    4008:	80 e3       	ldi	r24, 0x30	; 48
    400a:	90 e0       	ldi	r25, 0x00	; 0
    400c:	2c 87       	std	Y+12, r18	; 0x0c
    400e:	66 d0       	rcall	.+204    	; 0x40dc <fputc>
    4010:	2c 85       	ldd	r18, Y+12	; 0x0c
    4012:	22 ff       	sbrs	r18, 2
    4014:	16 c0       	rjmp	.+44     	; 0x4042 <vfprintf+0x362>
    4016:	21 ff       	sbrs	r18, 1
    4018:	03 c0       	rjmp	.+6      	; 0x4020 <vfprintf+0x340>
    401a:	88 e5       	ldi	r24, 0x58	; 88
    401c:	90 e0       	ldi	r25, 0x00	; 0
    401e:	02 c0       	rjmp	.+4      	; 0x4024 <vfprintf+0x344>
    4020:	88 e7       	ldi	r24, 0x78	; 120
    4022:	90 e0       	ldi	r25, 0x00	; 0
    4024:	b7 01       	movw	r22, r14
    4026:	0c c0       	rjmp	.+24     	; 0x4040 <vfprintf+0x360>
    4028:	82 2f       	mov	r24, r18
    402a:	86 78       	andi	r24, 0x86	; 134
    402c:	51 f0       	breq	.+20     	; 0x4042 <vfprintf+0x362>
    402e:	21 fd       	sbrc	r18, 1
    4030:	02 c0       	rjmp	.+4      	; 0x4036 <vfprintf+0x356>
    4032:	80 e2       	ldi	r24, 0x20	; 32
    4034:	01 c0       	rjmp	.+2      	; 0x4038 <vfprintf+0x358>
    4036:	8b e2       	ldi	r24, 0x2B	; 43
    4038:	27 fd       	sbrc	r18, 7
    403a:	8d e2       	ldi	r24, 0x2D	; 45
    403c:	b7 01       	movw	r22, r14
    403e:	90 e0       	ldi	r25, 0x00	; 0
    4040:	4d d0       	rcall	.+154    	; 0x40dc <fputc>
    4042:	a5 14       	cp	r10, r5
    4044:	30 f4       	brcc	.+12     	; 0x4052 <vfprintf+0x372>
    4046:	b7 01       	movw	r22, r14
    4048:	80 e3       	ldi	r24, 0x30	; 48
    404a:	90 e0       	ldi	r25, 0x00	; 0
    404c:	47 d0       	rcall	.+142    	; 0x40dc <fputc>
    404e:	5a 94       	dec	r5
    4050:	f8 cf       	rjmp	.-16     	; 0x4042 <vfprintf+0x362>
    4052:	aa 94       	dec	r10
    4054:	f4 01       	movw	r30, r8
    4056:	ea 0d       	add	r30, r10
    4058:	f1 1d       	adc	r31, r1
    405a:	80 81       	ld	r24, Z
    405c:	b7 01       	movw	r22, r14
    405e:	90 e0       	ldi	r25, 0x00	; 0
    4060:	3d d0       	rcall	.+122    	; 0x40dc <fputc>
    4062:	a1 10       	cpse	r10, r1
    4064:	f6 cf       	rjmp	.-20     	; 0x4052 <vfprintf+0x372>
    4066:	33 20       	and	r3, r3
    4068:	09 f4       	brne	.+2      	; 0x406c <vfprintf+0x38c>
    406a:	5d ce       	rjmp	.-838    	; 0x3d26 <vfprintf+0x46>
    406c:	b7 01       	movw	r22, r14
    406e:	80 e2       	ldi	r24, 0x20	; 32
    4070:	90 e0       	ldi	r25, 0x00	; 0
    4072:	34 d0       	rcall	.+104    	; 0x40dc <fputc>
    4074:	3a 94       	dec	r3
    4076:	f7 cf       	rjmp	.-18     	; 0x4066 <vfprintf+0x386>
    4078:	f7 01       	movw	r30, r14
    407a:	86 81       	ldd	r24, Z+6	; 0x06
    407c:	97 81       	ldd	r25, Z+7	; 0x07
    407e:	02 c0       	rjmp	.+4      	; 0x4084 <vfprintf+0x3a4>
    4080:	8f ef       	ldi	r24, 0xFF	; 255
    4082:	9f ef       	ldi	r25, 0xFF	; 255
    4084:	2c 96       	adiw	r28, 0x0c	; 12
    4086:	cd bf       	out	0x3d, r28	; 61
    4088:	de bf       	out	0x3e, r29	; 62
    408a:	df 91       	pop	r29
    408c:	cf 91       	pop	r28
    408e:	1f 91       	pop	r17
    4090:	0f 91       	pop	r16
    4092:	ff 90       	pop	r15
    4094:	ef 90       	pop	r14
    4096:	df 90       	pop	r13
    4098:	cf 90       	pop	r12
    409a:	bf 90       	pop	r11
    409c:	af 90       	pop	r10
    409e:	9f 90       	pop	r9
    40a0:	8f 90       	pop	r8
    40a2:	7f 90       	pop	r7
    40a4:	6f 90       	pop	r6
    40a6:	5f 90       	pop	r5
    40a8:	4f 90       	pop	r4
    40aa:	3f 90       	pop	r3
    40ac:	2f 90       	pop	r2
    40ae:	08 95       	ret

000040b0 <strnlen_P>:
    40b0:	fc 01       	movw	r30, r24
    40b2:	05 90       	lpm	r0, Z+
    40b4:	61 50       	subi	r22, 0x01	; 1
    40b6:	70 40       	sbci	r23, 0x00	; 0
    40b8:	01 10       	cpse	r0, r1
    40ba:	d8 f7       	brcc	.-10     	; 0x40b2 <strnlen_P+0x2>
    40bc:	80 95       	com	r24
    40be:	90 95       	com	r25
    40c0:	8e 0f       	add	r24, r30
    40c2:	9f 1f       	adc	r25, r31
    40c4:	08 95       	ret

000040c6 <strnlen>:
    40c6:	fc 01       	movw	r30, r24
    40c8:	61 50       	subi	r22, 0x01	; 1
    40ca:	70 40       	sbci	r23, 0x00	; 0
    40cc:	01 90       	ld	r0, Z+
    40ce:	01 10       	cpse	r0, r1
    40d0:	d8 f7       	brcc	.-10     	; 0x40c8 <strnlen+0x2>
    40d2:	80 95       	com	r24
    40d4:	90 95       	com	r25
    40d6:	8e 0f       	add	r24, r30
    40d8:	9f 1f       	adc	r25, r31
    40da:	08 95       	ret

000040dc <fputc>:
    40dc:	0f 93       	push	r16
    40de:	1f 93       	push	r17
    40e0:	cf 93       	push	r28
    40e2:	df 93       	push	r29
    40e4:	18 2f       	mov	r17, r24
    40e6:	09 2f       	mov	r16, r25
    40e8:	eb 01       	movw	r28, r22
    40ea:	8b 81       	ldd	r24, Y+3	; 0x03
    40ec:	81 fd       	sbrc	r24, 1
    40ee:	03 c0       	rjmp	.+6      	; 0x40f6 <fputc+0x1a>
    40f0:	8f ef       	ldi	r24, 0xFF	; 255
    40f2:	9f ef       	ldi	r25, 0xFF	; 255
    40f4:	20 c0       	rjmp	.+64     	; 0x4136 <fputc+0x5a>
    40f6:	82 ff       	sbrs	r24, 2
    40f8:	10 c0       	rjmp	.+32     	; 0x411a <fputc+0x3e>
    40fa:	4e 81       	ldd	r20, Y+6	; 0x06
    40fc:	5f 81       	ldd	r21, Y+7	; 0x07
    40fe:	2c 81       	ldd	r18, Y+4	; 0x04
    4100:	3d 81       	ldd	r19, Y+5	; 0x05
    4102:	42 17       	cp	r20, r18
    4104:	53 07       	cpc	r21, r19
    4106:	7c f4       	brge	.+30     	; 0x4126 <fputc+0x4a>
    4108:	e8 81       	ld	r30, Y
    410a:	f9 81       	ldd	r31, Y+1	; 0x01
    410c:	9f 01       	movw	r18, r30
    410e:	2f 5f       	subi	r18, 0xFF	; 255
    4110:	3f 4f       	sbci	r19, 0xFF	; 255
    4112:	28 83       	st	Y, r18
    4114:	39 83       	std	Y+1, r19	; 0x01
    4116:	10 83       	st	Z, r17
    4118:	06 c0       	rjmp	.+12     	; 0x4126 <fputc+0x4a>
    411a:	e8 85       	ldd	r30, Y+8	; 0x08
    411c:	f9 85       	ldd	r31, Y+9	; 0x09
    411e:	81 2f       	mov	r24, r17
    4120:	19 95       	eicall
    4122:	89 2b       	or	r24, r25
    4124:	29 f7       	brne	.-54     	; 0x40f0 <fputc+0x14>
    4126:	2e 81       	ldd	r18, Y+6	; 0x06
    4128:	3f 81       	ldd	r19, Y+7	; 0x07
    412a:	2f 5f       	subi	r18, 0xFF	; 255
    412c:	3f 4f       	sbci	r19, 0xFF	; 255
    412e:	2e 83       	std	Y+6, r18	; 0x06
    4130:	3f 83       	std	Y+7, r19	; 0x07
    4132:	81 2f       	mov	r24, r17
    4134:	90 2f       	mov	r25, r16
    4136:	df 91       	pop	r29
    4138:	cf 91       	pop	r28
    413a:	1f 91       	pop	r17
    413c:	0f 91       	pop	r16
    413e:	08 95       	ret

00004140 <__ultoa_invert>:
    4140:	fa 01       	movw	r30, r20
    4142:	aa 27       	eor	r26, r26
    4144:	28 30       	cpi	r18, 0x08	; 8
    4146:	51 f1       	breq	.+84     	; 0x419c <__ultoa_invert+0x5c>
    4148:	20 31       	cpi	r18, 0x10	; 16
    414a:	81 f1       	breq	.+96     	; 0x41ac <__ultoa_invert+0x6c>
    414c:	e8 94       	clt
    414e:	6f 93       	push	r22
    4150:	6e 7f       	andi	r22, 0xFE	; 254
    4152:	6e 5f       	subi	r22, 0xFE	; 254
    4154:	7f 4f       	sbci	r23, 0xFF	; 255
    4156:	8f 4f       	sbci	r24, 0xFF	; 255
    4158:	9f 4f       	sbci	r25, 0xFF	; 255
    415a:	af 4f       	sbci	r26, 0xFF	; 255
    415c:	b1 e0       	ldi	r27, 0x01	; 1
    415e:	3e d0       	rcall	.+124    	; 0x41dc <__ultoa_invert+0x9c>
    4160:	b4 e0       	ldi	r27, 0x04	; 4
    4162:	3c d0       	rcall	.+120    	; 0x41dc <__ultoa_invert+0x9c>
    4164:	67 0f       	add	r22, r23
    4166:	78 1f       	adc	r23, r24
    4168:	89 1f       	adc	r24, r25
    416a:	9a 1f       	adc	r25, r26
    416c:	a1 1d       	adc	r26, r1
    416e:	68 0f       	add	r22, r24
    4170:	79 1f       	adc	r23, r25
    4172:	8a 1f       	adc	r24, r26
    4174:	91 1d       	adc	r25, r1
    4176:	a1 1d       	adc	r26, r1
    4178:	6a 0f       	add	r22, r26
    417a:	71 1d       	adc	r23, r1
    417c:	81 1d       	adc	r24, r1
    417e:	91 1d       	adc	r25, r1
    4180:	a1 1d       	adc	r26, r1
    4182:	20 d0       	rcall	.+64     	; 0x41c4 <__ultoa_invert+0x84>
    4184:	09 f4       	brne	.+2      	; 0x4188 <__ultoa_invert+0x48>
    4186:	68 94       	set
    4188:	3f 91       	pop	r19
    418a:	2a e0       	ldi	r18, 0x0A	; 10
    418c:	26 9f       	mul	r18, r22
    418e:	11 24       	eor	r1, r1
    4190:	30 19       	sub	r19, r0
    4192:	30 5d       	subi	r19, 0xD0	; 208
    4194:	31 93       	st	Z+, r19
    4196:	de f6       	brtc	.-74     	; 0x414e <__ultoa_invert+0xe>
    4198:	cf 01       	movw	r24, r30
    419a:	08 95       	ret
    419c:	46 2f       	mov	r20, r22
    419e:	47 70       	andi	r20, 0x07	; 7
    41a0:	40 5d       	subi	r20, 0xD0	; 208
    41a2:	41 93       	st	Z+, r20
    41a4:	b3 e0       	ldi	r27, 0x03	; 3
    41a6:	0f d0       	rcall	.+30     	; 0x41c6 <__ultoa_invert+0x86>
    41a8:	c9 f7       	brne	.-14     	; 0x419c <__ultoa_invert+0x5c>
    41aa:	f6 cf       	rjmp	.-20     	; 0x4198 <__ultoa_invert+0x58>
    41ac:	46 2f       	mov	r20, r22
    41ae:	4f 70       	andi	r20, 0x0F	; 15
    41b0:	40 5d       	subi	r20, 0xD0	; 208
    41b2:	4a 33       	cpi	r20, 0x3A	; 58
    41b4:	18 f0       	brcs	.+6      	; 0x41bc <__ultoa_invert+0x7c>
    41b6:	49 5d       	subi	r20, 0xD9	; 217
    41b8:	31 fd       	sbrc	r19, 1
    41ba:	40 52       	subi	r20, 0x20	; 32
    41bc:	41 93       	st	Z+, r20
    41be:	02 d0       	rcall	.+4      	; 0x41c4 <__ultoa_invert+0x84>
    41c0:	a9 f7       	brne	.-22     	; 0x41ac <__ultoa_invert+0x6c>
    41c2:	ea cf       	rjmp	.-44     	; 0x4198 <__ultoa_invert+0x58>
    41c4:	b4 e0       	ldi	r27, 0x04	; 4
    41c6:	a6 95       	lsr	r26
    41c8:	97 95       	ror	r25
    41ca:	87 95       	ror	r24
    41cc:	77 95       	ror	r23
    41ce:	67 95       	ror	r22
    41d0:	ba 95       	dec	r27
    41d2:	c9 f7       	brne	.-14     	; 0x41c6 <__ultoa_invert+0x86>
    41d4:	00 97       	sbiw	r24, 0x00	; 0
    41d6:	61 05       	cpc	r22, r1
    41d8:	71 05       	cpc	r23, r1
    41da:	08 95       	ret
    41dc:	9b 01       	movw	r18, r22
    41de:	ac 01       	movw	r20, r24
    41e0:	0a 2e       	mov	r0, r26
    41e2:	06 94       	lsr	r0
    41e4:	57 95       	ror	r21
    41e6:	47 95       	ror	r20
    41e8:	37 95       	ror	r19
    41ea:	27 95       	ror	r18
    41ec:	ba 95       	dec	r27
    41ee:	c9 f7       	brne	.-14     	; 0x41e2 <__ultoa_invert+0xa2>
    41f0:	62 0f       	add	r22, r18
    41f2:	73 1f       	adc	r23, r19
    41f4:	84 1f       	adc	r24, r20
    41f6:	95 1f       	adc	r25, r21
    41f8:	a0 1d       	adc	r26, r0
    41fa:	08 95       	ret

000041fc <_exit>:
    41fc:	f8 94       	cli

000041fe <__stop_program>:
    41fe:	ff cf       	rjmp	.-2      	; 0x41fe <__stop_program>
