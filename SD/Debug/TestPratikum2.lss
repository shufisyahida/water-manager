
TestPratikum2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000038e2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000011c  00802000  000038e2  00003976  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002d6  0080211c  0080211c  00003a92  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003a92  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00003ac4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000678  00000000  00000000  00003b08  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001195c  00000000  00000000  00004180  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000032d0  00000000  00000000  00015adc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000bbba  00000000  00000000  00018dac  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000013d8  00000000  00000000  00024968  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00033f3a  00000000  00000000  00025d40  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000768d  00000000  00000000  00059c7a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000788  00000000  00000000  00061308  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000d32f  00000000  00000000  00061a90  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	46 c2       	rjmp	.+1164   	; 0x48e <__ctors_end>
       2:	00 00       	nop
       4:	65 c2       	rjmp	.+1226   	; 0x4d0 <__bad_interrupt>
       6:	00 00       	nop
       8:	63 c2       	rjmp	.+1222   	; 0x4d0 <__bad_interrupt>
       a:	00 00       	nop
       c:	61 c2       	rjmp	.+1218   	; 0x4d0 <__bad_interrupt>
       e:	00 00       	nop
      10:	5f c2       	rjmp	.+1214   	; 0x4d0 <__bad_interrupt>
      12:	00 00       	nop
      14:	5d c2       	rjmp	.+1210   	; 0x4d0 <__bad_interrupt>
      16:	00 00       	nop
      18:	5b c2       	rjmp	.+1206   	; 0x4d0 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	59 c2       	rjmp	.+1202   	; 0x4d0 <__bad_interrupt>
      1e:	00 00       	nop
      20:	57 c2       	rjmp	.+1198   	; 0x4d0 <__bad_interrupt>
      22:	00 00       	nop
      24:	55 c2       	rjmp	.+1194   	; 0x4d0 <__bad_interrupt>
      26:	00 00       	nop
      28:	53 c2       	rjmp	.+1190   	; 0x4d0 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	51 c2       	rjmp	.+1186   	; 0x4d0 <__bad_interrupt>
      2e:	00 00       	nop
      30:	4f c2       	rjmp	.+1182   	; 0x4d0 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 3c 0f 	jmp	0x1e78	; 0x1e78 <__vector_13>
      38:	0c 94 a9 14 	jmp	0x2952	; 0x2952 <__vector_14>
      3c:	49 c2       	rjmp	.+1170   	; 0x4d0 <__bad_interrupt>
      3e:	00 00       	nop
      40:	47 c2       	rjmp	.+1166   	; 0x4d0 <__bad_interrupt>
      42:	00 00       	nop
      44:	45 c2       	rjmp	.+1162   	; 0x4d0 <__bad_interrupt>
      46:	00 00       	nop
      48:	43 c2       	rjmp	.+1158   	; 0x4d0 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	41 c2       	rjmp	.+1154   	; 0x4d0 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3f c2       	rjmp	.+1150   	; 0x4d0 <__bad_interrupt>
      52:	00 00       	nop
      54:	3d c2       	rjmp	.+1146   	; 0x4d0 <__bad_interrupt>
      56:	00 00       	nop
      58:	3b c2       	rjmp	.+1142   	; 0x4d0 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	39 c2       	rjmp	.+1138   	; 0x4d0 <__bad_interrupt>
      5e:	00 00       	nop
      60:	37 c2       	rjmp	.+1134   	; 0x4d0 <__bad_interrupt>
      62:	00 00       	nop
      64:	35 c2       	rjmp	.+1130   	; 0x4d0 <__bad_interrupt>
      66:	00 00       	nop
      68:	33 c2       	rjmp	.+1126   	; 0x4d0 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	31 c2       	rjmp	.+1122   	; 0x4d0 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2f c2       	rjmp	.+1118   	; 0x4d0 <__bad_interrupt>
      72:	00 00       	nop
      74:	2d c2       	rjmp	.+1114   	; 0x4d0 <__bad_interrupt>
      76:	00 00       	nop
      78:	2b c2       	rjmp	.+1110   	; 0x4d0 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	29 c2       	rjmp	.+1106   	; 0x4d0 <__bad_interrupt>
      7e:	00 00       	nop
      80:	27 c2       	rjmp	.+1102   	; 0x4d0 <__bad_interrupt>
      82:	00 00       	nop
      84:	25 c2       	rjmp	.+1098   	; 0x4d0 <__bad_interrupt>
      86:	00 00       	nop
      88:	23 c2       	rjmp	.+1094   	; 0x4d0 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	21 c2       	rjmp	.+1090   	; 0x4d0 <__bad_interrupt>
      8e:	00 00       	nop
      90:	1f c2       	rjmp	.+1086   	; 0x4d0 <__bad_interrupt>
      92:	00 00       	nop
      94:	1d c2       	rjmp	.+1082   	; 0x4d0 <__bad_interrupt>
      96:	00 00       	nop
      98:	1b c2       	rjmp	.+1078   	; 0x4d0 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 f4 0c 	jmp	0x19e8	; 0x19e8 <__vector_39>
      a0:	0c 94 26 0d 	jmp	0x1a4c	; 0x1a4c <__vector_40>
      a4:	0c 94 58 0d 	jmp	0x1ab0	; 0x1ab0 <__vector_41>
      a8:	0c 94 8a 0d 	jmp	0x1b14	; 0x1b14 <__vector_42>
      ac:	11 c2       	rjmp	.+1058   	; 0x4d0 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	0f c2       	rjmp	.+1054   	; 0x4d0 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	0d c2       	rjmp	.+1050   	; 0x4d0 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	0c 94 63 0f 	jmp	0x1ec6	; 0x1ec6 <__vector_46>
      bc:	09 c2       	rjmp	.+1042   	; 0x4d0 <__bad_interrupt>
      be:	00 00       	nop
      c0:	07 c2       	rjmp	.+1038   	; 0x4d0 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	05 c2       	rjmp	.+1034   	; 0x4d0 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	03 c2       	rjmp	.+1030   	; 0x4d0 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	01 c2       	rjmp	.+1026   	; 0x4d0 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	ff c1       	rjmp	.+1022   	; 0x4d0 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	fd c1       	rjmp	.+1018   	; 0x4d0 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	fb c1       	rjmp	.+1014   	; 0x4d0 <__bad_interrupt>
      da:	00 00       	nop
      dc:	f9 c1       	rjmp	.+1010   	; 0x4d0 <__bad_interrupt>
      de:	00 00       	nop
      e0:	f7 c1       	rjmp	.+1006   	; 0x4d0 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	f5 c1       	rjmp	.+1002   	; 0x4d0 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	f3 c1       	rjmp	.+998    	; 0x4d0 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	f1 c1       	rjmp	.+994    	; 0x4d0 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	ef c1       	rjmp	.+990    	; 0x4d0 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	ed c1       	rjmp	.+986    	; 0x4d0 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	eb c1       	rjmp	.+982    	; 0x4d0 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	e9 c1       	rjmp	.+978    	; 0x4d0 <__bad_interrupt>
      fe:	00 00       	nop
     100:	e7 c1       	rjmp	.+974    	; 0x4d0 <__bad_interrupt>
     102:	00 00       	nop
     104:	e5 c1       	rjmp	.+970    	; 0x4d0 <__bad_interrupt>
     106:	00 00       	nop
     108:	e3 c1       	rjmp	.+966    	; 0x4d0 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	e1 c1       	rjmp	.+962    	; 0x4d0 <__bad_interrupt>
     10e:	00 00       	nop
     110:	df c1       	rjmp	.+958    	; 0x4d0 <__bad_interrupt>
     112:	00 00       	nop
     114:	dd c1       	rjmp	.+954    	; 0x4d0 <__bad_interrupt>
     116:	00 00       	nop
     118:	db c1       	rjmp	.+950    	; 0x4d0 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	0c 94 2c 0c 	jmp	0x1858	; 0x1858 <__vector_71>
     120:	0c 94 5e 0c 	jmp	0x18bc	; 0x18bc <__vector_72>
     124:	0c 94 90 0c 	jmp	0x1920	; 0x1920 <__vector_73>
     128:	0c 94 c2 0c 	jmp	0x1984	; 0x1984 <__vector_74>
     12c:	d1 c1       	rjmp	.+930    	; 0x4d0 <__bad_interrupt>
     12e:	00 00       	nop
     130:	cf c1       	rjmp	.+926    	; 0x4d0 <__bad_interrupt>
     132:	00 00       	nop
     134:	cd c1       	rjmp	.+922    	; 0x4d0 <__bad_interrupt>
     136:	00 00       	nop
     138:	cb c1       	rjmp	.+918    	; 0x4d0 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	c9 c1       	rjmp	.+914    	; 0x4d0 <__bad_interrupt>
     13e:	00 00       	nop
     140:	c7 c1       	rjmp	.+910    	; 0x4d0 <__bad_interrupt>
     142:	00 00       	nop
     144:	c5 c1       	rjmp	.+906    	; 0x4d0 <__bad_interrupt>
     146:	00 00       	nop
     148:	c3 c1       	rjmp	.+902    	; 0x4d0 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	c1 c1       	rjmp	.+898    	; 0x4d0 <__bad_interrupt>
     14e:	00 00       	nop
     150:	bf c1       	rjmp	.+894    	; 0x4d0 <__bad_interrupt>
     152:	00 00       	nop
     154:	bd c1       	rjmp	.+890    	; 0x4d0 <__bad_interrupt>
     156:	00 00       	nop
     158:	bb c1       	rjmp	.+886    	; 0x4d0 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	b9 c1       	rjmp	.+882    	; 0x4d0 <__bad_interrupt>
     15e:	00 00       	nop
     160:	b7 c1       	rjmp	.+878    	; 0x4d0 <__bad_interrupt>
     162:	00 00       	nop
     164:	b5 c1       	rjmp	.+874    	; 0x4d0 <__bad_interrupt>
     166:	00 00       	nop
     168:	b3 c1       	rjmp	.+870    	; 0x4d0 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	b1 c1       	rjmp	.+866    	; 0x4d0 <__bad_interrupt>
     16e:	00 00       	nop
     170:	af c1       	rjmp	.+862    	; 0x4d0 <__bad_interrupt>
     172:	00 00       	nop
     174:	ad c1       	rjmp	.+858    	; 0x4d0 <__bad_interrupt>
     176:	00 00       	nop
     178:	ab c1       	rjmp	.+854    	; 0x4d0 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	a9 c1       	rjmp	.+850    	; 0x4d0 <__bad_interrupt>
     17e:	00 00       	nop
     180:	a7 c1       	rjmp	.+846    	; 0x4d0 <__bad_interrupt>
     182:	00 00       	nop
     184:	a5 c1       	rjmp	.+842    	; 0x4d0 <__bad_interrupt>
     186:	00 00       	nop
     188:	a3 c1       	rjmp	.+838    	; 0x4d0 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	a1 c1       	rjmp	.+834    	; 0x4d0 <__bad_interrupt>
     18e:	00 00       	nop
     190:	9f c1       	rjmp	.+830    	; 0x4d0 <__bad_interrupt>
     192:	00 00       	nop
     194:	9d c1       	rjmp	.+826    	; 0x4d0 <__bad_interrupt>
     196:	00 00       	nop
     198:	9b c1       	rjmp	.+822    	; 0x4d0 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	99 c1       	rjmp	.+818    	; 0x4d0 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	97 c1       	rjmp	.+814    	; 0x4d0 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	95 c1       	rjmp	.+810    	; 0x4d0 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	93 c1       	rjmp	.+806    	; 0x4d0 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	91 c1       	rjmp	.+802    	; 0x4d0 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	8f c1       	rjmp	.+798    	; 0x4d0 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	8d c1       	rjmp	.+794    	; 0x4d0 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	8b c1       	rjmp	.+790    	; 0x4d0 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	89 c1       	rjmp	.+786    	; 0x4d0 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	87 c1       	rjmp	.+782    	; 0x4d0 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	85 c1       	rjmp	.+778    	; 0x4d0 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	83 c1       	rjmp	.+774    	; 0x4d0 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	81 c1       	rjmp	.+770    	; 0x4d0 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	7f c1       	rjmp	.+766    	; 0x4d0 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	7d c1       	rjmp	.+762    	; 0x4d0 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	7b c1       	rjmp	.+758    	; 0x4d0 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	79 c1       	rjmp	.+754    	; 0x4d0 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	77 c1       	rjmp	.+750    	; 0x4d0 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	75 c1       	rjmp	.+746    	; 0x4d0 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	73 c1       	rjmp	.+742    	; 0x4d0 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	71 c1       	rjmp	.+738    	; 0x4d0 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	6f c1       	rjmp	.+734    	; 0x4d0 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	6d c1       	rjmp	.+730    	; 0x4d0 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	6b c1       	rjmp	.+726    	; 0x4d0 <__bad_interrupt>
	...

000001fc <__trampolines_end>:
     1fc:	00 00       	nop
     1fe:	00 00       	nop
     200:	00 00       	nop
     202:	00 20       	and	r0, r0
     204:	20 20       	and	r2, r0
     206:	20 20       	and	r2, r0
     208:	00 20       	and	r0, r0
     20a:	50 50       	subi	r21, 0x00	; 0
     20c:	50 00       	.word	0x0050	; ????
     20e:	00 00       	nop
     210:	00 50       	subi	r16, 0x00	; 0
     212:	50 f8       	bld	r5, 0
     214:	50 f8       	bld	r5, 0
     216:	50 50       	subi	r21, 0x00	; 0
     218:	20 78       	andi	r18, 0x80	; 128
     21a:	a0 70       	andi	r26, 0x00	; 0
     21c:	28 f0       	brcs	.+10     	; 0x228 <__trampolines_end+0x2c>
     21e:	20 c0       	rjmp	.+64     	; 0x260 <__trampolines_end+0x64>
     220:	c8 10       	cpse	r12, r8
     222:	20 40       	sbci	r18, 0x00	; 0
     224:	98 18       	sub	r9, r8
     226:	60 90 a0 40 	lds	r6, 0x40A0
     22a:	a8 90       	.word	0x90a8	; ????
     22c:	68 60       	ori	r22, 0x08	; 8
     22e:	20 40       	sbci	r18, 0x00	; 0
     230:	00 00       	nop
     232:	00 00       	nop
     234:	10 20       	and	r1, r0
     236:	40 40       	sbci	r20, 0x00	; 0
     238:	40 20       	and	r4, r0
     23a:	10 40       	sbci	r17, 0x00	; 0
     23c:	20 10       	cpse	r2, r0
     23e:	10 10       	cpse	r1, r0
     240:	20 40       	sbci	r18, 0x00	; 0
     242:	00 50       	subi	r16, 0x00	; 0
     244:	20 f8       	bld	r2, 0
     246:	20 50       	subi	r18, 0x00	; 0
     248:	00 00       	nop
     24a:	20 20       	and	r2, r0
     24c:	f8 20       	and	r15, r8
     24e:	20 00       	.word	0x0020	; ????
     250:	00 00       	nop
     252:	00 00       	nop
     254:	60 20       	and	r6, r0
     256:	40 00       	.word	0x0040	; ????
     258:	00 00       	nop
     25a:	f8 00       	.word	0x00f8	; ????
     25c:	00 00       	nop
     25e:	00 00       	nop
     260:	00 00       	nop
     262:	00 60       	ori	r16, 0x00	; 0
     264:	60 00       	.word	0x0060	; ????
     266:	08 10       	cpse	r0, r8
     268:	20 40       	sbci	r18, 0x00	; 0
     26a:	80 00       	.word	0x0080	; ????
     26c:	70 88       	ldd	r7, Z+16	; 0x10
     26e:	98 a8       	ldd	r9, Y+48	; 0x30
     270:	c8 88       	ldd	r12, Y+16	; 0x10
     272:	70 20       	and	r7, r0
     274:	60 20       	and	r6, r0
     276:	20 20       	and	r2, r0
     278:	20 70       	andi	r18, 0x00	; 0
     27a:	70 88       	ldd	r7, Z+16	; 0x10
     27c:	08 10       	cpse	r0, r8
     27e:	20 40       	sbci	r18, 0x00	; 0
     280:	f8 f8       	.word	0xf8f8	; ????
     282:	10 20       	and	r1, r0
     284:	10 08       	sbc	r1, r0
     286:	88 70       	andi	r24, 0x08	; 8
     288:	10 30       	cpi	r17, 0x00	; 0
     28a:	50 90 f8 10 	lds	r5, 0x10F8
     28e:	10 f8       	bld	r1, 0
     290:	80 f0       	brcs	.+32     	; 0x2b2 <__trampolines_end+0xb6>
     292:	08 08       	sbc	r0, r8
     294:	88 70       	andi	r24, 0x08	; 8
     296:	30 40       	sbci	r19, 0x00	; 0
     298:	80 f0       	brcs	.+32     	; 0x2ba <__trampolines_end+0xbe>
     29a:	88 88       	ldd	r8, Y+16	; 0x10
     29c:	70 f8       	bld	r7, 0
     29e:	08 10       	cpse	r0, r8
     2a0:	20 40       	sbci	r18, 0x00	; 0
     2a2:	40 40       	sbci	r20, 0x00	; 0
     2a4:	70 88       	ldd	r7, Z+16	; 0x10
     2a6:	88 70       	andi	r24, 0x08	; 8
     2a8:	88 88       	ldd	r8, Y+16	; 0x10
     2aa:	70 70       	andi	r23, 0x00	; 0
     2ac:	88 88       	ldd	r8, Y+16	; 0x10
     2ae:	78 08       	sbc	r7, r8
     2b0:	10 60       	ori	r17, 0x00	; 0
     2b2:	00 60       	ori	r16, 0x00	; 0
     2b4:	60 00       	.word	0x0060	; ????
     2b6:	60 60       	ori	r22, 0x00	; 0
     2b8:	00 00       	nop
     2ba:	60 60       	ori	r22, 0x00	; 0
     2bc:	00 60       	ori	r16, 0x00	; 0
     2be:	20 40       	sbci	r18, 0x00	; 0
     2c0:	08 10       	cpse	r0, r8
     2c2:	20 40       	sbci	r18, 0x00	; 0
     2c4:	20 10       	cpse	r2, r0
     2c6:	08 00       	.word	0x0008	; ????
     2c8:	00 f8       	bld	r0, 0
     2ca:	00 f8       	bld	r0, 0
     2cc:	00 00       	nop
     2ce:	80 40       	sbci	r24, 0x00	; 0
     2d0:	20 10       	cpse	r2, r0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	80 70       	andi	r24, 0x00	; 0
     2d6:	88 08       	sbc	r8, r8
     2d8:	10 20       	and	r1, r0
     2da:	00 20       	and	r0, r0
     2dc:	70 88       	ldd	r7, Z+16	; 0x10
     2de:	08 68       	ori	r16, 0x88	; 136
     2e0:	a8 a8       	ldd	r10, Y+48	; 0x30
     2e2:	70 70       	andi	r23, 0x00	; 0
     2e4:	88 88       	ldd	r8, Y+16	; 0x10
     2e6:	88 f8       	.word	0xf888	; ????
     2e8:	88 88       	ldd	r8, Y+16	; 0x10
     2ea:	f0 88       	ldd	r15, Z+16	; 0x10
     2ec:	88 f0       	brcs	.+34     	; 0x310 <__trampolines_end+0x114>
     2ee:	88 88       	ldd	r8, Y+16	; 0x10
     2f0:	f0 70       	andi	r31, 0x00	; 0
     2f2:	88 80       	ld	r8, Y
     2f4:	80 80       	ld	r8, Z
     2f6:	88 70       	andi	r24, 0x08	; 8
     2f8:	e0 90 88 88 	lds	r14, 0x8888
     2fc:	88 90       	.word	0x9088	; ????
     2fe:	e0 f8       	bld	r14, 0
     300:	80 80       	ld	r8, Z
     302:	f0 80       	ld	r15, Z
     304:	80 f8       	bld	r8, 0
     306:	f8 80       	ld	r15, Y
     308:	80 e0       	ldi	r24, 0x00	; 0
     30a:	80 80       	ld	r8, Z
     30c:	80 70       	andi	r24, 0x00	; 0
     30e:	88 80       	ld	r8, Y
     310:	80 98       	cbi	0x10, 0	; 16
     312:	88 70       	andi	r24, 0x08	; 8
     314:	88 88       	ldd	r8, Y+16	; 0x10
     316:	88 f8       	.word	0xf888	; ????
     318:	88 88       	ldd	r8, Y+16	; 0x10
     31a:	88 70       	andi	r24, 0x08	; 8
     31c:	20 20       	and	r2, r0
     31e:	20 20       	and	r2, r0
     320:	20 70       	andi	r18, 0x00	; 0
     322:	38 10       	cpse	r3, r8
     324:	10 10       	cpse	r1, r0
     326:	10 90 60 88 	lds	r1, 0x8860
     32a:	90 a0       	ldd	r9, Z+32	; 0x20
     32c:	c0 a0       	ldd	r12, Z+32	; 0x20
     32e:	90 88       	ldd	r9, Z+16	; 0x10
     330:	80 80       	ld	r8, Z
     332:	80 80       	ld	r8, Z
     334:	80 80       	ld	r8, Z
     336:	f8 88       	ldd	r15, Y+16	; 0x10
     338:	d8 a8       	ldd	r13, Y+48	; 0x30
     33a:	88 88       	ldd	r8, Y+16	; 0x10
     33c:	88 88       	ldd	r8, Y+16	; 0x10
     33e:	88 88       	ldd	r8, Y+16	; 0x10
     340:	c8 a8       	ldd	r12, Y+48	; 0x30
     342:	98 88       	ldd	r9, Y+16	; 0x10
     344:	88 70       	andi	r24, 0x08	; 8
     346:	88 88       	ldd	r8, Y+16	; 0x10
     348:	88 88       	ldd	r8, Y+16	; 0x10
     34a:	88 70       	andi	r24, 0x08	; 8
     34c:	f0 88       	ldd	r15, Z+16	; 0x10
     34e:	88 f0       	brcs	.+34     	; 0x372 <__trampolines_end+0x176>
     350:	80 80       	ld	r8, Z
     352:	80 70       	andi	r24, 0x00	; 0
     354:	88 88       	ldd	r8, Y+16	; 0x10
     356:	88 a8       	ldd	r8, Y+48	; 0x30
     358:	90 68       	ori	r25, 0x80	; 128
     35a:	f0 88       	ldd	r15, Z+16	; 0x10
     35c:	88 f0       	brcs	.+34     	; 0x380 <__trampolines_end+0x184>
     35e:	a0 90 88 78 	lds	r10, 0x7888
     362:	80 80       	ld	r8, Z
     364:	70 08       	sbc	r7, r0
     366:	08 f0       	brcs	.+2      	; 0x36a <__trampolines_end+0x16e>
     368:	f8 20       	and	r15, r8
     36a:	20 20       	and	r2, r0
     36c:	20 20       	and	r2, r0
     36e:	20 88       	ldd	r2, Z+16	; 0x10
     370:	88 88       	ldd	r8, Y+16	; 0x10
     372:	88 88       	ldd	r8, Y+16	; 0x10
     374:	88 70       	andi	r24, 0x08	; 8
     376:	88 88       	ldd	r8, Y+16	; 0x10
     378:	88 88       	ldd	r8, Y+16	; 0x10
     37a:	88 50       	subi	r24, 0x08	; 8
     37c:	20 88       	ldd	r2, Z+16	; 0x10
     37e:	88 88       	ldd	r8, Y+16	; 0x10
     380:	a8 a8       	ldd	r10, Y+48	; 0x30
     382:	d8 88       	ldd	r13, Y+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	50 20       	and	r5, r0
     388:	50 88       	ldd	r5, Z+16	; 0x10
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 50       	subi	r24, 0x08	; 8
     38e:	20 20       	and	r2, r0
     390:	20 20       	and	r2, r0
     392:	f8 08       	sbc	r15, r8
     394:	10 20       	and	r1, r0
     396:	40 80       	ld	r4, Z
     398:	f8 38       	cpi	r31, 0x88	; 136
     39a:	20 20       	and	r2, r0
     39c:	20 20       	and	r2, r0
     39e:	20 38       	cpi	r18, 0x80	; 128
     3a0:	00 80       	ld	r0, Z
     3a2:	40 20       	and	r4, r0
     3a4:	10 08       	sbc	r1, r0
     3a6:	00 e0       	ldi	r16, 0x00	; 0
     3a8:	20 20       	and	r2, r0
     3aa:	20 20       	and	r2, r0
     3ac:	20 e0       	ldi	r18, 0x00	; 0
     3ae:	20 50       	subi	r18, 0x00	; 0
     3b0:	88 00       	.word	0x0088	; ????
	...
     3ba:	00 f8       	bld	r0, 0
     3bc:	40 20       	and	r4, r0
     3be:	10 00       	.word	0x0010	; ????
     3c0:	00 00       	nop
     3c2:	00 00       	nop
     3c4:	00 70       	andi	r16, 0x00	; 0
     3c6:	08 78       	andi	r16, 0x88	; 136
     3c8:	88 78       	andi	r24, 0x88	; 136
     3ca:	80 80       	ld	r8, Z
     3cc:	b0 c8       	rjmp	.-3744   	; 0xfffff52e <__eeprom_end+0xff7ef52e>
     3ce:	88 88       	ldd	r8, Y+16	; 0x10
     3d0:	f0 00       	.word	0x00f0	; ????
     3d2:	00 70       	andi	r16, 0x00	; 0
     3d4:	80 80       	ld	r8, Z
     3d6:	88 70       	andi	r24, 0x08	; 8
     3d8:	08 08       	sbc	r0, r8
     3da:	68 98       	cbi	0x0d, 0	; 13
     3dc:	88 88       	ldd	r8, Y+16	; 0x10
     3de:	78 00       	.word	0x0078	; ????
     3e0:	00 70       	andi	r16, 0x00	; 0
     3e2:	88 f8       	.word	0xf888	; ????
     3e4:	80 70       	andi	r24, 0x00	; 0
     3e6:	30 48       	sbci	r19, 0x80	; 128
     3e8:	40 e0       	ldi	r20, 0x00	; 0
     3ea:	40 40       	sbci	r20, 0x00	; 0
     3ec:	40 00       	.word	0x0040	; ????
     3ee:	00 78       	andi	r16, 0x80	; 128
     3f0:	88 78       	andi	r24, 0x88	; 136
     3f2:	08 30       	cpi	r16, 0x08	; 8
     3f4:	80 80       	ld	r8, Z
     3f6:	b0 c8       	rjmp	.-3744   	; 0xfffff558 <__eeprom_end+0xff7ef558>
     3f8:	88 88       	ldd	r8, Y+16	; 0x10
     3fa:	88 20       	and	r8, r8
     3fc:	00 60       	ori	r16, 0x00	; 0
     3fe:	20 20       	and	r2, r0
     400:	20 70       	andi	r18, 0x00	; 0
     402:	10 00       	.word	0x0010	; ????
     404:	30 10       	cpse	r3, r0
     406:	10 90 60 40 	lds	r1, 0x4060
     40a:	40 48       	sbci	r20, 0x80	; 128
     40c:	50 60       	ori	r21, 0x00	; 0
     40e:	50 48       	sbci	r21, 0x80	; 128
     410:	60 20       	and	r6, r0
     412:	20 20       	and	r2, r0
     414:	20 20       	and	r2, r0
     416:	70 00       	.word	0x0070	; ????
     418:	00 d0       	rcall	.+0      	; 0x41a <__trampolines_end+0x21e>
     41a:	a8 a8       	ldd	r10, Y+48	; 0x30
     41c:	88 88       	ldd	r8, Y+16	; 0x10
     41e:	00 00       	nop
     420:	b0 c8       	rjmp	.-3744   	; 0xfffff582 <__eeprom_end+0xff7ef582>
     422:	88 88       	ldd	r8, Y+16	; 0x10
     424:	88 00       	.word	0x0088	; ????
     426:	00 70       	andi	r16, 0x00	; 0
     428:	88 88       	ldd	r8, Y+16	; 0x10
     42a:	88 70       	andi	r24, 0x08	; 8
     42c:	00 00       	nop
     42e:	f0 88       	ldd	r15, Z+16	; 0x10
     430:	f0 80       	ld	r15, Z
     432:	80 00       	.word	0x0080	; ????
     434:	00 68       	ori	r16, 0x80	; 128
     436:	98 78       	andi	r25, 0x88	; 136
     438:	08 08       	sbc	r0, r8
     43a:	00 00       	nop
     43c:	b0 c8       	rjmp	.-3744   	; 0xfffff59e <__eeprom_end+0xff7ef59e>
     43e:	80 80       	ld	r8, Z
     440:	80 00       	.word	0x0080	; ????
     442:	00 70       	andi	r16, 0x00	; 0
     444:	80 70       	andi	r24, 0x00	; 0
     446:	08 f0       	brcs	.+2      	; 0x44a <__trampolines_end+0x24e>
     448:	40 40       	sbci	r20, 0x00	; 0
     44a:	e0 40       	sbci	r30, 0x00	; 0
     44c:	40 48       	sbci	r20, 0x80	; 128
     44e:	30 00       	.word	0x0030	; ????
     450:	00 88       	ldd	r0, Z+16	; 0x10
     452:	88 88       	ldd	r8, Y+16	; 0x10
     454:	98 68       	ori	r25, 0x88	; 136
     456:	00 00       	nop
     458:	88 88       	ldd	r8, Y+16	; 0x10
     45a:	88 50       	subi	r24, 0x08	; 8
     45c:	20 00       	.word	0x0020	; ????
     45e:	00 88       	ldd	r0, Z+16	; 0x10
     460:	88 a8       	ldd	r8, Y+48	; 0x30
     462:	a8 50       	subi	r26, 0x08	; 8
     464:	00 00       	nop
     466:	88 50       	subi	r24, 0x08	; 8
     468:	20 50       	subi	r18, 0x00	; 0
     46a:	88 00       	.word	0x0088	; ????
     46c:	00 88       	ldd	r0, Z+16	; 0x10
     46e:	88 78       	andi	r24, 0x88	; 136
     470:	08 70       	andi	r16, 0x08	; 8
     472:	00 00       	nop
     474:	f8 10       	cpse	r15, r8
     476:	20 40       	sbci	r18, 0x00	; 0
     478:	f8 10       	cpse	r15, r8
     47a:	20 20       	and	r2, r0
     47c:	40 20       	and	r4, r0
     47e:	20 10       	cpse	r2, r0
     480:	20 20       	and	r2, r0
     482:	20 20       	and	r2, r0
     484:	20 20       	and	r2, r0
     486:	20 40       	sbci	r18, 0x00	; 0
     488:	20 20       	and	r2, r0
     48a:	10 20       	and	r1, r0
     48c:	20 40       	sbci	r18, 0x00	; 0

0000048e <__ctors_end>:
     48e:	11 24       	eor	r1, r1
     490:	1f be       	out	0x3f, r1	; 63
     492:	cf ef       	ldi	r28, 0xFF	; 255
     494:	cd bf       	out	0x3d, r28	; 61
     496:	df e5       	ldi	r29, 0x5F	; 95
     498:	de bf       	out	0x3e, r29	; 62
     49a:	00 e0       	ldi	r16, 0x00	; 0
     49c:	0c bf       	out	0x3c, r16	; 60

0000049e <__do_copy_data>:
     49e:	11 e2       	ldi	r17, 0x21	; 33
     4a0:	a0 e0       	ldi	r26, 0x00	; 0
     4a2:	b0 e2       	ldi	r27, 0x20	; 32
     4a4:	e2 ee       	ldi	r30, 0xE2	; 226
     4a6:	f8 e3       	ldi	r31, 0x38	; 56
     4a8:	00 e0       	ldi	r16, 0x00	; 0
     4aa:	0b bf       	out	0x3b, r16	; 59
     4ac:	02 c0       	rjmp	.+4      	; 0x4b2 <__do_copy_data+0x14>
     4ae:	07 90       	elpm	r0, Z+
     4b0:	0d 92       	st	X+, r0
     4b2:	ac 31       	cpi	r26, 0x1C	; 28
     4b4:	b1 07       	cpc	r27, r17
     4b6:	d9 f7       	brne	.-10     	; 0x4ae <__do_copy_data+0x10>

000004b8 <__do_clear_bss>:
     4b8:	23 e2       	ldi	r18, 0x23	; 35
     4ba:	ac e1       	ldi	r26, 0x1C	; 28
     4bc:	b1 e2       	ldi	r27, 0x21	; 33
     4be:	01 c0       	rjmp	.+2      	; 0x4c2 <.do_clear_bss_start>

000004c0 <.do_clear_bss_loop>:
     4c0:	1d 92       	st	X+, r1

000004c2 <.do_clear_bss_start>:
     4c2:	a2 3f       	cpi	r26, 0xF2	; 242
     4c4:	b2 07       	cpc	r27, r18
     4c6:	e1 f7       	brne	.-8      	; 0x4c0 <.do_clear_bss_loop>
     4c8:	0e 94 ad 1a 	call	0x355a	; 0x355a <main>
     4cc:	0c 94 6f 1c 	jmp	0x38de	; 0x38de <_exit>

000004d0 <__bad_interrupt>:
     4d0:	97 cd       	rjmp	.-1234   	; 0x0 <__vectors>

000004d2 <_1101010101_>:

#if ((_STATIC_PORT_PIN_CONF_ == 1) && (QTOUCH_SNS_PORT_COUNT >= 1))

GLOBAL_FUNCTION _1101010101_
_1101010101_:
    sts	CONCAT( PORT, SNS1, _DIRCLR ), p_1
     4d2:	80 93 a2 06 	sts	0x06A2, r24
    sts	CONCAT( PORT, SNSK1, _DIRCLR ), p_2
     4d6:	60 93 a2 06 	sts	0x06A2, r22
    sts	CONCAT( PORT, SNS1, _OUTSET), p_1
     4da:	80 93 a5 06 	sts	0x06A5, r24
    sts	CONCAT( PORT, SNSK1, _OUTCLR), p_2    
     4de:	60 93 a6 06 	sts	0x06A6, r22
    sts	CONCAT( PORT, SNSK1, _DIRSET), p_2   
     4e2:	60 93 a1 06 	sts	0x06A1, r22
    ret
     4e6:	08 95       	ret

000004e8 <_1101010111_>:


GLOBAL_FUNCTION _1101010111_
_1101010111_:
    push r19
     4e8:	3f 93       	push	r19
    sts	CONCAT( PORT, SNSK1, _DIRCLR), p_2
     4ea:	60 93 a2 06 	sts	0x06A2, r22
    sts	CONCAT( PORT, SNS1, _DIRSET), p_1
     4ee:	80 93 a1 06 	sts	0x06A1, r24
    _10100011_
    _01101001_
    _00011001_
    _00011001_
#endif
    sts	CONCAT( PORT, SNS1, _DIRCLR ), p_1
     4f2:	80 93 a2 06 	sts	0x06A2, r24
    sts	CONCAT( PORT, SNSK1, _DIRSET ), p_2 
     4f6:	60 93 a1 06 	sts	0x06A1, r22
    pop  r19
     4fa:	3f 91       	pop	r19
    lds	r_v, CONCAT(PORT, SNS1, _IN )
     4fc:	80 91 a8 06 	lds	r24, 0x06A8
    and	r_v, p_3
     500:	84 23       	and	r24, r20
    ret
     502:	08 95       	ret

00000504 <_1101010110_>:

GLOBAL_FUNCTION _1101010110_
_1101010110_:
    sts	CONCAT( PORT, SNS1, _OUTCLR), p_1
     504:	80 93 a6 06 	sts	0x06A6, r24
    sts	CONCAT( PORT, SNS1, _DIRSET), p_1
     508:	80 93 a1 06 	sts	0x06A1, r24
    ret
     50c:	08 95       	ret

0000050e <burst_1_1_10_0_1>:
     50e:	a1 e0       	ldi	r26, 0x01	; 1
     510:	b0 e0       	ldi	r27, 0x00	; 0
     512:	ed e8       	ldi	r30, 0x8D	; 141
     514:	f2 e0       	ldi	r31, 0x02	; 2
     516:	0c 94 17 1b 	jmp	0x362e	; 0x362e <__prologue_saves__+0xc>
     51a:	e8 2f       	mov	r30, r24
     51c:	0f b7       	in	r16, 0x3f	; 63
     51e:	00 78       	andi	r16, 0x80	; 128
     520:	19 82       	std	Y+1, r1	; 0x01
     522:	80 91 1d 21 	lds	r24, 0x211D
     526:	81 30       	cpi	r24, 0x01	; 1
     528:	19 f0       	breq	.+6      	; 0x530 <burst_1_1_10_0_1+0x22>
     52a:	81 e0       	ldi	r24, 0x01	; 1
     52c:	80 93 1d 21 	sts	0x211D, r24
     530:	ce 2e       	mov	r12, r30
     532:	dd 24       	eor	r13, r13
     534:	f6 01       	movw	r30, r12
     536:	e1 5a       	subi	r30, 0xA1	; 161
     538:	fe 4d       	sbci	r31, 0xDE	; 222
     53a:	b0 80       	ld	r11, Z
     53c:	f6 01       	movw	r30, r12
     53e:	ed 59       	subi	r30, 0x9D	; 157
     540:	fe 4d       	sbci	r31, 0xDE	; 222
     542:	a0 80       	ld	r10, Z
     544:	f8 94       	cli
     546:	bb 20       	and	r11, r11
     548:	09 f4       	brne	.+2      	; 0x54c <burst_1_1_10_0_1+0x3e>
     54a:	aa c0       	rjmp	.+340    	; 0x6a0 <burst_1_1_10_0_1+0x192>
     54c:	8b 2d       	mov	r24, r11
     54e:	da df       	rcall	.-76     	; 0x504 <_1101010110_>
     550:	8b 2d       	mov	r24, r11
     552:	6a 2d       	mov	r22, r10
     554:	be df       	rcall	.-132    	; 0x4d2 <_1101010101_>
     556:	1b 2d       	mov	r17, r11
     558:	ee 24       	eor	r14, r14
     55a:	ff 24       	eor	r15, r15
     55c:	60 e0       	ldi	r22, 0x00	; 0
     55e:	81 2c       	mov	r8, r1
     560:	30 e2       	ldi	r19, 0x20	; 32
     562:	93 2e       	mov	r9, r19
     564:	f5 fe       	sbrs	r15, 5
     566:	07 c0       	rjmp	.+14     	; 0x576 <burst_1_1_10_0_1+0x68>
     568:	90 91 60 21 	lds	r25, 0x2160
     56c:	80 91 5f 21 	lds	r24, 0x215F
     570:	98 2b       	or	r25, r24
     572:	19 f5       	brne	.+70     	; 0x5ba <burst_1_1_10_0_1+0xac>
     574:	35 c0       	rjmp	.+106    	; 0x5e0 <burst_1_1_10_0_1+0xd2>
     576:	8f b7       	in	r24, 0x3f	; 63
     578:	80 2b       	or	r24, r16
     57a:	8f bf       	out	0x3f, r24	; 63
     57c:	00 00       	nop
     57e:	f8 94       	cli
     580:	8b 2d       	mov	r24, r11
     582:	6a 2d       	mov	r22, r10
     584:	41 2f       	mov	r20, r17
     586:	b0 df       	rcall	.-160    	; 0x4e8 <_1101010111_>
     588:	68 2f       	mov	r22, r24
     58a:	08 94       	sec
     58c:	e1 1c       	adc	r14, r1
     58e:	f1 1c       	adc	r15, r1
     590:	80 91 00 20 	lds	r24, 0x2000
     594:	8f 5f       	subi	r24, 0xFF	; 255
     596:	80 93 00 20 	sts	0x2000, r24
     59a:	82 30       	cpi	r24, 0x02	; 2
     59c:	30 f0       	brcs	.+12     	; 0x5aa <burst_1_1_10_0_1+0x9c>
     59e:	82 30       	cpi	r24, 0x02	; 2
     5a0:	21 f0       	breq	.+8      	; 0x5aa <burst_1_1_10_0_1+0x9c>
     5a2:	83 30       	cpi	r24, 0x03	; 3
     5a4:	11 f0       	breq	.+4      	; 0x5aa <burst_1_1_10_0_1+0x9c>
     5a6:	10 92 00 20 	sts	0x2000, r1
     5aa:	66 23       	and	r22, r22
     5ac:	d9 f2       	breq	.-74     	; 0x564 <burst_1_1_10_0_1+0x56>
     5ae:	20 91 60 21 	lds	r18, 0x2160
     5b2:	80 91 5f 21 	lds	r24, 0x215F
     5b6:	28 2b       	or	r18, r24
     5b8:	15 c0       	rjmp	.+42     	; 0x5e4 <burst_1_1_10_0_1+0xd6>
     5ba:	41 2f       	mov	r20, r17
     5bc:	80 e0       	ldi	r24, 0x00	; 0
     5be:	40 ff       	sbrs	r20, 0
     5c0:	09 c0       	rjmp	.+18     	; 0x5d4 <burst_1_1_10_0_1+0xc6>
     5c2:	e8 2f       	mov	r30, r24
     5c4:	f0 e0       	ldi	r31, 0x00	; 0
     5c6:	ee 0f       	add	r30, r30
     5c8:	ff 1f       	adc	r31, r31
     5ca:	e8 5d       	subi	r30, 0xD8	; 216
     5cc:	fe 4d       	sbci	r31, 0xDE	; 222
     5ce:	80 82       	st	Z, r8
     5d0:	91 82       	std	Z+1, r9	; 0x01
     5d2:	01 c0       	rjmp	.+2      	; 0x5d6 <burst_1_1_10_0_1+0xc8>
     5d4:	90 fd       	sbrc	r25, 0
     5d6:	8f 5f       	subi	r24, 0xFF	; 255
     5d8:	96 95       	lsr	r25
     5da:	46 95       	lsr	r20
     5dc:	99 23       	and	r25, r25
     5de:	79 f7       	brne	.-34     	; 0x5be <burst_1_1_10_0_1+0xb0>
     5e0:	10 e0       	ldi	r17, 0x00	; 0
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	8f b7       	in	r24, 0x3f	; 63
     5e6:	80 2b       	or	r24, r16
     5e8:	8f bf       	out	0x3f, r24	; 63
     5ea:	10 92 1e 21 	sts	0x211E, r1
     5ee:	22 23       	and	r18, r18
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <burst_1_1_10_0_1+0xe6>
     5f2:	3f c0       	rjmp	.+126    	; 0x672 <burst_1_1_10_0_1+0x164>
     5f4:	11 23       	and	r17, r17
     5f6:	09 f4       	brne	.+2      	; 0x5fa <burst_1_1_10_0_1+0xec>
     5f8:	3c c0       	rjmp	.+120    	; 0x672 <burst_1_1_10_0_1+0x164>
     5fa:	30 91 64 21 	lds	r19, 0x2164
     5fe:	80 91 63 21 	lds	r24, 0x2163
     602:	38 2b       	or	r19, r24
     604:	56 2f       	mov	r21, r22
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	80 e0       	ldi	r24, 0x00	; 0
     60a:	70 e0       	ldi	r23, 0x00	; 0
     60c:	40 e0       	ldi	r20, 0x00	; 0
     60e:	23 c0       	rjmp	.+70     	; 0x656 <burst_1_1_10_0_1+0x148>
     610:	50 fd       	sbrc	r21, 0
     612:	17 c0       	rjmp	.+46     	; 0x642 <burst_1_1_10_0_1+0x134>
     614:	19 c0       	rjmp	.+50     	; 0x648 <burst_1_1_10_0_1+0x13a>
     616:	30 ff       	sbrs	r19, 0
     618:	13 c0       	rjmp	.+38     	; 0x640 <burst_1_1_10_0_1+0x132>
     61a:	98 17       	cp	r25, r24
     61c:	81 f4       	brne	.+32     	; 0x63e <burst_1_1_10_0_1+0x130>
     61e:	e4 2f       	mov	r30, r20
     620:	f0 e0       	ldi	r31, 0x00	; 0
     622:	ee 0f       	add	r30, r30
     624:	ff 1f       	adc	r31, r31
     626:	e8 5d       	subi	r30, 0xD8	; 216
     628:	fe 4d       	sbci	r31, 0xDE	; 222
     62a:	e0 82       	st	Z, r14
     62c:	f1 82       	std	Z+1, r15	; 0x01
     62e:	85 2f       	mov	r24, r21
     630:	8e 7f       	andi	r24, 0xFE	; 254
     632:	19 f4       	brne	.+6      	; 0x63a <burst_1_1_10_0_1+0x12c>
     634:	89 2f       	mov	r24, r25
     636:	71 e0       	ldi	r23, 0x01	; 1
     638:	08 c0       	rjmp	.+16     	; 0x64a <burst_1_1_10_0_1+0x13c>
     63a:	89 2f       	mov	r24, r25
     63c:	06 c0       	rjmp	.+12     	; 0x64a <burst_1_1_10_0_1+0x13c>
     63e:	8f 5f       	subi	r24, 0xFF	; 255
     640:	36 95       	lsr	r19
     642:	33 23       	and	r19, r19
     644:	41 f7       	brne	.-48     	; 0x616 <burst_1_1_10_0_1+0x108>
     646:	01 c0       	rjmp	.+2      	; 0x64a <burst_1_1_10_0_1+0x13c>
     648:	20 fd       	sbrc	r18, 0
     64a:	9f 5f       	subi	r25, 0xFF	; 255
     64c:	20 fd       	sbrc	r18, 0
     64e:	4f 5f       	subi	r20, 0xFF	; 255
     650:	56 95       	lsr	r21
     652:	26 95       	lsr	r18
     654:	11 f0       	breq	.+4      	; 0x65a <burst_1_1_10_0_1+0x14c>
     656:	55 23       	and	r21, r21
     658:	d9 f6       	brne	.-74     	; 0x610 <burst_1_1_10_0_1+0x102>
     65a:	40 93 1e 21 	sts	0x211E, r20
     65e:	60 95       	com	r22
     660:	16 23       	and	r17, r22
     662:	71 30       	cpi	r23, 0x01	; 1
     664:	21 f4       	brne	.+8      	; 0x66e <burst_1_1_10_0_1+0x160>
     666:	11 23       	and	r17, r17
     668:	11 f4       	brne	.+4      	; 0x66e <burst_1_1_10_0_1+0x160>
     66a:	ee 24       	eor	r14, r14
     66c:	ff 24       	eor	r15, r15
     66e:	60 e0       	ldi	r22, 0x00	; 0
     670:	13 c0       	rjmp	.+38     	; 0x698 <burst_1_1_10_0_1+0x18a>
     672:	80 91 60 21 	lds	r24, 0x2160
     676:	90 91 5f 21 	lds	r25, 0x215F
     67a:	89 2b       	or	r24, r25
     67c:	89 83       	std	Y+1, r24	; 0x01
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	06 c0       	rjmp	.+12     	; 0x68e <burst_1_1_10_0_1+0x180>
     682:	89 81       	ldd	r24, Y+1	; 0x01
     684:	80 fd       	sbrc	r24, 0
     686:	9f 5f       	subi	r25, 0xFF	; 255
     688:	89 81       	ldd	r24, Y+1	; 0x01
     68a:	86 95       	lsr	r24
     68c:	89 83       	std	Y+1, r24	; 0x01
     68e:	89 81       	ldd	r24, Y+1	; 0x01
     690:	88 23       	and	r24, r24
     692:	b9 f7       	brne	.-18     	; 0x682 <burst_1_1_10_0_1+0x174>
     694:	90 93 1e 21 	sts	0x211E, r25
     698:	f8 94       	cli
     69a:	11 23       	and	r17, r17
     69c:	09 f0       	breq	.+2      	; 0x6a0 <burst_1_1_10_0_1+0x192>
     69e:	62 cf       	rjmp	.-316    	; 0x564 <burst_1_1_10_0_1+0x56>
     6a0:	8f e5       	ldi	r24, 0x5F	; 95
     6a2:	91 e2       	ldi	r25, 0x21	; 33
     6a4:	c8 0e       	add	r12, r24
     6a6:	d9 1e       	adc	r13, r25
     6a8:	f6 01       	movw	r30, r12
     6aa:	80 81       	ld	r24, Z
     6ac:	2b df       	rcall	.-426    	; 0x504 <_1101010110_>
     6ae:	10 92 1c 21 	sts	0x211C, r1
     6b2:	8f b7       	in	r24, 0x3f	; 63
     6b4:	08 2b       	or	r16, r24
     6b6:	0f bf       	out	0x3f, r16	; 63
     6b8:	21 96       	adiw	r28, 0x01	; 1
     6ba:	ec e0       	ldi	r30, 0x0C	; 12
     6bc:	0c 94 30 1b 	jmp	0x3660	; 0x3660 <__epilogue_restores__+0xc>

000006c0 <qt_get_library_sig>:
     6c0:	fc 01       	movw	r30, r24
     6c2:	80 e2       	ldi	r24, 0x20	; 32
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	80 83       	st	Z, r24
     6c8:	91 83       	std	Z+1, r25	; 0x01
     6ca:	12 82       	std	Z+2, r1	; 0x02
     6cc:	13 82       	std	Z+3, r1	; 0x03
     6ce:	80 e4       	ldi	r24, 0x40	; 64
     6d0:	94 e0       	ldi	r25, 0x04	; 4
     6d2:	84 83       	std	Z+4, r24	; 0x04
     6d4:	95 83       	std	Z+5, r25	; 0x05
     6d6:	08 95       	ret

000006d8 <qt_enable_key>:
     6d8:	90 91 59 21 	lds	r25, 0x2159
     6dc:	a9 2f       	mov	r26, r25
     6de:	b0 e0       	ldi	r27, 0x00	; 0
     6e0:	fd 01       	movw	r30, r26
     6e2:	ee 0f       	add	r30, r30
     6e4:	ff 1f       	adc	r31, r31
     6e6:	ea 0f       	add	r30, r26
     6e8:	fb 1f       	adc	r31, r27
     6ea:	ee 0f       	add	r30, r30
     6ec:	ff 1f       	adc	r31, r31
     6ee:	ef 5b       	subi	r30, 0xBF	; 191
     6f0:	fe 4d       	sbci	r31, 0xDE	; 222
     6f2:	43 83       	std	Z+3, r20	; 0x03
     6f4:	67 70       	andi	r22, 0x07	; 7
     6f6:	85 83       	std	Z+5, r24	; 0x05
     6f8:	23 70       	andi	r18, 0x03	; 3
     6fa:	66 0f       	add	r22, r22
     6fc:	66 0f       	add	r22, r22
     6fe:	66 0f       	add	r22, r22
     700:	26 2b       	or	r18, r22
     702:	24 83       	std	Z+4, r18	; 0x04
     704:	9f 5f       	subi	r25, 0xFF	; 255
     706:	90 93 59 21 	sts	0x2159, r25
     70a:	08 95       	ret

0000070c <qt_get_sensor_delta>:
     70c:	1f 93       	push	r17
     70e:	cf 93       	push	r28
     710:	df 93       	push	r29
     712:	28 2f       	mov	r18, r24
     714:	c8 2f       	mov	r28, r24
     716:	d0 e0       	ldi	r29, 0x00	; 0
     718:	fe 01       	movw	r30, r28
     71a:	ee 0f       	add	r30, r30
     71c:	ff 1f       	adc	r31, r31
     71e:	ec 0f       	add	r30, r28
     720:	fd 1f       	adc	r31, r29
     722:	ee 0f       	add	r30, r30
     724:	ff 1f       	adc	r31, r31
     726:	ef 5b       	subi	r30, 0xBF	; 191
     728:	fe 4d       	sbci	r31, 0xDE	; 222
     72a:	35 81       	ldd	r19, Z+5	; 0x05
     72c:	83 81       	ldd	r24, Z+3	; 0x03
     72e:	90 e0       	ldi	r25, 0x00	; 0
     730:	00 90 21 21 	lds	r0, 0x2121
     734:	02 c0       	rjmp	.+4      	; 0x73a <qt_get_sensor_delta+0x2e>
     736:	95 95       	asr	r25
     738:	87 95       	ror	r24
     73a:	0a 94       	dec	r0
     73c:	e2 f7       	brpl	.-8      	; 0x736 <qt_get_sensor_delta+0x2a>
     73e:	18 2f       	mov	r17, r24
     740:	84 30       	cpi	r24, 0x04	; 4
     742:	08 f4       	brcc	.+2      	; 0x746 <qt_get_sensor_delta+0x3a>
     744:	14 e0       	ldi	r17, 0x04	; 4
     746:	80 91 59 21 	lds	r24, 0x2159
     74a:	28 17       	cp	r18, r24
     74c:	18 f0       	brcs	.+6      	; 0x754 <qt_get_sensor_delta+0x48>
     74e:	20 e0       	ldi	r18, 0x00	; 0
     750:	30 e0       	ldi	r19, 0x00	; 0
     752:	2d c0       	rjmp	.+90     	; 0x7ae <qt_get_sensor_delta+0xa2>
     754:	83 2f       	mov	r24, r19
     756:	1d d1       	rcall	.+570    	; 0x992 <get_channel_delta>
     758:	9c 01       	movw	r18, r24
     75a:	41 2f       	mov	r20, r17
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	16 95       	lsr	r17
     760:	16 95       	lsr	r17
     762:	81 2f       	mov	r24, r17
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	84 1b       	sub	r24, r20
     768:	95 0b       	sbc	r25, r21
     76a:	82 17       	cp	r24, r18
     76c:	93 07       	cpc	r25, r19
     76e:	64 f4       	brge	.+24     	; 0x788 <qt_get_sensor_delta+0x7c>
     770:	fe 01       	movw	r30, r28
     772:	ee 0f       	add	r30, r30
     774:	ff 1f       	adc	r31, r31
     776:	ec 0f       	add	r30, r28
     778:	fd 1f       	adc	r31, r29
     77a:	ee 0f       	add	r30, r30
     77c:	ff 1f       	adc	r31, r31
     77e:	ef 5b       	subi	r30, 0xBF	; 191
     780:	fe 4d       	sbci	r31, 0xDE	; 222
     782:	84 81       	ldd	r24, Z+4	; 0x04
     784:	8b 7f       	andi	r24, 0xFB	; 251
     786:	84 83       	std	Z+4, r24	; 0x04
     788:	88 27       	eor	r24, r24
     78a:	99 27       	eor	r25, r25
     78c:	84 1b       	sub	r24, r20
     78e:	95 0b       	sbc	r25, r21
     790:	82 17       	cp	r24, r18
     792:	93 07       	cpc	r25, r19
     794:	64 f0       	brlt	.+24     	; 0x7ae <qt_get_sensor_delta+0xa2>
     796:	fe 01       	movw	r30, r28
     798:	ee 0f       	add	r30, r30
     79a:	ff 1f       	adc	r31, r31
     79c:	ec 0f       	add	r30, r28
     79e:	fd 1f       	adc	r31, r29
     7a0:	ee 0f       	add	r30, r30
     7a2:	ff 1f       	adc	r31, r31
     7a4:	ef 5b       	subi	r30, 0xBF	; 191
     7a6:	fe 4d       	sbci	r31, 0xDE	; 222
     7a8:	84 81       	ldd	r24, Z+4	; 0x04
     7aa:	84 60       	ori	r24, 0x04	; 4
     7ac:	84 83       	std	Z+4, r24	; 0x04
     7ae:	c9 01       	movw	r24, r18
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	1f 91       	pop	r17
     7b6:	08 95       	ret

000007b8 <qt_measure_sensors>:
     7b8:	ff 92       	push	r15
     7ba:	0f 93       	push	r16
     7bc:	1f 93       	push	r17
     7be:	cf 93       	push	r28
     7c0:	df 93       	push	r29
     7c2:	10 92 39 21 	sts	0x2139, r1
     7c6:	10 92 3a 21 	sts	0x213A, r1
     7ca:	20 91 3d 21 	lds	r18, 0x213D
     7ce:	30 91 3e 21 	lds	r19, 0x213E
     7d2:	80 93 3d 21 	sts	0x213D, r24
     7d6:	90 93 3e 21 	sts	0x213E, r25
     7da:	40 91 3f 21 	lds	r20, 0x213F
     7de:	50 91 40 21 	lds	r21, 0x2140
     7e2:	42 1b       	sub	r20, r18
     7e4:	53 0b       	sbc	r21, r19
     7e6:	48 0f       	add	r20, r24
     7e8:	59 1f       	adc	r21, r25
     7ea:	ff 24       	eor	r15, r15
     7ec:	03 c0       	rjmp	.+6      	; 0x7f4 <qt_measure_sensors+0x3c>
     7ee:	f3 94       	inc	r15
     7f0:	48 5c       	subi	r20, 0xC8	; 200
     7f2:	50 40       	sbci	r21, 0x00	; 0
     7f4:	48 3c       	cpi	r20, 0xC8	; 200
     7f6:	51 05       	cpc	r21, r1
     7f8:	d0 f7       	brcc	.-12     	; 0x7ee <qt_measure_sensors+0x36>
     7fa:	40 93 3f 21 	sts	0x213F, r20
     7fe:	50 93 40 21 	sts	0x2140, r21
     802:	80 91 5a 21 	lds	r24, 0x215A
     806:	88 23       	and	r24, r24
     808:	41 f0       	breq	.+16     	; 0x81a <qt_measure_sensors+0x62>
     80a:	8f 15       	cp	r24, r15
     80c:	18 f4       	brcc	.+6      	; 0x814 <qt_measure_sensors+0x5c>
     80e:	10 92 5a 21 	sts	0x215A, r1
     812:	03 c0       	rjmp	.+6      	; 0x81a <qt_measure_sensors+0x62>
     814:	8f 19       	sub	r24, r15
     816:	80 93 5a 21 	sts	0x215A, r24
     81a:	c3 d3       	rcall	.+1926   	; 0xfa2 <burst>
     81c:	e0 91 3b 21 	lds	r30, 0x213B
     820:	f0 91 3c 21 	lds	r31, 0x213C
     824:	30 97       	sbiw	r30, 0x00	; 0
     826:	09 f0       	breq	.+2      	; 0x82a <qt_measure_sensors+0x72>
     828:	19 95       	eicall
     82a:	10 e0       	ldi	r17, 0x00	; 0
     82c:	00 e0       	ldi	r16, 0x00	; 0
     82e:	05 c0       	rjmp	.+10     	; 0x83a <qt_measure_sensors+0x82>
     830:	81 2f       	mov	r24, r17
     832:	6f 2d       	mov	r22, r15
     834:	c3 d0       	rcall	.+390    	; 0x9bc <process_sensor>
     836:	08 2b       	or	r16, r24
     838:	1f 5f       	subi	r17, 0xFF	; 255
     83a:	60 91 59 21 	lds	r22, 0x2159
     83e:	16 17       	cp	r17, r22
     840:	b8 f3       	brcs	.-18     	; 0x830 <qt_measure_sensors+0x78>
     842:	00 23       	and	r16, r16
     844:	49 f0       	breq	.+18     	; 0x858 <qt_measure_sensors+0xa0>
     846:	80 91 39 21 	lds	r24, 0x2139
     84a:	90 91 3a 21 	lds	r25, 0x213A
     84e:	91 60       	ori	r25, 0x01	; 1
     850:	80 93 39 21 	sts	0x2139, r24
     854:	90 93 3a 21 	sts	0x213A, r25
     858:	10 92 38 21 	sts	0x2138, r1
     85c:	a1 e4       	ldi	r26, 0x41	; 65
     85e:	b1 e2       	ldi	r27, 0x21	; 33
     860:	30 e0       	ldi	r19, 0x00	; 0
     862:	41 e0       	ldi	r20, 0x01	; 1
     864:	50 e0       	ldi	r21, 0x00	; 0
     866:	17 c0       	rjmp	.+46     	; 0x896 <qt_measure_sensors+0xde>
     868:	8c 91       	ld	r24, X
     86a:	88 71       	andi	r24, 0x18	; 24
     86c:	91 f0       	breq	.+36     	; 0x892 <qt_measure_sensors+0xda>
     86e:	e3 2f       	mov	r30, r19
     870:	e6 95       	lsr	r30
     872:	e6 95       	lsr	r30
     874:	e6 95       	lsr	r30
     876:	f0 e0       	ldi	r31, 0x00	; 0
     878:	e8 5d       	subi	r30, 0xD8	; 216
     87a:	fe 4d       	sbci	r31, 0xDE	; 222
     87c:	83 2f       	mov	r24, r19
     87e:	87 70       	andi	r24, 0x07	; 7
     880:	ea 01       	movw	r28, r20
     882:	02 c0       	rjmp	.+4      	; 0x888 <qt_measure_sensors+0xd0>
     884:	cc 0f       	add	r28, r28
     886:	dd 1f       	adc	r29, r29
     888:	8a 95       	dec	r24
     88a:	e2 f7       	brpl	.-8      	; 0x884 <qt_measure_sensors+0xcc>
     88c:	20 89       	ldd	r18, Z+16	; 0x10
     88e:	2c 2b       	or	r18, r28
     890:	20 8b       	std	Z+16, r18	; 0x10
     892:	3f 5f       	subi	r19, 0xFF	; 255
     894:	16 96       	adiw	r26, 0x06	; 6
     896:	36 17       	cp	r19, r22
     898:	38 f3       	brcs	.-50     	; 0x868 <qt_measure_sensors+0xb0>
     89a:	80 91 39 21 	lds	r24, 0x2139
     89e:	90 91 3a 21 	lds	r25, 0x213A
     8a2:	cd b7       	in	r28, 0x3d	; 61
     8a4:	de b7       	in	r29, 0x3e	; 62
     8a6:	e5 e0       	ldi	r30, 0x05	; 5
     8a8:	0c 94 37 1b 	jmp	0x366e	; 0x366e <__epilogue_restores__+0x1a>

000008ac <qt_reset_sensing>:
     8ac:	10 92 59 21 	sts	0x2159, r1
     8b0:	84 e0       	ldi	r24, 0x04	; 4
     8b2:	80 93 22 21 	sts	0x2122, r24
     8b6:	94 e1       	ldi	r25, 0x14	; 20
     8b8:	90 93 25 21 	sts	0x2125, r25
     8bc:	85 e0       	ldi	r24, 0x05	; 5
     8be:	80 93 26 21 	sts	0x2126, r24
     8c2:	10 92 24 21 	sts	0x2124, r1
     8c6:	90 93 23 21 	sts	0x2123, r25
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	80 93 21 21 	sts	0x2121, r24
     8d0:	83 e0       	ldi	r24, 0x03	; 3
     8d2:	80 93 27 21 	sts	0x2127, r24
     8d6:	54 d3       	rcall	.+1704   	; 0xf80 <burst_reset>
     8d8:	10 92 3b 21 	sts	0x213B, r1
     8dc:	10 92 3c 21 	sts	0x213C, r1
     8e0:	08 95       	ret

000008e2 <qt_calibrate_sensing>:
     8e2:	1f 93       	push	r17
     8e4:	10 e0       	ldi	r17, 0x00	; 0
     8e6:	03 c0       	rjmp	.+6      	; 0x8ee <qt_calibrate_sensing+0xc>
     8e8:	81 2f       	mov	r24, r17
     8ea:	27 d0       	rcall	.+78     	; 0x93a <start_cal_sensor>
     8ec:	1f 5f       	subi	r17, 0xFF	; 255
     8ee:	80 91 59 21 	lds	r24, 0x2159
     8f2:	18 17       	cp	r17, r24
     8f4:	c8 f3       	brcs	.-14     	; 0x8e8 <qt_calibrate_sensing+0x6>
     8f6:	1f 91       	pop	r17
     8f8:	08 95       	ret

000008fa <qt_init_sensing_with_burst>:
     8fa:	ef 92       	push	r14
     8fc:	ff 92       	push	r15
     8fe:	1f 93       	push	r17
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
     904:	ec 01       	movw	r28, r24
     906:	7b 01       	movw	r14, r22
     908:	10 e0       	ldi	r17, 0x00	; 0
     90a:	03 c0       	rjmp	.+6      	; 0x912 <qt_init_sensing_with_burst+0x18>
     90c:	81 2f       	mov	r24, r17
     90e:	15 d0       	rcall	.+42     	; 0x93a <start_cal_sensor>
     910:	1f 5f       	subi	r17, 0xFF	; 255
     912:	80 91 59 21 	lds	r24, 0x2159
     916:	18 17       	cp	r17, r24
     918:	c8 f3       	brcs	.-14     	; 0x90c <qt_init_sensing_with_burst+0x12>
     91a:	10 92 3d 21 	sts	0x213D, r1
     91e:	10 92 3e 21 	sts	0x213E, r1
     922:	c0 93 1f 21 	sts	0x211F, r28
     926:	d0 93 20 21 	sts	0x2120, r29
     92a:	c7 01       	movw	r24, r14
     92c:	24 d3       	rcall	.+1608   	; 0xf76 <burst_init>
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	1f 91       	pop	r17
     934:	ff 90       	pop	r15
     936:	ef 90       	pop	r14
     938:	08 95       	ret

0000093a <start_cal_sensor>:
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	e1 e4       	ldi	r30, 0x41	; 65
     93e:	f1 e2       	ldi	r31, 0x21	; 33
     940:	9c 01       	movw	r18, r24
     942:	22 0f       	add	r18, r18
     944:	33 1f       	adc	r19, r19
     946:	28 0f       	add	r18, r24
     948:	39 1f       	adc	r19, r25
     94a:	d9 01       	movw	r26, r18
     94c:	aa 0f       	add	r26, r26
     94e:	bb 1f       	adc	r27, r27
     950:	ae 0f       	add	r26, r30
     952:	bf 1f       	adc	r27, r31
     954:	15 96       	adiw	r26, 0x05	; 5
     956:	4c 91       	ld	r20, X
     958:	15 97       	sbiw	r26, 0x05	; 5
     95a:	80 91 39 21 	lds	r24, 0x2139
     95e:	90 91 3a 21 	lds	r25, 0x213A
     962:	82 60       	ori	r24, 0x02	; 2
     964:	80 93 39 21 	sts	0x2139, r24
     968:	90 93 3a 21 	sts	0x213A, r25
     96c:	2f 5f       	subi	r18, 0xFF	; 255
     96e:	3f 4f       	sbci	r19, 0xFF	; 255
     970:	22 0f       	add	r18, r18
     972:	33 1f       	adc	r19, r19
     974:	e2 0f       	add	r30, r18
     976:	f3 1f       	adc	r31, r19
     978:	10 82       	st	Z, r1
     97a:	eb e5       	ldi	r30, 0x5B	; 91
     97c:	f1 e2       	ldi	r31, 0x21	; 33
     97e:	e4 0f       	add	r30, r20
     980:	f1 1d       	adc	r31, r1
     982:	80 e8       	ldi	r24, 0x80	; 128
     984:	80 83       	st	Z, r24
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	8c 93       	st	X, r24
     98a:	8f e0       	ldi	r24, 0x0F	; 15
     98c:	11 96       	adiw	r26, 0x01	; 1
     98e:	8c 93       	st	X, r24
     990:	08 95       	ret

00000992 <get_channel_delta>:
     992:	90 e0       	ldi	r25, 0x00	; 0
     994:	fc 01       	movw	r30, r24
     996:	34 96       	adiw	r30, 0x04	; 4
     998:	a8 e2       	ldi	r26, 0x28	; 40
     99a:	b1 e2       	ldi	r27, 0x21	; 33
     99c:	ee 0f       	add	r30, r30
     99e:	ff 1f       	adc	r31, r31
     9a0:	ea 0f       	add	r30, r26
     9a2:	fb 1f       	adc	r31, r27
     9a4:	88 0f       	add	r24, r24
     9a6:	99 1f       	adc	r25, r25
     9a8:	a8 0f       	add	r26, r24
     9aa:	b9 1f       	adc	r27, r25
     9ac:	20 81       	ld	r18, Z
     9ae:	31 81       	ldd	r19, Z+1	; 0x01
     9b0:	8d 91       	ld	r24, X+
     9b2:	9c 91       	ld	r25, X
     9b4:	28 1b       	sub	r18, r24
     9b6:	39 0b       	sbc	r19, r25
     9b8:	c9 01       	movw	r24, r18
     9ba:	08 95       	ret

000009bc <process_sensor>:
     9bc:	a0 e0       	ldi	r26, 0x00	; 0
     9be:	b0 e0       	ldi	r27, 0x00	; 0
     9c0:	e4 ee       	ldi	r30, 0xE4	; 228
     9c2:	f4 e0       	ldi	r31, 0x04	; 4
     9c4:	0c 94 15 1b 	jmp	0x362a	; 0x362a <__prologue_saves__+0x8>
     9c8:	78 2e       	mov	r7, r24
     9ca:	f6 2e       	mov	r15, r22
     9cc:	9f de       	rcall	.-706    	; 0x70c <qt_get_sensor_delta>
     9ce:	5c 01       	movw	r10, r24
     9d0:	07 2d       	mov	r16, r7
     9d2:	10 e0       	ldi	r17, 0x00	; 0
     9d4:	f8 01       	movw	r30, r16
     9d6:	ee 0f       	add	r30, r30
     9d8:	ff 1f       	adc	r31, r31
     9da:	e0 0f       	add	r30, r16
     9dc:	f1 1f       	adc	r31, r17
     9de:	ee 0f       	add	r30, r30
     9e0:	ff 1f       	adc	r31, r31
     9e2:	ef 5b       	subi	r30, 0xBF	; 191
     9e4:	fe 4d       	sbci	r31, 0xDE	; 222
     9e6:	54 81       	ldd	r21, Z+4	; 0x04
     9e8:	43 81       	ldd	r20, Z+3	; 0x03
     9ea:	24 2f       	mov	r18, r20
     9ec:	30 e0       	ldi	r19, 0x00	; 0
     9ee:	85 2f       	mov	r24, r21
     9f0:	83 70       	andi	r24, 0x03	; 3
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	01 96       	adiw	r24, 0x01	; 1
     9f6:	02 c0       	rjmp	.+4      	; 0x9fc <process_sensor+0x40>
     9f8:	35 95       	asr	r19
     9fa:	27 95       	ror	r18
     9fc:	8a 95       	dec	r24
     9fe:	e2 f7       	brpl	.-8      	; 0x9f8 <process_sensor+0x3c>
     a00:	82 2f       	mov	r24, r18
     a02:	22 30       	cpi	r18, 0x02	; 2
     a04:	08 f4       	brcc	.+2      	; 0xa08 <process_sensor+0x4c>
     a06:	82 e0       	ldi	r24, 0x02	; 2
     a08:	24 2f       	mov	r18, r20
     a0a:	30 e0       	ldi	r19, 0x00	; 0
     a0c:	b9 01       	movw	r22, r18
     a0e:	68 1b       	sub	r22, r24
     a10:	71 09       	sbc	r23, r1
     a12:	f8 01       	movw	r30, r16
     a14:	ee 0f       	add	r30, r30
     a16:	ff 1f       	adc	r31, r31
     a18:	e0 0f       	add	r30, r16
     a1a:	f1 1f       	adc	r31, r17
     a1c:	ef 01       	movw	r28, r30
     a1e:	cc 0f       	add	r28, r28
     a20:	dd 1f       	adc	r29, r29
     a22:	cf 5b       	subi	r28, 0xBF	; 191
     a24:	de 4d       	sbci	r29, 0xDE	; 222
     a26:	88 81       	ld	r24, Y
     a28:	84 30       	cpi	r24, 0x04	; 4
     a2a:	09 f4       	brne	.+2      	; 0xa2e <process_sensor+0x72>
     a2c:	fb c0       	rjmp	.+502    	; 0xc24 <process_sensor+0x268>
     a2e:	85 30       	cpi	r24, 0x05	; 5
     a30:	30 f4       	brcc	.+12     	; 0xa3e <process_sensor+0x82>
     a32:	81 30       	cpi	r24, 0x01	; 1
     a34:	71 f0       	breq	.+28     	; 0xa52 <process_sensor+0x96>
     a36:	82 30       	cpi	r24, 0x02	; 2
     a38:	09 f0       	breq	.+2      	; 0xa3c <process_sensor+0x80>
     a3a:	96 c2       	rjmp	.+1324   	; 0xf68 <process_sensor+0x5ac>
     a3c:	6e c0       	rjmp	.+220    	; 0xb1a <process_sensor+0x15e>
     a3e:	80 31       	cpi	r24, 0x10	; 16
     a40:	09 f4       	brne	.+2      	; 0xa44 <process_sensor+0x88>
     a42:	a5 c1       	rjmp	.+842    	; 0xd8e <process_sensor+0x3d2>
     a44:	80 32       	cpi	r24, 0x20	; 32
     a46:	09 f4       	brne	.+2      	; 0xa4a <process_sensor+0x8e>
     a48:	56 c2       	rjmp	.+1196   	; 0xef6 <process_sensor+0x53a>
     a4a:	88 30       	cpi	r24, 0x08	; 8
     a4c:	09 f0       	breq	.+2      	; 0xa50 <process_sensor+0x94>
     a4e:	8c c2       	rjmp	.+1304   	; 0xf68 <process_sensor+0x5ac>
     a50:	02 c2       	rjmp	.+1028   	; 0xe56 <process_sensor+0x49a>
     a52:	40 91 39 21 	lds	r20, 0x2139
     a56:	50 91 3a 21 	lds	r21, 0x213A
     a5a:	ca 01       	movw	r24, r20
     a5c:	92 60       	ori	r25, 0x02	; 2
     a5e:	80 93 39 21 	sts	0x2139, r24
     a62:	90 93 3a 21 	sts	0x213A, r25
     a66:	8d 81       	ldd	r24, Y+5	; 0x05
     a68:	69 81       	ldd	r22, Y+1	; 0x01
     a6a:	a8 2f       	mov	r26, r24
     a6c:	b0 e0       	ldi	r27, 0x00	; 0
     a6e:	6a 30       	cpi	r22, 0x0A	; 10
     a70:	60 f0       	brcs	.+24     	; 0xa8a <process_sensor+0xce>
     a72:	aa 0f       	add	r26, r26
     a74:	bb 1f       	adc	r27, r27
     a76:	fd 01       	movw	r30, r26
     a78:	e8 5d       	subi	r30, 0xD8	; 216
     a7a:	fe 4d       	sbci	r31, 0xDE	; 222
     a7c:	80 81       	ld	r24, Z
     a7e:	91 81       	ldd	r25, Z+1	; 0x01
     a80:	a0 5d       	subi	r26, 0xD0	; 208
     a82:	be 4d       	sbci	r27, 0xDE	; 222
     a84:	8d 93       	st	X+, r24
     a86:	9c 93       	st	X, r25
     a88:	18 c0       	rjmp	.+48     	; 0xaba <process_sensor+0xfe>
     a8a:	aa 0f       	add	r26, r26
     a8c:	bb 1f       	adc	r27, r27
     a8e:	fd 01       	movw	r30, r26
     a90:	e0 5d       	subi	r30, 0xD0	; 208
     a92:	fe 4d       	sbci	r31, 0xDE	; 222
     a94:	20 81       	ld	r18, Z
     a96:	31 81       	ldd	r19, Z+1	; 0x01
     a98:	a8 5d       	subi	r26, 0xD8	; 216
     a9a:	be 4d       	sbci	r27, 0xDE	; 222
     a9c:	8d 91       	ld	r24, X+
     a9e:	9c 91       	ld	r25, X
     aa0:	82 17       	cp	r24, r18
     aa2:	93 07       	cpc	r25, r19
     aa4:	18 f4       	brcc	.+6      	; 0xaac <process_sensor+0xf0>
     aa6:	21 50       	subi	r18, 0x01	; 1
     aa8:	30 40       	sbci	r19, 0x00	; 0
     aaa:	05 c0       	rjmp	.+10     	; 0xab6 <process_sensor+0xfa>
     aac:	28 17       	cp	r18, r24
     aae:	39 07       	cpc	r19, r25
     ab0:	50 f4       	brcc	.+20     	; 0xac6 <process_sensor+0x10a>
     ab2:	2f 5f       	subi	r18, 0xFF	; 255
     ab4:	3f 4f       	sbci	r19, 0xFF	; 255
     ab6:	20 83       	st	Z, r18
     ab8:	31 83       	std	Z+1, r19	; 0x01
     aba:	48 60       	ori	r20, 0x08	; 8
     abc:	52 60       	ori	r21, 0x02	; 2
     abe:	40 93 39 21 	sts	0x2139, r20
     ac2:	50 93 3a 21 	sts	0x213A, r21
     ac6:	86 2f       	mov	r24, r22
     ac8:	81 50       	subi	r24, 0x01	; 1
     aca:	f8 01       	movw	r30, r16
     acc:	ee 0f       	add	r30, r30
     ace:	ff 1f       	adc	r31, r31
     ad0:	e0 0f       	add	r30, r16
     ad2:	f1 1f       	adc	r31, r17
     ad4:	ef 01       	movw	r28, r30
     ad6:	cc 0f       	add	r28, r28
     ad8:	dd 1f       	adc	r29, r29
     ada:	cf 5b       	subi	r28, 0xBF	; 191
     adc:	de 4d       	sbci	r29, 0xDE	; 222
     ade:	89 83       	std	Y+1, r24	; 0x01
     ae0:	88 23       	and	r24, r24
     ae2:	b1 f4       	brne	.+44     	; 0xb10 <process_sensor+0x154>
     ae4:	ad 81       	ldd	r26, Y+5	; 0x05
     ae6:	82 e0       	ldi	r24, 0x02	; 2
     ae8:	88 83       	st	Y, r24
     aea:	80 91 39 21 	lds	r24, 0x2139
     aee:	90 91 3a 21 	lds	r25, 0x213A
     af2:	82 60       	ori	r24, 0x02	; 2
     af4:	80 93 39 21 	sts	0x2139, r24
     af8:	90 93 3a 21 	sts	0x213A, r25
     afc:	ee 0f       	add	r30, r30
     afe:	ff 1f       	adc	r31, r31
     b00:	ed 5b       	subi	r30, 0xBD	; 189
     b02:	fe 4d       	sbci	r31, 0xDE	; 222
     b04:	10 82       	st	Z, r1
     b06:	b0 e0       	ldi	r27, 0x00	; 0
     b08:	a5 5a       	subi	r26, 0xA5	; 165
     b0a:	be 4d       	sbci	r27, 0xDE	; 222
     b0c:	80 e8       	ldi	r24, 0x80	; 128
     b0e:	8c 93       	st	X, r24
     b10:	80 91 23 21 	lds	r24, 0x2123
     b14:	80 93 5a 21 	sts	0x215A, r24
     b18:	25 c2       	rjmp	.+1098   	; 0xf64 <process_sensor+0x5a8>
     b1a:	52 ff       	sbrs	r21, 2
     b1c:	08 c0       	rjmp	.+16     	; 0xb2e <process_sensor+0x172>
     b1e:	ed 81       	ldd	r30, Y+5	; 0x05
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	e5 5a       	subi	r30, 0xA5	; 165
     b24:	fe 4d       	sbci	r31, 0xDE	; 222
     b26:	10 82       	st	Z, r1
     b28:	80 e2       	ldi	r24, 0x20	; 32
     b2a:	88 83       	st	Y, r24
     b2c:	0c c2       	rjmp	.+1048   	; 0xf46 <process_sensor+0x58a>
     b2e:	c5 01       	movw	r24, r10
     b30:	b7 fe       	sbrs	r11, 7
     b32:	02 c0       	rjmp	.+4      	; 0xb38 <process_sensor+0x17c>
     b34:	80 e0       	ldi	r24, 0x00	; 0
     b36:	90 e0       	ldi	r25, 0x00	; 0
     b38:	82 17       	cp	r24, r18
     b3a:	93 07       	cpc	r25, r19
     b3c:	80 f0       	brcs	.+32     	; 0xb5e <process_sensor+0x1a2>
     b3e:	f8 01       	movw	r30, r16
     b40:	ee 0f       	add	r30, r30
     b42:	ff 1f       	adc	r31, r31
     b44:	e0 0f       	add	r30, r16
     b46:	f1 1f       	adc	r31, r17
     b48:	ee 0f       	add	r30, r30
     b4a:	ff 1f       	adc	r31, r31
     b4c:	df 01       	movw	r26, r30
     b4e:	af 5b       	subi	r26, 0xBF	; 191
     b50:	be 4d       	sbci	r27, 0xDE	; 222
     b52:	84 e0       	ldi	r24, 0x04	; 4
     b54:	8c 93       	st	X, r24
     b56:	ed 5b       	subi	r30, 0xBD	; 189
     b58:	fe 4d       	sbci	r31, 0xDE	; 222
     b5a:	10 82       	st	Z, r1
     b5c:	fa c1       	rjmp	.+1012   	; 0xf52 <process_sensor+0x596>
     b5e:	ff 20       	and	r15, r15
     b60:	09 f4       	brne	.+2      	; 0xb64 <process_sensor+0x1a8>
     b62:	02 c2       	rjmp	.+1028   	; 0xf68 <process_sensor+0x5ac>
     b64:	80 91 5a 21 	lds	r24, 0x215A
     b68:	88 23       	and	r24, r24
     b6a:	09 f0       	breq	.+2      	; 0xb6e <process_sensor+0x1b2>
     b6c:	fd c1       	rjmp	.+1018   	; 0xf68 <process_sensor+0x5ac>
     b6e:	f8 01       	movw	r30, r16
     b70:	ee 0f       	add	r30, r30
     b72:	ff 1f       	adc	r31, r31
     b74:	e0 0f       	add	r30, r16
     b76:	f1 1f       	adc	r31, r17
     b78:	ee 0f       	add	r30, r30
     b7a:	ff 1f       	adc	r31, r31
     b7c:	ef 5b       	subi	r30, 0xBF	; 191
     b7e:	fe 4d       	sbci	r31, 0xDE	; 222
     b80:	85 81       	ldd	r24, Z+5	; 0x05
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	ec 01       	movw	r28, r24
     b86:	cc 0f       	add	r28, r28
     b88:	dd 1f       	adc	r29, r29
     b8a:	c0 5d       	subi	r28, 0xD0	; 208
     b8c:	de 4d       	sbci	r29, 0xDE	; 222
     b8e:	28 81       	ld	r18, Y
     b90:	39 81       	ldd	r19, Y+1	; 0x01
     b92:	fc 01       	movw	r30, r24
     b94:	ee 0f       	add	r30, r30
     b96:	ff 1f       	adc	r31, r31
     b98:	e8 5d       	subi	r30, 0xD8	; 216
     b9a:	fe 4d       	sbci	r31, 0xDE	; 222
     b9c:	01 90       	ld	r0, Z+
     b9e:	f0 81       	ld	r31, Z
     ba0:	e0 2d       	mov	r30, r0
     ba2:	2e 17       	cp	r18, r30
     ba4:	3f 07       	cpc	r19, r31
     ba6:	88 f4       	brcc	.+34     	; 0xbca <process_sensor+0x20e>
     ba8:	fc 01       	movw	r30, r24
     baa:	e5 5a       	subi	r30, 0xA5	; 165
     bac:	fe 4d       	sbci	r31, 0xDE	; 222
     bae:	90 81       	ld	r25, Z
     bb0:	9f 0d       	add	r25, r15
     bb2:	90 83       	st	Z, r25
     bb4:	80 91 26 21 	lds	r24, 0x2126
     bb8:	80 58       	subi	r24, 0x80	; 128
     bba:	98 17       	cp	r25, r24
     bbc:	08 f4       	brcc	.+2      	; 0xbc0 <process_sensor+0x204>
     bbe:	d4 c1       	rjmp	.+936    	; 0xf68 <process_sensor+0x5ac>
     bc0:	80 e8       	ldi	r24, 0x80	; 128
     bc2:	80 83       	st	Z, r24
     bc4:	2f 5f       	subi	r18, 0xFF	; 255
     bc6:	3f 4f       	sbci	r19, 0xFF	; 255
     bc8:	14 c0       	rjmp	.+40     	; 0xbf2 <process_sensor+0x236>
     bca:	dc 01       	movw	r26, r24
     bcc:	a5 5a       	subi	r26, 0xA5	; 165
     bce:	be 4d       	sbci	r27, 0xDE	; 222
     bd0:	e2 17       	cp	r30, r18
     bd2:	f3 07       	cpc	r31, r19
     bd4:	d0 f4       	brcc	.+52     	; 0xc0a <process_sensor+0x24e>
     bd6:	8c 91       	ld	r24, X
     bd8:	8f 19       	sub	r24, r15
     bda:	8c 93       	st	X, r24
     bdc:	40 e8       	ldi	r20, 0x80	; 128
     bde:	90 91 25 21 	lds	r25, 0x2125
     be2:	54 2f       	mov	r21, r20
     be4:	59 1b       	sub	r21, r25
     be6:	58 17       	cp	r21, r24
     be8:	08 f4       	brcc	.+2      	; 0xbec <process_sensor+0x230>
     bea:	be c1       	rjmp	.+892    	; 0xf68 <process_sensor+0x5ac>
     bec:	4c 93       	st	X, r20
     bee:	21 50       	subi	r18, 0x01	; 1
     bf0:	30 40       	sbci	r19, 0x00	; 0
     bf2:	28 83       	st	Y, r18
     bf4:	39 83       	std	Y+1, r19	; 0x01
     bf6:	80 91 39 21 	lds	r24, 0x2139
     bfa:	90 91 3a 21 	lds	r25, 0x213A
     bfe:	88 60       	ori	r24, 0x08	; 8
     c00:	80 93 39 21 	sts	0x2139, r24
     c04:	90 93 3a 21 	sts	0x213A, r25
     c08:	af c1       	rjmp	.+862    	; 0xf68 <process_sensor+0x5ac>
     c0a:	2c 91       	ld	r18, X
     c0c:	21 38       	cpi	r18, 0x81	; 129
     c0e:	10 f0       	brcs	.+4      	; 0xc14 <process_sensor+0x258>
     c10:	21 50       	subi	r18, 0x01	; 1
     c12:	2c 93       	st	X, r18
     c14:	fc 01       	movw	r30, r24
     c16:	e5 5a       	subi	r30, 0xA5	; 165
     c18:	fe 4d       	sbci	r31, 0xDE	; 222
     c1a:	80 81       	ld	r24, Z
     c1c:	87 fd       	sbrc	r24, 7
     c1e:	a4 c1       	rjmp	.+840    	; 0xf68 <process_sensor+0x5ac>
     c20:	8f 5f       	subi	r24, 0xFF	; 255
     c22:	67 c1       	rjmp	.+718    	; 0xef2 <process_sensor+0x536>
     c24:	c5 01       	movw	r24, r10
     c26:	b7 fe       	sbrs	r11, 7
     c28:	02 c0       	rjmp	.+4      	; 0xc2e <process_sensor+0x272>
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	90 e0       	ldi	r25, 0x00	; 0
     c2e:	f8 01       	movw	r30, r16
     c30:	ee 0f       	add	r30, r30
     c32:	ff 1f       	adc	r31, r31
     c34:	82 17       	cp	r24, r18
     c36:	93 07       	cpc	r25, r19
     c38:	08 f4       	brcc	.+2      	; 0xc3c <process_sensor+0x280>
     c3a:	8f c0       	rjmp	.+286    	; 0xd5a <process_sensor+0x39e>
     c3c:	80 91 23 21 	lds	r24, 0x2123
     c40:	80 93 5a 21 	sts	0x215A, r24
     c44:	9f 01       	movw	r18, r30
     c46:	20 0f       	add	r18, r16
     c48:	31 1f       	adc	r19, r17
     c4a:	22 0f       	add	r18, r18
     c4c:	33 1f       	adc	r19, r19
     c4e:	d9 01       	movw	r26, r18
     c50:	ad 5b       	subi	r26, 0xBD	; 189
     c52:	be 4d       	sbci	r27, 0xDE	; 222
     c54:	8c 91       	ld	r24, X
     c56:	8f 5f       	subi	r24, 0xFF	; 255
     c58:	8c 93       	st	X, r24
     c5a:	f9 01       	movw	r30, r18
     c5c:	ef 5b       	subi	r30, 0xBF	; 191
     c5e:	fe 4d       	sbci	r31, 0xDE	; 222
     c60:	84 81       	ldd	r24, Z+4	; 0x04
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	88 73       	andi	r24, 0x38	; 56
     c66:	90 70       	andi	r25, 0x00	; 0
     c68:	23 e0       	ldi	r18, 0x03	; 3
     c6a:	96 95       	lsr	r25
     c6c:	87 95       	ror	r24
     c6e:	2a 95       	dec	r18
     c70:	e1 f7       	brne	.-8      	; 0xc6a <process_sensor+0x2ae>
     c72:	68 2e       	mov	r6, r24
     c74:	88 23       	and	r24, r24
     c76:	09 f4       	brne	.+2      	; 0xc7a <process_sensor+0x2be>
     c78:	3e c0       	rjmp	.+124    	; 0xcf6 <process_sensor+0x33a>
     c7a:	cc 24       	eor	r12, r12
     c7c:	dd 24       	eor	r13, r13
     c7e:	7f 01       	movw	r14, r30
     c80:	83 e0       	ldi	r24, 0x03	; 3
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	e8 0e       	add	r14, r24
     c86:	f9 1e       	adc	r15, r25
     c88:	4d 01       	movw	r8, r26
     c8a:	2f c0       	rjmp	.+94     	; 0xcea <process_sensor+0x32e>
     c8c:	d7 14       	cp	r13, r7
     c8e:	61 f1       	breq	.+88     	; 0xce8 <process_sensor+0x32c>
     c90:	8d 2d       	mov	r24, r13
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	ec 01       	movw	r28, r24
     c96:	cc 0f       	add	r28, r28
     c98:	dd 1f       	adc	r29, r29
     c9a:	c8 0f       	add	r28, r24
     c9c:	d9 1f       	adc	r29, r25
     c9e:	cc 0f       	add	r28, r28
     ca0:	dd 1f       	adc	r29, r29
     ca2:	cf 5b       	subi	r28, 0xBF	; 191
     ca4:	de 4d       	sbci	r29, 0xDE	; 222
     ca6:	8c 81       	ldd	r24, Y+4	; 0x04
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	88 73       	andi	r24, 0x38	; 56
     cac:	90 70       	andi	r25, 0x00	; 0
     cae:	73 e0       	ldi	r23, 0x03	; 3
     cb0:	96 95       	lsr	r25
     cb2:	87 95       	ror	r24
     cb4:	7a 95       	dec	r23
     cb6:	e1 f7       	brne	.-8      	; 0xcb0 <process_sensor+0x2f4>
     cb8:	68 16       	cp	r6, r24
     cba:	b1 f4       	brne	.+44     	; 0xce8 <process_sensor+0x32c>
     cbc:	8d 2d       	mov	r24, r13
     cbe:	26 dd       	rcall	.-1460   	; 0x70c <qt_get_sensor_delta>
     cc0:	2b 81       	ldd	r18, Y+3	; 0x03
     cc2:	82 1b       	sub	r24, r18
     cc4:	91 09       	sbc	r25, r1
     cc6:	f7 01       	movw	r30, r14
     cc8:	20 81       	ld	r18, Z
     cca:	a5 01       	movw	r20, r10
     ccc:	42 1b       	sub	r20, r18
     cce:	51 09       	sbc	r21, r1
     cd0:	48 17       	cp	r20, r24
     cd2:	59 07       	cpc	r21, r25
     cd4:	2c f0       	brlt	.+10     	; 0xce0 <process_sensor+0x324>
     cd6:	88 81       	ld	r24, Y
     cd8:	80 31       	cpi	r24, 0x10	; 16
     cda:	11 f0       	breq	.+4      	; 0xce0 <process_sensor+0x324>
     cdc:	88 30       	cpi	r24, 0x08	; 8
     cde:	21 f4       	brne	.+8      	; 0xce8 <process_sensor+0x32c>
     ce0:	f4 01       	movw	r30, r8
     ce2:	10 82       	st	Z, r1
     ce4:	cc 24       	eor	r12, r12
     ce6:	c3 94       	inc	r12
     ce8:	d3 94       	inc	r13
     cea:	80 91 59 21 	lds	r24, 0x2159
     cee:	d8 16       	cp	r13, r24
     cf0:	68 f2       	brcs	.-102    	; 0xc8c <process_sensor+0x2d0>
     cf2:	cc 20       	and	r12, r12
     cf4:	79 f4       	brne	.+30     	; 0xd14 <process_sensor+0x358>
     cf6:	80 91 22 21 	lds	r24, 0x2122
     cfa:	88 23       	and	r24, r24
     cfc:	59 f0       	breq	.+22     	; 0xd14 <process_sensor+0x358>
     cfe:	80 91 39 21 	lds	r24, 0x2139
     d02:	90 91 3a 21 	lds	r25, 0x213A
     d06:	98 60       	ori	r25, 0x08	; 8
     d08:	80 93 39 21 	sts	0x2139, r24
     d0c:	90 93 3a 21 	sts	0x213A, r25
     d10:	41 e0       	ldi	r20, 0x01	; 1
     d12:	01 c0       	rjmp	.+2      	; 0xd16 <process_sensor+0x35a>
     d14:	40 e0       	ldi	r20, 0x00	; 0
     d16:	98 01       	movw	r18, r16
     d18:	22 0f       	add	r18, r18
     d1a:	33 1f       	adc	r19, r19
     d1c:	20 0f       	add	r18, r16
     d1e:	31 1f       	adc	r19, r17
     d20:	f9 01       	movw	r30, r18
     d22:	ee 0f       	add	r30, r30
     d24:	ff 1f       	adc	r31, r31
     d26:	ed 5b       	subi	r30, 0xBD	; 189
     d28:	fe 4d       	sbci	r31, 0xDE	; 222
     d2a:	90 81       	ld	r25, Z
     d2c:	80 91 22 21 	lds	r24, 0x2122
     d30:	98 17       	cp	r25, r24
     d32:	08 f4       	brcc	.+2      	; 0xd36 <process_sensor+0x37a>
     d34:	1a c1       	rjmp	.+564    	; 0xf6a <process_sensor+0x5ae>
     d36:	80 91 39 21 	lds	r24, 0x2139
     d3a:	90 91 3a 21 	lds	r25, 0x213A
     d3e:	83 60       	ori	r24, 0x03	; 3
     d40:	80 93 39 21 	sts	0x2139, r24
     d44:	90 93 3a 21 	sts	0x213A, r25
     d48:	f9 01       	movw	r30, r18
     d4a:	ee 0f       	add	r30, r30
     d4c:	ff 1f       	adc	r31, r31
     d4e:	ef 5b       	subi	r30, 0xBF	; 191
     d50:	fe 4d       	sbci	r31, 0xDE	; 222
     d52:	80 e1       	ldi	r24, 0x10	; 16
     d54:	80 83       	st	Z, r24
     d56:	11 82       	std	Z+1, r1	; 0x01
     d58:	08 c1       	rjmp	.+528    	; 0xf6a <process_sensor+0x5ae>
     d5a:	e0 0f       	add	r30, r16
     d5c:	f1 1f       	adc	r31, r17
     d5e:	ee 0f       	add	r30, r30
     d60:	ff 1f       	adc	r31, r31
     d62:	df 01       	movw	r26, r30
     d64:	af 5b       	subi	r26, 0xBF	; 191
     d66:	be 4d       	sbci	r27, 0xDE	; 222
     d68:	15 96       	adiw	r26, 0x05	; 5
     d6a:	2c 91       	ld	r18, X
     d6c:	15 97       	sbiw	r26, 0x05	; 5
     d6e:	82 e0       	ldi	r24, 0x02	; 2
     d70:	8c 93       	st	X, r24
     d72:	80 91 39 21 	lds	r24, 0x2139
     d76:	90 91 3a 21 	lds	r25, 0x213A
     d7a:	82 60       	ori	r24, 0x02	; 2
     d7c:	80 93 39 21 	sts	0x2139, r24
     d80:	90 93 3a 21 	sts	0x213A, r25
     d84:	ed 5b       	subi	r30, 0xBD	; 189
     d86:	fe 4d       	sbci	r31, 0xDE	; 222
     d88:	10 82       	st	Z, r1
     d8a:	e2 2f       	mov	r30, r18
     d8c:	ae c0       	rjmp	.+348    	; 0xeea <process_sensor+0x52e>
     d8e:	52 ff       	sbrs	r21, 2
     d90:	0e c0       	rjmp	.+28     	; 0xdae <process_sensor+0x3f2>
     d92:	ed 81       	ldd	r30, Y+5	; 0x05
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	e5 5a       	subi	r30, 0xA5	; 165
     d98:	fe 4d       	sbci	r31, 0xDE	; 222
     d9a:	80 e8       	ldi	r24, 0x80	; 128
     d9c:	80 83       	st	Z, r24
     d9e:	80 e2       	ldi	r24, 0x20	; 32
     da0:	88 83       	st	Y, r24
     da2:	80 91 39 21 	lds	r24, 0x2139
     da6:	90 91 3a 21 	lds	r25, 0x213A
     daa:	90 61       	ori	r25, 0x10	; 16
     dac:	4a c0       	rjmp	.+148    	; 0xe42 <process_sensor+0x486>
     dae:	c5 01       	movw	r24, r10
     db0:	b7 fe       	sbrs	r11, 7
     db2:	02 c0       	rjmp	.+4      	; 0xdb8 <process_sensor+0x3fc>
     db4:	80 e0       	ldi	r24, 0x00	; 0
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	f8 01       	movw	r30, r16
     dba:	ee 0f       	add	r30, r30
     dbc:	ff 1f       	adc	r31, r31
     dbe:	40 91 39 21 	lds	r20, 0x2139
     dc2:	50 91 3a 21 	lds	r21, 0x213A
     dc6:	86 17       	cp	r24, r22
     dc8:	97 07       	cpc	r25, r23
     dca:	70 f4       	brcc	.+28     	; 0xde8 <process_sensor+0x42c>
     dcc:	e0 0f       	add	r30, r16
     dce:	f1 1f       	adc	r31, r17
     dd0:	ee 0f       	add	r30, r30
     dd2:	ff 1f       	adc	r31, r31
     dd4:	ef 5b       	subi	r30, 0xBF	; 191
     dd6:	fe 4d       	sbci	r31, 0xDE	; 222
     dd8:	88 e0       	ldi	r24, 0x08	; 8
     dda:	80 83       	st	Z, r24
     ddc:	54 60       	ori	r21, 0x04	; 4
     dde:	40 93 39 21 	sts	0x2139, r20
     de2:	50 93 3a 21 	sts	0x213A, r21
     de6:	31 c0       	rjmp	.+98     	; 0xe4a <process_sensor+0x48e>
     de8:	41 60       	ori	r20, 0x01	; 1
     dea:	40 93 39 21 	sts	0x2139, r20
     dee:	50 93 3a 21 	sts	0x213A, r21
     df2:	e0 0f       	add	r30, r16
     df4:	f1 1f       	adc	r31, r17
     df6:	ee 0f       	add	r30, r30
     df8:	ff 1f       	adc	r31, r31
     dfa:	ed 5b       	subi	r30, 0xBD	; 189
     dfc:	fe 4d       	sbci	r31, 0xDE	; 222
     dfe:	90 81       	ld	r25, Z
     e00:	80 91 22 21 	lds	r24, 0x2122
     e04:	98 17       	cp	r25, r24
     e06:	10 f4       	brcc	.+4      	; 0xe0c <process_sensor+0x450>
     e08:	9f 5f       	subi	r25, 0xFF	; 255
     e0a:	90 83       	st	Z, r25
     e0c:	90 91 24 21 	lds	r25, 0x2124
     e10:	99 23       	and	r25, r25
     e12:	71 f0       	breq	.+28     	; 0xe30 <process_sensor+0x474>
     e14:	f8 01       	movw	r30, r16
     e16:	ee 0f       	add	r30, r30
     e18:	ff 1f       	adc	r31, r31
     e1a:	e0 0f       	add	r30, r16
     e1c:	f1 1f       	adc	r31, r17
     e1e:	ee 0f       	add	r30, r30
     e20:	ff 1f       	adc	r31, r31
     e22:	ef 5b       	subi	r30, 0xBF	; 191
     e24:	fe 4d       	sbci	r31, 0xDE	; 222
     e26:	81 81       	ldd	r24, Z+1	; 0x01
     e28:	89 17       	cp	r24, r25
     e2a:	20 f4       	brcc	.+8      	; 0xe34 <process_sensor+0x478>
     e2c:	8f 0d       	add	r24, r15
     e2e:	81 83       	std	Z+1, r24	; 0x01
     e30:	40 e0       	ldi	r20, 0x00	; 0
     e32:	0c c0       	rjmp	.+24     	; 0xe4c <process_sensor+0x490>
     e34:	87 2d       	mov	r24, r7
     e36:	81 dd       	rcall	.-1278   	; 0x93a <start_cal_sensor>
     e38:	80 91 39 21 	lds	r24, 0x2139
     e3c:	90 91 3a 21 	lds	r25, 0x213A
     e40:	92 60       	ori	r25, 0x02	; 2
     e42:	80 93 39 21 	sts	0x2139, r24
     e46:	90 93 3a 21 	sts	0x213A, r25
     e4a:	41 e0       	ldi	r20, 0x01	; 1
     e4c:	80 91 23 21 	lds	r24, 0x2123
     e50:	80 93 5a 21 	sts	0x215A, r24
     e54:	8a c0       	rjmp	.+276    	; 0xf6a <process_sensor+0x5ae>
     e56:	80 91 23 21 	lds	r24, 0x2123
     e5a:	80 93 5a 21 	sts	0x215A, r24
     e5e:	df 01       	movw	r26, r30
     e60:	aa 0f       	add	r26, r26
     e62:	bb 1f       	adc	r27, r27
     e64:	ad 5b       	subi	r26, 0xBD	; 189
     e66:	be 4d       	sbci	r27, 0xDE	; 222
     e68:	8c 91       	ld	r24, X
     e6a:	88 23       	and	r24, r24
     e6c:	89 f1       	breq	.+98     	; 0xed0 <process_sensor+0x514>
     e6e:	c5 01       	movw	r24, r10
     e70:	b7 fe       	sbrs	r11, 7
     e72:	02 c0       	rjmp	.+4      	; 0xe78 <process_sensor+0x4bc>
     e74:	80 e0       	ldi	r24, 0x00	; 0
     e76:	90 e0       	ldi	r25, 0x00	; 0
     e78:	40 91 39 21 	lds	r20, 0x2139
     e7c:	50 91 3a 21 	lds	r21, 0x213A
     e80:	68 17       	cp	r22, r24
     e82:	79 07       	cpc	r23, r25
     e84:	90 f4       	brcc	.+36     	; 0xeaa <process_sensor+0x4ee>
     e86:	f8 01       	movw	r30, r16
     e88:	ee 0f       	add	r30, r30
     e8a:	ff 1f       	adc	r31, r31
     e8c:	e0 0f       	add	r30, r16
     e8e:	f1 1f       	adc	r31, r17
     e90:	ee 0f       	add	r30, r30
     e92:	ff 1f       	adc	r31, r31
     e94:	ef 5b       	subi	r30, 0xBF	; 191
     e96:	fe 4d       	sbci	r31, 0xDE	; 222
     e98:	80 e1       	ldi	r24, 0x10	; 16
     e9a:	80 83       	st	Z, r24
     e9c:	41 60       	ori	r20, 0x01	; 1
     e9e:	40 93 39 21 	sts	0x2139, r20
     ea2:	50 93 3a 21 	sts	0x213A, r21
     ea6:	40 e0       	ldi	r20, 0x00	; 0
     ea8:	06 c0       	rjmp	.+12     	; 0xeb6 <process_sensor+0x4fa>
     eaa:	54 60       	ori	r21, 0x04	; 4
     eac:	40 93 39 21 	sts	0x2139, r20
     eb0:	50 93 3a 21 	sts	0x213A, r21
     eb4:	41 e0       	ldi	r20, 0x01	; 1
     eb6:	f8 01       	movw	r30, r16
     eb8:	ee 0f       	add	r30, r30
     eba:	ff 1f       	adc	r31, r31
     ebc:	e0 0f       	add	r30, r16
     ebe:	f1 1f       	adc	r31, r17
     ec0:	ee 0f       	add	r30, r30
     ec2:	ff 1f       	adc	r31, r31
     ec4:	ed 5b       	subi	r30, 0xBD	; 189
     ec6:	fe 4d       	sbci	r31, 0xDE	; 222
     ec8:	80 81       	ld	r24, Z
     eca:	81 50       	subi	r24, 0x01	; 1
     ecc:	80 83       	st	Z, r24
     ece:	4d c0       	rjmp	.+154    	; 0xf6a <process_sensor+0x5ae>
     ed0:	ed 81       	ldd	r30, Y+5	; 0x05
     ed2:	82 e0       	ldi	r24, 0x02	; 2
     ed4:	88 83       	st	Y, r24
     ed6:	80 91 39 21 	lds	r24, 0x2139
     eda:	90 91 3a 21 	lds	r25, 0x213A
     ede:	82 60       	ori	r24, 0x02	; 2
     ee0:	80 93 39 21 	sts	0x2139, r24
     ee4:	90 93 3a 21 	sts	0x213A, r25
     ee8:	1c 92       	st	X, r1
     eea:	f0 e0       	ldi	r31, 0x00	; 0
     eec:	e5 5a       	subi	r30, 0xA5	; 165
     eee:	fe 4d       	sbci	r31, 0xDE	; 222
     ef0:	80 e8       	ldi	r24, 0x80	; 128
     ef2:	80 83       	st	Z, r24
     ef4:	39 c0       	rjmp	.+114    	; 0xf68 <process_sensor+0x5ac>
     ef6:	8d 81       	ldd	r24, Y+5	; 0x05
     ef8:	a8 2f       	mov	r26, r24
     efa:	b0 e0       	ldi	r27, 0x00	; 0
     efc:	a5 5a       	subi	r26, 0xA5	; 165
     efe:	be 4d       	sbci	r27, 0xDE	; 222
     f00:	9c 91       	ld	r25, X
     f02:	9f 5f       	subi	r25, 0xFF	; 255
     f04:	9c 93       	st	X, r25
     f06:	52 fd       	sbrc	r21, 2
     f08:	18 c0       	rjmp	.+48     	; 0xf3a <process_sensor+0x57e>
     f0a:	97 ff       	sbrs	r25, 7
     f0c:	03 c0       	rjmp	.+6      	; 0xf14 <process_sensor+0x558>
     f0e:	80 e1       	ldi	r24, 0x10	; 16
     f10:	88 83       	st	Y, r24
     f12:	2a c0       	rjmp	.+84     	; 0xf68 <process_sensor+0x5ac>
     f14:	82 e0       	ldi	r24, 0x02	; 2
     f16:	88 83       	st	Y, r24
     f18:	80 91 39 21 	lds	r24, 0x2139
     f1c:	90 91 3a 21 	lds	r25, 0x213A
     f20:	82 60       	ori	r24, 0x02	; 2
     f22:	80 93 39 21 	sts	0x2139, r24
     f26:	90 93 3a 21 	sts	0x213A, r25
     f2a:	ee 0f       	add	r30, r30
     f2c:	ff 1f       	adc	r31, r31
     f2e:	ed 5b       	subi	r30, 0xBD	; 189
     f30:	fe 4d       	sbci	r31, 0xDE	; 222
     f32:	10 82       	st	Z, r1
     f34:	80 e8       	ldi	r24, 0x80	; 128
     f36:	8c 93       	st	X, r24
     f38:	17 c0       	rjmp	.+46     	; 0xf68 <process_sensor+0x5ac>
     f3a:	80 91 27 21 	lds	r24, 0x2127
     f3e:	98 17       	cp	r25, r24
     f40:	40 f0       	brcs	.+16     	; 0xf52 <process_sensor+0x596>
     f42:	87 2d       	mov	r24, r7
     f44:	fa dc       	rcall	.-1548   	; 0x93a <start_cal_sensor>
     f46:	80 91 39 21 	lds	r24, 0x2139
     f4a:	90 91 3a 21 	lds	r25, 0x213A
     f4e:	90 61       	ori	r25, 0x10	; 16
     f50:	05 c0       	rjmp	.+10     	; 0xf5c <process_sensor+0x5a0>
     f52:	80 91 39 21 	lds	r24, 0x2139
     f56:	90 91 3a 21 	lds	r25, 0x213A
     f5a:	94 60       	ori	r25, 0x04	; 4
     f5c:	80 93 39 21 	sts	0x2139, r24
     f60:	90 93 3a 21 	sts	0x213A, r25
     f64:	41 e0       	ldi	r20, 0x01	; 1
     f66:	01 c0       	rjmp	.+2      	; 0xf6a <process_sensor+0x5ae>
     f68:	40 e0       	ldi	r20, 0x00	; 0
     f6a:	84 2f       	mov	r24, r20
     f6c:	cd b7       	in	r28, 0x3d	; 61
     f6e:	de b7       	in	r29, 0x3e	; 62
     f70:	ee e0       	ldi	r30, 0x0E	; 14
     f72:	0c 94 2e 1b 	jmp	0x365c	; 0x365c <__epilogue_restores__+0x8>

00000f76 <burst_init>:
     f76:	fc 01       	movw	r30, r24
     f78:	00 97       	sbiw	r24, 0x00	; 0
     f7a:	09 f0       	breq	.+2      	; 0xf7e <burst_init+0x8>
     f7c:	19 95       	eicall
     f7e:	08 95       	ret

00000f80 <burst_reset>:
     f80:	10 92 5f 21 	sts	0x215F, r1
     f84:	10 92 60 21 	sts	0x2160, r1
     f88:	10 92 63 21 	sts	0x2163, r1
     f8c:	10 92 64 21 	sts	0x2164, r1
     f90:	10 92 61 21 	sts	0x2161, r1
     f94:	10 92 62 21 	sts	0x2162, r1
     f98:	10 92 65 21 	sts	0x2165, r1
     f9c:	10 92 66 21 	sts	0x2166, r1
     fa0:	08 95       	ret

00000fa2 <burst>:
     fa2:	80 91 61 21 	lds	r24, 0x2161
     fa6:	90 91 5f 21 	lds	r25, 0x215F
     faa:	89 2b       	or	r24, r25
     fac:	41 f0       	breq	.+16     	; 0xfbe <burst+0x1c>
     fae:	e0 91 1f 21 	lds	r30, 0x211F
     fb2:	f0 91 20 21 	lds	r31, 0x2120
     fb6:	30 97       	sbiw	r30, 0x00	; 0
     fb8:	11 f0       	breq	.+4      	; 0xfbe <burst+0x1c>
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	19 95       	eicall
     fbe:	80 91 62 21 	lds	r24, 0x2162
     fc2:	90 91 60 21 	lds	r25, 0x2160
     fc6:	89 2b       	or	r24, r25
     fc8:	41 f0       	breq	.+16     	; 0xfda <burst+0x38>
     fca:	e0 91 1f 21 	lds	r30, 0x211F
     fce:	f0 91 20 21 	lds	r31, 0x2120
     fd2:	30 97       	sbiw	r30, 0x00	; 0
     fd4:	11 f0       	breq	.+4      	; 0xfda <burst+0x38>
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	19 95       	eicall
     fda:	08 95       	ret

00000fdc <adc_handler>:
		return true;
	} else {
		cpu_irq_restore(irqflags);
		return false;
	}
}
     fdc:	61 30       	cpi	r22, 0x01	; 1
     fde:	69 f5       	brne	.+90     	; 0x103a <adc_handler+0x5e>
     fe0:	80 91 68 21 	lds	r24, 0x2168
     fe4:	8f 5f       	subi	r24, 0xFF	; 255
     fe6:	80 93 68 21 	sts	0x2168, r24
     fea:	81 30       	cpi	r24, 0x01	; 1
     fec:	39 f4       	brne	.+14     	; 0xffc <adc_handler+0x20>
     fee:	40 93 69 21 	sts	0x2169, r20
     ff2:	50 93 6a 21 	sts	0x216A, r21
     ff6:	10 92 6d 21 	sts	0x216D, r1
     ffa:	0c c0       	rjmp	.+24     	; 0x1014 <adc_handler+0x38>
     ffc:	80 91 69 21 	lds	r24, 0x2169
    1000:	90 91 6a 21 	lds	r25, 0x216A
    1004:	48 0f       	add	r20, r24
    1006:	59 1f       	adc	r21, r25
    1008:	56 95       	lsr	r21
    100a:	47 95       	ror	r20
    100c:	40 93 69 21 	sts	0x2169, r20
    1010:	50 93 6a 21 	sts	0x216A, r21
    1014:	80 91 68 21 	lds	r24, 0x2168
    1018:	84 30       	cpi	r24, 0x04	; 4
    101a:	31 f4       	brne	.+12     	; 0x1028 <adc_handler+0x4c>
    101c:	10 92 68 21 	sts	0x2168, r1
    1020:	81 e0       	ldi	r24, 0x01	; 1
    1022:	80 93 6d 21 	sts	0x216D, r24
    1026:	08 95       	ret
    1028:	9f b7       	in	r25, 0x3f	; 63
    102a:	f8 94       	cli
    102c:	e0 e0       	ldi	r30, 0x00	; 0
    102e:	f2 e0       	ldi	r31, 0x02	; 2
    1030:	80 81       	ld	r24, Z
    1032:	84 60       	ori	r24, 0x04	; 4
    1034:	80 83       	st	Z, r24
    1036:	9f bf       	out	0x3f, r25	; 63
    1038:	08 95       	ret
    103a:	62 30       	cpi	r22, 0x02	; 2
    103c:	61 f5       	brne	.+88     	; 0x1096 <adc_handler+0xba>
    103e:	80 91 67 21 	lds	r24, 0x2167
    1042:	8f 5f       	subi	r24, 0xFF	; 255
    1044:	80 93 67 21 	sts	0x2167, r24
    1048:	81 30       	cpi	r24, 0x01	; 1
    104a:	39 f4       	brne	.+14     	; 0x105a <adc_handler+0x7e>
    104c:	40 93 6b 21 	sts	0x216B, r20
    1050:	50 93 6c 21 	sts	0x216C, r21
    1054:	10 92 6e 21 	sts	0x216E, r1
    1058:	0c c0       	rjmp	.+24     	; 0x1072 <adc_handler+0x96>
    105a:	80 91 6b 21 	lds	r24, 0x216B
    105e:	90 91 6c 21 	lds	r25, 0x216C
    1062:	48 0f       	add	r20, r24
    1064:	59 1f       	adc	r21, r25
    1066:	56 95       	lsr	r21
    1068:	47 95       	ror	r20
    106a:	40 93 6b 21 	sts	0x216B, r20
    106e:	50 93 6c 21 	sts	0x216C, r21
    1072:	80 91 67 21 	lds	r24, 0x2167
    1076:	84 30       	cpi	r24, 0x04	; 4
    1078:	31 f4       	brne	.+12     	; 0x1086 <adc_handler+0xaa>
    107a:	10 92 67 21 	sts	0x2167, r1
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	80 93 6e 21 	sts	0x216E, r24
    1084:	08 95       	ret
    1086:	9f b7       	in	r25, 0x3f	; 63
    1088:	f8 94       	cli
    108a:	e0 e0       	ldi	r30, 0x00	; 0
    108c:	f2 e0       	ldi	r31, 0x02	; 2
    108e:	80 81       	ld	r24, Z
    1090:	88 60       	ori	r24, 0x08	; 8
    1092:	80 83       	st	Z, r24
    1094:	9f bf       	out	0x3f, r25	; 63
    1096:	08 95       	ret

00001098 <adc_sensors_init>:
 *
 * This will set up the ADC for reading the NTC and light sensor
 * present on the A3BU-Xplained board.
 */
void adc_sensors_init(void)
{
    1098:	1f 93       	push	r17
    109a:	cf 93       	push	r28
    109c:	df 93       	push	r29
    109e:	cd b7       	in	r28, 0x3d	; 61
    10a0:	de b7       	in	r29, 0x3e	; 62
    10a2:	2b 97       	sbiw	r28, 0x0b	; 11
    10a4:	cd bf       	out	0x3d, r28	; 61
    10a6:	de bf       	out	0x3e, r29	; 62
	struct adc_config adc_conf;
	struct adc_channel_config adc_ch_conf;

	/* Clear the ADC configuration structs */
	adc_read_configuration(&ADCA, &adc_conf);
    10a8:	be 01       	movw	r22, r28
    10aa:	6f 5f       	subi	r22, 0xFF	; 255
    10ac:	7f 4f       	sbci	r23, 0xFF	; 255
    10ae:	80 e0       	ldi	r24, 0x00	; 0
    10b0:	92 e0       	ldi	r25, 0x02	; 2
    10b2:	b6 d5       	rcall	.+2924   	; 0x1c20 <adc_read_configuration>
	adcch_read_configuration(&ADCA, ADC_CH0, &adc_ch_conf);
    10b4:	ae 01       	movw	r20, r28
    10b6:	48 5f       	subi	r20, 0xF8	; 248
    10b8:	5f 4f       	sbci	r21, 0xFF	; 255
    10ba:	61 e0       	ldi	r22, 0x01	; 1
    10bc:	80 e0       	ldi	r24, 0x00	; 0
    10be:	92 e0       	ldi	r25, 0x02	; 2
    10c0:	0b d6       	rcall	.+3094   	; 0x1cd8 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    10c2:	8a 81       	ldd	r24, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    10c4:	9b 81       	ldd	r25, Y+3	; 0x03
    10c6:	9f 78       	andi	r25, 0x8F	; 143
	conf->refctrl |= ref;
    10c8:	90 61       	ori	r25, 0x10	; 16
    10ca:	9b 83       	std	Y+3, r25	; 0x03
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    10cc:	96 e0       	ldi	r25, 0x06	; 6
    10ce:	9d 83       	std	Y+5, r25	; 0x05
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    10d0:	81 7e       	andi	r24, 0xE1	; 225
    10d2:	80 61       	ori	r24, 0x10	; 16
    10d4:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    10d6:	1c 82       	std	Y+4, r1	; 0x04
	*/
	adc_set_conversion_parameters(&adc_conf, ADC_SIGN_ON, ADC_RES_12,
			ADC_REF_VCC);
	adc_set_clock_rate(&adc_conf, 125000UL);
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_write_configuration(&ADCA, &adc_conf);
    10d8:	be 01       	movw	r22, r28
    10da:	6f 5f       	subi	r22, 0xFF	; 255
    10dc:	7f 4f       	sbci	r23, 0xFF	; 255
    10de:	80 e0       	ldi	r24, 0x00	; 0
    10e0:	92 e0       	ldi	r25, 0x02	; 2
    10e2:	4a d5       	rcall	.+2708   	; 0x1b78 <adc_write_configuration>
	adc_set_callback(&ADCA, &adc_handler);
    10e4:	6e ee       	ldi	r22, 0xEE	; 238
    10e6:	77 e0       	ldi	r23, 0x07	; 7
    10e8:	80 e0       	ldi	r24, 0x00	; 0
    10ea:	92 e0       	ldi	r25, 0x02	; 2
    10ec:	48 d3       	rcall	.+1680   	; 0x177e <adc_set_callback>
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    10ee:	11 e0       	ldi	r17, 0x01	; 1
    10f0:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    10f2:	19 86       	std	Y+9, r1	; 0x09
 *
 * \param ch_conf Pointer to ADC channel configuration.
 */
static inline void adcch_enable_interrupt(struct adc_channel_config *ch_conf)
{
	ch_conf->intctrl &= ~ADC_CH_INTLVL_gm;
    10f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    10f6:	80 7f       	andi	r24, 0xF0	; 240
	ch_conf->intctrl |= CONFIG_ADC_INTLVL;
    10f8:	81 60       	ori	r24, 0x01	; 1
    10fa:	8a 87       	std	Y+10, r24	; 0x0a
	 * - interrupts enabled
	 */
	adcch_set_input(&adc_ch_conf, ADCCH_POS_PIN0, ADCCH_NEG_NONE, 1);
	adcch_set_interrupt_mode(&adc_ch_conf, ADCCH_MODE_COMPLETE);
	adcch_enable_interrupt(&adc_ch_conf);
	adcch_write_configuration(&ADCA, ADC_CH0, &adc_ch_conf);
    10fc:	ae 01       	movw	r20, r28
    10fe:	48 5f       	subi	r20, 0xF8	; 248
    1100:	5f 4f       	sbci	r21, 0xFF	; 255
    1102:	61 e0       	ldi	r22, 0x01	; 1
    1104:	80 e0       	ldi	r24, 0x00	; 0
    1106:	92 e0       	ldi	r25, 0x02	; 2
    1108:	ae d5       	rcall	.+2908   	; 0x1c66 <adcch_write_configuration>
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    110a:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    110c:	88 e0       	ldi	r24, 0x08	; 8
    110e:	89 87       	std	Y+9, r24	; 0x09
	 * - single-ended measurement
	 * - interrupt flag set on completed conversion
	 * - interrupts enabled
	 */
	adcch_set_input(&adc_ch_conf, ADCCH_POS_PIN1, ADCCH_NEG_NONE, 1);
	adcch_write_configuration(&ADCA, ADC_CH1, &adc_ch_conf);
    1110:	ae 01       	movw	r20, r28
    1112:	48 5f       	subi	r20, 0xF8	; 248
    1114:	5f 4f       	sbci	r21, 0xFF	; 255
    1116:	62 e0       	ldi	r22, 0x02	; 2
    1118:	80 e0       	ldi	r24, 0x00	; 0
    111a:	92 e0       	ldi	r25, 0x02	; 2
    111c:	a4 d5       	rcall	.+2888   	; 0x1c66 <adcch_write_configuration>

	adc_enable(&ADCA);
    111e:	80 e0       	ldi	r24, 0x00	; 0
    1120:	92 e0       	ldi	r25, 0x02	; 2
    1122:	83 d3       	rcall	.+1798   	; 0x182a <adc_enable>
}
    1124:	2b 96       	adiw	r28, 0x0b	; 11
    1126:	cd bf       	out	0x3d, r28	; 61
    1128:	de bf       	out	0x3e, r29	; 62
    112a:	df 91       	pop	r29
    112c:	cf 91       	pop	r28
    112e:	1f 91       	pop	r17
    1130:	08 95       	ret

00001132 <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
    1132:	bf 92       	push	r11
    1134:	cf 92       	push	r12
    1136:	df 92       	push	r13
    1138:	ef 92       	push	r14
    113a:	ff 92       	push	r15
    113c:	0f 93       	push	r16
    113e:	1f 93       	push	r17
    1140:	cf 93       	push	r28
    1142:	df 93       	push	r29
    1144:	1f 92       	push	r1
    1146:	cd b7       	in	r28, 0x3d	; 61
    1148:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    114a:	88 e0       	ldi	r24, 0x08	; 8
    114c:	80 93 06 06 	sts	0x0606, r24
    1150:	80 e0       	ldi	r24, 0x00	; 0
    1152:	90 e0       	ldi	r25, 0x00	; 0
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	do { barrier(); } while (--n);
    1154:	01 96       	adiw	r24, 0x01	; 1
    1156:	85 33       	cpi	r24, 0x35	; 53
    1158:	91 05       	cpc	r25, r1
    115a:	e1 f7       	brne	.-8      	; 0x1154 <st7565r_init+0x22>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    115c:	88 e0       	ldi	r24, 0x08	; 8
    115e:	80 93 05 06 	sts	0x0605, r24
    1162:	80 e0       	ldi	r24, 0x00	; 0
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	01 96       	adiw	r24, 0x01	; 1
    1168:	85 33       	cpi	r24, 0x35	; 53
    116a:	91 05       	cpc	r25, r1
    116c:	e1 f7       	brne	.-8      	; 0x1166 <st7565r_init+0x34>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
    116e:	0f 2e       	mov	r0, r31
    1170:	fb e2       	ldi	r31, 0x2B	; 43
    1172:	bf 2e       	mov	r11, r31
    1174:	f0 2d       	mov	r31, r0
    1176:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
    1178:	80 ea       	ldi	r24, 0xA0	; 160
    117a:	99 e0       	ldi	r25, 0x09	; 9
    117c:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
    1180:	c1 2c       	mov	r12, r1
    1182:	d1 2c       	mov	r13, r1
    1184:	76 01       	movw	r14, r12
    1186:	00 e4       	ldi	r16, 0x40	; 64
    1188:	12 e4       	ldi	r17, 0x42	; 66
    118a:	2f e0       	ldi	r18, 0x0F	; 15
    118c:	30 e0       	ldi	r19, 0x00	; 0
    118e:	43 e0       	ldi	r20, 0x03	; 3
    1190:	be 01       	movw	r22, r28
    1192:	6f 5f       	subi	r22, 0xFF	; 255
    1194:	7f 4f       	sbci	r23, 0xFF	; 255
    1196:	80 ea       	ldi	r24, 0xA0	; 160
    1198:	99 e0       	ldi	r25, 0x09	; 9
    119a:	0e 94 99 11 	call	0x2332	; 0x2332 <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    119e:	00 e6       	ldi	r16, 0x60	; 96
    11a0:	16 e0       	ldi	r17, 0x06	; 6
    11a2:	ff 24       	eor	r15, r15
    11a4:	f3 94       	inc	r15
    11a6:	f8 01       	movw	r30, r16
    11a8:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    11aa:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    11ac:	be 01       	movw	r22, r28
    11ae:	6f 5f       	subi	r22, 0xFF	; 255
    11b0:	7f 4f       	sbci	r23, 0xFF	; 255
    11b2:	80 ea       	ldi	r24, 0xA0	; 160
    11b4:	99 e0       	ldi	r25, 0x09	; 9
    11b6:	0e 94 b3 11 	call	0x2366	; 0x2366 <usart_spi_select_device>
    11ba:	f8 01       	movw	r30, r16
    11bc:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    11be:	e0 ea       	ldi	r30, 0xA0	; 160
    11c0:	f9 e0       	ldi	r31, 0x09	; 9
    11c2:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    11c4:	85 ff       	sbrs	r24, 5
    11c6:	fd cf       	rjmp	.-6      	; 0x11c2 <st7565r_init+0x90>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    11c8:	80 ea       	ldi	r24, 0xA0	; 160
    11ca:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    11ce:	e0 ea       	ldi	r30, 0xA0	; 160
    11d0:	f9 e0       	ldi	r31, 0x09	; 9
    11d2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    11d4:	86 ff       	sbrs	r24, 6
    11d6:	fd cf       	rjmp	.-6      	; 0x11d2 <st7565r_init+0xa0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    11d8:	e0 ea       	ldi	r30, 0xA0	; 160
    11da:	f9 e0       	ldi	r31, 0x09	; 9
    11dc:	80 e4       	ldi	r24, 0x40	; 64
    11de:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    11e0:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    11e2:	be 01       	movw	r22, r28
    11e4:	6f 5f       	subi	r22, 0xFF	; 255
    11e6:	7f 4f       	sbci	r23, 0xFF	; 255
    11e8:	80 ea       	ldi	r24, 0xA0	; 160
    11ea:	99 e0       	ldi	r25, 0x09	; 9
    11ec:	0e 94 c9 11 	call	0x2392	; 0x2392 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    11f0:	8b e2       	ldi	r24, 0x2B	; 43
    11f2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    11f4:	be 01       	movw	r22, r28
    11f6:	6f 5f       	subi	r22, 0xFF	; 255
    11f8:	7f 4f       	sbci	r23, 0xFF	; 255
    11fa:	80 ea       	ldi	r24, 0xA0	; 160
    11fc:	99 e0       	ldi	r25, 0x09	; 9
    11fe:	0e 94 b3 11 	call	0x2366	; 0x2366 <usart_spi_select_device>
    1202:	81 e0       	ldi	r24, 0x01	; 1
    1204:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1208:	e0 ea       	ldi	r30, 0xA0	; 160
    120a:	f9 e0       	ldi	r31, 0x09	; 9
    120c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    120e:	85 ff       	sbrs	r24, 5
    1210:	fd cf       	rjmp	.-6      	; 0x120c <st7565r_init+0xda>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1212:	86 ea       	ldi	r24, 0xA6	; 166
    1214:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1218:	e0 ea       	ldi	r30, 0xA0	; 160
    121a:	f9 e0       	ldi	r31, 0x09	; 9
    121c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    121e:	86 ff       	sbrs	r24, 6
    1220:	fd cf       	rjmp	.-6      	; 0x121c <st7565r_init+0xea>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1222:	e0 ea       	ldi	r30, 0xA0	; 160
    1224:	f9 e0       	ldi	r31, 0x09	; 9
    1226:	80 e4       	ldi	r24, 0x40	; 64
    1228:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    122a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    122c:	be 01       	movw	r22, r28
    122e:	6f 5f       	subi	r22, 0xFF	; 255
    1230:	7f 4f       	sbci	r23, 0xFF	; 255
    1232:	80 ea       	ldi	r24, 0xA0	; 160
    1234:	99 e0       	ldi	r25, 0x09	; 9
    1236:	0e 94 c9 11 	call	0x2392	; 0x2392 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    123a:	8b e2       	ldi	r24, 0x2B	; 43
    123c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    123e:	be 01       	movw	r22, r28
    1240:	6f 5f       	subi	r22, 0xFF	; 255
    1242:	7f 4f       	sbci	r23, 0xFF	; 255
    1244:	80 ea       	ldi	r24, 0xA0	; 160
    1246:	99 e0       	ldi	r25, 0x09	; 9
    1248:	0e 94 b3 11 	call	0x2366	; 0x2366 <usart_spi_select_device>
    124c:	81 e0       	ldi	r24, 0x01	; 1
    124e:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1252:	e0 ea       	ldi	r30, 0xA0	; 160
    1254:	f9 e0       	ldi	r31, 0x09	; 9
    1256:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1258:	85 ff       	sbrs	r24, 5
    125a:	fd cf       	rjmp	.-6      	; 0x1256 <st7565r_init+0x124>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    125c:	88 ec       	ldi	r24, 0xC8	; 200
    125e:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1262:	e0 ea       	ldi	r30, 0xA0	; 160
    1264:	f9 e0       	ldi	r31, 0x09	; 9
    1266:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1268:	86 ff       	sbrs	r24, 6
    126a:	fd cf       	rjmp	.-6      	; 0x1266 <st7565r_init+0x134>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    126c:	e0 ea       	ldi	r30, 0xA0	; 160
    126e:	f9 e0       	ldi	r31, 0x09	; 9
    1270:	80 e4       	ldi	r24, 0x40	; 64
    1272:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1274:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1276:	be 01       	movw	r22, r28
    1278:	6f 5f       	subi	r22, 0xFF	; 255
    127a:	7f 4f       	sbci	r23, 0xFF	; 255
    127c:	80 ea       	ldi	r24, 0xA0	; 160
    127e:	99 e0       	ldi	r25, 0x09	; 9
    1280:	0e 94 c9 11 	call	0x2392	; 0x2392 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1284:	8b e2       	ldi	r24, 0x2B	; 43
    1286:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1288:	be 01       	movw	r22, r28
    128a:	6f 5f       	subi	r22, 0xFF	; 255
    128c:	7f 4f       	sbci	r23, 0xFF	; 255
    128e:	80 ea       	ldi	r24, 0xA0	; 160
    1290:	99 e0       	ldi	r25, 0x09	; 9
    1292:	0e 94 b3 11 	call	0x2366	; 0x2366 <usart_spi_select_device>
    1296:	81 e0       	ldi	r24, 0x01	; 1
    1298:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    129c:	e0 ea       	ldi	r30, 0xA0	; 160
    129e:	f9 e0       	ldi	r31, 0x09	; 9
    12a0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    12a2:	85 ff       	sbrs	r24, 5
    12a4:	fd cf       	rjmp	.-6      	; 0x12a0 <st7565r_init+0x16e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    12a6:	82 ea       	ldi	r24, 0xA2	; 162
    12a8:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    12ac:	e0 ea       	ldi	r30, 0xA0	; 160
    12ae:	f9 e0       	ldi	r31, 0x09	; 9
    12b0:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    12b2:	86 ff       	sbrs	r24, 6
    12b4:	fd cf       	rjmp	.-6      	; 0x12b0 <st7565r_init+0x17e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    12b6:	e0 ea       	ldi	r30, 0xA0	; 160
    12b8:	f9 e0       	ldi	r31, 0x09	; 9
    12ba:	80 e4       	ldi	r24, 0x40	; 64
    12bc:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    12be:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    12c0:	be 01       	movw	r22, r28
    12c2:	6f 5f       	subi	r22, 0xFF	; 255
    12c4:	7f 4f       	sbci	r23, 0xFF	; 255
    12c6:	80 ea       	ldi	r24, 0xA0	; 160
    12c8:	99 e0       	ldi	r25, 0x09	; 9
    12ca:	0e 94 c9 11 	call	0x2392	; 0x2392 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    12ce:	8b e2       	ldi	r24, 0x2B	; 43
    12d0:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    12d2:	be 01       	movw	r22, r28
    12d4:	6f 5f       	subi	r22, 0xFF	; 255
    12d6:	7f 4f       	sbci	r23, 0xFF	; 255
    12d8:	80 ea       	ldi	r24, 0xA0	; 160
    12da:	99 e0       	ldi	r25, 0x09	; 9
    12dc:	0e 94 b3 11 	call	0x2366	; 0x2366 <usart_spi_select_device>
    12e0:	81 e0       	ldi	r24, 0x01	; 1
    12e2:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    12e6:	e0 ea       	ldi	r30, 0xA0	; 160
    12e8:	f9 e0       	ldi	r31, 0x09	; 9
    12ea:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    12ec:	85 ff       	sbrs	r24, 5
    12ee:	fd cf       	rjmp	.-6      	; 0x12ea <st7565r_init+0x1b8>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    12f0:	8f e2       	ldi	r24, 0x2F	; 47
    12f2:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    12f6:	e0 ea       	ldi	r30, 0xA0	; 160
    12f8:	f9 e0       	ldi	r31, 0x09	; 9
    12fa:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    12fc:	86 ff       	sbrs	r24, 6
    12fe:	fd cf       	rjmp	.-6      	; 0x12fa <st7565r_init+0x1c8>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1300:	e0 ea       	ldi	r30, 0xA0	; 160
    1302:	f9 e0       	ldi	r31, 0x09	; 9
    1304:	80 e4       	ldi	r24, 0x40	; 64
    1306:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1308:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    130a:	be 01       	movw	r22, r28
    130c:	6f 5f       	subi	r22, 0xFF	; 255
    130e:	7f 4f       	sbci	r23, 0xFF	; 255
    1310:	80 ea       	ldi	r24, 0xA0	; 160
    1312:	99 e0       	ldi	r25, 0x09	; 9
    1314:	0e 94 c9 11 	call	0x2392	; 0x2392 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1318:	8b e2       	ldi	r24, 0x2B	; 43
    131a:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    131c:	be 01       	movw	r22, r28
    131e:	6f 5f       	subi	r22, 0xFF	; 255
    1320:	7f 4f       	sbci	r23, 0xFF	; 255
    1322:	80 ea       	ldi	r24, 0xA0	; 160
    1324:	99 e0       	ldi	r25, 0x09	; 9
    1326:	0e 94 b3 11 	call	0x2366	; 0x2366 <usart_spi_select_device>
    132a:	81 e0       	ldi	r24, 0x01	; 1
    132c:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1330:	e0 ea       	ldi	r30, 0xA0	; 160
    1332:	f9 e0       	ldi	r31, 0x09	; 9
    1334:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1336:	85 ff       	sbrs	r24, 5
    1338:	fd cf       	rjmp	.-6      	; 0x1334 <st7565r_init+0x202>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    133a:	88 ef       	ldi	r24, 0xF8	; 248
    133c:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1340:	e0 ea       	ldi	r30, 0xA0	; 160
    1342:	f9 e0       	ldi	r31, 0x09	; 9
    1344:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1346:	86 ff       	sbrs	r24, 6
    1348:	fd cf       	rjmp	.-6      	; 0x1344 <st7565r_init+0x212>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    134a:	e0 ea       	ldi	r30, 0xA0	; 160
    134c:	f9 e0       	ldi	r31, 0x09	; 9
    134e:	80 e4       	ldi	r24, 0x40	; 64
    1350:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1352:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1354:	be 01       	movw	r22, r28
    1356:	6f 5f       	subi	r22, 0xFF	; 255
    1358:	7f 4f       	sbci	r23, 0xFF	; 255
    135a:	80 ea       	ldi	r24, 0xA0	; 160
    135c:	99 e0       	ldi	r25, 0x09	; 9
    135e:	0e 94 c9 11 	call	0x2392	; 0x2392 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1362:	8b e2       	ldi	r24, 0x2B	; 43
    1364:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1366:	be 01       	movw	r22, r28
    1368:	6f 5f       	subi	r22, 0xFF	; 255
    136a:	7f 4f       	sbci	r23, 0xFF	; 255
    136c:	80 ea       	ldi	r24, 0xA0	; 160
    136e:	99 e0       	ldi	r25, 0x09	; 9
    1370:	fa d7       	rcall	.+4084   	; 0x2366 <usart_spi_select_device>
    1372:	81 e0       	ldi	r24, 0x01	; 1
    1374:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1378:	e0 ea       	ldi	r30, 0xA0	; 160
    137a:	f9 e0       	ldi	r31, 0x09	; 9
    137c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    137e:	85 ff       	sbrs	r24, 5
    1380:	fd cf       	rjmp	.-6      	; 0x137c <st7565r_init+0x24a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1382:	10 92 a0 09 	sts	0x09A0, r1
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1386:	e0 ea       	ldi	r30, 0xA0	; 160
    1388:	f9 e0       	ldi	r31, 0x09	; 9
    138a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    138c:	86 ff       	sbrs	r24, 6
    138e:	fd cf       	rjmp	.-6      	; 0x138a <st7565r_init+0x258>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1390:	e0 ea       	ldi	r30, 0xA0	; 160
    1392:	f9 e0       	ldi	r31, 0x09	; 9
    1394:	80 e4       	ldi	r24, 0x40	; 64
    1396:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1398:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    139a:	be 01       	movw	r22, r28
    139c:	6f 5f       	subi	r22, 0xFF	; 255
    139e:	7f 4f       	sbci	r23, 0xFF	; 255
    13a0:	80 ea       	ldi	r24, 0xA0	; 160
    13a2:	99 e0       	ldi	r25, 0x09	; 9
    13a4:	f6 d7       	rcall	.+4076   	; 0x2392 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    13a6:	8b e2       	ldi	r24, 0x2B	; 43
    13a8:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    13aa:	be 01       	movw	r22, r28
    13ac:	6f 5f       	subi	r22, 0xFF	; 255
    13ae:	7f 4f       	sbci	r23, 0xFF	; 255
    13b0:	80 ea       	ldi	r24, 0xA0	; 160
    13b2:	99 e0       	ldi	r25, 0x09	; 9
    13b4:	d8 d7       	rcall	.+4016   	; 0x2366 <usart_spi_select_device>
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    13bc:	e0 ea       	ldi	r30, 0xA0	; 160
    13be:	f9 e0       	ldi	r31, 0x09	; 9
    13c0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    13c2:	85 ff       	sbrs	r24, 5
    13c4:	fd cf       	rjmp	.-6      	; 0x13c0 <st7565r_init+0x28e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    13c6:	81 e2       	ldi	r24, 0x21	; 33
    13c8:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    13cc:	e0 ea       	ldi	r30, 0xA0	; 160
    13ce:	f9 e0       	ldi	r31, 0x09	; 9
    13d0:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    13d2:	86 ff       	sbrs	r24, 6
    13d4:	fd cf       	rjmp	.-6      	; 0x13d0 <st7565r_init+0x29e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    13d6:	e0 ea       	ldi	r30, 0xA0	; 160
    13d8:	f9 e0       	ldi	r31, 0x09	; 9
    13da:	80 e4       	ldi	r24, 0x40	; 64
    13dc:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    13de:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    13e0:	be 01       	movw	r22, r28
    13e2:	6f 5f       	subi	r22, 0xFF	; 255
    13e4:	7f 4f       	sbci	r23, 0xFF	; 255
    13e6:	80 ea       	ldi	r24, 0xA0	; 160
    13e8:	99 e0       	ldi	r25, 0x09	; 9
    13ea:	d3 d7       	rcall	.+4006   	; 0x2392 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    13ec:	8b e2       	ldi	r24, 0x2B	; 43
    13ee:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    13f0:	be 01       	movw	r22, r28
    13f2:	6f 5f       	subi	r22, 0xFF	; 255
    13f4:	7f 4f       	sbci	r23, 0xFF	; 255
    13f6:	80 ea       	ldi	r24, 0xA0	; 160
    13f8:	99 e0       	ldi	r25, 0x09	; 9
    13fa:	b5 d7       	rcall	.+3946   	; 0x2366 <usart_spi_select_device>
    13fc:	81 e0       	ldi	r24, 0x01	; 1
    13fe:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1402:	e0 ea       	ldi	r30, 0xA0	; 160
    1404:	f9 e0       	ldi	r31, 0x09	; 9
    1406:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1408:	85 ff       	sbrs	r24, 5
    140a:	fd cf       	rjmp	.-6      	; 0x1406 <st7565r_init+0x2d4>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    140c:	81 e8       	ldi	r24, 0x81	; 129
    140e:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1412:	e0 ea       	ldi	r30, 0xA0	; 160
    1414:	f9 e0       	ldi	r31, 0x09	; 9
    1416:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1418:	86 ff       	sbrs	r24, 6
    141a:	fd cf       	rjmp	.-6      	; 0x1416 <st7565r_init+0x2e4>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    141c:	e0 ea       	ldi	r30, 0xA0	; 160
    141e:	f9 e0       	ldi	r31, 0x09	; 9
    1420:	80 e4       	ldi	r24, 0x40	; 64
    1422:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1424:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1426:	be 01       	movw	r22, r28
    1428:	6f 5f       	subi	r22, 0xFF	; 255
    142a:	7f 4f       	sbci	r23, 0xFF	; 255
    142c:	80 ea       	ldi	r24, 0xA0	; 160
    142e:	99 e0       	ldi	r25, 0x09	; 9
    1430:	b0 d7       	rcall	.+3936   	; 0x2392 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1432:	8b e2       	ldi	r24, 0x2B	; 43
    1434:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1436:	be 01       	movw	r22, r28
    1438:	6f 5f       	subi	r22, 0xFF	; 255
    143a:	7f 4f       	sbci	r23, 0xFF	; 255
    143c:	80 ea       	ldi	r24, 0xA0	; 160
    143e:	99 e0       	ldi	r25, 0x09	; 9
    1440:	92 d7       	rcall	.+3876   	; 0x2366 <usart_spi_select_device>
    1442:	81 e0       	ldi	r24, 0x01	; 1
    1444:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1448:	e0 ea       	ldi	r30, 0xA0	; 160
    144a:	f9 e0       	ldi	r31, 0x09	; 9
    144c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    144e:	85 ff       	sbrs	r24, 5
    1450:	fd cf       	rjmp	.-6      	; 0x144c <st7565r_init+0x31a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1452:	81 e2       	ldi	r24, 0x21	; 33
    1454:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1458:	e0 ea       	ldi	r30, 0xA0	; 160
    145a:	f9 e0       	ldi	r31, 0x09	; 9
    145c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    145e:	86 ff       	sbrs	r24, 6
    1460:	fd cf       	rjmp	.-6      	; 0x145c <st7565r_init+0x32a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1462:	e0 ea       	ldi	r30, 0xA0	; 160
    1464:	f9 e0       	ldi	r31, 0x09	; 9
    1466:	80 e4       	ldi	r24, 0x40	; 64
    1468:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    146a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    146c:	be 01       	movw	r22, r28
    146e:	6f 5f       	subi	r22, 0xFF	; 255
    1470:	7f 4f       	sbci	r23, 0xFF	; 255
    1472:	80 ea       	ldi	r24, 0xA0	; 160
    1474:	99 e0       	ldi	r25, 0x09	; 9
    1476:	8d d7       	rcall	.+3866   	; 0x2392 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1478:	8b e2       	ldi	r24, 0x2B	; 43
    147a:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    147c:	be 01       	movw	r22, r28
    147e:	6f 5f       	subi	r22, 0xFF	; 255
    1480:	7f 4f       	sbci	r23, 0xFF	; 255
    1482:	80 ea       	ldi	r24, 0xA0	; 160
    1484:	99 e0       	ldi	r25, 0x09	; 9
    1486:	6f d7       	rcall	.+3806   	; 0x2366 <usart_spi_select_device>
    1488:	81 e0       	ldi	r24, 0x01	; 1
    148a:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    148e:	e0 ea       	ldi	r30, 0xA0	; 160
    1490:	f9 e0       	ldi	r31, 0x09	; 9
    1492:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1494:	85 ff       	sbrs	r24, 5
    1496:	fd cf       	rjmp	.-6      	; 0x1492 <st7565r_init+0x360>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1498:	8f ea       	ldi	r24, 0xAF	; 175
    149a:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    149e:	e0 ea       	ldi	r30, 0xA0	; 160
    14a0:	f9 e0       	ldi	r31, 0x09	; 9
    14a2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    14a4:	86 ff       	sbrs	r24, 6
    14a6:	fd cf       	rjmp	.-6      	; 0x14a2 <st7565r_init+0x370>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    14a8:	e0 ea       	ldi	r30, 0xA0	; 160
    14aa:	f9 e0       	ldi	r31, 0x09	; 9
    14ac:	80 e4       	ldi	r24, 0x40	; 64
    14ae:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    14b0:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    14b2:	be 01       	movw	r22, r28
    14b4:	6f 5f       	subi	r22, 0xFF	; 255
    14b6:	7f 4f       	sbci	r23, 0xFF	; 255
    14b8:	80 ea       	ldi	r24, 0xA0	; 160
    14ba:	99 e0       	ldi	r25, 0x09	; 9
    14bc:	6a d7       	rcall	.+3796   	; 0x2392 <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
    14be:	0f 90       	pop	r0
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	1f 91       	pop	r17
    14c6:	0f 91       	pop	r16
    14c8:	ff 90       	pop	r15
    14ca:	ef 90       	pop	r14
    14cc:	df 90       	pop	r13
    14ce:	cf 90       	pop	r12
    14d0:	bf 90       	pop	r11
    14d2:	08 95       	ret

000014d4 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
    14d4:	ff 92       	push	r15
    14d6:	0f 93       	push	r16
    14d8:	1f 93       	push	r17
    14da:	cf 93       	push	r28
    14dc:	df 93       	push	r29
    14de:	1f 92       	push	r1
    14e0:	cd b7       	in	r28, 0x3d	; 61
    14e2:	de b7       	in	r29, 0x3e	; 62
    14e4:	08 2f       	mov	r16, r24
    14e6:	f6 2e       	mov	r15, r22
    14e8:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
    14ea:	6e d7       	rcall	.+3804   	; 0x23c8 <gfx_mono_framebuffer_put_byte>
 * \param address the page address
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
    14ec:	0f 70       	andi	r16, 0x0F	; 15
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
    14ee:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    14f0:	8b e2       	ldi	r24, 0x2B	; 43
    14f2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    14f4:	be 01       	movw	r22, r28
    14f6:	6f 5f       	subi	r22, 0xFF	; 255
    14f8:	7f 4f       	sbci	r23, 0xFF	; 255
    14fa:	80 ea       	ldi	r24, 0xA0	; 160
    14fc:	99 e0       	ldi	r25, 0x09	; 9
    14fe:	33 d7       	rcall	.+3686   	; 0x2366 <usart_spi_select_device>
    1500:	81 e0       	ldi	r24, 0x01	; 1
    1502:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1506:	e0 ea       	ldi	r30, 0xA0	; 160
    1508:	f9 e0       	ldi	r31, 0x09	; 9
    150a:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    150c:	95 ff       	sbrs	r25, 5
    150e:	fd cf       	rjmp	.-6      	; 0x150a <gfx_mono_st7565r_put_byte+0x36>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1510:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1514:	e0 ea       	ldi	r30, 0xA0	; 160
    1516:	f9 e0       	ldi	r31, 0x09	; 9
    1518:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    151a:	86 ff       	sbrs	r24, 6
    151c:	fd cf       	rjmp	.-6      	; 0x1518 <gfx_mono_st7565r_put_byte+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    151e:	e0 ea       	ldi	r30, 0xA0	; 160
    1520:	f9 e0       	ldi	r31, 0x09	; 9
    1522:	80 e4       	ldi	r24, 0x40	; 64
    1524:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1526:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1528:	be 01       	movw	r22, r28
    152a:	6f 5f       	subi	r22, 0xFF	; 255
    152c:	7f 4f       	sbci	r23, 0xFF	; 255
    152e:	80 ea       	ldi	r24, 0xA0	; 160
    1530:	99 e0       	ldi	r25, 0x09	; 9
    1532:	2f d7       	rcall	.+3678   	; 0x2392 <usart_spi_deselect_device>
 * \param address the column address
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
    1534:	0f 2d       	mov	r16, r15
    1536:	0f 77       	andi	r16, 0x7F	; 127
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
    1538:	02 95       	swap	r16
    153a:	0f 70       	andi	r16, 0x0F	; 15
    153c:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    153e:	8b e2       	ldi	r24, 0x2B	; 43
    1540:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1542:	be 01       	movw	r22, r28
    1544:	6f 5f       	subi	r22, 0xFF	; 255
    1546:	7f 4f       	sbci	r23, 0xFF	; 255
    1548:	80 ea       	ldi	r24, 0xA0	; 160
    154a:	99 e0       	ldi	r25, 0x09	; 9
    154c:	0c d7       	rcall	.+3608   	; 0x2366 <usart_spi_select_device>
    154e:	81 e0       	ldi	r24, 0x01	; 1
    1550:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1554:	e0 ea       	ldi	r30, 0xA0	; 160
    1556:	f9 e0       	ldi	r31, 0x09	; 9
    1558:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    155a:	85 ff       	sbrs	r24, 5
    155c:	fd cf       	rjmp	.-6      	; 0x1558 <gfx_mono_st7565r_put_byte+0x84>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    155e:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1562:	e0 ea       	ldi	r30, 0xA0	; 160
    1564:	f9 e0       	ldi	r31, 0x09	; 9
    1566:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1568:	86 ff       	sbrs	r24, 6
    156a:	fd cf       	rjmp	.-6      	; 0x1566 <gfx_mono_st7565r_put_byte+0x92>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    156c:	e0 ea       	ldi	r30, 0xA0	; 160
    156e:	f9 e0       	ldi	r31, 0x09	; 9
    1570:	80 e4       	ldi	r24, 0x40	; 64
    1572:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1574:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1576:	be 01       	movw	r22, r28
    1578:	6f 5f       	subi	r22, 0xFF	; 255
    157a:	7f 4f       	sbci	r23, 0xFF	; 255
    157c:	80 ea       	ldi	r24, 0xA0	; 160
    157e:	99 e0       	ldi	r25, 0x09	; 9
    1580:	08 d7       	rcall	.+3600   	; 0x2392 <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
    1582:	0f 2d       	mov	r16, r15
    1584:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1586:	8b e2       	ldi	r24, 0x2B	; 43
    1588:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    158a:	be 01       	movw	r22, r28
    158c:	6f 5f       	subi	r22, 0xFF	; 255
    158e:	7f 4f       	sbci	r23, 0xFF	; 255
    1590:	80 ea       	ldi	r24, 0xA0	; 160
    1592:	99 e0       	ldi	r25, 0x09	; 9
    1594:	e8 d6       	rcall	.+3536   	; 0x2366 <usart_spi_select_device>
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    159c:	e0 ea       	ldi	r30, 0xA0	; 160
    159e:	f9 e0       	ldi	r31, 0x09	; 9
    15a0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    15a2:	85 ff       	sbrs	r24, 5
    15a4:	fd cf       	rjmp	.-6      	; 0x15a0 <gfx_mono_st7565r_put_byte+0xcc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    15a6:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    15aa:	e0 ea       	ldi	r30, 0xA0	; 160
    15ac:	f9 e0       	ldi	r31, 0x09	; 9
    15ae:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    15b0:	86 ff       	sbrs	r24, 6
    15b2:	fd cf       	rjmp	.-6      	; 0x15ae <gfx_mono_st7565r_put_byte+0xda>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    15b4:	e0 ea       	ldi	r30, 0xA0	; 160
    15b6:	f9 e0       	ldi	r31, 0x09	; 9
    15b8:	80 e4       	ldi	r24, 0x40	; 64
    15ba:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    15bc:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    15be:	be 01       	movw	r22, r28
    15c0:	6f 5f       	subi	r22, 0xFF	; 255
    15c2:	7f 4f       	sbci	r23, 0xFF	; 255
    15c4:	80 ea       	ldi	r24, 0xA0	; 160
    15c6:	99 e0       	ldi	r25, 0x09	; 9
    15c8:	e4 d6       	rcall	.+3528   	; 0x2392 <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    15ca:	8b e2       	ldi	r24, 0x2B	; 43
    15cc:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    15ce:	be 01       	movw	r22, r28
    15d0:	6f 5f       	subi	r22, 0xFF	; 255
    15d2:	7f 4f       	sbci	r23, 0xFF	; 255
    15d4:	80 ea       	ldi	r24, 0xA0	; 160
    15d6:	99 e0       	ldi	r25, 0x09	; 9
    15d8:	c6 d6       	rcall	.+3468   	; 0x2366 <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    15da:	81 e0       	ldi	r24, 0x01	; 1
    15dc:	80 93 65 06 	sts	0x0665, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    15e0:	e0 ea       	ldi	r30, 0xA0	; 160
    15e2:	f9 e0       	ldi	r31, 0x09	; 9
    15e4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    15e6:	85 ff       	sbrs	r24, 5
    15e8:	fd cf       	rjmp	.-6      	; 0x15e4 <gfx_mono_st7565r_put_byte+0x110>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    15ea:	10 93 a0 09 	sts	0x09A0, r17
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    15ee:	e0 ea       	ldi	r30, 0xA0	; 160
    15f0:	f9 e0       	ldi	r31, 0x09	; 9
    15f2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    15f4:	86 ff       	sbrs	r24, 6
    15f6:	fd cf       	rjmp	.-6      	; 0x15f2 <gfx_mono_st7565r_put_byte+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    15f8:	e0 ea       	ldi	r30, 0xA0	; 160
    15fa:	f9 e0       	ldi	r31, 0x09	; 9
    15fc:	80 e4       	ldi	r24, 0x40	; 64
    15fe:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1600:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    1602:	81 e0       	ldi	r24, 0x01	; 1
    1604:	80 93 66 06 	sts	0x0666, r24
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1608:	be 01       	movw	r22, r28
    160a:	6f 5f       	subi	r22, 0xFF	; 255
    160c:	7f 4f       	sbci	r23, 0xFF	; 255
    160e:	80 ea       	ldi	r24, 0xA0	; 160
    1610:	99 e0       	ldi	r25, 0x09	; 9
    1612:	bf d6       	rcall	.+3454   	; 0x2392 <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
    1614:	0f 90       	pop	r0
    1616:	df 91       	pop	r29
    1618:	cf 91       	pop	r28
    161a:	1f 91       	pop	r17
    161c:	0f 91       	pop	r16
    161e:	ff 90       	pop	r15
    1620:	08 95       	ret

00001622 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
    1622:	0f 93       	push	r16
    1624:	1f 93       	push	r17
    1626:	cf 93       	push	r28
    1628:	df 93       	push	r29
    162a:	1f 92       	push	r1
    162c:	cd b7       	in	r28, 0x3d	; 61
    162e:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
    1630:	8f e6       	ldi	r24, 0x6F	; 111
    1632:	91 e2       	ldi	r25, 0x21	; 33
    1634:	c4 d6       	rcall	.+3464   	; 0x23be <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
    1636:	7d dd       	rcall	.-1286   	; 0x1132 <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1638:	8b e2       	ldi	r24, 0x2B	; 43
    163a:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    163c:	be 01       	movw	r22, r28
    163e:	6f 5f       	subi	r22, 0xFF	; 255
    1640:	7f 4f       	sbci	r23, 0xFF	; 255
    1642:	80 ea       	ldi	r24, 0xA0	; 160
    1644:	99 e0       	ldi	r25, 0x09	; 9
    1646:	8f d6       	rcall	.+3358   	; 0x2366 <usart_spi_select_device>
    1648:	81 e0       	ldi	r24, 0x01	; 1
    164a:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    164e:	e0 ea       	ldi	r30, 0xA0	; 160
    1650:	f9 e0       	ldi	r31, 0x09	; 9
    1652:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1654:	85 ff       	sbrs	r24, 5
    1656:	fd cf       	rjmp	.-6      	; 0x1652 <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1658:	80 e4       	ldi	r24, 0x40	; 64
    165a:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    165e:	e0 ea       	ldi	r30, 0xA0	; 160
    1660:	f9 e0       	ldi	r31, 0x09	; 9
    1662:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1664:	86 ff       	sbrs	r24, 6
    1666:	fd cf       	rjmp	.-6      	; 0x1662 <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1668:	e0 ea       	ldi	r30, 0xA0	; 160
    166a:	f9 e0       	ldi	r31, 0x09	; 9
    166c:	80 e4       	ldi	r24, 0x40	; 64
    166e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1670:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1672:	be 01       	movw	r22, r28
    1674:	6f 5f       	subi	r22, 0xFF	; 255
    1676:	7f 4f       	sbci	r23, 0xFF	; 255
    1678:	80 ea       	ldi	r24, 0xA0	; 160
    167a:	99 e0       	ldi	r25, 0x09	; 9
    167c:	8a d6       	rcall	.+3348   	; 0x2392 <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    167e:	00 e0       	ldi	r16, 0x00	; 0
    1680:	0a c0       	rjmp	.+20     	; 0x1696 <gfx_mono_st7565r_init+0x74>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
    1682:	40 e0       	ldi	r20, 0x00	; 0
    1684:	61 2f       	mov	r22, r17
    1686:	80 2f       	mov	r24, r16
    1688:	25 df       	rcall	.-438    	; 0x14d4 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
    168a:	1f 5f       	subi	r17, 0xFF	; 255
    168c:	10 38       	cpi	r17, 0x80	; 128
    168e:	c9 f7       	brne	.-14     	; 0x1682 <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    1690:	0f 5f       	subi	r16, 0xFF	; 255
    1692:	04 30       	cpi	r16, 0x04	; 4
    1694:	11 f0       	breq	.+4      	; 0x169a <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
    1696:	10 e0       	ldi	r17, 0x00	; 0
    1698:	f4 cf       	rjmp	.-24     	; 0x1682 <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
    169a:	0f 90       	pop	r0
    169c:	df 91       	pop	r29
    169e:	cf 91       	pop	r28
    16a0:	1f 91       	pop	r17
    16a2:	0f 91       	pop	r16
    16a4:	08 95       	ret

000016a6 <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
    16a6:	ff 92       	push	r15
    16a8:	0f 93       	push	r16
    16aa:	1f 93       	push	r17
    16ac:	cf 93       	push	r28
    16ae:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
    16b0:	88 23       	and	r24, r24
    16b2:	8c f1       	brlt	.+98     	; 0x1716 <gfx_mono_st7565r_draw_pixel+0x70>
    16b4:	60 32       	cpi	r22, 0x20	; 32
    16b6:	78 f5       	brcc	.+94     	; 0x1716 <gfx_mono_st7565r_draw_pixel+0x70>
    16b8:	d4 2f       	mov	r29, r20
    16ba:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
    16bc:	f6 2e       	mov	r15, r22
    16be:	f6 94       	lsr	r15
    16c0:	f6 94       	lsr	r15
    16c2:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
    16c4:	2f 2d       	mov	r18, r15
    16c6:	30 e0       	ldi	r19, 0x00	; 0
    16c8:	31 95       	neg	r19
    16ca:	21 95       	neg	r18
    16cc:	31 09       	sbc	r19, r1
    16ce:	22 0f       	add	r18, r18
    16d0:	33 1f       	adc	r19, r19
    16d2:	22 0f       	add	r18, r18
    16d4:	33 1f       	adc	r19, r19
    16d6:	22 0f       	add	r18, r18
    16d8:	33 1f       	adc	r19, r19
    16da:	26 0f       	add	r18, r22
    16dc:	31 1d       	adc	r19, r1
    16de:	61 e0       	ldi	r22, 0x01	; 1
    16e0:	70 e0       	ldi	r23, 0x00	; 0
    16e2:	8b 01       	movw	r16, r22
    16e4:	02 c0       	rjmp	.+4      	; 0x16ea <gfx_mono_st7565r_draw_pixel+0x44>
    16e6:	00 0f       	add	r16, r16
    16e8:	11 1f       	adc	r17, r17
    16ea:	2a 95       	dec	r18
    16ec:	e2 f7       	brpl	.-8      	; 0x16e6 <gfx_mono_st7565r_draw_pixel+0x40>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
    16ee:	68 2f       	mov	r22, r24
    16f0:	8f 2d       	mov	r24, r15
    16f2:	78 d6       	rcall	.+3312   	; 0x23e4 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
    16f4:	d1 30       	cpi	r29, 0x01	; 1
    16f6:	21 f0       	breq	.+8      	; 0x1700 <gfx_mono_st7565r_draw_pixel+0x5a>
    16f8:	28 f0       	brcs	.+10     	; 0x1704 <gfx_mono_st7565r_draw_pixel+0x5e>
    16fa:	d2 30       	cpi	r29, 0x02	; 2
    16fc:	39 f0       	breq	.+14     	; 0x170c <gfx_mono_st7565r_draw_pixel+0x66>
    16fe:	07 c0       	rjmp	.+14     	; 0x170e <gfx_mono_st7565r_draw_pixel+0x68>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
    1700:	80 2b       	or	r24, r16
		break;
    1702:	05 c0       	rjmp	.+10     	; 0x170e <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
    1704:	60 2f       	mov	r22, r16
    1706:	60 95       	com	r22
    1708:	86 23       	and	r24, r22
		break;
    170a:	01 c0       	rjmp	.+2      	; 0x170e <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
    170c:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
    170e:	48 2f       	mov	r20, r24
    1710:	6c 2f       	mov	r22, r28
    1712:	8f 2d       	mov	r24, r15
    1714:	df de       	rcall	.-578    	; 0x14d4 <gfx_mono_st7565r_put_byte>
}
    1716:	df 91       	pop	r29
    1718:	cf 91       	pop	r28
    171a:	1f 91       	pop	r17
    171c:	0f 91       	pop	r16
    171e:	ff 90       	pop	r15
    1720:	08 95       	ret

00001722 <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
    1722:	60 c6       	rjmp	.+3264   	; 0x23e4 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
    1724:	08 95       	ret

00001726 <tb_init>:


uint16_t qt_measurement_period_msec = 25;

void tb_init(void) {
	qt_config_data.qt_di				= DEF_QT_DI;
    1726:	e1 e2       	ldi	r30, 0x21	; 33
    1728:	f1 e2       	ldi	r31, 0x21	; 33
    172a:	84 e0       	ldi	r24, 0x04	; 4
    172c:	81 83       	std	Z+1, r24	; 0x01
	qt_config_data.qt_neg_drift_rate	= DEF_QT_NEG_DRIFT_RATE;
    172e:	84 e1       	ldi	r24, 0x14	; 20
    1730:	84 83       	std	Z+4, r24	; 0x04
	qt_config_data.qt_pos_drift_rate	= DEF_QT_POS_DRIFT_RATE;
    1732:	95 e0       	ldi	r25, 0x05	; 5
    1734:	95 83       	std	Z+5, r25	; 0x05
	qt_config_data.qt_max_on_duration	= DEF_QT_MAX_ON_DURATION;
    1736:	13 82       	std	Z+3, r1	; 0x03
	qt_config_data.qt_drift_hold_time	= DEF_QT_DRIFT_HOLD_TIME;
    1738:	82 83       	std	Z+2, r24	; 0x02
	qt_config_data.qt_recal_threshold	= DEF_QT_RECAL_THRESHOLD;
    173a:	81 e0       	ldi	r24, 0x01	; 1
    173c:	80 83       	st	Z, r24
	qt_config_data.qt_pos_recal_delay	= DEF_QT_POS_RECAL_DELAY;
    173e:	83 e0       	ldi	r24, 0x03	; 3
    1740:	86 83       	std	Z+6, r24	; 0x06
	qt_filter_callback					= 0;
    1742:	10 92 3b 21 	sts	0x213B, r1
    1746:	10 92 3c 21 	sts	0x213C, r1


	#ifdef QTOUCH_STUDIO_MASKS
		SNS_array[0][0] = 0x40;
    174a:	ef e5       	ldi	r30, 0x5F	; 95
    174c:	f1 e2       	ldi	r31, 0x21	; 33
    174e:	80 e4       	ldi	r24, 0x40	; 64
    1750:	80 83       	st	Z, r24
		SNS_array[0][1] = 0x0;
    1752:	11 82       	std	Z+1, r1	; 0x01
		SNS_array[1][0] = 0x0;
    1754:	12 82       	std	Z+2, r1	; 0x02
		SNS_array[1][1] = 0x0;
    1756:	13 82       	std	Z+3, r1	; 0x03

		SNSK_array[0][0] = 0x80;
    1758:	e3 e6       	ldi	r30, 0x63	; 99
    175a:	f1 e2       	ldi	r31, 0x21	; 33
    175c:	80 e8       	ldi	r24, 0x80	; 128
    175e:	80 83       	st	Z, r24
		SNSK_array[0][1] = 0x0;
    1760:	11 82       	std	Z+1, r1	; 0x01
		SNSK_array[1][0] = 0x0;
    1762:	12 82       	std	Z+2, r1	; 0x02
		SNSK_array[1][1] = 0x0;
    1764:	13 82       	std	Z+3, r1	; 0x03
	 * When using "pin configurability" this will result in channel 0
	 * because it is the first and only channel that is used.
	 * For the standard qtouch library setup we would need to use
	 * channel 3 since we are using the last two pins on the port.
	 */
	qt_enable_key(CHANNEL_0, NO_AKS_GROUP, 10, HYST_6_25);
    1766:	23 e0       	ldi	r18, 0x03	; 3
    1768:	4a e0       	ldi	r20, 0x0A	; 10
    176a:	60 e0       	ldi	r22, 0x00	; 0
    176c:	80 e0       	ldi	r24, 0x00	; 0
    176e:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <qt_enable_key>

	qt_init_sensing();
    1772:	60 e0       	ldi	r22, 0x00	; 0
    1774:	70 e0       	ldi	r23, 0x00	; 0
    1776:	87 e8       	ldi	r24, 0x87	; 135
    1778:	92 e0       	ldi	r25, 0x02	; 2
    177a:	bf c8       	rjmp	.-3714   	; 0x8fa <qt_init_sensing_with_burst>
    177c:	08 95       	ret

0000177e <adc_set_callback>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    177e:	4f b7       	in	r20, 0x3f	; 63
	cpu_irq_disable();
    1780:	f8 94       	cli
	Assert(callback);

	flags = cpu_irq_save();

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    1782:	28 2f       	mov	r18, r24
    1784:	39 2f       	mov	r19, r25
    1786:	21 15       	cp	r18, r1
    1788:	82 e0       	ldi	r24, 0x02	; 2
    178a:	38 07       	cpc	r19, r24
    178c:	29 f4       	brne	.+10     	; 0x1798 <adc_set_callback+0x1a>
		adca_callback = callback;
    178e:	60 93 ec 23 	sts	0x23EC, r22
    1792:	70 93 ed 23 	sts	0x23ED, r23
    1796:	07 c0       	rjmp	.+14     	; 0x17a6 <adc_set_callback+0x28>
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1798:	20 34       	cpi	r18, 0x40	; 64
    179a:	32 40       	sbci	r19, 0x02	; 2
    179c:	21 f4       	brne	.+8      	; 0x17a6 <adc_set_callback+0x28>
		adcb_callback = callback;
    179e:	60 93 ea 23 	sts	0x23EA, r22
    17a2:	70 93 eb 23 	sts	0x23EB, r23
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    17a6:	4f bf       	out	0x3f, r20	; 63
    17a8:	08 95       	ret

000017aa <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
    17aa:	81 15       	cp	r24, r1
    17ac:	22 e0       	ldi	r18, 0x02	; 2
    17ae:	92 07       	cpc	r25, r18
    17b0:	69 f4       	brne	.+26     	; 0x17cc <adc_enable_clock+0x22>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
    17b2:	80 91 70 23 	lds	r24, 0x2370
    17b6:	91 e0       	ldi	r25, 0x01	; 1
    17b8:	98 0f       	add	r25, r24
    17ba:	90 93 70 23 	sts	0x2370, r25
    17be:	81 11       	cpse	r24, r1
    17c0:	14 c0       	rjmp	.+40     	; 0x17ea <adc_enable_clock+0x40>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    17c2:	62 e0       	ldi	r22, 0x02	; 2
    17c4:	81 e0       	ldi	r24, 0x01	; 1
    17c6:	0c 94 5f 18 	jmp	0x30be	; 0x30be <sysclk_enable_module>
    17ca:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
    17cc:	80 34       	cpi	r24, 0x40	; 64
    17ce:	92 40       	sbci	r25, 0x02	; 2
    17d0:	61 f4       	brne	.+24     	; 0x17ea <adc_enable_clock+0x40>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
    17d2:	80 91 6f 23 	lds	r24, 0x236F
    17d6:	91 e0       	ldi	r25, 0x01	; 1
    17d8:	98 0f       	add	r25, r24
    17da:	90 93 6f 23 	sts	0x236F, r25
    17de:	81 11       	cpse	r24, r1
    17e0:	04 c0       	rjmp	.+8      	; 0x17ea <adc_enable_clock+0x40>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    17e2:	62 e0       	ldi	r22, 0x02	; 2
    17e4:	82 e0       	ldi	r24, 0x02	; 2
    17e6:	0c 94 5f 18 	jmp	0x30be	; 0x30be <sysclk_enable_module>
    17ea:	08 95       	ret

000017ec <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
    17ec:	81 15       	cp	r24, r1
    17ee:	22 e0       	ldi	r18, 0x02	; 2
    17f0:	92 07       	cpc	r25, r18
    17f2:	61 f4       	brne	.+24     	; 0x180c <adc_disable_clock+0x20>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
    17f4:	80 91 70 23 	lds	r24, 0x2370
    17f8:	81 50       	subi	r24, 0x01	; 1
    17fa:	80 93 70 23 	sts	0x2370, r24
    17fe:	81 11       	cpse	r24, r1
    1800:	13 c0       	rjmp	.+38     	; 0x1828 <adc_disable_clock+0x3c>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1802:	62 e0       	ldi	r22, 0x02	; 2
    1804:	81 e0       	ldi	r24, 0x01	; 1
    1806:	0c 94 6b 18 	jmp	0x30d6	; 0x30d6 <sysclk_disable_module>
    180a:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
    180c:	80 34       	cpi	r24, 0x40	; 64
    180e:	92 40       	sbci	r25, 0x02	; 2
    1810:	59 f4       	brne	.+22     	; 0x1828 <adc_disable_clock+0x3c>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
    1812:	80 91 6f 23 	lds	r24, 0x236F
    1816:	81 50       	subi	r24, 0x01	; 1
    1818:	80 93 6f 23 	sts	0x236F, r24
    181c:	81 11       	cpse	r24, r1
    181e:	04 c0       	rjmp	.+8      	; 0x1828 <adc_disable_clock+0x3c>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1820:	62 e0       	ldi	r22, 0x02	; 2
    1822:	82 e0       	ldi	r24, 0x02	; 2
    1824:	0c 94 6b 18 	jmp	0x30d6	; 0x30d6 <sysclk_disable_module>
    1828:	08 95       	ret

0000182a <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
    182a:	1f 93       	push	r17
    182c:	cf 93       	push	r28
    182e:	df 93       	push	r29
    1830:	ec 01       	movw	r28, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1832:	1f b7       	in	r17, 0x3f	; 63
	cpu_irq_disable();
    1834:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
    1836:	b9 df       	rcall	.-142    	; 0x17aa <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
    1838:	88 81       	ld	r24, Y
    183a:	81 60       	ori	r24, 0x01	; 1
    183c:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    183e:	1f bf       	out	0x3f, r17	; 63

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1840:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    1842:	f8 94       	cli
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
    1844:	e4 ee       	ldi	r30, 0xE4	; 228
    1846:	f3 e2       	ldi	r31, 0x23	; 35
    1848:	81 81       	ldd	r24, Z+1	; 0x01
    184a:	8f 5f       	subi	r24, 0xFF	; 255
    184c:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    184e:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
    1850:	df 91       	pop	r29
    1852:	cf 91       	pop	r28
    1854:	1f 91       	pop	r17
    1856:	08 95       	ret

00001858 <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
    1858:	1f 92       	push	r1
    185a:	0f 92       	push	r0
    185c:	0f b6       	in	r0, 0x3f	; 63
    185e:	0f 92       	push	r0
    1860:	11 24       	eor	r1, r1
    1862:	0b b6       	in	r0, 0x3b	; 59
    1864:	0f 92       	push	r0
    1866:	2f 93       	push	r18
    1868:	3f 93       	push	r19
    186a:	4f 93       	push	r20
    186c:	5f 93       	push	r21
    186e:	6f 93       	push	r22
    1870:	7f 93       	push	r23
    1872:	8f 93       	push	r24
    1874:	9f 93       	push	r25
    1876:	af 93       	push	r26
    1878:	bf 93       	push	r27
    187a:	ef 93       	push	r30
    187c:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
    187e:	40 91 24 02 	lds	r20, 0x0224
    1882:	50 91 25 02 	lds	r21, 0x0225
    1886:	e0 91 ec 23 	lds	r30, 0x23EC
    188a:	f0 91 ed 23 	lds	r31, 0x23ED
    188e:	61 e0       	ldi	r22, 0x01	; 1
    1890:	80 e0       	ldi	r24, 0x00	; 0
    1892:	92 e0       	ldi	r25, 0x02	; 2
    1894:	19 95       	eicall
}
    1896:	ff 91       	pop	r31
    1898:	ef 91       	pop	r30
    189a:	bf 91       	pop	r27
    189c:	af 91       	pop	r26
    189e:	9f 91       	pop	r25
    18a0:	8f 91       	pop	r24
    18a2:	7f 91       	pop	r23
    18a4:	6f 91       	pop	r22
    18a6:	5f 91       	pop	r21
    18a8:	4f 91       	pop	r20
    18aa:	3f 91       	pop	r19
    18ac:	2f 91       	pop	r18
    18ae:	0f 90       	pop	r0
    18b0:	0b be       	out	0x3b, r0	; 59
    18b2:	0f 90       	pop	r0
    18b4:	0f be       	out	0x3f, r0	; 63
    18b6:	0f 90       	pop	r0
    18b8:	1f 90       	pop	r1
    18ba:	18 95       	reti

000018bc <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
    18bc:	1f 92       	push	r1
    18be:	0f 92       	push	r0
    18c0:	0f b6       	in	r0, 0x3f	; 63
    18c2:	0f 92       	push	r0
    18c4:	11 24       	eor	r1, r1
    18c6:	0b b6       	in	r0, 0x3b	; 59
    18c8:	0f 92       	push	r0
    18ca:	2f 93       	push	r18
    18cc:	3f 93       	push	r19
    18ce:	4f 93       	push	r20
    18d0:	5f 93       	push	r21
    18d2:	6f 93       	push	r22
    18d4:	7f 93       	push	r23
    18d6:	8f 93       	push	r24
    18d8:	9f 93       	push	r25
    18da:	af 93       	push	r26
    18dc:	bf 93       	push	r27
    18de:	ef 93       	push	r30
    18e0:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
    18e2:	40 91 2c 02 	lds	r20, 0x022C
    18e6:	50 91 2d 02 	lds	r21, 0x022D
    18ea:	e0 91 ec 23 	lds	r30, 0x23EC
    18ee:	f0 91 ed 23 	lds	r31, 0x23ED
    18f2:	62 e0       	ldi	r22, 0x02	; 2
    18f4:	80 e0       	ldi	r24, 0x00	; 0
    18f6:	92 e0       	ldi	r25, 0x02	; 2
    18f8:	19 95       	eicall
}
    18fa:	ff 91       	pop	r31
    18fc:	ef 91       	pop	r30
    18fe:	bf 91       	pop	r27
    1900:	af 91       	pop	r26
    1902:	9f 91       	pop	r25
    1904:	8f 91       	pop	r24
    1906:	7f 91       	pop	r23
    1908:	6f 91       	pop	r22
    190a:	5f 91       	pop	r21
    190c:	4f 91       	pop	r20
    190e:	3f 91       	pop	r19
    1910:	2f 91       	pop	r18
    1912:	0f 90       	pop	r0
    1914:	0b be       	out	0x3b, r0	; 59
    1916:	0f 90       	pop	r0
    1918:	0f be       	out	0x3f, r0	; 63
    191a:	0f 90       	pop	r0
    191c:	1f 90       	pop	r1
    191e:	18 95       	reti

00001920 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
    1920:	1f 92       	push	r1
    1922:	0f 92       	push	r0
    1924:	0f b6       	in	r0, 0x3f	; 63
    1926:	0f 92       	push	r0
    1928:	11 24       	eor	r1, r1
    192a:	0b b6       	in	r0, 0x3b	; 59
    192c:	0f 92       	push	r0
    192e:	2f 93       	push	r18
    1930:	3f 93       	push	r19
    1932:	4f 93       	push	r20
    1934:	5f 93       	push	r21
    1936:	6f 93       	push	r22
    1938:	7f 93       	push	r23
    193a:	8f 93       	push	r24
    193c:	9f 93       	push	r25
    193e:	af 93       	push	r26
    1940:	bf 93       	push	r27
    1942:	ef 93       	push	r30
    1944:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
    1946:	40 91 34 02 	lds	r20, 0x0234
    194a:	50 91 35 02 	lds	r21, 0x0235
    194e:	e0 91 ec 23 	lds	r30, 0x23EC
    1952:	f0 91 ed 23 	lds	r31, 0x23ED
    1956:	64 e0       	ldi	r22, 0x04	; 4
    1958:	80 e0       	ldi	r24, 0x00	; 0
    195a:	92 e0       	ldi	r25, 0x02	; 2
    195c:	19 95       	eicall
}
    195e:	ff 91       	pop	r31
    1960:	ef 91       	pop	r30
    1962:	bf 91       	pop	r27
    1964:	af 91       	pop	r26
    1966:	9f 91       	pop	r25
    1968:	8f 91       	pop	r24
    196a:	7f 91       	pop	r23
    196c:	6f 91       	pop	r22
    196e:	5f 91       	pop	r21
    1970:	4f 91       	pop	r20
    1972:	3f 91       	pop	r19
    1974:	2f 91       	pop	r18
    1976:	0f 90       	pop	r0
    1978:	0b be       	out	0x3b, r0	; 59
    197a:	0f 90       	pop	r0
    197c:	0f be       	out	0x3f, r0	; 63
    197e:	0f 90       	pop	r0
    1980:	1f 90       	pop	r1
    1982:	18 95       	reti

00001984 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    1984:	1f 92       	push	r1
    1986:	0f 92       	push	r0
    1988:	0f b6       	in	r0, 0x3f	; 63
    198a:	0f 92       	push	r0
    198c:	11 24       	eor	r1, r1
    198e:	0b b6       	in	r0, 0x3b	; 59
    1990:	0f 92       	push	r0
    1992:	2f 93       	push	r18
    1994:	3f 93       	push	r19
    1996:	4f 93       	push	r20
    1998:	5f 93       	push	r21
    199a:	6f 93       	push	r22
    199c:	7f 93       	push	r23
    199e:	8f 93       	push	r24
    19a0:	9f 93       	push	r25
    19a2:	af 93       	push	r26
    19a4:	bf 93       	push	r27
    19a6:	ef 93       	push	r30
    19a8:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    19aa:	40 91 3c 02 	lds	r20, 0x023C
    19ae:	50 91 3d 02 	lds	r21, 0x023D
    19b2:	e0 91 ec 23 	lds	r30, 0x23EC
    19b6:	f0 91 ed 23 	lds	r31, 0x23ED
    19ba:	68 e0       	ldi	r22, 0x08	; 8
    19bc:	80 e0       	ldi	r24, 0x00	; 0
    19be:	92 e0       	ldi	r25, 0x02	; 2
    19c0:	19 95       	eicall
}
    19c2:	ff 91       	pop	r31
    19c4:	ef 91       	pop	r30
    19c6:	bf 91       	pop	r27
    19c8:	af 91       	pop	r26
    19ca:	9f 91       	pop	r25
    19cc:	8f 91       	pop	r24
    19ce:	7f 91       	pop	r23
    19d0:	6f 91       	pop	r22
    19d2:	5f 91       	pop	r21
    19d4:	4f 91       	pop	r20
    19d6:	3f 91       	pop	r19
    19d8:	2f 91       	pop	r18
    19da:	0f 90       	pop	r0
    19dc:	0b be       	out	0x3b, r0	; 59
    19de:	0f 90       	pop	r0
    19e0:	0f be       	out	0x3f, r0	; 63
    19e2:	0f 90       	pop	r0
    19e4:	1f 90       	pop	r1
    19e6:	18 95       	reti

000019e8 <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    19e8:	1f 92       	push	r1
    19ea:	0f 92       	push	r0
    19ec:	0f b6       	in	r0, 0x3f	; 63
    19ee:	0f 92       	push	r0
    19f0:	11 24       	eor	r1, r1
    19f2:	0b b6       	in	r0, 0x3b	; 59
    19f4:	0f 92       	push	r0
    19f6:	2f 93       	push	r18
    19f8:	3f 93       	push	r19
    19fa:	4f 93       	push	r20
    19fc:	5f 93       	push	r21
    19fe:	6f 93       	push	r22
    1a00:	7f 93       	push	r23
    1a02:	8f 93       	push	r24
    1a04:	9f 93       	push	r25
    1a06:	af 93       	push	r26
    1a08:	bf 93       	push	r27
    1a0a:	ef 93       	push	r30
    1a0c:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1a0e:	40 91 64 02 	lds	r20, 0x0264
    1a12:	50 91 65 02 	lds	r21, 0x0265
    1a16:	e0 91 ea 23 	lds	r30, 0x23EA
    1a1a:	f0 91 eb 23 	lds	r31, 0x23EB
    1a1e:	61 e0       	ldi	r22, 0x01	; 1
    1a20:	80 e4       	ldi	r24, 0x40	; 64
    1a22:	92 e0       	ldi	r25, 0x02	; 2
    1a24:	19 95       	eicall
}
    1a26:	ff 91       	pop	r31
    1a28:	ef 91       	pop	r30
    1a2a:	bf 91       	pop	r27
    1a2c:	af 91       	pop	r26
    1a2e:	9f 91       	pop	r25
    1a30:	8f 91       	pop	r24
    1a32:	7f 91       	pop	r23
    1a34:	6f 91       	pop	r22
    1a36:	5f 91       	pop	r21
    1a38:	4f 91       	pop	r20
    1a3a:	3f 91       	pop	r19
    1a3c:	2f 91       	pop	r18
    1a3e:	0f 90       	pop	r0
    1a40:	0b be       	out	0x3b, r0	; 59
    1a42:	0f 90       	pop	r0
    1a44:	0f be       	out	0x3f, r0	; 63
    1a46:	0f 90       	pop	r0
    1a48:	1f 90       	pop	r1
    1a4a:	18 95       	reti

00001a4c <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    1a4c:	1f 92       	push	r1
    1a4e:	0f 92       	push	r0
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	0f 92       	push	r0
    1a54:	11 24       	eor	r1, r1
    1a56:	0b b6       	in	r0, 0x3b	; 59
    1a58:	0f 92       	push	r0
    1a5a:	2f 93       	push	r18
    1a5c:	3f 93       	push	r19
    1a5e:	4f 93       	push	r20
    1a60:	5f 93       	push	r21
    1a62:	6f 93       	push	r22
    1a64:	7f 93       	push	r23
    1a66:	8f 93       	push	r24
    1a68:	9f 93       	push	r25
    1a6a:	af 93       	push	r26
    1a6c:	bf 93       	push	r27
    1a6e:	ef 93       	push	r30
    1a70:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    1a72:	40 91 6c 02 	lds	r20, 0x026C
    1a76:	50 91 6d 02 	lds	r21, 0x026D
    1a7a:	e0 91 ea 23 	lds	r30, 0x23EA
    1a7e:	f0 91 eb 23 	lds	r31, 0x23EB
    1a82:	62 e0       	ldi	r22, 0x02	; 2
    1a84:	80 e4       	ldi	r24, 0x40	; 64
    1a86:	92 e0       	ldi	r25, 0x02	; 2
    1a88:	19 95       	eicall
}
    1a8a:	ff 91       	pop	r31
    1a8c:	ef 91       	pop	r30
    1a8e:	bf 91       	pop	r27
    1a90:	af 91       	pop	r26
    1a92:	9f 91       	pop	r25
    1a94:	8f 91       	pop	r24
    1a96:	7f 91       	pop	r23
    1a98:	6f 91       	pop	r22
    1a9a:	5f 91       	pop	r21
    1a9c:	4f 91       	pop	r20
    1a9e:	3f 91       	pop	r19
    1aa0:	2f 91       	pop	r18
    1aa2:	0f 90       	pop	r0
    1aa4:	0b be       	out	0x3b, r0	; 59
    1aa6:	0f 90       	pop	r0
    1aa8:	0f be       	out	0x3f, r0	; 63
    1aaa:	0f 90       	pop	r0
    1aac:	1f 90       	pop	r1
    1aae:	18 95       	reti

00001ab0 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    1ab0:	1f 92       	push	r1
    1ab2:	0f 92       	push	r0
    1ab4:	0f b6       	in	r0, 0x3f	; 63
    1ab6:	0f 92       	push	r0
    1ab8:	11 24       	eor	r1, r1
    1aba:	0b b6       	in	r0, 0x3b	; 59
    1abc:	0f 92       	push	r0
    1abe:	2f 93       	push	r18
    1ac0:	3f 93       	push	r19
    1ac2:	4f 93       	push	r20
    1ac4:	5f 93       	push	r21
    1ac6:	6f 93       	push	r22
    1ac8:	7f 93       	push	r23
    1aca:	8f 93       	push	r24
    1acc:	9f 93       	push	r25
    1ace:	af 93       	push	r26
    1ad0:	bf 93       	push	r27
    1ad2:	ef 93       	push	r30
    1ad4:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    1ad6:	40 91 74 02 	lds	r20, 0x0274
    1ada:	50 91 75 02 	lds	r21, 0x0275
    1ade:	e0 91 ea 23 	lds	r30, 0x23EA
    1ae2:	f0 91 eb 23 	lds	r31, 0x23EB
    1ae6:	64 e0       	ldi	r22, 0x04	; 4
    1ae8:	80 e4       	ldi	r24, 0x40	; 64
    1aea:	92 e0       	ldi	r25, 0x02	; 2
    1aec:	19 95       	eicall
}
    1aee:	ff 91       	pop	r31
    1af0:	ef 91       	pop	r30
    1af2:	bf 91       	pop	r27
    1af4:	af 91       	pop	r26
    1af6:	9f 91       	pop	r25
    1af8:	8f 91       	pop	r24
    1afa:	7f 91       	pop	r23
    1afc:	6f 91       	pop	r22
    1afe:	5f 91       	pop	r21
    1b00:	4f 91       	pop	r20
    1b02:	3f 91       	pop	r19
    1b04:	2f 91       	pop	r18
    1b06:	0f 90       	pop	r0
    1b08:	0b be       	out	0x3b, r0	; 59
    1b0a:	0f 90       	pop	r0
    1b0c:	0f be       	out	0x3f, r0	; 63
    1b0e:	0f 90       	pop	r0
    1b10:	1f 90       	pop	r1
    1b12:	18 95       	reti

00001b14 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1b14:	1f 92       	push	r1
    1b16:	0f 92       	push	r0
    1b18:	0f b6       	in	r0, 0x3f	; 63
    1b1a:	0f 92       	push	r0
    1b1c:	11 24       	eor	r1, r1
    1b1e:	0b b6       	in	r0, 0x3b	; 59
    1b20:	0f 92       	push	r0
    1b22:	2f 93       	push	r18
    1b24:	3f 93       	push	r19
    1b26:	4f 93       	push	r20
    1b28:	5f 93       	push	r21
    1b2a:	6f 93       	push	r22
    1b2c:	7f 93       	push	r23
    1b2e:	8f 93       	push	r24
    1b30:	9f 93       	push	r25
    1b32:	af 93       	push	r26
    1b34:	bf 93       	push	r27
    1b36:	ef 93       	push	r30
    1b38:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    1b3a:	40 91 7c 02 	lds	r20, 0x027C
    1b3e:	50 91 7d 02 	lds	r21, 0x027D
    1b42:	e0 91 ea 23 	lds	r30, 0x23EA
    1b46:	f0 91 eb 23 	lds	r31, 0x23EB
    1b4a:	68 e0       	ldi	r22, 0x08	; 8
    1b4c:	80 e4       	ldi	r24, 0x40	; 64
    1b4e:	92 e0       	ldi	r25, 0x02	; 2
    1b50:	19 95       	eicall
}
    1b52:	ff 91       	pop	r31
    1b54:	ef 91       	pop	r30
    1b56:	bf 91       	pop	r27
    1b58:	af 91       	pop	r26
    1b5a:	9f 91       	pop	r25
    1b5c:	8f 91       	pop	r24
    1b5e:	7f 91       	pop	r23
    1b60:	6f 91       	pop	r22
    1b62:	5f 91       	pop	r21
    1b64:	4f 91       	pop	r20
    1b66:	3f 91       	pop	r19
    1b68:	2f 91       	pop	r18
    1b6a:	0f 90       	pop	r0
    1b6c:	0b be       	out	0x3b, r0	; 59
    1b6e:	0f 90       	pop	r0
    1b70:	0f be       	out	0x3f, r0	; 63
    1b72:	0f 90       	pop	r0
    1b74:	1f 90       	pop	r1
    1b76:	18 95       	reti

00001b78 <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    1b78:	df 92       	push	r13
    1b7a:	ef 92       	push	r14
    1b7c:	ff 92       	push	r15
    1b7e:	0f 93       	push	r16
    1b80:	1f 93       	push	r17
    1b82:	cf 93       	push	r28
    1b84:	df 93       	push	r29
    1b86:	ec 01       	movw	r28, r24
    1b88:	8b 01       	movw	r16, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    1b8a:	c1 15       	cp	r28, r1
    1b8c:	22 e0       	ldi	r18, 0x02	; 2
    1b8e:	d2 07       	cpc	r29, r18
    1b90:	81 f4       	brne	.+32     	; 0x1bb2 <adc_write_configuration+0x3a>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    1b92:	61 e2       	ldi	r22, 0x21	; 33
    1b94:	70 e0       	ldi	r23, 0x00	; 0
    1b96:	82 e0       	ldi	r24, 0x02	; 2
    1b98:	0e 94 76 18 	call	0x30ec	; 0x30ec <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    1b9c:	e8 2e       	mov	r14, r24
    1b9e:	f1 2c       	mov	r15, r1
    1ba0:	60 e2       	ldi	r22, 0x20	; 32
    1ba2:	70 e0       	ldi	r23, 0x00	; 0
    1ba4:	82 e0       	ldi	r24, 0x02	; 2
    1ba6:	0e 94 76 18 	call	0x30ec	; 0x30ec <nvm_read_byte>
		data <<= 8;
    1baa:	fe 2c       	mov	r15, r14
    1bac:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCACAL0);
    1bae:	e8 2a       	or	r14, r24
    1bb0:	12 c0       	rjmp	.+36     	; 0x1bd6 <adc_write_configuration+0x5e>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1bb2:	80 34       	cpi	r24, 0x40	; 64
    1bb4:	92 40       	sbci	r25, 0x02	; 2
    1bb6:	61 f5       	brne	.+88     	; 0x1c10 <adc_write_configuration+0x98>
    1bb8:	65 e2       	ldi	r22, 0x25	; 37
    1bba:	70 e0       	ldi	r23, 0x00	; 0
    1bbc:	82 e0       	ldi	r24, 0x02	; 2
    1bbe:	0e 94 76 18 	call	0x30ec	; 0x30ec <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    1bc2:	e8 2e       	mov	r14, r24
    1bc4:	f1 2c       	mov	r15, r1
    1bc6:	64 e2       	ldi	r22, 0x24	; 36
    1bc8:	70 e0       	ldi	r23, 0x00	; 0
    1bca:	82 e0       	ldi	r24, 0x02	; 2
    1bcc:	0e 94 76 18 	call	0x30ec	; 0x30ec <nvm_read_byte>
		data <<= 8;
    1bd0:	fe 2c       	mov	r15, r14
    1bd2:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCBCAL0);
    1bd4:	e8 2a       	or	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1bd6:	df b6       	in	r13, 0x3f	; 63
	cpu_irq_disable();
    1bd8:	f8 94       	cli
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    1bda:	ce 01       	movw	r24, r28
    1bdc:	e6 dd       	rcall	.-1076   	; 0x17aa <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
    1bde:	88 81       	ld	r24, Y

	adc->CTRLA = ADC_FLUSH_bm;
    1be0:	92 e0       	ldi	r25, 0x02	; 2
    1be2:	98 83       	st	Y, r25
	adc->CAL = cal;
    1be4:	ec 86       	std	Y+12, r14	; 0x0c
    1be6:	fd 86       	std	Y+13, r15	; 0x0d
	adc->CMP = conf->cmp;
    1be8:	f8 01       	movw	r30, r16
    1bea:	25 81       	ldd	r18, Z+5	; 0x05
    1bec:	36 81       	ldd	r19, Z+6	; 0x06
    1bee:	28 8f       	std	Y+24, r18	; 0x18
    1bf0:	39 8f       	std	Y+25, r19	; 0x19
	adc->REFCTRL = conf->refctrl;
    1bf2:	92 81       	ldd	r25, Z+2	; 0x02
    1bf4:	9a 83       	std	Y+2, r25	; 0x02
	adc->PRESCALER = conf->prescaler;
    1bf6:	94 81       	ldd	r25, Z+4	; 0x04
    1bf8:	9c 83       	std	Y+4, r25	; 0x04
	adc->EVCTRL = conf->evctrl;
    1bfa:	93 81       	ldd	r25, Z+3	; 0x03
    1bfc:	9b 83       	std	Y+3, r25	; 0x03
	adc->CTRLB = conf->ctrlb;
    1bfe:	91 81       	ldd	r25, Z+1	; 0x01
    1c00:	99 83       	std	Y+1, r25	; 0x01
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
	enable = adc->CTRLA & ADC_ENABLE_bm;
    1c02:	81 70       	andi	r24, 0x01	; 1
	adc->REFCTRL = conf->refctrl;
	adc->PRESCALER = conf->prescaler;
	adc->EVCTRL = conf->evctrl;
	adc->CTRLB = conf->ctrlb;

	adc->CTRLA = enable | conf->ctrla;
    1c04:	90 81       	ld	r25, Z
    1c06:	89 2b       	or	r24, r25
    1c08:	88 83       	st	Y, r24

	adc_disable_clock(adc);
    1c0a:	ce 01       	movw	r24, r28
    1c0c:	ef dd       	rcall	.-1058   	; 0x17ec <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1c0e:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    1c10:	df 91       	pop	r29
    1c12:	cf 91       	pop	r28
    1c14:	1f 91       	pop	r17
    1c16:	0f 91       	pop	r16
    1c18:	ff 90       	pop	r15
    1c1a:	ef 90       	pop	r14
    1c1c:	df 90       	pop	r13
    1c1e:	08 95       	ret

00001c20 <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    1c20:	ff 92       	push	r15
    1c22:	0f 93       	push	r16
    1c24:	1f 93       	push	r17
    1c26:	cf 93       	push	r28
    1c28:	df 93       	push	r29
    1c2a:	ec 01       	movw	r28, r24
    1c2c:	8b 01       	movw	r16, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1c2e:	ff b6       	in	r15, 0x3f	; 63
	cpu_irq_disable();
    1c30:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    1c32:	bb dd       	rcall	.-1162   	; 0x17aa <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    1c34:	88 81       	ld	r24, Y
    1c36:	80 7c       	andi	r24, 0xC0	; 192
    1c38:	f8 01       	movw	r30, r16
    1c3a:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    1c3c:	88 8d       	ldd	r24, Y+24	; 0x18
    1c3e:	99 8d       	ldd	r25, Y+25	; 0x19
    1c40:	85 83       	std	Z+5, r24	; 0x05
    1c42:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    1c44:	8a 81       	ldd	r24, Y+2	; 0x02
    1c46:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    1c48:	8c 81       	ldd	r24, Y+4	; 0x04
    1c4a:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    1c4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4e:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    1c50:	89 81       	ldd	r24, Y+1	; 0x01
    1c52:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    1c54:	ce 01       	movw	r24, r28
    1c56:	ca dd       	rcall	.-1132   	; 0x17ec <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1c58:	ff be       	out	0x3f, r15	; 63

	cpu_irq_restore(flags);
}
    1c5a:	df 91       	pop	r29
    1c5c:	cf 91       	pop	r28
    1c5e:	1f 91       	pop	r17
    1c60:	0f 91       	pop	r16
    1c62:	ff 90       	pop	r15
    1c64:	08 95       	ret

00001c66 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    1c66:	cf 92       	push	r12
    1c68:	df 92       	push	r13
    1c6a:	ef 92       	push	r14
    1c6c:	ff 92       	push	r15
    1c6e:	0f 93       	push	r16
    1c70:	1f 93       	push	r17
    1c72:	cf 93       	push	r28
    1c74:	df 93       	push	r29
    1c76:	7c 01       	movw	r14, r24
    1c78:	d6 2e       	mov	r13, r22
    1c7a:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1c7c:	86 2f       	mov	r24, r22
    1c7e:	83 70       	andi	r24, 0x03	; 3
    1c80:	29 f4       	brne	.+10     	; 0x1c8c <adcch_write_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    1c82:	96 2f       	mov	r25, r22
    1c84:	96 95       	lsr	r25
    1c86:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1c88:	82 e0       	ldi	r24, 0x02	; 2
    1c8a:	02 c0       	rjmp	.+4      	; 0x1c90 <adcch_write_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1c8c:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1c8e:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1c90:	90 ff       	sbrs	r25, 0
		index++;
    1c92:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1c94:	e7 01       	movw	r28, r14
    1c96:	a0 96       	adiw	r28, 0x20	; 32
    1c98:	98 e0       	ldi	r25, 0x08	; 8
    1c9a:	89 9f       	mul	r24, r25
    1c9c:	c0 0d       	add	r28, r0
    1c9e:	d1 1d       	adc	r29, r1
    1ca0:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1ca2:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1ca4:	f8 94       	cli
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    1ca6:	c7 01       	movw	r24, r14
    1ca8:	80 dd       	rcall	.-1280   	; 0x17aa <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    1caa:	f8 01       	movw	r30, r16
    1cac:	80 81       	ld	r24, Z
    1cae:	88 83       	st	Y, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    1cb0:	82 81       	ldd	r24, Z+2	; 0x02
    1cb2:	8a 83       	std	Y+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    1cb4:	81 81       	ldd	r24, Z+1	; 0x01
    1cb6:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1cb8:	d0 fe       	sbrs	r13, 0
    1cba:	02 c0       	rjmp	.+4      	; 0x1cc0 <adcch_write_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    1cbc:	83 81       	ldd	r24, Z+3	; 0x03
    1cbe:	8e 83       	std	Y+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    1cc0:	c7 01       	movw	r24, r14
    1cc2:	94 dd       	rcall	.-1240   	; 0x17ec <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1cc4:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1cc6:	df 91       	pop	r29
    1cc8:	cf 91       	pop	r28
    1cca:	1f 91       	pop	r17
    1ccc:	0f 91       	pop	r16
    1cce:	ff 90       	pop	r15
    1cd0:	ef 90       	pop	r14
    1cd2:	df 90       	pop	r13
    1cd4:	cf 90       	pop	r12
    1cd6:	08 95       	ret

00001cd8 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    1cd8:	cf 92       	push	r12
    1cda:	df 92       	push	r13
    1cdc:	ef 92       	push	r14
    1cde:	ff 92       	push	r15
    1ce0:	0f 93       	push	r16
    1ce2:	1f 93       	push	r17
    1ce4:	cf 93       	push	r28
    1ce6:	df 93       	push	r29
    1ce8:	7c 01       	movw	r14, r24
    1cea:	d6 2e       	mov	r13, r22
    1cec:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1cee:	86 2f       	mov	r24, r22
    1cf0:	83 70       	andi	r24, 0x03	; 3
    1cf2:	29 f4       	brne	.+10     	; 0x1cfe <adcch_read_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    1cf4:	96 2f       	mov	r25, r22
    1cf6:	96 95       	lsr	r25
    1cf8:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1cfa:	82 e0       	ldi	r24, 0x02	; 2
    1cfc:	02 c0       	rjmp	.+4      	; 0x1d02 <adcch_read_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1cfe:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1d00:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1d02:	90 ff       	sbrs	r25, 0
		index++;
    1d04:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1d06:	e7 01       	movw	r28, r14
    1d08:	a0 96       	adiw	r28, 0x20	; 32
    1d0a:	98 e0       	ldi	r25, 0x08	; 8
    1d0c:	89 9f       	mul	r24, r25
    1d0e:	c0 0d       	add	r28, r0
    1d10:	d1 1d       	adc	r29, r1
    1d12:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1d14:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1d16:	f8 94       	cli

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1d18:	c7 01       	movw	r24, r14
    1d1a:	47 dd       	rcall	.-1394   	; 0x17aa <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    1d1c:	88 81       	ld	r24, Y
    1d1e:	f8 01       	movw	r30, r16
    1d20:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    1d22:	8a 81       	ldd	r24, Y+2	; 0x02
    1d24:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    1d26:	89 81       	ldd	r24, Y+1	; 0x01
    1d28:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1d2a:	d0 fe       	sbrs	r13, 0
    1d2c:	02 c0       	rjmp	.+4      	; 0x1d32 <adcch_read_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    1d2e:	8e 81       	ldd	r24, Y+6	; 0x06
    1d30:	83 83       	std	Z+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    1d32:	c7 01       	movw	r24, r14
    1d34:	5b dd       	rcall	.-1354   	; 0x17ec <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1d36:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1d38:	df 91       	pop	r29
    1d3a:	cf 91       	pop	r28
    1d3c:	1f 91       	pop	r17
    1d3e:	0f 91       	pop	r16
    1d40:	ff 90       	pop	r15
    1d42:	ef 90       	pop	r14
    1d44:	df 90       	pop	r13
    1d46:	cf 90       	pop	r12
    1d48:	08 95       	ret

00001d4a <twim_interrupt_handler>:
 * \brief Common TWI master interrupt service routine.
 *
 *  Check current status and calls the appropriate handler.
 */
static void twim_interrupt_handler(void)
{
    1d4a:	cf 93       	push	r28
    1d4c:	df 93       	push	r29
	uint8_t const master_status = transfer.bus->MASTER.STATUS;
    1d4e:	e0 91 71 23 	lds	r30, 0x2371
    1d52:	f0 91 72 23 	lds	r31, 0x2372
    1d56:	84 81       	ldd	r24, Z+4	; 0x04

	if (master_status & TWI_MASTER_ARBLOST_bm) {
    1d58:	83 ff       	sbrs	r24, 3
    1d5a:	08 c0       	rjmp	.+16     	; 0x1d6c <twim_interrupt_handler+0x22>

		transfer.bus->MASTER.STATUS = master_status | TWI_MASTER_ARBLOST_bm;
    1d5c:	88 60       	ori	r24, 0x08	; 8
    1d5e:	84 83       	std	Z+4, r24	; 0x04
		transfer.bus->MASTER.CTRLC  = TWI_MASTER_CMD_STOP_gc;
    1d60:	83 e0       	ldi	r24, 0x03	; 3
    1d62:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_BUSY;
    1d64:	86 ef       	ldi	r24, 0xF6	; 246
    1d66:	80 93 7b 23 	sts	0x237B, r24
    1d6a:	83 c0       	rjmp	.+262    	; 0x1e72 <twim_interrupt_handler+0x128>
    1d6c:	98 2f       	mov	r25, r24
    1d6e:	94 71       	andi	r25, 0x14	; 20

	} else if ((master_status & TWI_MASTER_BUSERR_bm) ||
    1d70:	31 f0       	breq	.+12     	; 0x1d7e <twim_interrupt_handler+0x34>
		(master_status & TWI_MASTER_RXACK_bm)) {

		transfer.bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1d72:	83 e0       	ldi	r24, 0x03	; 3
    1d74:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_IO_ERROR;
    1d76:	8f ef       	ldi	r24, 0xFF	; 255
    1d78:	80 93 7b 23 	sts	0x237B, r24
    1d7c:	7a c0       	rjmp	.+244    	; 0x1e72 <twim_interrupt_handler+0x128>

	} else if (master_status & TWI_MASTER_WIF_bm) {
    1d7e:	86 ff       	sbrs	r24, 6
    1d80:	43 c0       	rjmp	.+134    	; 0x1e08 <twim_interrupt_handler+0xbe>
 *  Handles TWI transactions (master write) and responses to (N)ACK.
 */
static inline void twim_write_handler(void)
{
	TWI_t * const         bus = transfer.bus;
	twi_package_t * const pkg = transfer.pkg;
    1d82:	c1 e7       	ldi	r28, 0x71	; 113
    1d84:	d3 e2       	ldi	r29, 0x23	; 35
    1d86:	aa 81       	ldd	r26, Y+2	; 0x02
    1d88:	bb 81       	ldd	r27, Y+3	; 0x03

	if (transfer.addr_count < pkg->addr_length) {
    1d8a:	8c 81       	ldd	r24, Y+4	; 0x04
    1d8c:	9d 81       	ldd	r25, Y+5	; 0x05
    1d8e:	14 96       	adiw	r26, 0x04	; 4
    1d90:	2d 91       	ld	r18, X+
    1d92:	3c 91       	ld	r19, X
    1d94:	15 97       	sbiw	r26, 0x05	; 5
    1d96:	82 17       	cp	r24, r18
    1d98:	93 07       	cpc	r25, r19
    1d9a:	6c f4       	brge	.+26     	; 0x1db6 <twim_interrupt_handler+0x6c>

		const uint8_t * const data = pkg->addr;
		bus->MASTER.DATA = data[transfer.addr_count++];
    1d9c:	9c 01       	movw	r18, r24
    1d9e:	2f 5f       	subi	r18, 0xFF	; 255
    1da0:	3f 4f       	sbci	r19, 0xFF	; 255
    1da2:	20 93 75 23 	sts	0x2375, r18
    1da6:	30 93 76 23 	sts	0x2376, r19
    1daa:	a8 0f       	add	r26, r24
    1dac:	b9 1f       	adc	r27, r25
    1dae:	11 96       	adiw	r26, 0x01	; 1
    1db0:	8c 91       	ld	r24, X
    1db2:	87 83       	std	Z+7, r24	; 0x07
    1db4:	5e c0       	rjmp	.+188    	; 0x1e72 <twim_interrupt_handler+0x128>

	} else if (transfer.data_count < pkg->length) {
    1db6:	80 91 77 23 	lds	r24, 0x2377
    1dba:	90 91 78 23 	lds	r25, 0x2378
    1dbe:	18 96       	adiw	r26, 0x08	; 8
    1dc0:	2d 91       	ld	r18, X+
    1dc2:	3c 91       	ld	r19, X
    1dc4:	19 97       	sbiw	r26, 0x09	; 9
    1dc6:	82 17       	cp	r24, r18
    1dc8:	93 07       	cpc	r25, r19
    1dca:	c8 f4       	brcc	.+50     	; 0x1dfe <twim_interrupt_handler+0xb4>

		if (transfer.read) {
    1dcc:	20 91 79 23 	lds	r18, 0x2379
    1dd0:	22 23       	and	r18, r18
    1dd2:	21 f0       	breq	.+8      	; 0x1ddc <twim_interrupt_handler+0x92>

			/* Send repeated START condition (Address|R/W=1). */

			bus->MASTER.ADDR |= 0x01;
    1dd4:	86 81       	ldd	r24, Z+6	; 0x06
    1dd6:	81 60       	ori	r24, 0x01	; 1
    1dd8:	86 83       	std	Z+6, r24	; 0x06
    1dda:	4b c0       	rjmp	.+150    	; 0x1e72 <twim_interrupt_handler+0x128>

		} else {
			const uint8_t * const data = pkg->buffer;
    1ddc:	16 96       	adiw	r26, 0x06	; 6
    1dde:	2d 91       	ld	r18, X+
    1de0:	3c 91       	ld	r19, X
    1de2:	17 97       	sbiw	r26, 0x07	; 7
			bus->MASTER.DATA = data[transfer.data_count++];
    1de4:	ac 01       	movw	r20, r24
    1de6:	4f 5f       	subi	r20, 0xFF	; 255
    1de8:	5f 4f       	sbci	r21, 0xFF	; 255
    1dea:	40 93 77 23 	sts	0x2377, r20
    1dee:	50 93 78 23 	sts	0x2378, r21
    1df2:	d9 01       	movw	r26, r18
    1df4:	a8 0f       	add	r26, r24
    1df6:	b9 1f       	adc	r27, r25
    1df8:	8c 91       	ld	r24, X
    1dfa:	87 83       	std	Z+7, r24	; 0x07
    1dfc:	3a c0       	rjmp	.+116    	; 0x1e72 <twim_interrupt_handler+0x128>

	} else {

		/* Send STOP condition to complete the transaction. */

		bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1dfe:	83 e0       	ldi	r24, 0x03	; 3
    1e00:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = STATUS_OK;
    1e02:	10 92 7b 23 	sts	0x237B, r1
    1e06:	35 c0       	rjmp	.+106    	; 0x1e72 <twim_interrupt_handler+0x128>

	} else if (master_status & TWI_MASTER_WIF_bm) {

		twim_write_handler();

	} else if (master_status & TWI_MASTER_RIF_bm) {
    1e08:	88 23       	and	r24, r24
    1e0a:	84 f5       	brge	.+96     	; 0x1e6c <twim_interrupt_handler+0x122>
 *  reading bytes from the TWI slave.
 */
static inline void twim_read_handler(void)
{
	TWI_t * const         bus = transfer.bus;
	twi_package_t * const pkg = transfer.pkg;
    1e0c:	a1 e7       	ldi	r26, 0x71	; 113
    1e0e:	b3 e2       	ldi	r27, 0x23	; 35
    1e10:	12 96       	adiw	r26, 0x02	; 2
    1e12:	cd 91       	ld	r28, X+
    1e14:	dc 91       	ld	r29, X
    1e16:	13 97       	sbiw	r26, 0x03	; 3

	if (transfer.data_count < pkg->length) {
    1e18:	16 96       	adiw	r26, 0x06	; 6
    1e1a:	8d 91       	ld	r24, X+
    1e1c:	9c 91       	ld	r25, X
    1e1e:	17 97       	sbiw	r26, 0x07	; 7
    1e20:	28 85       	ldd	r18, Y+8	; 0x08
    1e22:	39 85       	ldd	r19, Y+9	; 0x09
    1e24:	82 17       	cp	r24, r18
    1e26:	93 07       	cpc	r25, r19
    1e28:	d8 f4       	brcc	.+54     	; 0x1e60 <twim_interrupt_handler+0x116>

		uint8_t * const data = pkg->buffer;
    1e2a:	6e 81       	ldd	r22, Y+6	; 0x06
    1e2c:	7f 81       	ldd	r23, Y+7	; 0x07
		data[transfer.data_count++] = bus->MASTER.DATA;
    1e2e:	9c 01       	movw	r18, r24
    1e30:	2f 5f       	subi	r18, 0xFF	; 255
    1e32:	3f 4f       	sbci	r19, 0xFF	; 255
    1e34:	20 93 77 23 	sts	0x2377, r18
    1e38:	30 93 78 23 	sts	0x2378, r19
    1e3c:	47 81       	ldd	r20, Z+7	; 0x07
    1e3e:	db 01       	movw	r26, r22
    1e40:	a8 0f       	add	r26, r24
    1e42:	b9 1f       	adc	r27, r25
    1e44:	4c 93       	st	X, r20

		/* If there is more to read, issue ACK and start a byte read.
		 * Otherwise, issue NACK and STOP to complete the transaction.
		 */
		if (transfer.data_count < pkg->length) {
    1e46:	88 85       	ldd	r24, Y+8	; 0x08
    1e48:	99 85       	ldd	r25, Y+9	; 0x09
    1e4a:	28 17       	cp	r18, r24
    1e4c:	39 07       	cpc	r19, r25
    1e4e:	18 f4       	brcc	.+6      	; 0x1e56 <twim_interrupt_handler+0x10c>

			bus->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
    1e50:	82 e0       	ldi	r24, 0x02	; 2
    1e52:	83 83       	std	Z+3, r24	; 0x03
    1e54:	0e c0       	rjmp	.+28     	; 0x1e72 <twim_interrupt_handler+0x128>

		} else {

			bus->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    1e56:	87 e0       	ldi	r24, 0x07	; 7
    1e58:	83 83       	std	Z+3, r24	; 0x03
			transfer.status = STATUS_OK;
    1e5a:	10 92 7b 23 	sts	0x237B, r1
    1e5e:	09 c0       	rjmp	.+18     	; 0x1e72 <twim_interrupt_handler+0x128>

	} else {

		/* Issue STOP and buffer overflow condition. */

		bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1e60:	83 e0       	ldi	r24, 0x03	; 3
    1e62:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_NO_MEMORY;
    1e64:	89 ef       	ldi	r24, 0xF9	; 249
    1e66:	80 93 7b 23 	sts	0x237B, r24
    1e6a:	03 c0       	rjmp	.+6      	; 0x1e72 <twim_interrupt_handler+0x128>

		twim_read_handler();

	} else {

		transfer.status = ERR_PROTOCOL;
    1e6c:	8b ef       	ldi	r24, 0xFB	; 251
    1e6e:	80 93 7b 23 	sts	0x237B, r24
	}
}
    1e72:	df 91       	pop	r29
    1e74:	cf 91       	pop	r28
    1e76:	08 95       	ret

00001e78 <__vector_13>:
 * parameters specified in the global \c transfer structure.
 */
static void twim_interrupt_handler(void);

#ifdef TWIC
ISR(TWIC_TWIM_vect) { twim_interrupt_handler(); }
    1e78:	1f 92       	push	r1
    1e7a:	0f 92       	push	r0
    1e7c:	0f b6       	in	r0, 0x3f	; 63
    1e7e:	0f 92       	push	r0
    1e80:	11 24       	eor	r1, r1
    1e82:	0b b6       	in	r0, 0x3b	; 59
    1e84:	0f 92       	push	r0
    1e86:	2f 93       	push	r18
    1e88:	3f 93       	push	r19
    1e8a:	4f 93       	push	r20
    1e8c:	5f 93       	push	r21
    1e8e:	6f 93       	push	r22
    1e90:	7f 93       	push	r23
    1e92:	8f 93       	push	r24
    1e94:	9f 93       	push	r25
    1e96:	af 93       	push	r26
    1e98:	bf 93       	push	r27
    1e9a:	ef 93       	push	r30
    1e9c:	ff 93       	push	r31
    1e9e:	55 df       	rcall	.-342    	; 0x1d4a <twim_interrupt_handler>
    1ea0:	ff 91       	pop	r31
    1ea2:	ef 91       	pop	r30
    1ea4:	bf 91       	pop	r27
    1ea6:	af 91       	pop	r26
    1ea8:	9f 91       	pop	r25
    1eaa:	8f 91       	pop	r24
    1eac:	7f 91       	pop	r23
    1eae:	6f 91       	pop	r22
    1eb0:	5f 91       	pop	r21
    1eb2:	4f 91       	pop	r20
    1eb4:	3f 91       	pop	r19
    1eb6:	2f 91       	pop	r18
    1eb8:	0f 90       	pop	r0
    1eba:	0b be       	out	0x3b, r0	; 59
    1ebc:	0f 90       	pop	r0
    1ebe:	0f be       	out	0x3f, r0	; 63
    1ec0:	0f 90       	pop	r0
    1ec2:	1f 90       	pop	r1
    1ec4:	18 95       	reti

00001ec6 <__vector_46>:
#endif
#ifdef TWID
ISR(TWID_TWIM_vect) { twim_interrupt_handler(); }
#endif
#ifdef TWIE
ISR(TWIE_TWIM_vect) { twim_interrupt_handler(); }
    1ec6:	1f 92       	push	r1
    1ec8:	0f 92       	push	r0
    1eca:	0f b6       	in	r0, 0x3f	; 63
    1ecc:	0f 92       	push	r0
    1ece:	11 24       	eor	r1, r1
    1ed0:	0b b6       	in	r0, 0x3b	; 59
    1ed2:	0f 92       	push	r0
    1ed4:	2f 93       	push	r18
    1ed6:	3f 93       	push	r19
    1ed8:	4f 93       	push	r20
    1eda:	5f 93       	push	r21
    1edc:	6f 93       	push	r22
    1ede:	7f 93       	push	r23
    1ee0:	8f 93       	push	r24
    1ee2:	9f 93       	push	r25
    1ee4:	af 93       	push	r26
    1ee6:	bf 93       	push	r27
    1ee8:	ef 93       	push	r30
    1eea:	ff 93       	push	r31
    1eec:	2e df       	rcall	.-420    	; 0x1d4a <twim_interrupt_handler>
    1eee:	ff 91       	pop	r31
    1ef0:	ef 91       	pop	r30
    1ef2:	bf 91       	pop	r27
    1ef4:	af 91       	pop	r26
    1ef6:	9f 91       	pop	r25
    1ef8:	8f 91       	pop	r24
    1efa:	7f 91       	pop	r23
    1efc:	6f 91       	pop	r22
    1efe:	5f 91       	pop	r21
    1f00:	4f 91       	pop	r20
    1f02:	3f 91       	pop	r19
    1f04:	2f 91       	pop	r18
    1f06:	0f 90       	pop	r0
    1f08:	0b be       	out	0x3b, r0	; 59
    1f0a:	0f 90       	pop	r0
    1f0c:	0f be       	out	0x3f, r0	; 63
    1f0e:	0f 90       	pop	r0
    1f10:	1f 90       	pop	r1
    1f12:	18 95       	reti

00001f14 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1f14:	cf 92       	push	r12
    1f16:	df 92       	push	r13
    1f18:	ef 92       	push	r14
    1f1a:	ff 92       	push	r15
    1f1c:	0f 93       	push	r16
    1f1e:	1f 93       	push	r17
    1f20:	cf 93       	push	r28
    1f22:	df 93       	push	r29
    1f24:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    1f26:	d9 01       	movw	r26, r18
    1f28:	c8 01       	movw	r24, r16
    1f2a:	b6 95       	lsr	r27
    1f2c:	a7 95       	ror	r26
    1f2e:	97 95       	ror	r25
    1f30:	87 95       	ror	r24
    1f32:	48 17       	cp	r20, r24
    1f34:	59 07       	cpc	r21, r25
    1f36:	6a 07       	cpc	r22, r26
    1f38:	7b 07       	cpc	r23, r27
    1f3a:	78 f4       	brcc	.+30     	; 0x1f5a <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1f3c:	6a 01       	movw	r12, r20
    1f3e:	7b 01       	movw	r14, r22
    1f40:	cc 0c       	add	r12, r12
    1f42:	dd 1c       	adc	r13, r13
    1f44:	ee 1c       	adc	r14, r14
    1f46:	ff 1c       	adc	r15, r15
    1f48:	c9 01       	movw	r24, r18
    1f4a:	b8 01       	movw	r22, r16
    1f4c:	a7 01       	movw	r20, r14
    1f4e:	96 01       	movw	r18, r12
    1f50:	0e 94 ef 1a 	call	0x35de	; 0x35de <__udivmodsi4>
    1f54:	21 50       	subi	r18, 0x01	; 1
    1f56:	31 09       	sbc	r19, r1
    1f58:	02 c0       	rjmp	.+4      	; 0x1f5e <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1f5a:	20 e0       	ldi	r18, 0x00	; 0
    1f5c:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1f5e:	83 2f       	mov	r24, r19
    1f60:	8f 70       	andi	r24, 0x0F	; 15
    1f62:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1f64:	2e 83       	std	Y+6, r18	; 0x06
}
    1f66:	df 91       	pop	r29
    1f68:	cf 91       	pop	r28
    1f6a:	1f 91       	pop	r17
    1f6c:	0f 91       	pop	r16
    1f6e:	ff 90       	pop	r15
    1f70:	ef 90       	pop	r14
    1f72:	df 90       	pop	r13
    1f74:	cf 90       	pop	r12
    1f76:	08 95       	ret

00001f78 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1f78:	ef 92       	push	r14
    1f7a:	ff 92       	push	r15
    1f7c:	0f 93       	push	r16
    1f7e:	1f 93       	push	r17
    1f80:	cf 93       	push	r28
    1f82:	df 93       	push	r29
    1f84:	ec 01       	movw	r28, r24
    1f86:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1f88:	00 97       	sbiw	r24, 0x00	; 0
    1f8a:	09 f4       	brne	.+2      	; 0x1f8e <usart_init_spi+0x16>
    1f8c:	8c c1       	rjmp	.+792    	; 0x22a6 <usart_init_spi+0x32e>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1f8e:	80 3c       	cpi	r24, 0xC0	; 192
    1f90:	91 05       	cpc	r25, r1
    1f92:	29 f4       	brne	.+10     	; 0x1f9e <usart_init_spi+0x26>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1f94:	60 e1       	ldi	r22, 0x10	; 16
    1f96:	80 e0       	ldi	r24, 0x00	; 0
    1f98:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    1f9c:	84 c1       	rjmp	.+776    	; 0x22a6 <usart_init_spi+0x32e>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1f9e:	80 38       	cpi	r24, 0x80	; 128
    1fa0:	91 40       	sbci	r25, 0x01	; 1
    1fa2:	29 f4       	brne	.+10     	; 0x1fae <usart_init_spi+0x36>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1fa4:	62 e0       	ldi	r22, 0x02	; 2
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
    1fa8:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    1fac:	7c c1       	rjmp	.+760    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1fae:	c1 15       	cp	r28, r1
    1fb0:	81 e0       	ldi	r24, 0x01	; 1
    1fb2:	d8 07       	cpc	r29, r24
    1fb4:	29 f4       	brne	.+10     	; 0x1fc0 <usart_init_spi+0x48>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1fb6:	61 e0       	ldi	r22, 0x01	; 1
    1fb8:	80 e0       	ldi	r24, 0x00	; 0
    1fba:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    1fbe:	73 c1       	rjmp	.+742    	; 0x22a6 <usart_init_spi+0x32e>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1fc0:	c0 38       	cpi	r28, 0x80	; 128
    1fc2:	e3 e0       	ldi	r30, 0x03	; 3
    1fc4:	de 07       	cpc	r29, r30
    1fc6:	29 f4       	brne	.+10     	; 0x1fd2 <usart_init_spi+0x5a>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1fc8:	61 e0       	ldi	r22, 0x01	; 1
    1fca:	81 e0       	ldi	r24, 0x01	; 1
    1fcc:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    1fd0:	6a c1       	rjmp	.+724    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1fd2:	c0 39       	cpi	r28, 0x90	; 144
    1fd4:	f3 e0       	ldi	r31, 0x03	; 3
    1fd6:	df 07       	cpc	r29, r31
    1fd8:	29 f4       	brne	.+10     	; 0x1fe4 <usart_init_spi+0x6c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1fda:	61 e0       	ldi	r22, 0x01	; 1
    1fdc:	82 e0       	ldi	r24, 0x02	; 2
    1fde:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    1fe2:	61 c1       	rjmp	.+706    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    1fe4:	c1 15       	cp	r28, r1
    1fe6:	32 e0       	ldi	r19, 0x02	; 2
    1fe8:	d3 07       	cpc	r29, r19
    1fea:	29 f4       	brne	.+10     	; 0x1ff6 <usart_init_spi+0x7e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1fec:	62 e0       	ldi	r22, 0x02	; 2
    1fee:	81 e0       	ldi	r24, 0x01	; 1
    1ff0:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    1ff4:	58 c1       	rjmp	.+688    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    1ff6:	c0 34       	cpi	r28, 0x40	; 64
    1ff8:	82 e0       	ldi	r24, 0x02	; 2
    1ffa:	d8 07       	cpc	r29, r24
    1ffc:	29 f4       	brne	.+10     	; 0x2008 <usart_init_spi+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1ffe:	62 e0       	ldi	r22, 0x02	; 2
    2000:	82 e0       	ldi	r24, 0x02	; 2
    2002:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    2006:	4f c1       	rjmp	.+670    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    2008:	c0 32       	cpi	r28, 0x20	; 32
    200a:	e3 e0       	ldi	r30, 0x03	; 3
    200c:	de 07       	cpc	r29, r30
    200e:	29 f4       	brne	.+10     	; 0x201a <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    2010:	64 e0       	ldi	r22, 0x04	; 4
    2012:	82 e0       	ldi	r24, 0x02	; 2
    2014:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    2018:	46 c1       	rjmp	.+652    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    201a:	c1 15       	cp	r28, r1
    201c:	f8 e0       	ldi	r31, 0x08	; 8
    201e:	df 07       	cpc	r29, r31
    2020:	29 f4       	brne	.+10     	; 0x202c <usart_init_spi+0xb4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    2022:	61 e0       	ldi	r22, 0x01	; 1
    2024:	83 e0       	ldi	r24, 0x03	; 3
    2026:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    202a:	3d c1       	rjmp	.+634    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    202c:	c1 15       	cp	r28, r1
    202e:	39 e0       	ldi	r19, 0x09	; 9
    2030:	d3 07       	cpc	r29, r19
    2032:	29 f4       	brne	.+10     	; 0x203e <usart_init_spi+0xc6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    2034:	61 e0       	ldi	r22, 0x01	; 1
    2036:	84 e0       	ldi	r24, 0x04	; 4
    2038:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    203c:	34 c1       	rjmp	.+616    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    203e:	c1 15       	cp	r28, r1
    2040:	8a e0       	ldi	r24, 0x0A	; 10
    2042:	d8 07       	cpc	r29, r24
    2044:	29 f4       	brne	.+10     	; 0x2050 <usart_init_spi+0xd8>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    2046:	61 e0       	ldi	r22, 0x01	; 1
    2048:	85 e0       	ldi	r24, 0x05	; 5
    204a:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    204e:	2b c1       	rjmp	.+598    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    2050:	c1 15       	cp	r28, r1
    2052:	eb e0       	ldi	r30, 0x0B	; 11
    2054:	de 07       	cpc	r29, r30
    2056:	29 f4       	brne	.+10     	; 0x2062 <usart_init_spi+0xea>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    2058:	61 e0       	ldi	r22, 0x01	; 1
    205a:	86 e0       	ldi	r24, 0x06	; 6
    205c:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    2060:	22 c1       	rjmp	.+580    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    2062:	c0 34       	cpi	r28, 0x40	; 64
    2064:	f8 e0       	ldi	r31, 0x08	; 8
    2066:	df 07       	cpc	r29, r31
    2068:	29 f4       	brne	.+10     	; 0x2074 <usart_init_spi+0xfc>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    206a:	62 e0       	ldi	r22, 0x02	; 2
    206c:	83 e0       	ldi	r24, 0x03	; 3
    206e:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    2072:	19 c1       	rjmp	.+562    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    2074:	c0 34       	cpi	r28, 0x40	; 64
    2076:	39 e0       	ldi	r19, 0x09	; 9
    2078:	d3 07       	cpc	r29, r19
    207a:	29 f4       	brne	.+10     	; 0x2086 <usart_init_spi+0x10e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    207c:	62 e0       	ldi	r22, 0x02	; 2
    207e:	84 e0       	ldi	r24, 0x04	; 4
    2080:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    2084:	10 c1       	rjmp	.+544    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    2086:	c0 34       	cpi	r28, 0x40	; 64
    2088:	8a e0       	ldi	r24, 0x0A	; 10
    208a:	d8 07       	cpc	r29, r24
    208c:	29 f4       	brne	.+10     	; 0x2098 <usart_init_spi+0x120>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    208e:	62 e0       	ldi	r22, 0x02	; 2
    2090:	85 e0       	ldi	r24, 0x05	; 5
    2092:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    2096:	07 c1       	rjmp	.+526    	; 0x22a6 <usart_init_spi+0x32e>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    2098:	c0 39       	cpi	r28, 0x90	; 144
    209a:	e8 e0       	ldi	r30, 0x08	; 8
    209c:	de 07       	cpc	r29, r30
    209e:	29 f4       	brne	.+10     	; 0x20aa <usart_init_spi+0x132>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    20a0:	64 e0       	ldi	r22, 0x04	; 4
    20a2:	83 e0       	ldi	r24, 0x03	; 3
    20a4:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    20a8:	fe c0       	rjmp	.+508    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    20aa:	c0 39       	cpi	r28, 0x90	; 144
    20ac:	f9 e0       	ldi	r31, 0x09	; 9
    20ae:	df 07       	cpc	r29, r31
    20b0:	29 f4       	brne	.+10     	; 0x20bc <usart_init_spi+0x144>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    20b2:	64 e0       	ldi	r22, 0x04	; 4
    20b4:	84 e0       	ldi	r24, 0x04	; 4
    20b6:	0e 94 5f 18 	call	0x30be	; 0x30be <sysclk_enable_module>
    20ba:	f5 c0       	rjmp	.+490    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    20bc:	c0 39       	cpi	r28, 0x90	; 144
    20be:	3a e0       	ldi	r19, 0x0A	; 10
    20c0:	d3 07       	cpc	r29, r19
    20c2:	21 f4       	brne	.+8      	; 0x20cc <usart_init_spi+0x154>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    20c4:	64 e0       	ldi	r22, 0x04	; 4
    20c6:	85 e0       	ldi	r24, 0x05	; 5
    20c8:	fa d7       	rcall	.+4084   	; 0x30be <sysclk_enable_module>
    20ca:	ed c0       	rjmp	.+474    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    20cc:	c0 39       	cpi	r28, 0x90	; 144
    20ce:	8b e0       	ldi	r24, 0x0B	; 11
    20d0:	d8 07       	cpc	r29, r24
    20d2:	21 f4       	brne	.+8      	; 0x20dc <usart_init_spi+0x164>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    20d4:	64 e0       	ldi	r22, 0x04	; 4
    20d6:	86 e0       	ldi	r24, 0x06	; 6
    20d8:	f2 d7       	rcall	.+4068   	; 0x30be <sysclk_enable_module>
    20da:	e5 c0       	rjmp	.+458    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    20dc:	c0 3c       	cpi	r28, 0xC0	; 192
    20de:	e8 e0       	ldi	r30, 0x08	; 8
    20e0:	de 07       	cpc	r29, r30
    20e2:	21 f4       	brne	.+8      	; 0x20ec <usart_init_spi+0x174>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    20e4:	68 e0       	ldi	r22, 0x08	; 8
    20e6:	83 e0       	ldi	r24, 0x03	; 3
    20e8:	ea d7       	rcall	.+4052   	; 0x30be <sysclk_enable_module>
    20ea:	dd c0       	rjmp	.+442    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    20ec:	c0 3c       	cpi	r28, 0xC0	; 192
    20ee:	f9 e0       	ldi	r31, 0x09	; 9
    20f0:	df 07       	cpc	r29, r31
    20f2:	21 f4       	brne	.+8      	; 0x20fc <usart_init_spi+0x184>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    20f4:	68 e0       	ldi	r22, 0x08	; 8
    20f6:	84 e0       	ldi	r24, 0x04	; 4
    20f8:	e2 d7       	rcall	.+4036   	; 0x30be <sysclk_enable_module>
    20fa:	d5 c0       	rjmp	.+426    	; 0x22a6 <usart_init_spi+0x32e>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    20fc:	c0 3a       	cpi	r28, 0xA0	; 160
    20fe:	38 e0       	ldi	r19, 0x08	; 8
    2100:	d3 07       	cpc	r29, r19
    2102:	61 f4       	brne	.+24     	; 0x211c <usart_init_spi+0x1a4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    2104:	60 e1       	ldi	r22, 0x10	; 16
    2106:	83 e0       	ldi	r24, 0x03	; 3
    2108:	da d7       	rcall	.+4020   	; 0x30be <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    210a:	e0 ea       	ldi	r30, 0xA0	; 160
    210c:	f8 e0       	ldi	r31, 0x08	; 8
    210e:	84 81       	ldd	r24, Z+4	; 0x04
    2110:	8f 7e       	andi	r24, 0xEF	; 239
    2112:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    2114:	f7 01       	movw	r30, r14
    2116:	24 81       	ldd	r18, Z+4	; 0x04
    2118:	22 50       	subi	r18, 0x02	; 2
    211a:	43 c0       	rjmp	.+134    	; 0x21a2 <usart_init_spi+0x22a>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    211c:	c0 3a       	cpi	r28, 0xA0	; 160
    211e:	f9 e0       	ldi	r31, 0x09	; 9
    2120:	df 07       	cpc	r29, r31
    2122:	21 f4       	brne	.+8      	; 0x212c <usart_init_spi+0x1b4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    2124:	60 e1       	ldi	r22, 0x10	; 16
    2126:	84 e0       	ldi	r24, 0x04	; 4
    2128:	ca d7       	rcall	.+3988   	; 0x30be <sysclk_enable_module>
    212a:	bd c0       	rjmp	.+378    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    212c:	c0 3a       	cpi	r28, 0xA0	; 160
    212e:	3a e0       	ldi	r19, 0x0A	; 10
    2130:	d3 07       	cpc	r29, r19
    2132:	21 f4       	brne	.+8      	; 0x213c <usart_init_spi+0x1c4>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    2134:	60 e1       	ldi	r22, 0x10	; 16
    2136:	85 e0       	ldi	r24, 0x05	; 5
    2138:	c2 d7       	rcall	.+3972   	; 0x30be <sysclk_enable_module>
    213a:	b5 c0       	rjmp	.+362    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    213c:	c0 3a       	cpi	r28, 0xA0	; 160
    213e:	8b e0       	ldi	r24, 0x0B	; 11
    2140:	d8 07       	cpc	r29, r24
    2142:	21 f4       	brne	.+8      	; 0x214c <usart_init_spi+0x1d4>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    2144:	60 e1       	ldi	r22, 0x10	; 16
    2146:	86 e0       	ldi	r24, 0x06	; 6
    2148:	ba d7       	rcall	.+3956   	; 0x30be <sysclk_enable_module>
    214a:	ad c0       	rjmp	.+346    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    214c:	c0 3b       	cpi	r28, 0xB0	; 176
    214e:	e8 e0       	ldi	r30, 0x08	; 8
    2150:	de 07       	cpc	r29, r30
    2152:	21 f4       	brne	.+8      	; 0x215c <usart_init_spi+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    2154:	60 e2       	ldi	r22, 0x20	; 32
    2156:	83 e0       	ldi	r24, 0x03	; 3
    2158:	b2 d7       	rcall	.+3940   	; 0x30be <sysclk_enable_module>
    215a:	a5 c0       	rjmp	.+330    	; 0x22a6 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    215c:	c0 3b       	cpi	r28, 0xB0	; 176
    215e:	f9 e0       	ldi	r31, 0x09	; 9
    2160:	df 07       	cpc	r29, r31
    2162:	21 f4       	brne	.+8      	; 0x216c <usart_init_spi+0x1f4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    2164:	60 e2       	ldi	r22, 0x20	; 32
    2166:	84 e0       	ldi	r24, 0x04	; 4
    2168:	aa d7       	rcall	.+3924   	; 0x30be <sysclk_enable_module>
    216a:	9d c0       	rjmp	.+314    	; 0x22a6 <usart_init_spi+0x32e>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    216c:	c0 38       	cpi	r28, 0x80	; 128
    216e:	34 e0       	ldi	r19, 0x04	; 4
    2170:	d3 07       	cpc	r29, r19
    2172:	21 f4       	brne	.+8      	; 0x217c <usart_init_spi+0x204>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    2174:	60 e4       	ldi	r22, 0x40	; 64
    2176:	83 e0       	ldi	r24, 0x03	; 3
    2178:	a2 d7       	rcall	.+3908   	; 0x30be <sysclk_enable_module>
    217a:	95 c0       	rjmp	.+298    	; 0x22a6 <usart_init_spi+0x32e>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    217c:	c0 3a       	cpi	r28, 0xA0	; 160
    217e:	84 e0       	ldi	r24, 0x04	; 4
    2180:	d8 07       	cpc	r29, r24
    2182:	21 f4       	brne	.+8      	; 0x218c <usart_init_spi+0x214>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    2184:	60 e4       	ldi	r22, 0x40	; 64
    2186:	85 e0       	ldi	r24, 0x05	; 5
    2188:	9a d7       	rcall	.+3892   	; 0x30be <sysclk_enable_module>
    218a:	8d c0       	rjmp	.+282    	; 0x22a6 <usart_init_spi+0x32e>
    218c:	8c 81       	ldd	r24, Y+4	; 0x04
    218e:	8f 7e       	andi	r24, 0xEF	; 239
    2190:	8c 83       	std	Y+4, r24	; 0x04
    2192:	fb 01       	movw	r30, r22
    2194:	24 81       	ldd	r18, Z+4	; 0x04
    2196:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    2198:	ce 01       	movw	r24, r28
    219a:	c0 3a       	cpi	r28, 0xA0	; 160
    219c:	f8 e0       	ldi	r31, 0x08	; 8
    219e:	df 07       	cpc	r29, r31
    21a0:	31 f4       	brne	.+12     	; 0x21ae <usart_init_spi+0x236>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    21a2:	80 91 4e 06 	lds	r24, 0x064E
    21a6:	84 fd       	sbrc	r24, 4
    21a8:	86 c0       	rjmp	.+268    	; 0x22b6 <usart_init_spi+0x33e>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    21aa:	11 e1       	ldi	r17, 0x11	; 17
    21ac:	85 c0       	rjmp	.+266    	; 0x22b8 <usart_init_spi+0x340>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    21ae:	80 3b       	cpi	r24, 0xB0	; 176
    21b0:	38 e0       	ldi	r19, 0x08	; 8
    21b2:	93 07       	cpc	r25, r19
    21b4:	79 f0       	breq	.+30     	; 0x21d4 <usart_init_spi+0x25c>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    21b6:	80 3a       	cpi	r24, 0xA0	; 160
    21b8:	e9 e0       	ldi	r30, 0x09	; 9
    21ba:	9e 07       	cpc	r25, r30
    21bc:	31 f4       	brne	.+12     	; 0x21ca <usart_init_spi+0x252>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    21be:	30 91 6e 06 	lds	r19, 0x066E
    21c2:	34 fd       	sbrc	r19, 4
    21c4:	7c c0       	rjmp	.+248    	; 0x22be <usart_init_spi+0x346>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    21c6:	19 e1       	ldi	r17, 0x19	; 25
    21c8:	10 c0       	rjmp	.+32     	; 0x21ea <usart_init_spi+0x272>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    21ca:	80 3b       	cpi	r24, 0xB0	; 176
    21cc:	f9 e0       	ldi	r31, 0x09	; 9
    21ce:	9f 07       	cpc	r25, r31
    21d0:	a9 f0       	breq	.+42     	; 0x21fc <usart_init_spi+0x284>
    21d2:	01 c0       	rjmp	.+2      	; 0x21d6 <usart_init_spi+0x25e>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    21d4:	15 e1       	ldi	r17, 0x15	; 21
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    21d6:	80 3a       	cpi	r24, 0xA0	; 160
    21d8:	3a e0       	ldi	r19, 0x0A	; 10
    21da:	93 07       	cpc	r25, r19
    21dc:	31 f4       	brne	.+12     	; 0x21ea <usart_init_spi+0x272>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    21de:	80 91 8e 06 	lds	r24, 0x068E
    21e2:	84 fd       	sbrc	r24, 4
    21e4:	6e c0       	rjmp	.+220    	; 0x22c2 <usart_init_spi+0x34a>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    21e6:	11 e2       	ldi	r17, 0x21	; 33
    21e8:	0c c0       	rjmp	.+24     	; 0x2202 <usart_init_spi+0x28a>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    21ea:	80 3a       	cpi	r24, 0xA0	; 160
    21ec:	9b 40       	sbci	r25, 0x0B	; 11
    21ee:	49 f4       	brne	.+18     	; 0x2202 <usart_init_spi+0x28a>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    21f0:	80 91 ae 06 	lds	r24, 0x06AE
    21f4:	84 fd       	sbrc	r24, 4
    21f6:	04 c0       	rjmp	.+8      	; 0x2200 <usart_init_spi+0x288>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    21f8:	19 e2       	ldi	r17, 0x29	; 41
    21fa:	03 c0       	rjmp	.+6      	; 0x2202 <usart_init_spi+0x28a>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    21fc:	1d e1       	ldi	r17, 0x1D	; 29
    21fe:	01 c0       	rjmp	.+2      	; 0x2202 <usart_init_spi+0x28a>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    2200:	1d e2       	ldi	r17, 0x2D	; 45
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    2202:	e1 2f       	mov	r30, r17
    2204:	e6 95       	lsr	r30
    2206:	e6 95       	lsr	r30
    2208:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    220a:	30 e2       	ldi	r19, 0x20	; 32
    220c:	e3 9f       	mul	r30, r19
    220e:	f0 01       	movw	r30, r0
    2210:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2212:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    2214:	17 70       	andi	r17, 0x07	; 7
    2216:	81 e0       	ldi	r24, 0x01	; 1
    2218:	90 e0       	ldi	r25, 0x00	; 0
    221a:	01 2e       	mov	r0, r17
    221c:	02 c0       	rjmp	.+4      	; 0x2222 <usart_init_spi+0x2aa>
    221e:	88 0f       	add	r24, r24
    2220:	99 1f       	adc	r25, r25
    2222:	0a 94       	dec	r0
    2224:	e2 f7       	brpl	.-8      	; 0x221e <usart_init_spi+0x2a6>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    2226:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    2228:	22 30       	cpi	r18, 0x02	; 2
    222a:	10 f0       	brcs	.+4      	; 0x2230 <usart_init_spi+0x2b8>
    222c:	40 e0       	ldi	r20, 0x00	; 0
    222e:	01 c0       	rjmp	.+2      	; 0x2232 <usart_init_spi+0x2ba>
    2230:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    2232:	df 01       	movw	r26, r30
    2234:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    2236:	a1 0f       	add	r26, r17
    2238:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    223a:	3f b7       	in	r19, 0x3f	; 63
	cpu_irq_disable();
    223c:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    223e:	2c 91       	ld	r18, X
    2240:	27 70       	andi	r18, 0x07	; 7
    2242:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    2244:	9c 91       	ld	r25, X
    2246:	94 2b       	or	r25, r20
    2248:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    224a:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    224c:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    224e:	8d 81       	ldd	r24, Y+5	; 0x05
    2250:	80 6c       	ori	r24, 0xC0	; 192
    2252:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    2254:	f7 01       	movw	r30, r14
    2256:	84 81       	ldd	r24, Z+4	; 0x04
    2258:	8d 7f       	andi	r24, 0xFD	; 253
    225a:	81 30       	cpi	r24, 0x01	; 1
    225c:	21 f4       	brne	.+8      	; 0x2266 <usart_init_spi+0x2ee>
		usart->CTRLC |= USART_UCPHA_bm;
    225e:	8d 81       	ldd	r24, Y+5	; 0x05
    2260:	82 60       	ori	r24, 0x02	; 2
    2262:	8d 83       	std	Y+5, r24	; 0x05
    2264:	03 c0       	rjmp	.+6      	; 0x226c <usart_init_spi+0x2f4>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    2266:	8d 81       	ldd	r24, Y+5	; 0x05
    2268:	8d 7f       	andi	r24, 0xFD	; 253
    226a:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    226c:	f7 01       	movw	r30, r14
    226e:	85 81       	ldd	r24, Z+5	; 0x05
    2270:	88 23       	and	r24, r24
    2272:	21 f0       	breq	.+8      	; 0x227c <usart_init_spi+0x304>
		(usart)->CTRLC |= USART_DORD_bm;
    2274:	8d 81       	ldd	r24, Y+5	; 0x05
    2276:	84 60       	ori	r24, 0x04	; 4
    2278:	8d 83       	std	Y+5, r24	; 0x05
    227a:	03 c0       	rjmp	.+6      	; 0x2282 <usart_init_spi+0x30a>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    227c:	8d 81       	ldd	r24, Y+5	; 0x05
    227e:	8b 7f       	andi	r24, 0xFB	; 251
    2280:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    2282:	f7 01       	movw	r30, r14
    2284:	40 81       	ld	r20, Z
    2286:	51 81       	ldd	r21, Z+1	; 0x01
    2288:	62 81       	ldd	r22, Z+2	; 0x02
    228a:	73 81       	ldd	r23, Z+3	; 0x03
    228c:	00 e0       	ldi	r16, 0x00	; 0
    228e:	18 e4       	ldi	r17, 0x48	; 72
    2290:	28 ee       	ldi	r18, 0xE8	; 232
    2292:	31 e0       	ldi	r19, 0x01	; 1
    2294:	ce 01       	movw	r24, r28
    2296:	3e de       	rcall	.-900    	; 0x1f14 <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    2298:	8c 81       	ldd	r24, Y+4	; 0x04
    229a:	88 60       	ori	r24, 0x08	; 8
    229c:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    229e:	8c 81       	ldd	r24, Y+4	; 0x04
    22a0:	80 61       	ori	r24, 0x10	; 16
    22a2:	8c 83       	std	Y+4, r24	; 0x04
    22a4:	10 c0       	rjmp	.+32     	; 0x22c6 <usart_init_spi+0x34e>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    22a6:	8c 81       	ldd	r24, Y+4	; 0x04
    22a8:	8f 7e       	andi	r24, 0xEF	; 239
    22aa:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    22ac:	f7 01       	movw	r30, r14
    22ae:	24 81       	ldd	r18, Z+4	; 0x04
    22b0:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    22b2:	ce 01       	movw	r24, r28
    22b4:	7c cf       	rjmp	.-264    	; 0x21ae <usart_init_spi+0x236>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    22b6:	15 e1       	ldi	r17, 0x15	; 21
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    22b8:	80 ea       	ldi	r24, 0xA0	; 160
    22ba:	98 e0       	ldi	r25, 0x08	; 8
    22bc:	86 cf       	rjmp	.-244    	; 0x21ca <usart_init_spi+0x252>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    22be:	1d e1       	ldi	r17, 0x1D	; 29
    22c0:	94 cf       	rjmp	.-216    	; 0x21ea <usart_init_spi+0x272>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    22c2:	15 e2       	ldi	r17, 0x25	; 37
    22c4:	9e cf       	rjmp	.-196    	; 0x2202 <usart_init_spi+0x28a>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    22c6:	df 91       	pop	r29
    22c8:	cf 91       	pop	r28
    22ca:	1f 91       	pop	r17
    22cc:	0f 91       	pop	r16
    22ce:	ff 90       	pop	r15
    22d0:	ef 90       	pop	r14
    22d2:	08 95       	ret

000022d4 <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
    22d4:	80 3a       	cpi	r24, 0xA0	; 160
    22d6:	28 e0       	ldi	r18, 0x08	; 8
    22d8:	92 07       	cpc	r25, r18
    22da:	21 f4       	brne	.+8      	; 0x22e4 <usart_spi_init+0x10>
    22dc:	60 e1       	ldi	r22, 0x10	; 16
    22de:	83 e0       	ldi	r24, 0x03	; 3
    22e0:	ee c6       	rjmp	.+3548   	; 0x30be <sysclk_enable_module>
    22e2:	08 95       	ret
    22e4:	80 3b       	cpi	r24, 0xB0	; 176
    22e6:	28 e0       	ldi	r18, 0x08	; 8
    22e8:	92 07       	cpc	r25, r18
    22ea:	21 f4       	brne	.+8      	; 0x22f4 <usart_spi_init+0x20>
    22ec:	60 e2       	ldi	r22, 0x20	; 32
    22ee:	83 e0       	ldi	r24, 0x03	; 3
    22f0:	e6 c6       	rjmp	.+3532   	; 0x30be <sysclk_enable_module>
    22f2:	08 95       	ret
    22f4:	80 3a       	cpi	r24, 0xA0	; 160
    22f6:	29 e0       	ldi	r18, 0x09	; 9
    22f8:	92 07       	cpc	r25, r18
    22fa:	21 f4       	brne	.+8      	; 0x2304 <usart_spi_init+0x30>
    22fc:	60 e1       	ldi	r22, 0x10	; 16
    22fe:	84 e0       	ldi	r24, 0x04	; 4
    2300:	de c6       	rjmp	.+3516   	; 0x30be <sysclk_enable_module>
    2302:	08 95       	ret
    2304:	80 3b       	cpi	r24, 0xB0	; 176
    2306:	29 e0       	ldi	r18, 0x09	; 9
    2308:	92 07       	cpc	r25, r18
    230a:	21 f4       	brne	.+8      	; 0x2314 <usart_spi_init+0x40>
    230c:	60 e2       	ldi	r22, 0x20	; 32
    230e:	84 e0       	ldi	r24, 0x04	; 4
    2310:	d6 c6       	rjmp	.+3500   	; 0x30be <sysclk_enable_module>
    2312:	08 95       	ret
    2314:	80 3a       	cpi	r24, 0xA0	; 160
    2316:	2a e0       	ldi	r18, 0x0A	; 10
    2318:	92 07       	cpc	r25, r18
    231a:	21 f4       	brne	.+8      	; 0x2324 <usart_spi_init+0x50>
    231c:	60 e1       	ldi	r22, 0x10	; 16
    231e:	85 e0       	ldi	r24, 0x05	; 5
    2320:	ce c6       	rjmp	.+3484   	; 0x30be <sysclk_enable_module>
    2322:	08 95       	ret
    2324:	80 3a       	cpi	r24, 0xA0	; 160
    2326:	9b 40       	sbci	r25, 0x0B	; 11
    2328:	19 f4       	brne	.+6      	; 0x2330 <usart_spi_init+0x5c>
    232a:	60 e1       	ldi	r22, 0x10	; 16
    232c:	86 e0       	ldi	r24, 0x06	; 6
    232e:	c7 c6       	rjmp	.+3470   	; 0x30be <sysclk_enable_module>
    2330:	08 95       	ret

00002332 <usart_spi_setup_device>:
    2332:	0f 93       	push	r16
    2334:	1f 93       	push	r17
    2336:	cf 93       	push	r28
    2338:	df 93       	push	r29
    233a:	00 d0       	rcall	.+0      	; 0x233c <usart_spi_setup_device+0xa>
    233c:	00 d0       	rcall	.+0      	; 0x233e <usart_spi_setup_device+0xc>
    233e:	cd b7       	in	r28, 0x3d	; 61
    2340:	de b7       	in	r29, 0x3e	; 62
    2342:	09 83       	std	Y+1, r16	; 0x01
    2344:	1a 83       	std	Y+2, r17	; 0x02
    2346:	2b 83       	std	Y+3, r18	; 0x03
    2348:	3c 83       	std	Y+4, r19	; 0x04
    234a:	4d 83       	std	Y+5, r20	; 0x05
    234c:	1e 82       	std	Y+6, r1	; 0x06
    234e:	be 01       	movw	r22, r28
    2350:	6f 5f       	subi	r22, 0xFF	; 255
    2352:	7f 4f       	sbci	r23, 0xFF	; 255
    2354:	11 de       	rcall	.-990    	; 0x1f78 <usart_init_spi>
    2356:	26 96       	adiw	r28, 0x06	; 6
    2358:	cd bf       	out	0x3d, r28	; 61
    235a:	de bf       	out	0x3e, r29	; 62
    235c:	df 91       	pop	r29
    235e:	cf 91       	pop	r28
    2360:	1f 91       	pop	r17
    2362:	0f 91       	pop	r16
    2364:	08 95       	ret

00002366 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
    2366:	fb 01       	movw	r30, r22
    2368:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    236a:	e8 2f       	mov	r30, r24
    236c:	e6 95       	lsr	r30
    236e:	e6 95       	lsr	r30
    2370:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    2372:	40 e2       	ldi	r20, 0x20	; 32
    2374:	e4 9f       	mul	r30, r20
    2376:	f0 01       	movw	r30, r0
    2378:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    237a:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    237c:	87 70       	andi	r24, 0x07	; 7
    237e:	21 e0       	ldi	r18, 0x01	; 1
    2380:	30 e0       	ldi	r19, 0x00	; 0
    2382:	a9 01       	movw	r20, r18
    2384:	02 c0       	rjmp	.+4      	; 0x238a <usart_spi_select_device+0x24>
    2386:	44 0f       	add	r20, r20
    2388:	55 1f       	adc	r21, r21
    238a:	8a 95       	dec	r24
    238c:	e2 f7       	brpl	.-8      	; 0x2386 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    238e:	46 83       	std	Z+6, r20	; 0x06
    2390:	08 95       	ret

00002392 <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
    2392:	fb 01       	movw	r30, r22
    2394:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    2396:	e8 2f       	mov	r30, r24
    2398:	e6 95       	lsr	r30
    239a:	e6 95       	lsr	r30
    239c:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    239e:	40 e2       	ldi	r20, 0x20	; 32
    23a0:	e4 9f       	mul	r30, r20
    23a2:	f0 01       	movw	r30, r0
    23a4:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    23a6:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    23a8:	87 70       	andi	r24, 0x07	; 7
    23aa:	21 e0       	ldi	r18, 0x01	; 1
    23ac:	30 e0       	ldi	r19, 0x00	; 0
    23ae:	a9 01       	movw	r20, r18
    23b0:	02 c0       	rjmp	.+4      	; 0x23b6 <usart_spi_deselect_device+0x24>
    23b2:	44 0f       	add	r20, r20
    23b4:	55 1f       	adc	r21, r21
    23b6:	8a 95       	dec	r24
    23b8:	e2 f7       	brpl	.-8      	; 0x23b2 <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    23ba:	45 83       	std	Z+5, r20	; 0x05
    23bc:	08 95       	ret

000023be <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
    23be:	80 93 7c 23 	sts	0x237C, r24
    23c2:	90 93 7d 23 	sts	0x237D, r25
    23c6:	08 95       	ret

000023c8 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    23c8:	20 e8       	ldi	r18, 0x80	; 128
    23ca:	82 9f       	mul	r24, r18
    23cc:	c0 01       	movw	r24, r0
    23ce:	11 24       	eor	r1, r1
    23d0:	86 0f       	add	r24, r22
    23d2:	91 1d       	adc	r25, r1
    23d4:	e0 91 7c 23 	lds	r30, 0x237C
    23d8:	f0 91 7d 23 	lds	r31, 0x237D
    23dc:	e8 0f       	add	r30, r24
    23de:	f9 1f       	adc	r31, r25
    23e0:	40 83       	st	Z, r20
    23e2:	08 95       	ret

000023e4 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
    23e4:	20 e8       	ldi	r18, 0x80	; 128
    23e6:	82 9f       	mul	r24, r18
    23e8:	c0 01       	movw	r24, r0
    23ea:	11 24       	eor	r1, r1
    23ec:	86 0f       	add	r24, r22
    23ee:	91 1d       	adc	r25, r1
    23f0:	e0 91 7c 23 	lds	r30, 0x237C
    23f4:	f0 91 7d 23 	lds	r31, 0x237D
    23f8:	e8 0f       	add	r30, r24
    23fa:	f9 1f       	adc	r31, r25
}
    23fc:	80 81       	ld	r24, Z
    23fe:	08 95       	ret

00002400 <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
    2400:	ff 92       	push	r15
    2402:	0f 93       	push	r16
    2404:	1f 93       	push	r17
    2406:	cf 93       	push	r28
    2408:	df 93       	push	r29
    240a:	e4 2f       	mov	r30, r20
    240c:	f0 e0       	ldi	r31, 0x00	; 0
    240e:	e8 0f       	add	r30, r24
    2410:	f1 1d       	adc	r31, r1
    2412:	e1 38       	cpi	r30, 0x81	; 129
    2414:	f1 05       	cpc	r31, r1
    2416:	1c f0       	brlt	.+6      	; 0x241e <gfx_mono_generic_draw_horizontal_line+0x1e>
    2418:	c0 e8       	ldi	r28, 0x80	; 128
    241a:	4c 2f       	mov	r20, r28
    241c:	48 1b       	sub	r20, r24
    241e:	44 23       	and	r20, r20
    2420:	09 f4       	brne	.+2      	; 0x2424 <gfx_mono_generic_draw_horizontal_line+0x24>
    2422:	53 c0       	rjmp	.+166    	; 0x24ca <gfx_mono_generic_draw_horizontal_line+0xca>
    2424:	d6 2f       	mov	r29, r22
    2426:	d6 95       	lsr	r29
    2428:	d6 95       	lsr	r29
    242a:	d6 95       	lsr	r29
    242c:	ed 2f       	mov	r30, r29
    242e:	f0 e0       	ldi	r31, 0x00	; 0
    2430:	f1 95       	neg	r31
    2432:	e1 95       	neg	r30
    2434:	f1 09       	sbc	r31, r1
    2436:	ee 0f       	add	r30, r30
    2438:	ff 1f       	adc	r31, r31
    243a:	ee 0f       	add	r30, r30
    243c:	ff 1f       	adc	r31, r31
    243e:	ee 0f       	add	r30, r30
    2440:	ff 1f       	adc	r31, r31
    2442:	df 01       	movw	r26, r30
    2444:	a6 0f       	add	r26, r22
    2446:	b1 1d       	adc	r27, r1
    2448:	bd 01       	movw	r22, r26
    244a:	e1 e0       	ldi	r30, 0x01	; 1
    244c:	f0 e0       	ldi	r31, 0x00	; 0
    244e:	df 01       	movw	r26, r30
    2450:	02 c0       	rjmp	.+4      	; 0x2456 <gfx_mono_generic_draw_horizontal_line+0x56>
    2452:	aa 0f       	add	r26, r26
    2454:	bb 1f       	adc	r27, r27
    2456:	6a 95       	dec	r22
    2458:	e2 f7       	brpl	.-8      	; 0x2452 <gfx_mono_generic_draw_horizontal_line+0x52>
    245a:	fa 2e       	mov	r15, r26
    245c:	21 30       	cpi	r18, 0x01	; 1
    245e:	21 f0       	breq	.+8      	; 0x2468 <gfx_mono_generic_draw_horizontal_line+0x68>
    2460:	98 f0       	brcs	.+38     	; 0x2488 <gfx_mono_generic_draw_horizontal_line+0x88>
    2462:	22 30       	cpi	r18, 0x02	; 2
    2464:	19 f1       	breq	.+70     	; 0x24ac <gfx_mono_generic_draw_horizontal_line+0xac>
    2466:	31 c0       	rjmp	.+98     	; 0x24ca <gfx_mono_generic_draw_horizontal_line+0xca>
    2468:	c4 2f       	mov	r28, r20
    246a:	1f ef       	ldi	r17, 0xFF	; 255
    246c:	18 0f       	add	r17, r24
    246e:	01 2f       	mov	r16, r17
    2470:	0c 0f       	add	r16, r28
    2472:	60 2f       	mov	r22, r16
    2474:	8d 2f       	mov	r24, r29
    2476:	55 d9       	rcall	.-3414   	; 0x1722 <gfx_mono_st7565r_get_byte>
    2478:	48 2f       	mov	r20, r24
    247a:	4f 29       	or	r20, r15
    247c:	60 2f       	mov	r22, r16
    247e:	8d 2f       	mov	r24, r29
    2480:	29 d8       	rcall	.-4014   	; 0x14d4 <gfx_mono_st7565r_put_byte>
    2482:	c1 50       	subi	r28, 0x01	; 1
    2484:	a1 f7       	brne	.-24     	; 0x246e <gfx_mono_generic_draw_horizontal_line+0x6e>
    2486:	21 c0       	rjmp	.+66     	; 0x24ca <gfx_mono_generic_draw_horizontal_line+0xca>
    2488:	c4 2f       	mov	r28, r20
    248a:	1f ef       	ldi	r17, 0xFF	; 255
    248c:	18 0f       	add	r17, r24
    248e:	fa 2e       	mov	r15, r26
    2490:	f0 94       	com	r15
    2492:	01 2f       	mov	r16, r17
    2494:	0c 0f       	add	r16, r28
    2496:	60 2f       	mov	r22, r16
    2498:	8d 2f       	mov	r24, r29
    249a:	43 d9       	rcall	.-3450   	; 0x1722 <gfx_mono_st7565r_get_byte>
    249c:	48 2f       	mov	r20, r24
    249e:	4f 21       	and	r20, r15
    24a0:	60 2f       	mov	r22, r16
    24a2:	8d 2f       	mov	r24, r29
    24a4:	17 d8       	rcall	.-4050   	; 0x14d4 <gfx_mono_st7565r_put_byte>
    24a6:	c1 50       	subi	r28, 0x01	; 1
    24a8:	a1 f7       	brne	.-24     	; 0x2492 <gfx_mono_generic_draw_horizontal_line+0x92>
    24aa:	0f c0       	rjmp	.+30     	; 0x24ca <gfx_mono_generic_draw_horizontal_line+0xca>
    24ac:	c4 2f       	mov	r28, r20
    24ae:	1f ef       	ldi	r17, 0xFF	; 255
    24b0:	18 0f       	add	r17, r24
    24b2:	01 2f       	mov	r16, r17
    24b4:	0c 0f       	add	r16, r28
    24b6:	60 2f       	mov	r22, r16
    24b8:	8d 2f       	mov	r24, r29
    24ba:	33 d9       	rcall	.-3482   	; 0x1722 <gfx_mono_st7565r_get_byte>
    24bc:	48 2f       	mov	r20, r24
    24be:	4f 25       	eor	r20, r15
    24c0:	60 2f       	mov	r22, r16
    24c2:	8d 2f       	mov	r24, r29
    24c4:	07 d8       	rcall	.-4082   	; 0x14d4 <gfx_mono_st7565r_put_byte>
    24c6:	c1 50       	subi	r28, 0x01	; 1
    24c8:	a1 f7       	brne	.-24     	; 0x24b2 <gfx_mono_generic_draw_horizontal_line+0xb2>
    24ca:	df 91       	pop	r29
    24cc:	cf 91       	pop	r28
    24ce:	1f 91       	pop	r17
    24d0:	0f 91       	pop	r16
    24d2:	ff 90       	pop	r15
    24d4:	08 95       	ret

000024d6 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
    24d6:	ff 92       	push	r15
    24d8:	0f 93       	push	r16
    24da:	1f 93       	push	r17
    24dc:	cf 93       	push	r28
    24de:	df 93       	push	r29
	if (height == 0) {
    24e0:	22 23       	and	r18, r18
    24e2:	69 f0       	breq	.+26     	; 0x24fe <gfx_mono_generic_draw_filled_rect+0x28>
    24e4:	c2 2f       	mov	r28, r18
    24e6:	f4 2e       	mov	r15, r20
    24e8:	18 2f       	mov	r17, r24
    24ea:	df ef       	ldi	r29, 0xFF	; 255
    24ec:	d6 0f       	add	r29, r22
    24ee:	6d 2f       	mov	r22, r29
    24f0:	6c 0f       	add	r22, r28
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
    24f2:	20 2f       	mov	r18, r16
    24f4:	4f 2d       	mov	r20, r15
    24f6:	81 2f       	mov	r24, r17
    24f8:	83 df       	rcall	.-250    	; 0x2400 <gfx_mono_generic_draw_horizontal_line>
    24fa:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
    24fc:	c1 f7       	brne	.-16     	; 0x24ee <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
    24fe:	df 91       	pop	r29
    2500:	cf 91       	pop	r28
    2502:	1f 91       	pop	r17
    2504:	0f 91       	pop	r16
    2506:	ff 90       	pop	r15
    2508:	08 95       	ret

0000250a <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
    250a:	af 92       	push	r10
    250c:	bf 92       	push	r11
    250e:	cf 92       	push	r12
    2510:	df 92       	push	r13
    2512:	ef 92       	push	r14
    2514:	ff 92       	push	r15
    2516:	0f 93       	push	r16
    2518:	1f 93       	push	r17
    251a:	cf 93       	push	r28
    251c:	df 93       	push	r29
    251e:	c8 2f       	mov	r28, r24
    2520:	e6 2e       	mov	r14, r22
    2522:	b4 2e       	mov	r11, r20
    2524:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
    2526:	00 e0       	ldi	r16, 0x00	; 0
    2528:	f9 01       	movw	r30, r18
    252a:	24 81       	ldd	r18, Z+4	; 0x04
    252c:	43 81       	ldd	r20, Z+3	; 0x03
    252e:	6b 2d       	mov	r22, r11
    2530:	8e 2d       	mov	r24, r14
    2532:	d1 df       	rcall	.-94     	; 0x24d6 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
    2534:	f6 01       	movw	r30, r12
    2536:	80 81       	ld	r24, Z
    2538:	81 11       	cpse	r24, r1
    253a:	39 c0       	rjmp	.+114    	; 0x25ae <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
    253c:	83 81       	ldd	r24, Z+3	; 0x03
    253e:	28 2f       	mov	r18, r24
    2540:	26 95       	lsr	r18
    2542:	26 95       	lsr	r18
    2544:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
    2546:	87 70       	andi	r24, 0x07	; 7
    2548:	09 f0       	breq	.+2      	; 0x254c <gfx_mono_draw_char+0x42>
		char_row_size++;
    254a:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
    254c:	f6 01       	movw	r30, r12
    254e:	a4 80       	ldd	r10, Z+4	; 0x04
    2550:	2a 9d       	mul	r18, r10
    2552:	90 01       	movw	r18, r0
    2554:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
    2556:	8c 2f       	mov	r24, r28
    2558:	90 e0       	ldi	r25, 0x00	; 0
    255a:	45 81       	ldd	r20, Z+5	; 0x05
    255c:	84 1b       	sub	r24, r20
    255e:	91 09       	sbc	r25, r1
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
    2560:	28 9f       	mul	r18, r24
    2562:	a0 01       	movw	r20, r0
    2564:	29 9f       	mul	r18, r25
    2566:	50 0d       	add	r21, r0
    2568:	38 9f       	mul	r19, r24
    256a:	50 0d       	add	r21, r0
    256c:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
    256e:	01 81       	ldd	r16, Z+1	; 0x01
    2570:	12 81       	ldd	r17, Z+2	; 0x02
    2572:	04 0f       	add	r16, r20
    2574:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
    2576:	f6 01       	movw	r30, r12
    2578:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
    257a:	ff 20       	and	r15, r15
    257c:	a1 f0       	breq	.+40     	; 0x25a6 <gfx_mono_draw_char+0x9c>
    257e:	d0 e0       	ldi	r29, 0x00	; 0
    2580:	c0 e0       	ldi	r28, 0x00	; 0
    2582:	8c 2f       	mov	r24, r28
    2584:	8e 0d       	add	r24, r14
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
    2586:	9c 2f       	mov	r25, r28
    2588:	97 70       	andi	r25, 0x07	; 7
    258a:	21 f4       	brne	.+8      	; 0x2594 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
    258c:	f8 01       	movw	r30, r16
    258e:	d4 91       	lpm	r29, Z
				glyph_data++;
    2590:	0f 5f       	subi	r16, 0xFF	; 255
    2592:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
    2594:	dd 23       	and	r29, r29
    2596:	1c f4       	brge	.+6      	; 0x259e <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
    2598:	41 e0       	ldi	r20, 0x01	; 1
    259a:	6b 2d       	mov	r22, r11
    259c:	84 d8       	rcall	.-3832   	; 0x16a6 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
    259e:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
    25a0:	cf 5f       	subi	r28, 0xFF	; 255
    25a2:	cf 11       	cpse	r28, r15
    25a4:	ee cf       	rjmp	.-36     	; 0x2582 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
    25a6:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
    25a8:	aa 94       	dec	r10
	} while (rows_left > 0);
    25aa:	a1 10       	cpse	r10, r1
    25ac:	e4 cf       	rjmp	.-56     	; 0x2576 <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
    25ae:	df 91       	pop	r29
    25b0:	cf 91       	pop	r28
    25b2:	1f 91       	pop	r17
    25b4:	0f 91       	pop	r16
    25b6:	ff 90       	pop	r15
    25b8:	ef 90       	pop	r14
    25ba:	df 90       	pop	r13
    25bc:	cf 90       	pop	r12
    25be:	bf 90       	pop	r11
    25c0:	af 90       	pop	r10
    25c2:	08 95       	ret

000025c4 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
    25c4:	df 92       	push	r13
    25c6:	ef 92       	push	r14
    25c8:	ff 92       	push	r15
    25ca:	0f 93       	push	r16
    25cc:	1f 93       	push	r17
    25ce:	cf 93       	push	r28
    25d0:	df 93       	push	r29
    25d2:	04 2f       	mov	r16, r20
    25d4:	79 01       	movw	r14, r18
    25d6:	ec 01       	movw	r28, r24
    25d8:	16 2f       	mov	r17, r22

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    25da:	d6 2e       	mov	r13, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
    25dc:	89 91       	ld	r24, Y+
    25de:	8a 30       	cpi	r24, 0x0A	; 10
    25e0:	31 f4       	brne	.+12     	; 0x25ee <gfx_mono_draw_string+0x2a>
    25e2:	f7 01       	movw	r30, r14
    25e4:	84 81       	ldd	r24, Z+4	; 0x04
    25e6:	8f 5f       	subi	r24, 0xFF	; 255
			x = start_of_string_position_x;
			y += font->height + 1;
    25e8:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    25ea:	1d 2d       	mov	r17, r13
    25ec:	09 c0       	rjmp	.+18     	; 0x2600 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
    25ee:	8d 30       	cpi	r24, 0x0D	; 13
    25f0:	39 f0       	breq	.+14     	; 0x2600 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
    25f2:	97 01       	movw	r18, r14
    25f4:	40 2f       	mov	r20, r16
    25f6:	61 2f       	mov	r22, r17
    25f8:	88 df       	rcall	.-240    	; 0x250a <gfx_mono_draw_char>
			x += font->width;
    25fa:	f7 01       	movw	r30, r14
    25fc:	83 81       	ldd	r24, Z+3	; 0x03
    25fe:	18 0f       	add	r17, r24
		}
	} while (*(++str));
    2600:	88 81       	ld	r24, Y
    2602:	81 11       	cpse	r24, r1
    2604:	eb cf       	rjmp	.-42     	; 0x25dc <gfx_mono_draw_string+0x18>
}
    2606:	df 91       	pop	r29
    2608:	cf 91       	pop	r28
    260a:	1f 91       	pop	r17
    260c:	0f 91       	pop	r16
    260e:	ff 90       	pop	r15
    2610:	ef 90       	pop	r14
    2612:	df 90       	pop	r13
    2614:	08 95       	ret

00002616 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2616:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2618:	03 96       	adiw	r24, 0x03	; 3
    261a:	81 83       	std	Z+1, r24	; 0x01
    261c:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    261e:	2f ef       	ldi	r18, 0xFF	; 255
    2620:	3f ef       	ldi	r19, 0xFF	; 255
    2622:	23 83       	std	Z+3, r18	; 0x03
    2624:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2626:	85 83       	std	Z+5, r24	; 0x05
    2628:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    262a:	87 83       	std	Z+7, r24	; 0x07
    262c:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    262e:	10 82       	st	Z, r1
    2630:	08 95       	ret

00002632 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2632:	fc 01       	movw	r30, r24
    2634:	10 86       	std	Z+8, r1	; 0x08
    2636:	11 86       	std	Z+9, r1	; 0x09
    2638:	08 95       	ret

0000263a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    263a:	cf 93       	push	r28
    263c:	df 93       	push	r29
    263e:	9c 01       	movw	r18, r24
    2640:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2642:	dc 01       	movw	r26, r24
    2644:	11 96       	adiw	r26, 0x01	; 1
    2646:	cd 91       	ld	r28, X+
    2648:	dc 91       	ld	r29, X
    264a:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    264c:	c2 83       	std	Z+2, r28	; 0x02
    264e:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2650:	8c 81       	ldd	r24, Y+4	; 0x04
    2652:	9d 81       	ldd	r25, Y+5	; 0x05
    2654:	84 83       	std	Z+4, r24	; 0x04
    2656:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2658:	8c 81       	ldd	r24, Y+4	; 0x04
    265a:	9d 81       	ldd	r25, Y+5	; 0x05
    265c:	dc 01       	movw	r26, r24
    265e:	12 96       	adiw	r26, 0x02	; 2
    2660:	6d 93       	st	X+, r22
    2662:	7c 93       	st	X, r23
    2664:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    2666:	6c 83       	std	Y+4, r22	; 0x04
    2668:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    266a:	20 87       	std	Z+8, r18	; 0x08
    266c:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    266e:	f9 01       	movw	r30, r18
    2670:	80 81       	ld	r24, Z
    2672:	8f 5f       	subi	r24, 0xFF	; 255
    2674:	80 83       	st	Z, r24
}
    2676:	df 91       	pop	r29
    2678:	cf 91       	pop	r28
    267a:	08 95       	ret

0000267c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    267c:	cf 93       	push	r28
    267e:	df 93       	push	r29
    2680:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2682:	48 81       	ld	r20, Y
    2684:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2686:	4f 3f       	cpi	r20, 0xFF	; 255
    2688:	2f ef       	ldi	r18, 0xFF	; 255
    268a:	52 07       	cpc	r21, r18
    268c:	21 f4       	brne	.+8      	; 0x2696 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    268e:	fc 01       	movw	r30, r24
    2690:	a7 81       	ldd	r26, Z+7	; 0x07
    2692:	b0 85       	ldd	r27, Z+8	; 0x08
    2694:	0d c0       	rjmp	.+26     	; 0x26b0 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2696:	dc 01       	movw	r26, r24
    2698:	13 96       	adiw	r26, 0x03	; 3
    269a:	01 c0       	rjmp	.+2      	; 0x269e <vListInsert+0x22>
    269c:	df 01       	movw	r26, r30
    269e:	12 96       	adiw	r26, 0x02	; 2
    26a0:	ed 91       	ld	r30, X+
    26a2:	fc 91       	ld	r31, X
    26a4:	13 97       	sbiw	r26, 0x03	; 3
    26a6:	20 81       	ld	r18, Z
    26a8:	31 81       	ldd	r19, Z+1	; 0x01
    26aa:	42 17       	cp	r20, r18
    26ac:	53 07       	cpc	r21, r19
    26ae:	b0 f7       	brcc	.-20     	; 0x269c <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    26b0:	12 96       	adiw	r26, 0x02	; 2
    26b2:	ed 91       	ld	r30, X+
    26b4:	fc 91       	ld	r31, X
    26b6:	13 97       	sbiw	r26, 0x03	; 3
    26b8:	ea 83       	std	Y+2, r30	; 0x02
    26ba:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    26bc:	c4 83       	std	Z+4, r28	; 0x04
    26be:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    26c0:	ac 83       	std	Y+4, r26	; 0x04
    26c2:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    26c4:	12 96       	adiw	r26, 0x02	; 2
    26c6:	cd 93       	st	X+, r28
    26c8:	dc 93       	st	X, r29
    26ca:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    26cc:	88 87       	std	Y+8, r24	; 0x08
    26ce:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    26d0:	fc 01       	movw	r30, r24
    26d2:	20 81       	ld	r18, Z
    26d4:	2f 5f       	subi	r18, 0xFF	; 255
    26d6:	20 83       	st	Z, r18
}
    26d8:	df 91       	pop	r29
    26da:	cf 91       	pop	r28
    26dc:	08 95       	ret

000026de <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    26de:	cf 93       	push	r28
    26e0:	df 93       	push	r29
    26e2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    26e4:	a0 85       	ldd	r26, Z+8	; 0x08
    26e6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    26e8:	c2 81       	ldd	r28, Z+2	; 0x02
    26ea:	d3 81       	ldd	r29, Z+3	; 0x03
    26ec:	84 81       	ldd	r24, Z+4	; 0x04
    26ee:	95 81       	ldd	r25, Z+5	; 0x05
    26f0:	8c 83       	std	Y+4, r24	; 0x04
    26f2:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    26f4:	c4 81       	ldd	r28, Z+4	; 0x04
    26f6:	d5 81       	ldd	r29, Z+5	; 0x05
    26f8:	82 81       	ldd	r24, Z+2	; 0x02
    26fa:	93 81       	ldd	r25, Z+3	; 0x03
    26fc:	8a 83       	std	Y+2, r24	; 0x02
    26fe:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2700:	11 96       	adiw	r26, 0x01	; 1
    2702:	cd 91       	ld	r28, X+
    2704:	dc 91       	ld	r29, X
    2706:	12 97       	sbiw	r26, 0x02	; 2
    2708:	ce 17       	cp	r28, r30
    270a:	df 07       	cpc	r29, r31
    270c:	31 f4       	brne	.+12     	; 0x271a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    270e:	8c 81       	ldd	r24, Y+4	; 0x04
    2710:	9d 81       	ldd	r25, Y+5	; 0x05
    2712:	11 96       	adiw	r26, 0x01	; 1
    2714:	8d 93       	st	X+, r24
    2716:	9c 93       	st	X, r25
    2718:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    271a:	10 86       	std	Z+8, r1	; 0x08
    271c:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    271e:	8c 91       	ld	r24, X
    2720:	81 50       	subi	r24, 0x01	; 1
    2722:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    2724:	df 91       	pop	r29
    2726:	cf 91       	pop	r28
    2728:	08 95       	ret

0000272a <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    272a:	0f 93       	push	r16
    272c:	1f 93       	push	r17
    272e:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    2730:	71 e1       	ldi	r23, 0x11	; 17
    2732:	fc 01       	movw	r30, r24
    2734:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    2736:	31 97       	sbiw	r30, 0x01	; 1
    2738:	62 e2       	ldi	r22, 0x22	; 34
    273a:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    273c:	31 97       	sbiw	r30, 0x01	; 1
    273e:	23 e3       	ldi	r18, 0x33	; 51
    2740:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    2742:	01 2e       	mov	r0, r17
    2744:	00 0c       	add	r0, r0
    2746:	22 0b       	sbc	r18, r18
    2748:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    274a:	31 97       	sbiw	r30, 0x01	; 1
    274c:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    274e:	31 97       	sbiw	r30, 0x01	; 1
    2750:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    2752:	31 97       	sbiw	r30, 0x01	; 1
    2754:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    2756:	31 97       	sbiw	r30, 0x01	; 1
    2758:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    275a:	31 97       	sbiw	r30, 0x01	; 1
    275c:	20 e8       	ldi	r18, 0x80	; 128
    275e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    2760:	31 97       	sbiw	r30, 0x01	; 1
    2762:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    2764:	31 97       	sbiw	r30, 0x01	; 1
    2766:	22 e0       	ldi	r18, 0x02	; 2
    2768:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    276a:	31 97       	sbiw	r30, 0x01	; 1
    276c:	23 e0       	ldi	r18, 0x03	; 3
    276e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    2770:	31 97       	sbiw	r30, 0x01	; 1
    2772:	24 e0       	ldi	r18, 0x04	; 4
    2774:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    2776:	31 97       	sbiw	r30, 0x01	; 1
    2778:	25 e0       	ldi	r18, 0x05	; 5
    277a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    277c:	31 97       	sbiw	r30, 0x01	; 1
    277e:	26 e0       	ldi	r18, 0x06	; 6
    2780:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    2782:	31 97       	sbiw	r30, 0x01	; 1
    2784:	27 e0       	ldi	r18, 0x07	; 7
    2786:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    2788:	31 97       	sbiw	r30, 0x01	; 1
    278a:	28 e0       	ldi	r18, 0x08	; 8
    278c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    278e:	31 97       	sbiw	r30, 0x01	; 1
    2790:	29 e0       	ldi	r18, 0x09	; 9
    2792:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    2794:	31 97       	sbiw	r30, 0x01	; 1
    2796:	20 e1       	ldi	r18, 0x10	; 16
    2798:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    279a:	31 97       	sbiw	r30, 0x01	; 1
    279c:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    279e:	31 97       	sbiw	r30, 0x01	; 1
    27a0:	22 e1       	ldi	r18, 0x12	; 18
    27a2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    27a4:	31 97       	sbiw	r30, 0x01	; 1
    27a6:	23 e1       	ldi	r18, 0x13	; 19
    27a8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    27aa:	31 97       	sbiw	r30, 0x01	; 1
    27ac:	24 e1       	ldi	r18, 0x14	; 20
    27ae:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    27b0:	31 97       	sbiw	r30, 0x01	; 1
    27b2:	25 e1       	ldi	r18, 0x15	; 21
    27b4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    27b6:	31 97       	sbiw	r30, 0x01	; 1
    27b8:	26 e1       	ldi	r18, 0x16	; 22
    27ba:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    27bc:	31 97       	sbiw	r30, 0x01	; 1
    27be:	27 e1       	ldi	r18, 0x17	; 23
    27c0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    27c2:	31 97       	sbiw	r30, 0x01	; 1
    27c4:	28 e1       	ldi	r18, 0x18	; 24
    27c6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    27c8:	31 97       	sbiw	r30, 0x01	; 1
    27ca:	29 e1       	ldi	r18, 0x19	; 25
    27cc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    27ce:	31 97       	sbiw	r30, 0x01	; 1
    27d0:	20 e2       	ldi	r18, 0x20	; 32
    27d2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    27d4:	31 97       	sbiw	r30, 0x01	; 1
    27d6:	21 e2       	ldi	r18, 0x21	; 33
    27d8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    27da:	31 97       	sbiw	r30, 0x01	; 1
    27dc:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    27de:	31 97       	sbiw	r30, 0x01	; 1
    27e0:	23 e2       	ldi	r18, 0x23	; 35
    27e2:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    27e4:	31 97       	sbiw	r30, 0x01	; 1
    27e6:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    27e8:	31 97       	sbiw	r30, 0x01	; 1
    27ea:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    27ec:	31 97       	sbiw	r30, 0x01	; 1
    27ee:	26 e2       	ldi	r18, 0x26	; 38
    27f0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    27f2:	31 97       	sbiw	r30, 0x01	; 1
    27f4:	27 e2       	ldi	r18, 0x27	; 39
    27f6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    27f8:	31 97       	sbiw	r30, 0x01	; 1
    27fa:	28 e2       	ldi	r18, 0x28	; 40
    27fc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    27fe:	31 97       	sbiw	r30, 0x01	; 1
    2800:	29 e2       	ldi	r18, 0x29	; 41
    2802:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    2804:	31 97       	sbiw	r30, 0x01	; 1
    2806:	20 e3       	ldi	r18, 0x30	; 48
    2808:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    280a:	31 97       	sbiw	r30, 0x01	; 1
    280c:	21 e3       	ldi	r18, 0x31	; 49
    280e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    2810:	87 97       	sbiw	r24, 0x27	; 39
    2812:	1f 91       	pop	r17
    2814:	0f 91       	pop	r16
    2816:	08 95       	ret

00002818 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    2818:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    281a:	e0 e7       	ldi	r30, 0x70	; 112
    281c:	f0 e0       	ldi	r31, 0x00	; 0
    281e:	83 81       	ldd	r24, Z+3	; 0x03
    2820:	8a 7f       	andi	r24, 0xFA	; 250
    2822:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    2824:	e0 e0       	ldi	r30, 0x00	; 0
    2826:	f8 e0       	ldi	r31, 0x08	; 8
    2828:	80 ea       	ldi	r24, 0xA0	; 160
    282a:	9f e0       	ldi	r25, 0x0F	; 15
    282c:	86 a3       	std	Z+38, r24	; 0x26
    282e:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    2830:	91 e0       	ldi	r25, 0x01	; 1
    2832:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    2834:	a0 ea       	ldi	r26, 0xA0	; 160
    2836:	b0 e0       	ldi	r27, 0x00	; 0
    2838:	12 96       	adiw	r26, 0x02	; 2
    283a:	8c 91       	ld	r24, X
    283c:	12 97       	sbiw	r26, 0x02	; 2
    283e:	81 60       	ori	r24, 0x01	; 1
    2840:	12 96       	adiw	r26, 0x02	; 2
    2842:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    2844:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    2846:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    2848:	a0 91 d4 23 	lds	r26, 0x23D4
    284c:	b0 91 d5 23 	lds	r27, 0x23D5
    2850:	0d 90       	ld	r0, X+
    2852:	0d be       	out	0x3d, r0	; 61
    2854:	0d 90       	ld	r0, X+
    2856:	0e be       	out	0x3e, r0	; 62
    2858:	ff 91       	pop	r31
    285a:	ef 91       	pop	r30
    285c:	df 91       	pop	r29
    285e:	cf 91       	pop	r28
    2860:	bf 91       	pop	r27
    2862:	af 91       	pop	r26
    2864:	9f 91       	pop	r25
    2866:	8f 91       	pop	r24
    2868:	7f 91       	pop	r23
    286a:	6f 91       	pop	r22
    286c:	5f 91       	pop	r21
    286e:	4f 91       	pop	r20
    2870:	3f 91       	pop	r19
    2872:	2f 91       	pop	r18
    2874:	1f 91       	pop	r17
    2876:	0f 91       	pop	r16
    2878:	ff 90       	pop	r15
    287a:	ef 90       	pop	r14
    287c:	df 90       	pop	r13
    287e:	cf 90       	pop	r12
    2880:	bf 90       	pop	r11
    2882:	af 90       	pop	r10
    2884:	9f 90       	pop	r9
    2886:	8f 90       	pop	r8
    2888:	7f 90       	pop	r7
    288a:	6f 90       	pop	r6
    288c:	5f 90       	pop	r5
    288e:	4f 90       	pop	r4
    2890:	3f 90       	pop	r3
    2892:	2f 90       	pop	r2
    2894:	1f 90       	pop	r1
    2896:	0f 90       	pop	r0
    2898:	0f be       	out	0x3f, r0	; 63
    289a:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    289c:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    289e:	81 e0       	ldi	r24, 0x01	; 1
    28a0:	08 95       	ret

000028a2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    28a2:	0f 92       	push	r0
    28a4:	0f b6       	in	r0, 0x3f	; 63
    28a6:	f8 94       	cli
    28a8:	0f 92       	push	r0
    28aa:	1f 92       	push	r1
    28ac:	11 24       	eor	r1, r1
    28ae:	2f 92       	push	r2
    28b0:	3f 92       	push	r3
    28b2:	4f 92       	push	r4
    28b4:	5f 92       	push	r5
    28b6:	6f 92       	push	r6
    28b8:	7f 92       	push	r7
    28ba:	8f 92       	push	r8
    28bc:	9f 92       	push	r9
    28be:	af 92       	push	r10
    28c0:	bf 92       	push	r11
    28c2:	cf 92       	push	r12
    28c4:	df 92       	push	r13
    28c6:	ef 92       	push	r14
    28c8:	ff 92       	push	r15
    28ca:	0f 93       	push	r16
    28cc:	1f 93       	push	r17
    28ce:	2f 93       	push	r18
    28d0:	3f 93       	push	r19
    28d2:	4f 93       	push	r20
    28d4:	5f 93       	push	r21
    28d6:	6f 93       	push	r22
    28d8:	7f 93       	push	r23
    28da:	8f 93       	push	r24
    28dc:	9f 93       	push	r25
    28de:	af 93       	push	r26
    28e0:	bf 93       	push	r27
    28e2:	cf 93       	push	r28
    28e4:	df 93       	push	r29
    28e6:	ef 93       	push	r30
    28e8:	ff 93       	push	r31
    28ea:	a0 91 d4 23 	lds	r26, 0x23D4
    28ee:	b0 91 d5 23 	lds	r27, 0x23D5
    28f2:	0d b6       	in	r0, 0x3d	; 61
    28f4:	0d 92       	st	X+, r0
    28f6:	0e b6       	in	r0, 0x3e	; 62
    28f8:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    28fa:	74 d3       	rcall	.+1768   	; 0x2fe4 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    28fc:	a0 91 d4 23 	lds	r26, 0x23D4
    2900:	b0 91 d5 23 	lds	r27, 0x23D5
    2904:	0d 90       	ld	r0, X+
    2906:	0d be       	out	0x3d, r0	; 61
    2908:	0d 90       	ld	r0, X+
    290a:	0e be       	out	0x3e, r0	; 62
    290c:	ff 91       	pop	r31
    290e:	ef 91       	pop	r30
    2910:	df 91       	pop	r29
    2912:	cf 91       	pop	r28
    2914:	bf 91       	pop	r27
    2916:	af 91       	pop	r26
    2918:	9f 91       	pop	r25
    291a:	8f 91       	pop	r24
    291c:	7f 91       	pop	r23
    291e:	6f 91       	pop	r22
    2920:	5f 91       	pop	r21
    2922:	4f 91       	pop	r20
    2924:	3f 91       	pop	r19
    2926:	2f 91       	pop	r18
    2928:	1f 91       	pop	r17
    292a:	0f 91       	pop	r16
    292c:	ff 90       	pop	r15
    292e:	ef 90       	pop	r14
    2930:	df 90       	pop	r13
    2932:	cf 90       	pop	r12
    2934:	bf 90       	pop	r11
    2936:	af 90       	pop	r10
    2938:	9f 90       	pop	r9
    293a:	8f 90       	pop	r8
    293c:	7f 90       	pop	r7
    293e:	6f 90       	pop	r6
    2940:	5f 90       	pop	r5
    2942:	4f 90       	pop	r4
    2944:	3f 90       	pop	r3
    2946:	2f 90       	pop	r2
    2948:	1f 90       	pop	r1
    294a:	0f 90       	pop	r0
    294c:	0f be       	out	0x3f, r0	; 63
    294e:	0f 90       	pop	r0

    asm volatile ( "ret" );
    2950:	08 95       	ret

00002952 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    2952:	0f 92       	push	r0
    2954:	0f b6       	in	r0, 0x3f	; 63
    2956:	f8 94       	cli
    2958:	0f 92       	push	r0
    295a:	1f 92       	push	r1
    295c:	11 24       	eor	r1, r1
    295e:	2f 92       	push	r2
    2960:	3f 92       	push	r3
    2962:	4f 92       	push	r4
    2964:	5f 92       	push	r5
    2966:	6f 92       	push	r6
    2968:	7f 92       	push	r7
    296a:	8f 92       	push	r8
    296c:	9f 92       	push	r9
    296e:	af 92       	push	r10
    2970:	bf 92       	push	r11
    2972:	cf 92       	push	r12
    2974:	df 92       	push	r13
    2976:	ef 92       	push	r14
    2978:	ff 92       	push	r15
    297a:	0f 93       	push	r16
    297c:	1f 93       	push	r17
    297e:	2f 93       	push	r18
    2980:	3f 93       	push	r19
    2982:	4f 93       	push	r20
    2984:	5f 93       	push	r21
    2986:	6f 93       	push	r22
    2988:	7f 93       	push	r23
    298a:	8f 93       	push	r24
    298c:	9f 93       	push	r25
    298e:	af 93       	push	r26
    2990:	bf 93       	push	r27
    2992:	cf 93       	push	r28
    2994:	df 93       	push	r29
    2996:	ef 93       	push	r30
    2998:	ff 93       	push	r31
    299a:	a0 91 d4 23 	lds	r26, 0x23D4
    299e:	b0 91 d5 23 	lds	r27, 0x23D5
    29a2:	0d b6       	in	r0, 0x3d	; 61
    29a4:	0d 92       	st	X+, r0
    29a6:	0e b6       	in	r0, 0x3e	; 62
    29a8:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    29aa:	b1 d1       	rcall	.+866    	; 0x2d0e <xTaskIncrementTick>
    29ac:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    29ae:	1a d3       	rcall	.+1588   	; 0x2fe4 <vTaskSwitchContext>
        }
        portRESTORE_CONTEXT();
    29b0:	a0 91 d4 23 	lds	r26, 0x23D4
    29b4:	b0 91 d5 23 	lds	r27, 0x23D5
    29b8:	0d 90       	ld	r0, X+
    29ba:	0d be       	out	0x3d, r0	; 61
    29bc:	0d 90       	ld	r0, X+
    29be:	0e be       	out	0x3e, r0	; 62
    29c0:	ff 91       	pop	r31
    29c2:	ef 91       	pop	r30
    29c4:	df 91       	pop	r29
    29c6:	cf 91       	pop	r28
    29c8:	bf 91       	pop	r27
    29ca:	af 91       	pop	r26
    29cc:	9f 91       	pop	r25
    29ce:	8f 91       	pop	r24
    29d0:	7f 91       	pop	r23
    29d2:	6f 91       	pop	r22
    29d4:	5f 91       	pop	r21
    29d6:	4f 91       	pop	r20
    29d8:	3f 91       	pop	r19
    29da:	2f 91       	pop	r18
    29dc:	1f 91       	pop	r17
    29de:	0f 91       	pop	r16
    29e0:	ff 90       	pop	r15
    29e2:	ef 90       	pop	r14
    29e4:	df 90       	pop	r13
    29e6:	cf 90       	pop	r12
    29e8:	bf 90       	pop	r11
    29ea:	af 90       	pop	r10
    29ec:	9f 90       	pop	r9
    29ee:	8f 90       	pop	r8
    29f0:	7f 90       	pop	r7
    29f2:	6f 90       	pop	r6
    29f4:	5f 90       	pop	r5
    29f6:	4f 90       	pop	r4
    29f8:	3f 90       	pop	r3
    29fa:	2f 90       	pop	r2
    29fc:	1f 90       	pop	r1
    29fe:	0f 90       	pop	r0
    2a00:	0f be       	out	0x3f, r0	; 63
    2a02:	0f 90       	pop	r0

        asm volatile ( "reti" );
    2a04:	18 95       	reti

00002a06 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2a06:	cf 93       	push	r28
    2a08:	df 93       	push	r29
    2a0a:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    2a0c:	7a d1       	rcall	.+756    	; 0x2d02 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    2a0e:	ce 01       	movw	r24, r28
    2a10:	39 d6       	rcall	.+3186   	; 0x3684 <malloc>
    2a12:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2a14:	4f d2       	rcall	.+1182   	; 0x2eb4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2a16:	ce 01       	movw	r24, r28
    2a18:	df 91       	pop	r29
    2a1a:	cf 91       	pop	r28
    2a1c:	08 95       	ret

00002a1e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2a1e:	cf 93       	push	r28
    2a20:	df 93       	push	r29
	if( pv )
    2a22:	00 97       	sbiw	r24, 0x00	; 0
    2a24:	29 f0       	breq	.+10     	; 0x2a30 <vPortFree+0x12>
    2a26:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    2a28:	6c d1       	rcall	.+728    	; 0x2d02 <vTaskSuspendAll>
		{
			free( pv );
    2a2a:	ce 01       	movw	r24, r28
    2a2c:	c0 d6       	rcall	.+3456   	; 0x37ae <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    2a2e:	42 d2       	rcall	.+1156   	; 0x2eb4 <xTaskResumeAll>
	}
}
    2a30:	df 91       	pop	r29
    2a32:	cf 91       	pop	r28
    2a34:	08 95       	ret

00002a36 <prvIdleTask>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2a36:	c7 ea       	ldi	r28, 0xA7	; 167
    2a38:	d3 e2       	ldi	r29, 0x23	; 35
    2a3a:	88 81       	ld	r24, Y
    2a3c:	82 30       	cpi	r24, 0x02	; 2
    2a3e:	f0 f3       	brcs	.-4      	; 0x2a3c <prvIdleTask+0x6>
    2a40:	30 df       	rcall	.-416    	; 0x28a2 <vPortYield>
    2a42:	fb cf       	rjmp	.-10     	; 0x2a3a <prvIdleTask+0x4>

00002a44 <prvAddCurrentTaskToDelayedList>:
    2a44:	cf 93       	push	r28
    2a46:	df 93       	push	r29
    2a48:	ec 01       	movw	r28, r24
    2a4a:	e0 91 d4 23 	lds	r30, 0x23D4
    2a4e:	f0 91 d5 23 	lds	r31, 0x23D5
    2a52:	82 83       	std	Z+2, r24	; 0x02
    2a54:	93 83       	std	Z+3, r25	; 0x03
    2a56:	80 91 85 23 	lds	r24, 0x2385
    2a5a:	90 91 86 23 	lds	r25, 0x2386
    2a5e:	c8 17       	cp	r28, r24
    2a60:	d9 07       	cpc	r29, r25
    2a62:	60 f4       	brcc	.+24     	; 0x2a7c <prvAddCurrentTaskToDelayedList+0x38>
    2a64:	60 91 d4 23 	lds	r22, 0x23D4
    2a68:	70 91 d5 23 	lds	r23, 0x23D5
    2a6c:	80 91 91 23 	lds	r24, 0x2391
    2a70:	90 91 92 23 	lds	r25, 0x2392
    2a74:	6e 5f       	subi	r22, 0xFE	; 254
    2a76:	7f 4f       	sbci	r23, 0xFF	; 255
    2a78:	01 de       	rcall	.-1022   	; 0x267c <vListInsert>
    2a7a:	16 c0       	rjmp	.+44     	; 0x2aa8 <prvAddCurrentTaskToDelayedList+0x64>
    2a7c:	60 91 d4 23 	lds	r22, 0x23D4
    2a80:	70 91 d5 23 	lds	r23, 0x23D5
    2a84:	80 91 93 23 	lds	r24, 0x2393
    2a88:	90 91 94 23 	lds	r25, 0x2394
    2a8c:	6e 5f       	subi	r22, 0xFE	; 254
    2a8e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a90:	f5 dd       	rcall	.-1046   	; 0x267c <vListInsert>
    2a92:	80 91 0e 20 	lds	r24, 0x200E
    2a96:	90 91 0f 20 	lds	r25, 0x200F
    2a9a:	c8 17       	cp	r28, r24
    2a9c:	d9 07       	cpc	r29, r25
    2a9e:	20 f4       	brcc	.+8      	; 0x2aa8 <prvAddCurrentTaskToDelayedList+0x64>
    2aa0:	c0 93 0e 20 	sts	0x200E, r28
    2aa4:	d0 93 0f 20 	sts	0x200F, r29
    2aa8:	df 91       	pop	r29
    2aaa:	cf 91       	pop	r28
    2aac:	08 95       	ret

00002aae <xTaskGenericCreate>:
    2aae:	4f 92       	push	r4
    2ab0:	5f 92       	push	r5
    2ab2:	6f 92       	push	r6
    2ab4:	7f 92       	push	r7
    2ab6:	8f 92       	push	r8
    2ab8:	9f 92       	push	r9
    2aba:	af 92       	push	r10
    2abc:	bf 92       	push	r11
    2abe:	cf 92       	push	r12
    2ac0:	df 92       	push	r13
    2ac2:	ef 92       	push	r14
    2ac4:	ff 92       	push	r15
    2ac6:	0f 93       	push	r16
    2ac8:	1f 93       	push	r17
    2aca:	cf 93       	push	r28
    2acc:	df 93       	push	r29
    2ace:	4c 01       	movw	r8, r24
    2ad0:	eb 01       	movw	r28, r22
    2ad2:	5a 01       	movw	r10, r20
    2ad4:	29 01       	movw	r4, r18
    2ad6:	81 e2       	ldi	r24, 0x21	; 33
    2ad8:	90 e0       	ldi	r25, 0x00	; 0
    2ada:	95 df       	rcall	.-214    	; 0x2a06 <pvPortMalloc>
    2adc:	3c 01       	movw	r6, r24
    2ade:	00 97       	sbiw	r24, 0x00	; 0
    2ae0:	09 f4       	brne	.+2      	; 0x2ae4 <xTaskGenericCreate+0x36>
    2ae2:	d4 c0       	rjmp	.+424    	; 0x2c8c <xTaskGenericCreate+0x1de>
    2ae4:	c1 14       	cp	r12, r1
    2ae6:	d1 04       	cpc	r13, r1
    2ae8:	09 f0       	breq	.+2      	; 0x2aec <xTaskGenericCreate+0x3e>
    2aea:	cc c0       	rjmp	.+408    	; 0x2c84 <xTaskGenericCreate+0x1d6>
    2aec:	c5 01       	movw	r24, r10
    2aee:	8b df       	rcall	.-234    	; 0x2a06 <pvPortMalloc>
    2af0:	f3 01       	movw	r30, r6
    2af2:	87 8b       	std	Z+23, r24	; 0x17
    2af4:	90 8f       	std	Z+24, r25	; 0x18
    2af6:	89 2b       	or	r24, r25
    2af8:	19 f4       	brne	.+6      	; 0x2b00 <xTaskGenericCreate+0x52>
    2afa:	c3 01       	movw	r24, r6
    2afc:	90 df       	rcall	.-224    	; 0x2a1e <vPortFree>
    2afe:	c6 c0       	rjmp	.+396    	; 0x2c8c <xTaskGenericCreate+0x1de>
    2b00:	f1 e0       	ldi	r31, 0x01	; 1
    2b02:	af 1a       	sub	r10, r31
    2b04:	b1 08       	sbc	r11, r1
    2b06:	f3 01       	movw	r30, r6
    2b08:	87 89       	ldd	r24, Z+23	; 0x17
    2b0a:	90 8d       	ldd	r25, Z+24	; 0x18
    2b0c:	a8 0e       	add	r10, r24
    2b0e:	b9 1e       	adc	r11, r25
    2b10:	88 81       	ld	r24, Y
    2b12:	81 8f       	std	Z+25, r24	; 0x19
    2b14:	88 81       	ld	r24, Y
    2b16:	88 23       	and	r24, r24
    2b18:	81 f0       	breq	.+32     	; 0x2b3a <xTaskGenericCreate+0x8c>
    2b1a:	d3 01       	movw	r26, r6
    2b1c:	5a 96       	adiw	r26, 0x1a	; 26
    2b1e:	fe 01       	movw	r30, r28
    2b20:	31 96       	adiw	r30, 0x01	; 1
    2b22:	9e 01       	movw	r18, r28
    2b24:	28 5f       	subi	r18, 0xF8	; 248
    2b26:	3f 4f       	sbci	r19, 0xFF	; 255
    2b28:	ef 01       	movw	r28, r30
    2b2a:	81 91       	ld	r24, Z+
    2b2c:	8d 93       	st	X+, r24
    2b2e:	88 81       	ld	r24, Y
    2b30:	88 23       	and	r24, r24
    2b32:	19 f0       	breq	.+6      	; 0x2b3a <xTaskGenericCreate+0x8c>
    2b34:	e2 17       	cp	r30, r18
    2b36:	f3 07       	cpc	r31, r19
    2b38:	b9 f7       	brne	.-18     	; 0x2b28 <xTaskGenericCreate+0x7a>
    2b3a:	f3 01       	movw	r30, r6
    2b3c:	10 a2       	std	Z+32, r1	; 0x20
    2b3e:	10 2f       	mov	r17, r16
    2b40:	05 30       	cpi	r16, 0x05	; 5
    2b42:	08 f0       	brcs	.+2      	; 0x2b46 <xTaskGenericCreate+0x98>
    2b44:	14 e0       	ldi	r17, 0x04	; 4
    2b46:	f3 01       	movw	r30, r6
    2b48:	16 8b       	std	Z+22, r17	; 0x16
    2b4a:	e3 01       	movw	r28, r6
    2b4c:	22 96       	adiw	r28, 0x02	; 2
    2b4e:	ce 01       	movw	r24, r28
    2b50:	70 dd       	rcall	.-1312   	; 0x2632 <vListInitialiseItem>
    2b52:	c3 01       	movw	r24, r6
    2b54:	0c 96       	adiw	r24, 0x0c	; 12
    2b56:	6d dd       	rcall	.-1318   	; 0x2632 <vListInitialiseItem>
    2b58:	f3 01       	movw	r30, r6
    2b5a:	60 86       	std	Z+8, r6	; 0x08
    2b5c:	71 86       	std	Z+9, r7	; 0x09
    2b5e:	85 e0       	ldi	r24, 0x05	; 5
    2b60:	90 e0       	ldi	r25, 0x00	; 0
    2b62:	81 1b       	sub	r24, r17
    2b64:	91 09       	sbc	r25, r1
    2b66:	84 87       	std	Z+12, r24	; 0x0c
    2b68:	95 87       	std	Z+13, r25	; 0x0d
    2b6a:	62 8a       	std	Z+18, r6	; 0x12
    2b6c:	73 8a       	std	Z+19, r7	; 0x13
    2b6e:	a2 01       	movw	r20, r4
    2b70:	b4 01       	movw	r22, r8
    2b72:	c5 01       	movw	r24, r10
    2b74:	da dd       	rcall	.-1100   	; 0x272a <pxPortInitialiseStack>
    2b76:	f3 01       	movw	r30, r6
    2b78:	80 83       	st	Z, r24
    2b7a:	91 83       	std	Z+1, r25	; 0x01
    2b7c:	e1 14       	cp	r14, r1
    2b7e:	f1 04       	cpc	r15, r1
    2b80:	19 f0       	breq	.+6      	; 0x2b88 <xTaskGenericCreate+0xda>
    2b82:	f7 01       	movw	r30, r14
    2b84:	60 82       	st	Z, r6
    2b86:	71 82       	std	Z+1, r7	; 0x01
    2b88:	0f b6       	in	r0, 0x3f	; 63
    2b8a:	f8 94       	cli
    2b8c:	0f 92       	push	r0
    2b8e:	80 91 87 23 	lds	r24, 0x2387
    2b92:	8f 5f       	subi	r24, 0xFF	; 255
    2b94:	80 93 87 23 	sts	0x2387, r24
    2b98:	80 91 d4 23 	lds	r24, 0x23D4
    2b9c:	90 91 d5 23 	lds	r25, 0x23D5
    2ba0:	89 2b       	or	r24, r25
    2ba2:	91 f5       	brne	.+100    	; 0x2c08 <xTaskGenericCreate+0x15a>
    2ba4:	60 92 d4 23 	sts	0x23D4, r6
    2ba8:	70 92 d5 23 	sts	0x23D5, r7
    2bac:	80 91 87 23 	lds	r24, 0x2387
    2bb0:	81 30       	cpi	r24, 0x01	; 1
    2bb2:	c9 f5       	brne	.+114    	; 0x2c26 <xTaskGenericCreate+0x178>
    2bb4:	0f 2e       	mov	r0, r31
    2bb6:	f7 ea       	ldi	r31, 0xA7	; 167
    2bb8:	ef 2e       	mov	r14, r31
    2bba:	f3 e2       	ldi	r31, 0x23	; 35
    2bbc:	ff 2e       	mov	r15, r31
    2bbe:	f0 2d       	mov	r31, r0
    2bc0:	0f 2e       	mov	r0, r31
    2bc2:	f4 ed       	ldi	r31, 0xD4	; 212
    2bc4:	cf 2e       	mov	r12, r31
    2bc6:	f3 e2       	ldi	r31, 0x23	; 35
    2bc8:	df 2e       	mov	r13, r31
    2bca:	f0 2d       	mov	r31, r0
    2bcc:	c7 01       	movw	r24, r14
    2bce:	23 dd       	rcall	.-1466   	; 0x2616 <vListInitialise>
    2bd0:	f9 e0       	ldi	r31, 0x09	; 9
    2bd2:	ef 0e       	add	r14, r31
    2bd4:	f1 1c       	adc	r15, r1
    2bd6:	ec 14       	cp	r14, r12
    2bd8:	fd 04       	cpc	r15, r13
    2bda:	c1 f7       	brne	.-16     	; 0x2bcc <xTaskGenericCreate+0x11e>
    2bdc:	8e e9       	ldi	r24, 0x9E	; 158
    2bde:	93 e2       	ldi	r25, 0x23	; 35
    2be0:	1a dd       	rcall	.-1484   	; 0x2616 <vListInitialise>
    2be2:	85 e9       	ldi	r24, 0x95	; 149
    2be4:	93 e2       	ldi	r25, 0x23	; 35
    2be6:	17 dd       	rcall	.-1490   	; 0x2616 <vListInitialise>
    2be8:	88 e8       	ldi	r24, 0x88	; 136
    2bea:	93 e2       	ldi	r25, 0x23	; 35
    2bec:	14 dd       	rcall	.-1496   	; 0x2616 <vListInitialise>
    2bee:	8e e9       	ldi	r24, 0x9E	; 158
    2bf0:	93 e2       	ldi	r25, 0x23	; 35
    2bf2:	80 93 93 23 	sts	0x2393, r24
    2bf6:	90 93 94 23 	sts	0x2394, r25
    2bfa:	85 e9       	ldi	r24, 0x95	; 149
    2bfc:	93 e2       	ldi	r25, 0x23	; 35
    2bfe:	80 93 91 23 	sts	0x2391, r24
    2c02:	90 93 92 23 	sts	0x2392, r25
    2c06:	0f c0       	rjmp	.+30     	; 0x2c26 <xTaskGenericCreate+0x178>
    2c08:	80 91 83 23 	lds	r24, 0x2383
    2c0c:	81 11       	cpse	r24, r1
    2c0e:	0b c0       	rjmp	.+22     	; 0x2c26 <xTaskGenericCreate+0x178>
    2c10:	e0 91 d4 23 	lds	r30, 0x23D4
    2c14:	f0 91 d5 23 	lds	r31, 0x23D5
    2c18:	86 89       	ldd	r24, Z+22	; 0x16
    2c1a:	08 17       	cp	r16, r24
    2c1c:	20 f0       	brcs	.+8      	; 0x2c26 <xTaskGenericCreate+0x178>
    2c1e:	60 92 d4 23 	sts	0x23D4, r6
    2c22:	70 92 d5 23 	sts	0x23D5, r7
    2c26:	80 91 7f 23 	lds	r24, 0x237F
    2c2a:	8f 5f       	subi	r24, 0xFF	; 255
    2c2c:	80 93 7f 23 	sts	0x237F, r24
    2c30:	f3 01       	movw	r30, r6
    2c32:	86 89       	ldd	r24, Z+22	; 0x16
    2c34:	90 91 84 23 	lds	r25, 0x2384
    2c38:	98 17       	cp	r25, r24
    2c3a:	10 f4       	brcc	.+4      	; 0x2c40 <xTaskGenericCreate+0x192>
    2c3c:	80 93 84 23 	sts	0x2384, r24
    2c40:	90 e0       	ldi	r25, 0x00	; 0
    2c42:	9c 01       	movw	r18, r24
    2c44:	22 0f       	add	r18, r18
    2c46:	33 1f       	adc	r19, r19
    2c48:	22 0f       	add	r18, r18
    2c4a:	33 1f       	adc	r19, r19
    2c4c:	22 0f       	add	r18, r18
    2c4e:	33 1f       	adc	r19, r19
    2c50:	82 0f       	add	r24, r18
    2c52:	93 1f       	adc	r25, r19
    2c54:	be 01       	movw	r22, r28
    2c56:	89 55       	subi	r24, 0x59	; 89
    2c58:	9c 4d       	sbci	r25, 0xDC	; 220
    2c5a:	ef dc       	rcall	.-1570   	; 0x263a <vListInsertEnd>
    2c5c:	0f 90       	pop	r0
    2c5e:	0f be       	out	0x3f, r0	; 63
    2c60:	80 91 83 23 	lds	r24, 0x2383
    2c64:	88 23       	and	r24, r24
    2c66:	51 f0       	breq	.+20     	; 0x2c7c <xTaskGenericCreate+0x1ce>
    2c68:	e0 91 d4 23 	lds	r30, 0x23D4
    2c6c:	f0 91 d5 23 	lds	r31, 0x23D5
    2c70:	86 89       	ldd	r24, Z+22	; 0x16
    2c72:	80 17       	cp	r24, r16
    2c74:	28 f4       	brcc	.+10     	; 0x2c80 <xTaskGenericCreate+0x1d2>
    2c76:	15 de       	rcall	.-982    	; 0x28a2 <vPortYield>
    2c78:	81 e0       	ldi	r24, 0x01	; 1
    2c7a:	09 c0       	rjmp	.+18     	; 0x2c8e <xTaskGenericCreate+0x1e0>
    2c7c:	81 e0       	ldi	r24, 0x01	; 1
    2c7e:	07 c0       	rjmp	.+14     	; 0x2c8e <xTaskGenericCreate+0x1e0>
    2c80:	81 e0       	ldi	r24, 0x01	; 1
    2c82:	05 c0       	rjmp	.+10     	; 0x2c8e <xTaskGenericCreate+0x1e0>
    2c84:	fc 01       	movw	r30, r24
    2c86:	c7 8a       	std	Z+23, r12	; 0x17
    2c88:	d0 8e       	std	Z+24, r13	; 0x18
    2c8a:	3a cf       	rjmp	.-396    	; 0x2b00 <xTaskGenericCreate+0x52>
    2c8c:	8f ef       	ldi	r24, 0xFF	; 255
    2c8e:	df 91       	pop	r29
    2c90:	cf 91       	pop	r28
    2c92:	1f 91       	pop	r17
    2c94:	0f 91       	pop	r16
    2c96:	ff 90       	pop	r15
    2c98:	ef 90       	pop	r14
    2c9a:	df 90       	pop	r13
    2c9c:	cf 90       	pop	r12
    2c9e:	bf 90       	pop	r11
    2ca0:	af 90       	pop	r10
    2ca2:	9f 90       	pop	r9
    2ca4:	8f 90       	pop	r8
    2ca6:	7f 90       	pop	r7
    2ca8:	6f 90       	pop	r6
    2caa:	5f 90       	pop	r5
    2cac:	4f 90       	pop	r4
    2cae:	08 95       	ret

00002cb0 <vTaskStartScheduler>:
    2cb0:	af 92       	push	r10
    2cb2:	bf 92       	push	r11
    2cb4:	cf 92       	push	r12
    2cb6:	df 92       	push	r13
    2cb8:	ef 92       	push	r14
    2cba:	ff 92       	push	r15
    2cbc:	0f 93       	push	r16
    2cbe:	a1 2c       	mov	r10, r1
    2cc0:	b1 2c       	mov	r11, r1
    2cc2:	c1 2c       	mov	r12, r1
    2cc4:	d1 2c       	mov	r13, r1
    2cc6:	e1 2c       	mov	r14, r1
    2cc8:	f1 2c       	mov	r15, r1
    2cca:	00 e0       	ldi	r16, 0x00	; 0
    2ccc:	20 e0       	ldi	r18, 0x00	; 0
    2cce:	30 e0       	ldi	r19, 0x00	; 0
    2cd0:	45 e5       	ldi	r20, 0x55	; 85
    2cd2:	50 e0       	ldi	r21, 0x00	; 0
    2cd4:	60 e1       	ldi	r22, 0x10	; 16
    2cd6:	70 e2       	ldi	r23, 0x20	; 32
    2cd8:	8b e1       	ldi	r24, 0x1B	; 27
    2cda:	95 e1       	ldi	r25, 0x15	; 21
    2cdc:	e8 de       	rcall	.-560    	; 0x2aae <xTaskGenericCreate>
    2cde:	81 30       	cpi	r24, 0x01	; 1
    2ce0:	41 f4       	brne	.+16     	; 0x2cf2 <vTaskStartScheduler+0x42>
    2ce2:	f8 94       	cli
    2ce4:	80 93 83 23 	sts	0x2383, r24
    2ce8:	10 92 85 23 	sts	0x2385, r1
    2cec:	10 92 86 23 	sts	0x2386, r1
    2cf0:	93 dd       	rcall	.-1242   	; 0x2818 <xPortStartScheduler>
    2cf2:	0f 91       	pop	r16
    2cf4:	ff 90       	pop	r15
    2cf6:	ef 90       	pop	r14
    2cf8:	df 90       	pop	r13
    2cfa:	cf 90       	pop	r12
    2cfc:	bf 90       	pop	r11
    2cfe:	af 90       	pop	r10
    2d00:	08 95       	ret

00002d02 <vTaskSuspendAll>:
    2d02:	80 91 7e 23 	lds	r24, 0x237E
    2d06:	8f 5f       	subi	r24, 0xFF	; 255
    2d08:	80 93 7e 23 	sts	0x237E, r24
    2d0c:	08 95       	ret

00002d0e <xTaskIncrementTick>:
    2d0e:	df 92       	push	r13
    2d10:	ef 92       	push	r14
    2d12:	ff 92       	push	r15
    2d14:	0f 93       	push	r16
    2d16:	1f 93       	push	r17
    2d18:	cf 93       	push	r28
    2d1a:	df 93       	push	r29
    2d1c:	80 91 7e 23 	lds	r24, 0x237E
    2d20:	81 11       	cpse	r24, r1
    2d22:	b3 c0       	rjmp	.+358    	; 0x2e8a <xTaskIncrementTick+0x17c>
    2d24:	80 91 85 23 	lds	r24, 0x2385
    2d28:	90 91 86 23 	lds	r25, 0x2386
    2d2c:	01 96       	adiw	r24, 0x01	; 1
    2d2e:	80 93 85 23 	sts	0x2385, r24
    2d32:	90 93 86 23 	sts	0x2386, r25
    2d36:	e0 90 85 23 	lds	r14, 0x2385
    2d3a:	f0 90 86 23 	lds	r15, 0x2386
    2d3e:	e1 14       	cp	r14, r1
    2d40:	f1 04       	cpc	r15, r1
    2d42:	99 f5       	brne	.+102    	; 0x2daa <xTaskIncrementTick+0x9c>
    2d44:	80 91 93 23 	lds	r24, 0x2393
    2d48:	90 91 94 23 	lds	r25, 0x2394
    2d4c:	20 91 91 23 	lds	r18, 0x2391
    2d50:	30 91 92 23 	lds	r19, 0x2392
    2d54:	20 93 93 23 	sts	0x2393, r18
    2d58:	30 93 94 23 	sts	0x2394, r19
    2d5c:	80 93 91 23 	sts	0x2391, r24
    2d60:	90 93 92 23 	sts	0x2392, r25
    2d64:	80 91 80 23 	lds	r24, 0x2380
    2d68:	8f 5f       	subi	r24, 0xFF	; 255
    2d6a:	80 93 80 23 	sts	0x2380, r24
    2d6e:	e0 91 93 23 	lds	r30, 0x2393
    2d72:	f0 91 94 23 	lds	r31, 0x2394
    2d76:	80 81       	ld	r24, Z
    2d78:	81 11       	cpse	r24, r1
    2d7a:	07 c0       	rjmp	.+14     	; 0x2d8a <xTaskIncrementTick+0x7c>
    2d7c:	8f ef       	ldi	r24, 0xFF	; 255
    2d7e:	9f ef       	ldi	r25, 0xFF	; 255
    2d80:	80 93 0e 20 	sts	0x200E, r24
    2d84:	90 93 0f 20 	sts	0x200F, r25
    2d88:	10 c0       	rjmp	.+32     	; 0x2daa <xTaskIncrementTick+0x9c>
    2d8a:	e0 91 93 23 	lds	r30, 0x2393
    2d8e:	f0 91 94 23 	lds	r31, 0x2394
    2d92:	05 80       	ldd	r0, Z+5	; 0x05
    2d94:	f6 81       	ldd	r31, Z+6	; 0x06
    2d96:	e0 2d       	mov	r30, r0
    2d98:	06 80       	ldd	r0, Z+6	; 0x06
    2d9a:	f7 81       	ldd	r31, Z+7	; 0x07
    2d9c:	e0 2d       	mov	r30, r0
    2d9e:	82 81       	ldd	r24, Z+2	; 0x02
    2da0:	93 81       	ldd	r25, Z+3	; 0x03
    2da2:	80 93 0e 20 	sts	0x200E, r24
    2da6:	90 93 0f 20 	sts	0x200F, r25
    2daa:	80 91 0e 20 	lds	r24, 0x200E
    2dae:	90 91 0f 20 	lds	r25, 0x200F
    2db2:	e8 16       	cp	r14, r24
    2db4:	f9 06       	cpc	r15, r25
    2db6:	10 f4       	brcc	.+4      	; 0x2dbc <xTaskIncrementTick+0xae>
    2db8:	d1 2c       	mov	r13, r1
    2dba:	4f c0       	rjmp	.+158    	; 0x2e5a <xTaskIncrementTick+0x14c>
    2dbc:	d1 2c       	mov	r13, r1
    2dbe:	e0 91 93 23 	lds	r30, 0x2393
    2dc2:	f0 91 94 23 	lds	r31, 0x2394
    2dc6:	90 81       	ld	r25, Z
    2dc8:	91 11       	cpse	r25, r1
    2dca:	07 c0       	rjmp	.+14     	; 0x2dda <xTaskIncrementTick+0xcc>
    2dcc:	8f ef       	ldi	r24, 0xFF	; 255
    2dce:	9f ef       	ldi	r25, 0xFF	; 255
    2dd0:	80 93 0e 20 	sts	0x200E, r24
    2dd4:	90 93 0f 20 	sts	0x200F, r25
    2dd8:	40 c0       	rjmp	.+128    	; 0x2e5a <xTaskIncrementTick+0x14c>
    2dda:	e0 91 93 23 	lds	r30, 0x2393
    2dde:	f0 91 94 23 	lds	r31, 0x2394
    2de2:	05 80       	ldd	r0, Z+5	; 0x05
    2de4:	f6 81       	ldd	r31, Z+6	; 0x06
    2de6:	e0 2d       	mov	r30, r0
    2de8:	c6 81       	ldd	r28, Z+6	; 0x06
    2dea:	d7 81       	ldd	r29, Z+7	; 0x07
    2dec:	2a 81       	ldd	r18, Y+2	; 0x02
    2dee:	3b 81       	ldd	r19, Y+3	; 0x03
    2df0:	e2 16       	cp	r14, r18
    2df2:	f3 06       	cpc	r15, r19
    2df4:	28 f4       	brcc	.+10     	; 0x2e00 <xTaskIncrementTick+0xf2>
    2df6:	20 93 0e 20 	sts	0x200E, r18
    2dfa:	30 93 0f 20 	sts	0x200F, r19
    2dfe:	2d c0       	rjmp	.+90     	; 0x2e5a <xTaskIncrementTick+0x14c>
    2e00:	8e 01       	movw	r16, r28
    2e02:	0e 5f       	subi	r16, 0xFE	; 254
    2e04:	1f 4f       	sbci	r17, 0xFF	; 255
    2e06:	c8 01       	movw	r24, r16
    2e08:	6a dc       	rcall	.-1836   	; 0x26de <uxListRemove>
    2e0a:	8c 89       	ldd	r24, Y+20	; 0x14
    2e0c:	9d 89       	ldd	r25, Y+21	; 0x15
    2e0e:	89 2b       	or	r24, r25
    2e10:	19 f0       	breq	.+6      	; 0x2e18 <xTaskIncrementTick+0x10a>
    2e12:	ce 01       	movw	r24, r28
    2e14:	0c 96       	adiw	r24, 0x0c	; 12
    2e16:	63 dc       	rcall	.-1850   	; 0x26de <uxListRemove>
    2e18:	2e 89       	ldd	r18, Y+22	; 0x16
    2e1a:	80 91 84 23 	lds	r24, 0x2384
    2e1e:	82 17       	cp	r24, r18
    2e20:	10 f4       	brcc	.+4      	; 0x2e26 <xTaskIncrementTick+0x118>
    2e22:	20 93 84 23 	sts	0x2384, r18
    2e26:	30 e0       	ldi	r19, 0x00	; 0
    2e28:	c9 01       	movw	r24, r18
    2e2a:	88 0f       	add	r24, r24
    2e2c:	99 1f       	adc	r25, r25
    2e2e:	88 0f       	add	r24, r24
    2e30:	99 1f       	adc	r25, r25
    2e32:	88 0f       	add	r24, r24
    2e34:	99 1f       	adc	r25, r25
    2e36:	82 0f       	add	r24, r18
    2e38:	93 1f       	adc	r25, r19
    2e3a:	b8 01       	movw	r22, r16
    2e3c:	89 55       	subi	r24, 0x59	; 89
    2e3e:	9c 4d       	sbci	r25, 0xDC	; 220
    2e40:	fc db       	rcall	.-2056   	; 0x263a <vListInsertEnd>
    2e42:	e0 91 d4 23 	lds	r30, 0x23D4
    2e46:	f0 91 d5 23 	lds	r31, 0x23D5
    2e4a:	9e 89       	ldd	r25, Y+22	; 0x16
    2e4c:	86 89       	ldd	r24, Z+22	; 0x16
    2e4e:	98 17       	cp	r25, r24
    2e50:	08 f4       	brcc	.+2      	; 0x2e54 <xTaskIncrementTick+0x146>
    2e52:	b5 cf       	rjmp	.-150    	; 0x2dbe <xTaskIncrementTick+0xb0>
    2e54:	dd 24       	eor	r13, r13
    2e56:	d3 94       	inc	r13
    2e58:	b2 cf       	rjmp	.-156    	; 0x2dbe <xTaskIncrementTick+0xb0>
    2e5a:	e0 91 d4 23 	lds	r30, 0x23D4
    2e5e:	f0 91 d5 23 	lds	r31, 0x23D5
    2e62:	86 89       	ldd	r24, Z+22	; 0x16
    2e64:	90 e0       	ldi	r25, 0x00	; 0
    2e66:	fc 01       	movw	r30, r24
    2e68:	ee 0f       	add	r30, r30
    2e6a:	ff 1f       	adc	r31, r31
    2e6c:	ee 0f       	add	r30, r30
    2e6e:	ff 1f       	adc	r31, r31
    2e70:	ee 0f       	add	r30, r30
    2e72:	ff 1f       	adc	r31, r31
    2e74:	8e 0f       	add	r24, r30
    2e76:	9f 1f       	adc	r25, r31
    2e78:	fc 01       	movw	r30, r24
    2e7a:	e9 55       	subi	r30, 0x59	; 89
    2e7c:	fc 4d       	sbci	r31, 0xDC	; 220
    2e7e:	80 81       	ld	r24, Z
    2e80:	82 30       	cpi	r24, 0x02	; 2
    2e82:	48 f0       	brcs	.+18     	; 0x2e96 <xTaskIncrementTick+0x188>
    2e84:	dd 24       	eor	r13, r13
    2e86:	d3 94       	inc	r13
    2e88:	06 c0       	rjmp	.+12     	; 0x2e96 <xTaskIncrementTick+0x188>
    2e8a:	80 91 82 23 	lds	r24, 0x2382
    2e8e:	8f 5f       	subi	r24, 0xFF	; 255
    2e90:	80 93 82 23 	sts	0x2382, r24
    2e94:	d1 2c       	mov	r13, r1
    2e96:	80 91 81 23 	lds	r24, 0x2381
    2e9a:	88 23       	and	r24, r24
    2e9c:	11 f0       	breq	.+4      	; 0x2ea2 <xTaskIncrementTick+0x194>
    2e9e:	dd 24       	eor	r13, r13
    2ea0:	d3 94       	inc	r13
    2ea2:	8d 2d       	mov	r24, r13
    2ea4:	df 91       	pop	r29
    2ea6:	cf 91       	pop	r28
    2ea8:	1f 91       	pop	r17
    2eaa:	0f 91       	pop	r16
    2eac:	ff 90       	pop	r15
    2eae:	ef 90       	pop	r14
    2eb0:	df 90       	pop	r13
    2eb2:	08 95       	ret

00002eb4 <xTaskResumeAll>:
    2eb4:	df 92       	push	r13
    2eb6:	ef 92       	push	r14
    2eb8:	ff 92       	push	r15
    2eba:	0f 93       	push	r16
    2ebc:	1f 93       	push	r17
    2ebe:	cf 93       	push	r28
    2ec0:	df 93       	push	r29
    2ec2:	0f b6       	in	r0, 0x3f	; 63
    2ec4:	f8 94       	cli
    2ec6:	0f 92       	push	r0
    2ec8:	80 91 7e 23 	lds	r24, 0x237E
    2ecc:	81 50       	subi	r24, 0x01	; 1
    2ece:	80 93 7e 23 	sts	0x237E, r24
    2ed2:	80 91 7e 23 	lds	r24, 0x237E
    2ed6:	81 11       	cpse	r24, r1
    2ed8:	5d c0       	rjmp	.+186    	; 0x2f94 <xTaskResumeAll+0xe0>
    2eda:	80 91 87 23 	lds	r24, 0x2387
    2ede:	81 11       	cpse	r24, r1
    2ee0:	30 c0       	rjmp	.+96     	; 0x2f42 <xTaskResumeAll+0x8e>
    2ee2:	5b c0       	rjmp	.+182    	; 0x2f9a <xTaskResumeAll+0xe6>
    2ee4:	d7 01       	movw	r26, r14
    2ee6:	15 96       	adiw	r26, 0x05	; 5
    2ee8:	ed 91       	ld	r30, X+
    2eea:	fc 91       	ld	r31, X
    2eec:	16 97       	sbiw	r26, 0x06	; 6
    2eee:	c6 81       	ldd	r28, Z+6	; 0x06
    2ef0:	d7 81       	ldd	r29, Z+7	; 0x07
    2ef2:	ce 01       	movw	r24, r28
    2ef4:	0c 96       	adiw	r24, 0x0c	; 12
    2ef6:	f3 db       	rcall	.-2074   	; 0x26de <uxListRemove>
    2ef8:	8e 01       	movw	r16, r28
    2efa:	0e 5f       	subi	r16, 0xFE	; 254
    2efc:	1f 4f       	sbci	r17, 0xFF	; 255
    2efe:	c8 01       	movw	r24, r16
    2f00:	ee db       	rcall	.-2084   	; 0x26de <uxListRemove>
    2f02:	2e 89       	ldd	r18, Y+22	; 0x16
    2f04:	80 91 84 23 	lds	r24, 0x2384
    2f08:	82 17       	cp	r24, r18
    2f0a:	10 f4       	brcc	.+4      	; 0x2f10 <xTaskResumeAll+0x5c>
    2f0c:	20 93 84 23 	sts	0x2384, r18
    2f10:	30 e0       	ldi	r19, 0x00	; 0
    2f12:	c9 01       	movw	r24, r18
    2f14:	88 0f       	add	r24, r24
    2f16:	99 1f       	adc	r25, r25
    2f18:	88 0f       	add	r24, r24
    2f1a:	99 1f       	adc	r25, r25
    2f1c:	88 0f       	add	r24, r24
    2f1e:	99 1f       	adc	r25, r25
    2f20:	82 0f       	add	r24, r18
    2f22:	93 1f       	adc	r25, r19
    2f24:	b8 01       	movw	r22, r16
    2f26:	89 55       	subi	r24, 0x59	; 89
    2f28:	9c 4d       	sbci	r25, 0xDC	; 220
    2f2a:	87 db       	rcall	.-2290   	; 0x263a <vListInsertEnd>
    2f2c:	e0 91 d4 23 	lds	r30, 0x23D4
    2f30:	f0 91 d5 23 	lds	r31, 0x23D5
    2f34:	9e 89       	ldd	r25, Y+22	; 0x16
    2f36:	86 89       	ldd	r24, Z+22	; 0x16
    2f38:	98 17       	cp	r25, r24
    2f3a:	58 f0       	brcs	.+22     	; 0x2f52 <xTaskResumeAll+0x9e>
    2f3c:	d0 92 81 23 	sts	0x2381, r13
    2f40:	08 c0       	rjmp	.+16     	; 0x2f52 <xTaskResumeAll+0x9e>
    2f42:	0f 2e       	mov	r0, r31
    2f44:	f8 e8       	ldi	r31, 0x88	; 136
    2f46:	ef 2e       	mov	r14, r31
    2f48:	f3 e2       	ldi	r31, 0x23	; 35
    2f4a:	ff 2e       	mov	r15, r31
    2f4c:	f0 2d       	mov	r31, r0
    2f4e:	dd 24       	eor	r13, r13
    2f50:	d3 94       	inc	r13
    2f52:	f7 01       	movw	r30, r14
    2f54:	80 81       	ld	r24, Z
    2f56:	81 11       	cpse	r24, r1
    2f58:	c5 cf       	rjmp	.-118    	; 0x2ee4 <xTaskResumeAll+0x30>
    2f5a:	80 91 82 23 	lds	r24, 0x2382
    2f5e:	88 23       	and	r24, r24
    2f60:	91 f0       	breq	.+36     	; 0x2f86 <xTaskResumeAll+0xd2>
    2f62:	80 91 82 23 	lds	r24, 0x2382
    2f66:	88 23       	and	r24, r24
    2f68:	71 f0       	breq	.+28     	; 0x2f86 <xTaskResumeAll+0xd2>
    2f6a:	c1 e0       	ldi	r28, 0x01	; 1
    2f6c:	d0 de       	rcall	.-608    	; 0x2d0e <xTaskIncrementTick>
    2f6e:	81 11       	cpse	r24, r1
    2f70:	c0 93 81 23 	sts	0x2381, r28
    2f74:	80 91 82 23 	lds	r24, 0x2382
    2f78:	81 50       	subi	r24, 0x01	; 1
    2f7a:	80 93 82 23 	sts	0x2382, r24
    2f7e:	80 91 82 23 	lds	r24, 0x2382
    2f82:	81 11       	cpse	r24, r1
    2f84:	f3 cf       	rjmp	.-26     	; 0x2f6c <xTaskResumeAll+0xb8>
    2f86:	80 91 81 23 	lds	r24, 0x2381
    2f8a:	81 30       	cpi	r24, 0x01	; 1
    2f8c:	29 f4       	brne	.+10     	; 0x2f98 <xTaskResumeAll+0xe4>
    2f8e:	89 dc       	rcall	.-1774   	; 0x28a2 <vPortYield>
    2f90:	81 e0       	ldi	r24, 0x01	; 1
    2f92:	03 c0       	rjmp	.+6      	; 0x2f9a <xTaskResumeAll+0xe6>
    2f94:	80 e0       	ldi	r24, 0x00	; 0
    2f96:	01 c0       	rjmp	.+2      	; 0x2f9a <xTaskResumeAll+0xe6>
    2f98:	80 e0       	ldi	r24, 0x00	; 0
    2f9a:	0f 90       	pop	r0
    2f9c:	0f be       	out	0x3f, r0	; 63
    2f9e:	df 91       	pop	r29
    2fa0:	cf 91       	pop	r28
    2fa2:	1f 91       	pop	r17
    2fa4:	0f 91       	pop	r16
    2fa6:	ff 90       	pop	r15
    2fa8:	ef 90       	pop	r14
    2faa:	df 90       	pop	r13
    2fac:	08 95       	ret

00002fae <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2fae:	cf 93       	push	r28
    2fb0:	df 93       	push	r29
    2fb2:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2fb4:	89 2b       	or	r24, r25
    2fb6:	91 f0       	breq	.+36     	; 0x2fdc <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2fb8:	a4 de       	rcall	.-696    	; 0x2d02 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2fba:	80 91 85 23 	lds	r24, 0x2385
    2fbe:	90 91 86 23 	lds	r25, 0x2386
    2fc2:	c8 0f       	add	r28, r24
    2fc4:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2fc6:	80 91 d4 23 	lds	r24, 0x23D4
    2fca:	90 91 d5 23 	lds	r25, 0x23D5
    2fce:	02 96       	adiw	r24, 0x02	; 2
    2fd0:	86 db       	rcall	.-2292   	; 0x26de <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2fd2:	ce 01       	movw	r24, r28
    2fd4:	37 dd       	rcall	.-1426   	; 0x2a44 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2fd6:	6e df       	rcall	.-292    	; 0x2eb4 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2fd8:	81 11       	cpse	r24, r1
    2fda:	01 c0       	rjmp	.+2      	; 0x2fde <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    2fdc:	62 dc       	rcall	.-1852   	; 0x28a2 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2fde:	df 91       	pop	r29
    2fe0:	cf 91       	pop	r28
    2fe2:	08 95       	ret

00002fe4 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2fe4:	80 91 7e 23 	lds	r24, 0x237E
    2fe8:	88 23       	and	r24, r24
    2fea:	21 f0       	breq	.+8      	; 0x2ff4 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2fec:	81 e0       	ldi	r24, 0x01	; 1
    2fee:	80 93 81 23 	sts	0x2381, r24
    2ff2:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    2ff4:	10 92 81 23 	sts	0x2381, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2ff8:	80 91 84 23 	lds	r24, 0x2384
    2ffc:	90 e0       	ldi	r25, 0x00	; 0
    2ffe:	fc 01       	movw	r30, r24
    3000:	ee 0f       	add	r30, r30
    3002:	ff 1f       	adc	r31, r31
    3004:	ee 0f       	add	r30, r30
    3006:	ff 1f       	adc	r31, r31
    3008:	ee 0f       	add	r30, r30
    300a:	ff 1f       	adc	r31, r31
    300c:	8e 0f       	add	r24, r30
    300e:	9f 1f       	adc	r25, r31
    3010:	fc 01       	movw	r30, r24
    3012:	e9 55       	subi	r30, 0x59	; 89
    3014:	fc 4d       	sbci	r31, 0xDC	; 220
    3016:	80 81       	ld	r24, Z
    3018:	81 11       	cpse	r24, r1
    301a:	17 c0       	rjmp	.+46     	; 0x304a <vTaskSwitchContext+0x66>
    301c:	80 91 84 23 	lds	r24, 0x2384
    3020:	81 50       	subi	r24, 0x01	; 1
    3022:	80 93 84 23 	sts	0x2384, r24
    3026:	80 91 84 23 	lds	r24, 0x2384
    302a:	90 e0       	ldi	r25, 0x00	; 0
    302c:	fc 01       	movw	r30, r24
    302e:	ee 0f       	add	r30, r30
    3030:	ff 1f       	adc	r31, r31
    3032:	ee 0f       	add	r30, r30
    3034:	ff 1f       	adc	r31, r31
    3036:	ee 0f       	add	r30, r30
    3038:	ff 1f       	adc	r31, r31
    303a:	8e 0f       	add	r24, r30
    303c:	9f 1f       	adc	r25, r31
    303e:	fc 01       	movw	r30, r24
    3040:	e9 55       	subi	r30, 0x59	; 89
    3042:	fc 4d       	sbci	r31, 0xDC	; 220
    3044:	80 81       	ld	r24, Z
    3046:	88 23       	and	r24, r24
    3048:	49 f3       	breq	.-46     	; 0x301c <vTaskSwitchContext+0x38>
    304a:	80 91 84 23 	lds	r24, 0x2384
    304e:	90 e0       	ldi	r25, 0x00	; 0
    3050:	9c 01       	movw	r18, r24
    3052:	22 0f       	add	r18, r18
    3054:	33 1f       	adc	r19, r19
    3056:	22 0f       	add	r18, r18
    3058:	33 1f       	adc	r19, r19
    305a:	22 0f       	add	r18, r18
    305c:	33 1f       	adc	r19, r19
    305e:	28 0f       	add	r18, r24
    3060:	39 1f       	adc	r19, r25
    3062:	d9 01       	movw	r26, r18
    3064:	a9 55       	subi	r26, 0x59	; 89
    3066:	bc 4d       	sbci	r27, 0xDC	; 220
    3068:	11 96       	adiw	r26, 0x01	; 1
    306a:	ed 91       	ld	r30, X+
    306c:	fc 91       	ld	r31, X
    306e:	12 97       	sbiw	r26, 0x02	; 2
    3070:	02 80       	ldd	r0, Z+2	; 0x02
    3072:	f3 81       	ldd	r31, Z+3	; 0x03
    3074:	e0 2d       	mov	r30, r0
    3076:	11 96       	adiw	r26, 0x01	; 1
    3078:	ed 93       	st	X+, r30
    307a:	fc 93       	st	X, r31
    307c:	12 97       	sbiw	r26, 0x02	; 2
    307e:	26 55       	subi	r18, 0x56	; 86
    3080:	3c 4d       	sbci	r19, 0xDC	; 220
    3082:	e2 17       	cp	r30, r18
    3084:	f3 07       	cpc	r31, r19
    3086:	29 f4       	brne	.+10     	; 0x3092 <vTaskSwitchContext+0xae>
    3088:	22 81       	ldd	r18, Z+2	; 0x02
    308a:	33 81       	ldd	r19, Z+3	; 0x03
    308c:	fd 01       	movw	r30, r26
    308e:	21 83       	std	Z+1, r18	; 0x01
    3090:	32 83       	std	Z+2, r19	; 0x02
    3092:	fc 01       	movw	r30, r24
    3094:	ee 0f       	add	r30, r30
    3096:	ff 1f       	adc	r31, r31
    3098:	ee 0f       	add	r30, r30
    309a:	ff 1f       	adc	r31, r31
    309c:	ee 0f       	add	r30, r30
    309e:	ff 1f       	adc	r31, r31
    30a0:	8e 0f       	add	r24, r30
    30a2:	9f 1f       	adc	r25, r31
    30a4:	fc 01       	movw	r30, r24
    30a6:	e9 55       	subi	r30, 0x59	; 89
    30a8:	fc 4d       	sbci	r31, 0xDC	; 220
    30aa:	01 80       	ldd	r0, Z+1	; 0x01
    30ac:	f2 81       	ldd	r31, Z+2	; 0x02
    30ae:	e0 2d       	mov	r30, r0
    30b0:	86 81       	ldd	r24, Z+6	; 0x06
    30b2:	97 81       	ldd	r25, Z+7	; 0x07
    30b4:	80 93 d4 23 	sts	0x23D4, r24
    30b8:	90 93 d5 23 	sts	0x23D5, r25
    30bc:	08 95       	ret

000030be <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    30be:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    30c0:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    30c2:	e8 2f       	mov	r30, r24
    30c4:	f0 e0       	ldi	r31, 0x00	; 0
    30c6:	e0 59       	subi	r30, 0x90	; 144
    30c8:	ff 4f       	sbci	r31, 0xFF	; 255
    30ca:	60 95       	com	r22
    30cc:	80 81       	ld	r24, Z
    30ce:	68 23       	and	r22, r24
    30d0:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    30d2:	9f bf       	out	0x3f, r25	; 63
    30d4:	08 95       	ret

000030d6 <sysclk_disable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    30d6:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    30d8:	f8 94       	cli

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
    30da:	e8 2f       	mov	r30, r24
    30dc:	f0 e0       	ldi	r31, 0x00	; 0
    30de:	e0 59       	subi	r30, 0x90	; 144
    30e0:	ff 4f       	sbci	r31, 0xFF	; 255
    30e2:	80 81       	ld	r24, Z
    30e4:	68 2b       	or	r22, r24
    30e6:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    30e8:	9f bf       	out	0x3f, r25	; 63
    30ea:	08 95       	ret

000030ec <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    30ec:	40 91 ca 01 	lds	r20, 0x01CA
	mov ZL, r22               ; Load byte index into low byte of Z.
    30f0:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    30f2:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    30f4:	80 93 ca 01 	sts	0x01CA, r24
	lpm r24, Z                ; Perform an LPM to read out byte
    30f8:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    30fa:	40 93 ca 01 	sts	0x01CA, r20
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    30fe:	08 95       	ret

00003100 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    3100:	cf 93       	push	r28
    3102:	df 93       	push	r29
    3104:	fc 01       	movw	r30, r24
    3106:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3108:	20 e0       	ldi	r18, 0x00	; 0
    310a:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    310c:	c6 2f       	mov	r28, r22
    310e:	d0 e0       	ldi	r29, 0x00	; 0
    3110:	de 01       	movw	r26, r28
    3112:	02 2e       	mov	r0, r18
    3114:	02 c0       	rjmp	.+4      	; 0x311a <ioport_configure_port_pin+0x1a>
    3116:	b5 95       	asr	r27
    3118:	a7 95       	ror	r26
    311a:	0a 94       	dec	r0
    311c:	e2 f7       	brpl	.-8      	; 0x3116 <ioport_configure_port_pin+0x16>
    311e:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3120:	50 83       	st	Z, r21
    3122:	2f 5f       	subi	r18, 0xFF	; 255
    3124:	3f 4f       	sbci	r19, 0xFF	; 255
    3126:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    3128:	28 30       	cpi	r18, 0x08	; 8
    312a:	31 05       	cpc	r19, r1
    312c:	89 f7       	brne	.-30     	; 0x3110 <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    312e:	40 ff       	sbrs	r20, 0
    3130:	0a c0       	rjmp	.+20     	; 0x3146 <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
    3132:	41 ff       	sbrs	r20, 1
    3134:	03 c0       	rjmp	.+6      	; 0x313c <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    3136:	fc 01       	movw	r30, r24
    3138:	65 83       	std	Z+5, r22	; 0x05
    313a:	02 c0       	rjmp	.+4      	; 0x3140 <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    313c:	fc 01       	movw	r30, r24
    313e:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    3140:	fc 01       	movw	r30, r24
    3142:	61 83       	std	Z+1, r22	; 0x01
    3144:	02 c0       	rjmp	.+4      	; 0x314a <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    3146:	fc 01       	movw	r30, r24
    3148:	62 83       	std	Z+2, r22	; 0x02
	}
}
    314a:	df 91       	pop	r29
    314c:	cf 91       	pop	r28
    314e:	08 95       	ret

00003150 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    3150:	43 e0       	ldi	r20, 0x03	; 3
    3152:	50 e0       	ldi	r21, 0x00	; 0
    3154:	61 e0       	ldi	r22, 0x01	; 1
    3156:	80 ee       	ldi	r24, 0xE0	; 224
    3158:	97 e0       	ldi	r25, 0x07	; 7
    315a:	d2 df       	rcall	.-92     	; 0x3100 <ioport_configure_port_pin>
    315c:	43 e0       	ldi	r20, 0x03	; 3
    315e:	50 e0       	ldi	r21, 0x00	; 0
    3160:	62 e0       	ldi	r22, 0x02	; 2
    3162:	80 ee       	ldi	r24, 0xE0	; 224
    3164:	97 e0       	ldi	r25, 0x07	; 7
    3166:	cc df       	rcall	.-104    	; 0x3100 <ioport_configure_port_pin>
    3168:	43 e0       	ldi	r20, 0x03	; 3
    316a:	50 e0       	ldi	r21, 0x00	; 0
    316c:	60 e1       	ldi	r22, 0x10	; 16
    316e:	80 e6       	ldi	r24, 0x60	; 96
    3170:	96 e0       	ldi	r25, 0x06	; 6
    3172:	c6 df       	rcall	.-116    	; 0x3100 <ioport_configure_port_pin>
    3174:	41 e0       	ldi	r20, 0x01	; 1
    3176:	50 e4       	ldi	r21, 0x40	; 64
    3178:	60 e2       	ldi	r22, 0x20	; 32
    317a:	80 e6       	ldi	r24, 0x60	; 96
    317c:	96 e0       	ldi	r25, 0x06	; 6
    317e:	c0 df       	rcall	.-128    	; 0x3100 <ioport_configure_port_pin>
    3180:	40 e0       	ldi	r20, 0x00	; 0
    3182:	5b e1       	ldi	r21, 0x1B	; 27
    3184:	60 e2       	ldi	r22, 0x20	; 32
    3186:	80 e8       	ldi	r24, 0x80	; 128
    3188:	96 e0       	ldi	r25, 0x06	; 6
    318a:	ba df       	rcall	.-140    	; 0x3100 <ioport_configure_port_pin>
    318c:	40 e0       	ldi	r20, 0x00	; 0
    318e:	5b e1       	ldi	r21, 0x1B	; 27
    3190:	62 e0       	ldi	r22, 0x02	; 2
    3192:	80 ea       	ldi	r24, 0xA0	; 160
    3194:	96 e0       	ldi	r25, 0x06	; 6
    3196:	b4 df       	rcall	.-152    	; 0x3100 <ioport_configure_port_pin>
    3198:	40 e0       	ldi	r20, 0x00	; 0
    319a:	5b e1       	ldi	r21, 0x1B	; 27
    319c:	64 e0       	ldi	r22, 0x04	; 4
    319e:	80 ea       	ldi	r24, 0xA0	; 160
    31a0:	96 e0       	ldi	r25, 0x06	; 6
    31a2:	ae df       	rcall	.-164    	; 0x3100 <ioport_configure_port_pin>
    31a4:	43 e0       	ldi	r20, 0x03	; 3
    31a6:	50 e0       	ldi	r21, 0x00	; 0
    31a8:	62 e0       	ldi	r22, 0x02	; 2
    31aa:	80 e6       	ldi	r24, 0x60	; 96
    31ac:	96 e0       	ldi	r25, 0x06	; 6
    31ae:	a8 df       	rcall	.-176    	; 0x3100 <ioport_configure_port_pin>
    31b0:	43 e0       	ldi	r20, 0x03	; 3
    31b2:	50 e0       	ldi	r21, 0x00	; 0
    31b4:	68 e0       	ldi	r22, 0x08	; 8
    31b6:	80 e6       	ldi	r24, 0x60	; 96
    31b8:	96 e0       	ldi	r25, 0x06	; 6
    31ba:	a2 df       	rcall	.-188    	; 0x3100 <ioport_configure_port_pin>
    31bc:	43 e0       	ldi	r20, 0x03	; 3
    31be:	50 e0       	ldi	r21, 0x00	; 0
    31c0:	68 e0       	ldi	r22, 0x08	; 8
    31c2:	80 ea       	ldi	r24, 0xA0	; 160
    31c4:	96 e0       	ldi	r25, 0x06	; 6
    31c6:	9c df       	rcall	.-200    	; 0x3100 <ioport_configure_port_pin>
    31c8:	43 e0       	ldi	r20, 0x03	; 3
    31ca:	50 e0       	ldi	r21, 0x00	; 0
    31cc:	61 e0       	ldi	r22, 0x01	; 1
    31ce:	80 e6       	ldi	r24, 0x60	; 96
    31d0:	96 e0       	ldi	r25, 0x06	; 6
    31d2:	96 df       	rcall	.-212    	; 0x3100 <ioport_configure_port_pin>
    31d4:	43 e0       	ldi	r20, 0x03	; 3
    31d6:	50 e0       	ldi	r21, 0x00	; 0
    31d8:	68 e0       	ldi	r22, 0x08	; 8
    31da:	80 e0       	ldi	r24, 0x00	; 0
    31dc:	96 e0       	ldi	r25, 0x06	; 6
    31de:	90 df       	rcall	.-224    	; 0x3100 <ioport_configure_port_pin>
    31e0:	41 e0       	ldi	r20, 0x01	; 1
    31e2:	50 e0       	ldi	r21, 0x00	; 0
    31e4:	60 e1       	ldi	r22, 0x10	; 16
    31e6:	80 e8       	ldi	r24, 0x80	; 128
    31e8:	96 e0       	ldi	r25, 0x06	; 6
    31ea:	8a cf       	rjmp	.-236    	; 0x3100 <ioport_configure_port_pin>
    31ec:	08 95       	ret

000031ee <setUpSerial>:
	PORTE_OUT=0b00000001;
}

void waterAlertOff(void) {
	PORTE_DIR=0b00000001;
	PORTE_OUT=0b00000000;
    31ee:	10 92 a7 08 	sts	0x08A7, r1
    31f2:	8c e0       	ldi	r24, 0x0C	; 12
    31f4:	80 93 a6 08 	sts	0x08A6, r24
    31f8:	10 92 a3 08 	sts	0x08A3, r1
    31fc:	83 e0       	ldi	r24, 0x03	; 3
    31fe:	80 93 a5 08 	sts	0x08A5, r24
    3202:	88 e1       	ldi	r24, 0x18	; 24
    3204:	80 93 a4 08 	sts	0x08A4, r24
    3208:	08 95       	ret

0000320a <sendChar>:
    320a:	e1 ea       	ldi	r30, 0xA1	; 161
    320c:	f8 e0       	ldi	r31, 0x08	; 8
    320e:	90 81       	ld	r25, Z
    3210:	95 ff       	sbrs	r25, 5
    3212:	fd cf       	rjmp	.-6      	; 0x320e <sendChar+0x4>
    3214:	80 93 a0 08 	sts	0x08A0, r24
    3218:	08 95       	ret

0000321a <receiveChar>:
    321a:	e1 ea       	ldi	r30, 0xA1	; 161
    321c:	f8 e0       	ldi	r31, 0x08	; 8
    321e:	80 81       	ld	r24, Z
    3220:	88 23       	and	r24, r24
    3222:	ec f7       	brge	.-6      	; 0x321e <receiveChar+0x4>
    3224:	80 91 a0 08 	lds	r24, 0x08A0
    3228:	08 95       	ret

0000322a <adc_init>:
    322a:	cf 93       	push	r28
    322c:	df 93       	push	r29
    322e:	cd b7       	in	r28, 0x3d	; 61
    3230:	de b7       	in	r29, 0x3e	; 62
    3232:	2b 97       	sbiw	r28, 0x0b	; 11
    3234:	cd bf       	out	0x3d, r28	; 61
    3236:	de bf       	out	0x3e, r29	; 62
    3238:	be 01       	movw	r22, r28
    323a:	6f 5f       	subi	r22, 0xFF	; 255
    323c:	7f 4f       	sbci	r23, 0xFF	; 255
    323e:	80 e0       	ldi	r24, 0x00	; 0
    3240:	92 e0       	ldi	r25, 0x02	; 2
    3242:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <adc_read_configuration>
    3246:	ae 01       	movw	r20, r28
    3248:	48 5f       	subi	r20, 0xF8	; 248
    324a:	5f 4f       	sbci	r21, 0xFF	; 255
    324c:	61 e0       	ldi	r22, 0x01	; 1
    324e:	80 e0       	ldi	r24, 0x00	; 0
    3250:	92 e0       	ldi	r25, 0x02	; 2
    3252:	0e 94 6c 0e 	call	0x1cd8	; 0x1cd8 <adcch_read_configuration>
    3256:	9a 81       	ldd	r25, Y+2	; 0x02
    3258:	8b 81       	ldd	r24, Y+3	; 0x03
    325a:	8f 78       	andi	r24, 0x8F	; 143
    325c:	80 61       	ori	r24, 0x10	; 16
    325e:	8b 83       	std	Y+3, r24	; 0x03
    3260:	89 2f       	mov	r24, r25
    3262:	81 7e       	andi	r24, 0xE1	; 225
    3264:	8a 83       	std	Y+2, r24	; 0x02
    3266:	1c 82       	std	Y+4, r1	; 0x04
    3268:	86 e0       	ldi	r24, 0x06	; 6
    326a:	8d 83       	std	Y+5, r24	; 0x05
    326c:	81 e0       	ldi	r24, 0x01	; 1
    326e:	88 87       	std	Y+8, r24	; 0x08
    3270:	19 86       	std	Y+9, r1	; 0x09
    3272:	be 01       	movw	r22, r28
    3274:	6f 5f       	subi	r22, 0xFF	; 255
    3276:	7f 4f       	sbci	r23, 0xFF	; 255
    3278:	80 e0       	ldi	r24, 0x00	; 0
    327a:	92 e0       	ldi	r25, 0x02	; 2
    327c:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <adc_write_configuration>
    3280:	ae 01       	movw	r20, r28
    3282:	48 5f       	subi	r20, 0xF8	; 248
    3284:	5f 4f       	sbci	r21, 0xFF	; 255
    3286:	61 e0       	ldi	r22, 0x01	; 1
    3288:	80 e0       	ldi	r24, 0x00	; 0
    328a:	92 e0       	ldi	r25, 0x02	; 2
    328c:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <adcch_write_configuration>
    3290:	2b 96       	adiw	r28, 0x0b	; 11
    3292:	cd bf       	out	0x3d, r28	; 61
    3294:	de bf       	out	0x3e, r29	; 62
    3296:	df 91       	pop	r29
    3298:	cf 91       	pop	r28
    329a:	08 95       	ret

0000329c <closeTap>:
    329c:	e0 e4       	ldi	r30, 0x40	; 64
    329e:	f6 e0       	ldi	r31, 0x06	; 6
    32a0:	80 81       	ld	r24, Z
    32a2:	81 60       	ori	r24, 0x01	; 1
    32a4:	80 83       	st	Z, r24
    32a6:	e0 e0       	ldi	r30, 0x00	; 0
    32a8:	f8 e0       	ldi	r31, 0x08	; 8
    32aa:	85 e0       	ldi	r24, 0x05	; 5
    32ac:	80 83       	st	Z, r24
    32ae:	86 e1       	ldi	r24, 0x16	; 22
    32b0:	81 83       	std	Z+1, r24	; 0x01
    32b2:	80 e4       	ldi	r24, 0x40	; 64
    32b4:	9f e1       	ldi	r25, 0x1F	; 31
    32b6:	86 a3       	std	Z+38, r24	; 0x26
    32b8:	97 a3       	std	Z+39, r25	; 0x27
    32ba:	87 e7       	ldi	r24, 0x77	; 119
    32bc:	91 e0       	ldi	r25, 0x01	; 1
    32be:	80 a7       	std	Z+40, r24	; 0x28
    32c0:	91 a7       	std	Z+41, r25	; 0x29
    32c2:	08 95       	ret

000032c4 <openTap>:
    32c4:	e0 e4       	ldi	r30, 0x40	; 64
    32c6:	f6 e0       	ldi	r31, 0x06	; 6
    32c8:	80 81       	ld	r24, Z
    32ca:	81 60       	ori	r24, 0x01	; 1
    32cc:	80 83       	st	Z, r24
    32ce:	e0 e0       	ldi	r30, 0x00	; 0
    32d0:	f8 e0       	ldi	r31, 0x08	; 8
    32d2:	85 e0       	ldi	r24, 0x05	; 5
    32d4:	80 83       	st	Z, r24
    32d6:	86 e1       	ldi	r24, 0x16	; 22
    32d8:	81 83       	std	Z+1, r24	; 0x01
    32da:	80 e4       	ldi	r24, 0x40	; 64
    32dc:	9f e1       	ldi	r25, 0x1F	; 31
    32de:	86 a3       	std	Z+38, r24	; 0x26
    32e0:	97 a3       	std	Z+39, r25	; 0x27
    32e2:	87 e7       	ldi	r24, 0x77	; 119
    32e4:	91 e0       	ldi	r25, 0x01	; 1
    32e6:	80 a7       	std	Z+40, r24	; 0x28
    32e8:	91 a7       	std	Z+41, r25	; 0x29
    32ea:	08 95       	ret

000032ec <clearLCD>:
	}
	
}
//Menampilkan status penggunaan air, status keran, suhu air (LCD)
void clearLCD(void){
	gfx_mono_draw_string("                    ",0,0,&sysfont);
    32ec:	27 e0       	ldi	r18, 0x07	; 7
    32ee:	30 e2       	ldi	r19, 0x20	; 32
    32f0:	40 e0       	ldi	r20, 0x00	; 0
    32f2:	60 e0       	ldi	r22, 0x00	; 0
    32f4:	85 e1       	ldi	r24, 0x15	; 21
    32f6:	90 e2       	ldi	r25, 0x20	; 32
    32f8:	65 c9       	rjmp	.-3382   	; 0x25c4 <gfx_mono_draw_string>
    32fa:	08 95       	ret

000032fc <vReceiver>:
    32fc:	80 e1       	ldi	r24, 0x10	; 16
    32fe:	80 93 85 06 	sts	0x0685, r24
    3302:	00 ee       	ldi	r16, 0xE0	; 224
    3304:	17 e0       	ldi	r17, 0x07	; 7
    3306:	dd 24       	eor	r13, r13
    3308:	d3 94       	inc	r13
    330a:	68 94       	set
    330c:	cc 24       	eor	r12, r12
    330e:	c1 f8       	bld	r12, 1
			isAutoWatering = 1;
		} else if(cmd=='g'){
			gfx_mono_draw_string("Open Watering Tap",0,0,&sysfont);
			if (isAutoWatering==0) {
				openTap();
				isWateringTapOpened = 1;
    3310:	c1 e0       	ldi	r28, 0x01	; 1
    3312:	d0 e0       	ldi	r29, 0x00	; 0
    3314:	0f 2e       	mov	r0, r31
    3316:	f0 e6       	ldi	r31, 0x60	; 96
    3318:	ef 2e       	mov	r14, r31
    331a:	f6 e0       	ldi	r31, 0x06	; 6
    331c:	ff 2e       	mov	r15, r31
    331e:	f0 2d       	mov	r31, r0
    3320:	68 94       	set
    3322:	aa 24       	eor	r10, r10
    3324:	a5 f8       	bld	r10, 5
    3326:	68 94       	set
    3328:	bb 24       	eor	r11, r11
    332a:	b4 f8       	bld	r11, 4
}

static void vReceiver(void *pvParameters){
	gpio_set_pin_high(NHD_C12832A1Z_BACKLIGHT);
	while (1){
		char cmd = receiveChar();
    332c:	76 df       	rcall	.-276    	; 0x321a <receiveChar>
		
		if(cmd=='a'){
    332e:	81 36       	cpi	r24, 0x61	; 97
    3330:	f9 f4       	brne	.+62     	; 0x3370 <vReceiver+0x74>
			//gfx_mono_draw_string("a",0,0,&sysfont);
			if (isTap1Opened==0)
    3332:	80 91 e2 23 	lds	r24, 0x23E2
    3336:	90 91 e3 23 	lds	r25, 0x23E3
    333a:	89 2b       	or	r24, r25
    333c:	81 f4       	brne	.+32     	; 0x335e <vReceiver+0x62>
			{
				clearLCD();
    333e:	d6 df       	rcall	.-84     	; 0x32ec <clearLCD>
				gfx_mono_draw_string("Open Tap 1",0,0,&sysfont);
    3340:	27 e0       	ldi	r18, 0x07	; 7
    3342:	30 e2       	ldi	r19, 0x20	; 32
    3344:	40 e0       	ldi	r20, 0x00	; 0
    3346:	60 e0       	ldi	r22, 0x00	; 0
    3348:	8a e2       	ldi	r24, 0x2A	; 42
    334a:	90 e2       	ldi	r25, 0x20	; 32
    334c:	3b d9       	rcall	.-3466   	; 0x25c4 <gfx_mono_draw_string>
				openTap();
    334e:	ba df       	rcall	.-140    	; 0x32c4 <openTap>
				isTap1Opened = 1;
    3350:	c0 93 e2 23 	sts	0x23E2, r28
    3354:	d0 93 e3 23 	sts	0x23E3, r29
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    3358:	f8 01       	movw	r30, r16
    335a:	d6 82       	std	Z+6, r13	; 0x06
    335c:	fb c0       	rjmp	.+502    	; 0x3554 <vReceiver+0x258>
				LED_On(LED0);
			} 
			else
			{
				clearLCD();
    335e:	c6 df       	rcall	.-116    	; 0x32ec <clearLCD>
				gfx_mono_draw_string("Tap 1 had opened",0,0,&sysfont);
    3360:	27 e0       	ldi	r18, 0x07	; 7
    3362:	30 e2       	ldi	r19, 0x20	; 32
    3364:	40 e0       	ldi	r20, 0x00	; 0
    3366:	60 e0       	ldi	r22, 0x00	; 0
    3368:	85 e3       	ldi	r24, 0x35	; 53
    336a:	90 e2       	ldi	r25, 0x20	; 32
    336c:	2b d9       	rcall	.-3498   	; 0x25c4 <gfx_mono_draw_string>
    336e:	f2 c0       	rjmp	.+484    	; 0x3554 <vReceiver+0x258>
			}
		} else if(cmd=='1'){
    3370:	81 33       	cpi	r24, 0x31	; 49
    3372:	f1 f4       	brne	.+60     	; 0x33b0 <vReceiver+0xb4>
			//gfx_mono_draw_string("1",0,0,&sysfont);
			if (isTap1Opened==1)
    3374:	80 91 e2 23 	lds	r24, 0x23E2
    3378:	90 91 e3 23 	lds	r25, 0x23E3
    337c:	01 97       	sbiw	r24, 0x01	; 1
    337e:	79 f4       	brne	.+30     	; 0x339e <vReceiver+0xa2>
			{
				gfx_mono_draw_string("Close Tap 1",0,0,&sysfont);
    3380:	27 e0       	ldi	r18, 0x07	; 7
    3382:	30 e2       	ldi	r19, 0x20	; 32
    3384:	40 e0       	ldi	r20, 0x00	; 0
    3386:	60 e0       	ldi	r22, 0x00	; 0
    3388:	86 e4       	ldi	r24, 0x46	; 70
    338a:	90 e2       	ldi	r25, 0x20	; 32
    338c:	1b d9       	rcall	.-3530   	; 0x25c4 <gfx_mono_draw_string>
				closeTap();
    338e:	86 df       	rcall	.-244    	; 0x329c <closeTap>
				isTap1Opened = 0;
    3390:	10 92 e2 23 	sts	0x23E2, r1
    3394:	10 92 e3 23 	sts	0x23E3, r1
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3398:	f8 01       	movw	r30, r16
    339a:	d5 82       	std	Z+5, r13	; 0x05
    339c:	db c0       	rjmp	.+438    	; 0x3554 <vReceiver+0x258>
				LED_Off(LED0);
			} 
			else
			{
				clearLCD();
    339e:	a6 df       	rcall	.-180    	; 0x32ec <clearLCD>
				gfx_mono_draw_string("Tap 1 had closed",0,0,&sysfont);
    33a0:	27 e0       	ldi	r18, 0x07	; 7
    33a2:	30 e2       	ldi	r19, 0x20	; 32
    33a4:	40 e0       	ldi	r20, 0x00	; 0
    33a6:	60 e0       	ldi	r22, 0x00	; 0
    33a8:	82 e5       	ldi	r24, 0x52	; 82
    33aa:	90 e2       	ldi	r25, 0x20	; 32
    33ac:	0b d9       	rcall	.-3562   	; 0x25c4 <gfx_mono_draw_string>
    33ae:	d2 c0       	rjmp	.+420    	; 0x3554 <vReceiver+0x258>
			}
		} else if(cmd=='b'){
    33b0:	82 36       	cpi	r24, 0x62	; 98
    33b2:	79 f4       	brne	.+30     	; 0x33d2 <vReceiver+0xd6>
			gfx_mono_draw_string("Open Tap 2",0,0,&sysfont);
    33b4:	27 e0       	ldi	r18, 0x07	; 7
    33b6:	30 e2       	ldi	r19, 0x20	; 32
    33b8:	40 e0       	ldi	r20, 0x00	; 0
    33ba:	60 e0       	ldi	r22, 0x00	; 0
    33bc:	83 e6       	ldi	r24, 0x63	; 99
    33be:	90 e2       	ldi	r25, 0x20	; 32
    33c0:	01 d9       	rcall	.-3582   	; 0x25c4 <gfx_mono_draw_string>
			openTap();
    33c2:	80 df       	rcall	.-256    	; 0x32c4 <openTap>
			isTap2Opened = 1;
    33c4:	c0 93 e0 23 	sts	0x23E0, r28
    33c8:	d0 93 e1 23 	sts	0x23E1, r29
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    33cc:	f8 01       	movw	r30, r16
    33ce:	c6 82       	std	Z+6, r12	; 0x06
    33d0:	c1 c0       	rjmp	.+386    	; 0x3554 <vReceiver+0x258>
			LED_On(LED1);
		} else if(cmd=='2'){
    33d2:	82 33       	cpi	r24, 0x32	; 50
    33d4:	79 f4       	brne	.+30     	; 0x33f4 <vReceiver+0xf8>
			gfx_mono_draw_string("Close Tap 2",0,0,&sysfont);
    33d6:	27 e0       	ldi	r18, 0x07	; 7
    33d8:	30 e2       	ldi	r19, 0x20	; 32
    33da:	40 e0       	ldi	r20, 0x00	; 0
    33dc:	60 e0       	ldi	r22, 0x00	; 0
    33de:	8e e6       	ldi	r24, 0x6E	; 110
    33e0:	90 e2       	ldi	r25, 0x20	; 32
    33e2:	f0 d8       	rcall	.-3616   	; 0x25c4 <gfx_mono_draw_string>
			closeTap();
    33e4:	5b df       	rcall	.-330    	; 0x329c <closeTap>
			isTap2Opened = 0;
    33e6:	10 92 e0 23 	sts	0x23E0, r1
    33ea:	10 92 e1 23 	sts	0x23E1, r1
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    33ee:	f8 01       	movw	r30, r16
    33f0:	c5 82       	std	Z+5, r12	; 0x05
    33f2:	b0 c0       	rjmp	.+352    	; 0x3554 <vReceiver+0x258>
			LED_Off(LED1);
		} else if(cmd=='c'){
    33f4:	83 36       	cpi	r24, 0x63	; 99
    33f6:	79 f4       	brne	.+30     	; 0x3416 <vReceiver+0x11a>
			gfx_mono_draw_string("Open Tap 3",0,0,&sysfont);
    33f8:	27 e0       	ldi	r18, 0x07	; 7
    33fa:	30 e2       	ldi	r19, 0x20	; 32
    33fc:	40 e0       	ldi	r20, 0x00	; 0
    33fe:	60 e0       	ldi	r22, 0x00	; 0
    3400:	8a e7       	ldi	r24, 0x7A	; 122
    3402:	90 e2       	ldi	r25, 0x20	; 32
    3404:	df d8       	rcall	.-3650   	; 0x25c4 <gfx_mono_draw_string>
			openTap();
    3406:	5e df       	rcall	.-324    	; 0x32c4 <openTap>
			isTap3Opened = 1;
    3408:	c0 93 de 23 	sts	0x23DE, r28
    340c:	d0 93 df 23 	sts	0x23DF, r29
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    3410:	f7 01       	movw	r30, r14
    3412:	b6 82       	std	Z+6, r11	; 0x06
    3414:	9f c0       	rjmp	.+318    	; 0x3554 <vReceiver+0x258>
			LED_On(LED2);
		} else if(cmd=='3'){
    3416:	83 33       	cpi	r24, 0x33	; 51
    3418:	79 f4       	brne	.+30     	; 0x3438 <vReceiver+0x13c>
			gfx_mono_draw_string("Close Tap 3",0,0,&sysfont);
    341a:	27 e0       	ldi	r18, 0x07	; 7
    341c:	30 e2       	ldi	r19, 0x20	; 32
    341e:	40 e0       	ldi	r20, 0x00	; 0
    3420:	60 e0       	ldi	r22, 0x00	; 0
    3422:	85 e8       	ldi	r24, 0x85	; 133
    3424:	90 e2       	ldi	r25, 0x20	; 32
    3426:	ce d8       	rcall	.-3684   	; 0x25c4 <gfx_mono_draw_string>
			closeTap();
    3428:	39 df       	rcall	.-398    	; 0x329c <closeTap>
			isTap3Opened = 0;
    342a:	10 92 de 23 	sts	0x23DE, r1
    342e:	10 92 df 23 	sts	0x23DF, r1
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3432:	f7 01       	movw	r30, r14
    3434:	b5 82       	std	Z+5, r11	; 0x05
    3436:	8e c0       	rjmp	.+284    	; 0x3554 <vReceiver+0x258>
			LED_Off(LED2);
		} else if(cmd=='d'){
    3438:	84 36       	cpi	r24, 0x64	; 100
    343a:	79 f4       	brne	.+30     	; 0x345a <vReceiver+0x15e>
			gfx_mono_draw_string("Open Tap 4",0,0,&sysfont);
    343c:	27 e0       	ldi	r18, 0x07	; 7
    343e:	30 e2       	ldi	r19, 0x20	; 32
    3440:	40 e0       	ldi	r20, 0x00	; 0
    3442:	60 e0       	ldi	r22, 0x00	; 0
    3444:	81 e9       	ldi	r24, 0x91	; 145
    3446:	90 e2       	ldi	r25, 0x20	; 32
    3448:	bd d8       	rcall	.-3718   	; 0x25c4 <gfx_mono_draw_string>
			openTap();
    344a:	3c df       	rcall	.-392    	; 0x32c4 <openTap>
			isTap4Opened = 1;
    344c:	c0 93 dc 23 	sts	0x23DC, r28
    3450:	d0 93 dd 23 	sts	0x23DD, r29
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    3454:	f7 01       	movw	r30, r14
    3456:	a6 82       	std	Z+6, r10	; 0x06
    3458:	7d c0       	rjmp	.+250    	; 0x3554 <vReceiver+0x258>
			LED_On(LED3);
		} else if(cmd=='4'){
    345a:	84 33       	cpi	r24, 0x34	; 52
    345c:	79 f4       	brne	.+30     	; 0x347c <vReceiver+0x180>
			gfx_mono_draw_string("Close Tap 4",0,0,&sysfont);
    345e:	27 e0       	ldi	r18, 0x07	; 7
    3460:	30 e2       	ldi	r19, 0x20	; 32
    3462:	40 e0       	ldi	r20, 0x00	; 0
    3464:	60 e0       	ldi	r22, 0x00	; 0
    3466:	8c e9       	ldi	r24, 0x9C	; 156
    3468:	90 e2       	ldi	r25, 0x20	; 32
    346a:	ac d8       	rcall	.-3752   	; 0x25c4 <gfx_mono_draw_string>
			closeTap();
    346c:	17 df       	rcall	.-466    	; 0x329c <closeTap>
			isTap3Opened = 0;
    346e:	10 92 de 23 	sts	0x23DE, r1
    3472:	10 92 df 23 	sts	0x23DF, r1
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3476:	f7 01       	movw	r30, r14
    3478:	a5 82       	std	Z+5, r10	; 0x05
    347a:	6c c0       	rjmp	.+216    	; 0x3554 <vReceiver+0x258>
			LED_Off(LED3);
		} else if(cmd=='e'){
    347c:	85 36       	cpi	r24, 0x65	; 101
    347e:	41 f4       	brne	.+16     	; 0x3490 <vReceiver+0x194>
			gfx_mono_draw_string("Water Discharge",0,0,&sysfont);
    3480:	27 e0       	ldi	r18, 0x07	; 7
    3482:	30 e2       	ldi	r19, 0x20	; 32
    3484:	40 e0       	ldi	r20, 0x00	; 0
    3486:	60 e0       	ldi	r22, 0x00	; 0
    3488:	88 ea       	ldi	r24, 0xA8	; 168
    348a:	90 e2       	ldi	r25, 0x20	; 32
    348c:	9b d8       	rcall	.-3786   	; 0x25c4 <gfx_mono_draw_string>
    348e:	62 c0       	rjmp	.+196    	; 0x3554 <vReceiver+0x258>
		} else if(cmd=='5'){
    3490:	85 33       	cpi	r24, 0x35	; 53
    3492:	41 f4       	brne	.+16     	; 0x34a4 <vReceiver+0x1a8>
			gfx_mono_draw_string("Water Discharge",0,0,&sysfont);
    3494:	27 e0       	ldi	r18, 0x07	; 7
    3496:	30 e2       	ldi	r19, 0x20	; 32
    3498:	40 e0       	ldi	r20, 0x00	; 0
    349a:	60 e0       	ldi	r22, 0x00	; 0
    349c:	88 ea       	ldi	r24, 0xA8	; 168
    349e:	90 e2       	ldi	r25, 0x20	; 32
    34a0:	91 d8       	rcall	.-3806   	; 0x25c4 <gfx_mono_draw_string>
    34a2:	58 c0       	rjmp	.+176    	; 0x3554 <vReceiver+0x258>
		} else if(cmd=='f'){
    34a4:	86 36       	cpi	r24, 0x66	; 102
    34a6:	61 f4       	brne	.+24     	; 0x34c0 <vReceiver+0x1c4>
			gfx_mono_draw_string("Manual Watering",0,0,&sysfont);
    34a8:	27 e0       	ldi	r18, 0x07	; 7
    34aa:	30 e2       	ldi	r19, 0x20	; 32
    34ac:	40 e0       	ldi	r20, 0x00	; 0
    34ae:	60 e0       	ldi	r22, 0x00	; 0
    34b0:	88 eb       	ldi	r24, 0xB8	; 184
    34b2:	90 e2       	ldi	r25, 0x20	; 32
    34b4:	87 d8       	rcall	.-3826   	; 0x25c4 <gfx_mono_draw_string>
			isAutoWatering = 0;
    34b6:	10 92 d6 23 	sts	0x23D6, r1
    34ba:	10 92 d7 23 	sts	0x23D7, r1
    34be:	4a c0       	rjmp	.+148    	; 0x3554 <vReceiver+0x258>
		} else if(cmd=='6'){
    34c0:	86 33       	cpi	r24, 0x36	; 54
    34c2:	61 f4       	brne	.+24     	; 0x34dc <vReceiver+0x1e0>
			gfx_mono_draw_string("Auto Watering",0,0,&sysfont);
    34c4:	27 e0       	ldi	r18, 0x07	; 7
    34c6:	30 e2       	ldi	r19, 0x20	; 32
    34c8:	40 e0       	ldi	r20, 0x00	; 0
    34ca:	60 e0       	ldi	r22, 0x00	; 0
    34cc:	88 ec       	ldi	r24, 0xC8	; 200
    34ce:	90 e2       	ldi	r25, 0x20	; 32
    34d0:	79 d8       	rcall	.-3854   	; 0x25c4 <gfx_mono_draw_string>
			isAutoWatering = 1;
    34d2:	c0 93 d6 23 	sts	0x23D6, r28
    34d6:	d0 93 d7 23 	sts	0x23D7, r29
    34da:	3c c0       	rjmp	.+120    	; 0x3554 <vReceiver+0x258>
		} else if(cmd=='g'){
    34dc:	87 36       	cpi	r24, 0x67	; 103
    34de:	f1 f4       	brne	.+60     	; 0x351c <vReceiver+0x220>
			gfx_mono_draw_string("Open Watering Tap",0,0,&sysfont);
    34e0:	27 e0       	ldi	r18, 0x07	; 7
    34e2:	30 e2       	ldi	r19, 0x20	; 32
    34e4:	40 e0       	ldi	r20, 0x00	; 0
    34e6:	60 e0       	ldi	r22, 0x00	; 0
    34e8:	86 ed       	ldi	r24, 0xD6	; 214
    34ea:	90 e2       	ldi	r25, 0x20	; 32
    34ec:	6b d8       	rcall	.-3882   	; 0x25c4 <gfx_mono_draw_string>
			if (isAutoWatering==0) {
    34ee:	80 91 d6 23 	lds	r24, 0x23D6
    34f2:	90 91 d7 23 	lds	r25, 0x23D7
    34f6:	89 2b       	or	r24, r25
    34f8:	49 f4       	brne	.+18     	; 0x350c <vReceiver+0x210>
				openTap();
    34fa:	e4 de       	rcall	.-568    	; 0x32c4 <openTap>
				isWateringTapOpened = 1;
    34fc:	c0 93 da 23 	sts	0x23DA, r28
    3500:	d0 93 db 23 	sts	0x23DB, r29
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    3504:	f8 01       	movw	r30, r16
    3506:	d6 82       	std	Z+6, r13	; 0x06
    3508:	c6 82       	std	Z+6, r12	; 0x06
    350a:	24 c0       	rjmp	.+72     	; 0x3554 <vReceiver+0x258>
							LED_On(LED0);
							LED_On(LED1);
			} else {
				gfx_mono_draw_string("Auto Watering Mode ON",0,0,&sysfont);
    350c:	27 e0       	ldi	r18, 0x07	; 7
    350e:	30 e2       	ldi	r19, 0x20	; 32
    3510:	40 e0       	ldi	r20, 0x00	; 0
    3512:	60 e0       	ldi	r22, 0x00	; 0
    3514:	88 ee       	ldi	r24, 0xE8	; 232
    3516:	90 e2       	ldi	r25, 0x20	; 32
    3518:	55 d8       	rcall	.-3926   	; 0x25c4 <gfx_mono_draw_string>
    351a:	1c c0       	rjmp	.+56     	; 0x3554 <vReceiver+0x258>
			}
		} else if(cmd=='7'){
    351c:	87 33       	cpi	r24, 0x37	; 55
    351e:	81 f4       	brne	.+32     	; 0x3540 <vReceiver+0x244>
			gfx_mono_draw_string("Close Watering Tap",0,0,&sysfont);
    3520:	27 e0       	ldi	r18, 0x07	; 7
    3522:	30 e2       	ldi	r19, 0x20	; 32
    3524:	40 e0       	ldi	r20, 0x00	; 0
    3526:	60 e0       	ldi	r22, 0x00	; 0
    3528:	8e ef       	ldi	r24, 0xFE	; 254
    352a:	90 e2       	ldi	r25, 0x20	; 32
    352c:	4b d8       	rcall	.-3946   	; 0x25c4 <gfx_mono_draw_string>
			closeTap();
    352e:	b6 de       	rcall	.-660    	; 0x329c <closeTap>
			isWateringTapOpened = 0;
    3530:	10 92 da 23 	sts	0x23DA, r1
    3534:	10 92 db 23 	sts	0x23DB, r1
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3538:	f8 01       	movw	r30, r16
    353a:	d5 82       	std	Z+5, r13	; 0x05
    353c:	c5 82       	std	Z+5, r12	; 0x05
    353e:	0a c0       	rjmp	.+20     	; 0x3554 <vReceiver+0x258>
			LED_Off(LED0);
			LED_Off(LED1);
		} else if(cmd=='p'){
    3540:	80 37       	cpi	r24, 0x70	; 112
    3542:	41 f4       	brne	.+16     	; 0x3554 <vReceiver+0x258>
			sendChar('p');
    3544:	62 de       	rcall	.-828    	; 0x320a <sendChar>
			gfx_mono_draw_string("Send PING",0,0,&sysfont);
    3546:	27 e0       	ldi	r18, 0x07	; 7
    3548:	30 e2       	ldi	r19, 0x20	; 32
    354a:	40 e0       	ldi	r20, 0x00	; 0
    354c:	60 e0       	ldi	r22, 0x00	; 0
    354e:	81 e1       	ldi	r24, 0x11	; 17
    3550:	91 e2       	ldi	r25, 0x21	; 33
    3552:	38 d8       	rcall	.-3984   	; 0x25c4 <gfx_mono_draw_string>
		}
		vTaskDelay(1);
    3554:	ce 01       	movw	r24, r28
    3556:	2b dd       	rcall	.-1450   	; 0x2fae <vTaskDelay>
	}
    3558:	e9 ce       	rjmp	.-558    	; 0x332c <vReceiver+0x30>

0000355a <main>:
}

int main (void)
{
    355a:	af 92       	push	r10
    355c:	bf 92       	push	r11
    355e:	cf 92       	push	r12
    3560:	df 92       	push	r13
    3562:	ef 92       	push	r14
    3564:	ff 92       	push	r15
    3566:	0f 93       	push	r16
	board_init(); //konfigurasi awal board
    3568:	f3 dd       	rcall	.-1050   	; 0x3150 <board_init>
	//sysclk_init(); //konfigurasi awal system clock
	adc_sensors_init();// konfigurasi adc
    356a:	0e 94 4c 08 	call	0x1098	; 0x1098 <adc_sensors_init>
	gfx_mono_init(); //konfigurasi awal LCD monochrom
    356e:	0e 94 11 0b 	call	0x1622	; 0x1622 <gfx_mono_st7565r_init>
	tb_init(); //konfigurasi touch button
    3572:	0e 94 93 0b 	call	0x1726	; 0x1726 <tb_init>
	cpu_irq_enable(); // konfigurasi untuk menghidupkan interrupt
    3576:	78 94       	sei
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    3578:	87 e0       	ldi	r24, 0x07	; 7
    357a:	80 93 a2 00 	sts	0x00A2, r24
	pmic_init(); //konfigurasi untuk menyalakan semua interrupt dan mengatur prioritas task
	//pwm_init();
	adc_init();
    357e:	55 de       	rcall	.-854    	; 0x322a <adc_init>
    3580:	80 e1       	ldi	r24, 0x10	; 16
    3582:	80 93 85 06 	sts	0x0685, r24
	
	gpio_set_pin_high(NHD_C12832A1Z_BACKLIGHT);
	
	PORTC_OUTSET = PIN3_bm;
    3586:	88 e0       	ldi	r24, 0x08	; 8
    3588:	80 93 45 06 	sts	0x0645, r24
	PORTC_DIRSET = PIN3_bm;
    358c:	80 93 41 06 	sts	0x0641, r24
	
	PORTC_OUTCLR = PIN2_bm;
    3590:	84 e0       	ldi	r24, 0x04	; 4
    3592:	80 93 46 06 	sts	0x0646, r24
	PORTC_DIRCLR = PIN2_bm;
    3596:	80 93 42 06 	sts	0x0642, r24
	
	setUpSerial();
    359a:	29 de       	rcall	.-942    	; 0x31ee <setUpSerial>
		 vTaskDelay(10);
	 }
}

void setMaxWater(int max) {
	maxWater = max;
    359c:	88 ec       	ldi	r24, 0xC8	; 200
    359e:	90 e0       	ldi	r25, 0x00	; 0
    35a0:	80 93 d8 23 	sts	0x23D8, r24
    35a4:	90 93 d9 23 	sts	0x23D9, r25
	//xTaskCreate(countWaterUsage, "", 400, NULL, 1, NULL);
	//xTaskCreate(waterAlertTask, "", 400, NULL, 1, NULL);
	//xTaskCreate(checkWater, "", 200, NULL, 1, NULL);
	//xTaskCreate(vLCD, "", 600, NULL, 1, NULL);
	//xTaskCreate(checkTap, "", 200, NULL, 1, NULL);
	xTaskCreate(vReceiver, "", 200, NULL, 1, NULL);
    35a8:	a1 2c       	mov	r10, r1
    35aa:	b1 2c       	mov	r11, r1
    35ac:	c1 2c       	mov	r12, r1
    35ae:	d1 2c       	mov	r13, r1
    35b0:	e1 2c       	mov	r14, r1
    35b2:	f1 2c       	mov	r15, r1
    35b4:	01 e0       	ldi	r16, 0x01	; 1
    35b6:	20 e0       	ldi	r18, 0x00	; 0
    35b8:	30 e0       	ldi	r19, 0x00	; 0
    35ba:	48 ec       	ldi	r20, 0xC8	; 200
    35bc:	50 e0       	ldi	r21, 0x00	; 0
    35be:	69 e2       	ldi	r22, 0x29	; 41
    35c0:	70 e2       	ldi	r23, 0x20	; 32
    35c2:	8e e7       	ldi	r24, 0x7E	; 126
    35c4:	99 e1       	ldi	r25, 0x19	; 25
    35c6:	73 da       	rcall	.-2842   	; 0x2aae <xTaskGenericCreate>
	
	
	vTaskStartScheduler();
    35c8:	73 db       	rcall	.-2330   	; 0x2cb0 <vTaskStartScheduler>
    35ca:	80 e0       	ldi	r24, 0x00	; 0
    35cc:	90 e0       	ldi	r25, 0x00	; 0
    35ce:	0f 91       	pop	r16
    35d0:	ff 90       	pop	r15
    35d2:	ef 90       	pop	r14
    35d4:	df 90       	pop	r13
    35d6:	cf 90       	pop	r12
    35d8:	bf 90       	pop	r11
    35da:	af 90       	pop	r10
    35dc:	08 95       	ret

000035de <__udivmodsi4>:
    35de:	a1 e2       	ldi	r26, 0x21	; 33
    35e0:	1a 2e       	mov	r1, r26
    35e2:	aa 1b       	sub	r26, r26
    35e4:	bb 1b       	sub	r27, r27
    35e6:	fd 01       	movw	r30, r26
    35e8:	0d c0       	rjmp	.+26     	; 0x3604 <__udivmodsi4_ep>

000035ea <__udivmodsi4_loop>:
    35ea:	aa 1f       	adc	r26, r26
    35ec:	bb 1f       	adc	r27, r27
    35ee:	ee 1f       	adc	r30, r30
    35f0:	ff 1f       	adc	r31, r31
    35f2:	a2 17       	cp	r26, r18
    35f4:	b3 07       	cpc	r27, r19
    35f6:	e4 07       	cpc	r30, r20
    35f8:	f5 07       	cpc	r31, r21
    35fa:	20 f0       	brcs	.+8      	; 0x3604 <__udivmodsi4_ep>
    35fc:	a2 1b       	sub	r26, r18
    35fe:	b3 0b       	sbc	r27, r19
    3600:	e4 0b       	sbc	r30, r20
    3602:	f5 0b       	sbc	r31, r21

00003604 <__udivmodsi4_ep>:
    3604:	66 1f       	adc	r22, r22
    3606:	77 1f       	adc	r23, r23
    3608:	88 1f       	adc	r24, r24
    360a:	99 1f       	adc	r25, r25
    360c:	1a 94       	dec	r1
    360e:	69 f7       	brne	.-38     	; 0x35ea <__udivmodsi4_loop>
    3610:	60 95       	com	r22
    3612:	70 95       	com	r23
    3614:	80 95       	com	r24
    3616:	90 95       	com	r25
    3618:	9b 01       	movw	r18, r22
    361a:	ac 01       	movw	r20, r24
    361c:	bd 01       	movw	r22, r26
    361e:	cf 01       	movw	r24, r30
    3620:	08 95       	ret

00003622 <__prologue_saves__>:
    3622:	2f 92       	push	r2
    3624:	3f 92       	push	r3
    3626:	4f 92       	push	r4
    3628:	5f 92       	push	r5
    362a:	6f 92       	push	r6
    362c:	7f 92       	push	r7
    362e:	8f 92       	push	r8
    3630:	9f 92       	push	r9
    3632:	af 92       	push	r10
    3634:	bf 92       	push	r11
    3636:	cf 92       	push	r12
    3638:	df 92       	push	r13
    363a:	ef 92       	push	r14
    363c:	ff 92       	push	r15
    363e:	0f 93       	push	r16
    3640:	1f 93       	push	r17
    3642:	cf 93       	push	r28
    3644:	df 93       	push	r29
    3646:	cd b7       	in	r28, 0x3d	; 61
    3648:	de b7       	in	r29, 0x3e	; 62
    364a:	ca 1b       	sub	r28, r26
    364c:	db 0b       	sbc	r29, r27
    364e:	cd bf       	out	0x3d, r28	; 61
    3650:	de bf       	out	0x3e, r29	; 62
    3652:	19 94       	eijmp

00003654 <__epilogue_restores__>:
    3654:	2a 88       	ldd	r2, Y+18	; 0x12
    3656:	39 88       	ldd	r3, Y+17	; 0x11
    3658:	48 88       	ldd	r4, Y+16	; 0x10
    365a:	5f 84       	ldd	r5, Y+15	; 0x0f
    365c:	6e 84       	ldd	r6, Y+14	; 0x0e
    365e:	7d 84       	ldd	r7, Y+13	; 0x0d
    3660:	8c 84       	ldd	r8, Y+12	; 0x0c
    3662:	9b 84       	ldd	r9, Y+11	; 0x0b
    3664:	aa 84       	ldd	r10, Y+10	; 0x0a
    3666:	b9 84       	ldd	r11, Y+9	; 0x09
    3668:	c8 84       	ldd	r12, Y+8	; 0x08
    366a:	df 80       	ldd	r13, Y+7	; 0x07
    366c:	ee 80       	ldd	r14, Y+6	; 0x06
    366e:	fd 80       	ldd	r15, Y+5	; 0x05
    3670:	0c 81       	ldd	r16, Y+4	; 0x04
    3672:	1b 81       	ldd	r17, Y+3	; 0x03
    3674:	aa 81       	ldd	r26, Y+2	; 0x02
    3676:	b9 81       	ldd	r27, Y+1	; 0x01
    3678:	ce 0f       	add	r28, r30
    367a:	d1 1d       	adc	r29, r1
    367c:	cd bf       	out	0x3d, r28	; 61
    367e:	de bf       	out	0x3e, r29	; 62
    3680:	ed 01       	movw	r28, r26
    3682:	08 95       	ret

00003684 <malloc>:
    3684:	cf 93       	push	r28
    3686:	df 93       	push	r29
    3688:	82 30       	cpi	r24, 0x02	; 2
    368a:	91 05       	cpc	r25, r1
    368c:	10 f4       	brcc	.+4      	; 0x3692 <malloc+0xe>
    368e:	82 e0       	ldi	r24, 0x02	; 2
    3690:	90 e0       	ldi	r25, 0x00	; 0
    3692:	e0 91 f0 23 	lds	r30, 0x23F0
    3696:	f0 91 f1 23 	lds	r31, 0x23F1
    369a:	20 e0       	ldi	r18, 0x00	; 0
    369c:	30 e0       	ldi	r19, 0x00	; 0
    369e:	c0 e0       	ldi	r28, 0x00	; 0
    36a0:	d0 e0       	ldi	r29, 0x00	; 0
    36a2:	30 97       	sbiw	r30, 0x00	; 0
    36a4:	11 f1       	breq	.+68     	; 0x36ea <malloc+0x66>
    36a6:	40 81       	ld	r20, Z
    36a8:	51 81       	ldd	r21, Z+1	; 0x01
    36aa:	48 17       	cp	r20, r24
    36ac:	59 07       	cpc	r21, r25
    36ae:	c0 f0       	brcs	.+48     	; 0x36e0 <malloc+0x5c>
    36b0:	48 17       	cp	r20, r24
    36b2:	59 07       	cpc	r21, r25
    36b4:	61 f4       	brne	.+24     	; 0x36ce <malloc+0x4a>
    36b6:	82 81       	ldd	r24, Z+2	; 0x02
    36b8:	93 81       	ldd	r25, Z+3	; 0x03
    36ba:	20 97       	sbiw	r28, 0x00	; 0
    36bc:	19 f0       	breq	.+6      	; 0x36c4 <malloc+0x40>
    36be:	8a 83       	std	Y+2, r24	; 0x02
    36c0:	9b 83       	std	Y+3, r25	; 0x03
    36c2:	2b c0       	rjmp	.+86     	; 0x371a <malloc+0x96>
    36c4:	80 93 f0 23 	sts	0x23F0, r24
    36c8:	90 93 f1 23 	sts	0x23F1, r25
    36cc:	26 c0       	rjmp	.+76     	; 0x371a <malloc+0x96>
    36ce:	21 15       	cp	r18, r1
    36d0:	31 05       	cpc	r19, r1
    36d2:	19 f0       	breq	.+6      	; 0x36da <malloc+0x56>
    36d4:	42 17       	cp	r20, r18
    36d6:	53 07       	cpc	r21, r19
    36d8:	18 f4       	brcc	.+6      	; 0x36e0 <malloc+0x5c>
    36da:	9a 01       	movw	r18, r20
    36dc:	be 01       	movw	r22, r28
    36de:	df 01       	movw	r26, r30
    36e0:	ef 01       	movw	r28, r30
    36e2:	02 80       	ldd	r0, Z+2	; 0x02
    36e4:	f3 81       	ldd	r31, Z+3	; 0x03
    36e6:	e0 2d       	mov	r30, r0
    36e8:	dc cf       	rjmp	.-72     	; 0x36a2 <malloc+0x1e>
    36ea:	21 15       	cp	r18, r1
    36ec:	31 05       	cpc	r19, r1
    36ee:	09 f1       	breq	.+66     	; 0x3732 <malloc+0xae>
    36f0:	28 1b       	sub	r18, r24
    36f2:	39 0b       	sbc	r19, r25
    36f4:	24 30       	cpi	r18, 0x04	; 4
    36f6:	31 05       	cpc	r19, r1
    36f8:	90 f4       	brcc	.+36     	; 0x371e <malloc+0x9a>
    36fa:	12 96       	adiw	r26, 0x02	; 2
    36fc:	8d 91       	ld	r24, X+
    36fe:	9c 91       	ld	r25, X
    3700:	13 97       	sbiw	r26, 0x03	; 3
    3702:	61 15       	cp	r22, r1
    3704:	71 05       	cpc	r23, r1
    3706:	21 f0       	breq	.+8      	; 0x3710 <malloc+0x8c>
    3708:	fb 01       	movw	r30, r22
    370a:	82 83       	std	Z+2, r24	; 0x02
    370c:	93 83       	std	Z+3, r25	; 0x03
    370e:	04 c0       	rjmp	.+8      	; 0x3718 <malloc+0x94>
    3710:	80 93 f0 23 	sts	0x23F0, r24
    3714:	90 93 f1 23 	sts	0x23F1, r25
    3718:	fd 01       	movw	r30, r26
    371a:	32 96       	adiw	r30, 0x02	; 2
    371c:	44 c0       	rjmp	.+136    	; 0x37a6 <malloc+0x122>
    371e:	fd 01       	movw	r30, r26
    3720:	e2 0f       	add	r30, r18
    3722:	f3 1f       	adc	r31, r19
    3724:	81 93       	st	Z+, r24
    3726:	91 93       	st	Z+, r25
    3728:	22 50       	subi	r18, 0x02	; 2
    372a:	31 09       	sbc	r19, r1
    372c:	2d 93       	st	X+, r18
    372e:	3c 93       	st	X, r19
    3730:	3a c0       	rjmp	.+116    	; 0x37a6 <malloc+0x122>
    3732:	20 91 ee 23 	lds	r18, 0x23EE
    3736:	30 91 ef 23 	lds	r19, 0x23EF
    373a:	23 2b       	or	r18, r19
    373c:	41 f4       	brne	.+16     	; 0x374e <malloc+0xca>
    373e:	20 91 03 20 	lds	r18, 0x2003
    3742:	30 91 04 20 	lds	r19, 0x2004
    3746:	20 93 ee 23 	sts	0x23EE, r18
    374a:	30 93 ef 23 	sts	0x23EF, r19
    374e:	20 91 01 20 	lds	r18, 0x2001
    3752:	30 91 02 20 	lds	r19, 0x2002
    3756:	21 15       	cp	r18, r1
    3758:	31 05       	cpc	r19, r1
    375a:	41 f4       	brne	.+16     	; 0x376c <malloc+0xe8>
    375c:	2d b7       	in	r18, 0x3d	; 61
    375e:	3e b7       	in	r19, 0x3e	; 62
    3760:	40 91 05 20 	lds	r20, 0x2005
    3764:	50 91 06 20 	lds	r21, 0x2006
    3768:	24 1b       	sub	r18, r20
    376a:	35 0b       	sbc	r19, r21
    376c:	e0 91 ee 23 	lds	r30, 0x23EE
    3770:	f0 91 ef 23 	lds	r31, 0x23EF
    3774:	e2 17       	cp	r30, r18
    3776:	f3 07       	cpc	r31, r19
    3778:	a0 f4       	brcc	.+40     	; 0x37a2 <malloc+0x11e>
    377a:	2e 1b       	sub	r18, r30
    377c:	3f 0b       	sbc	r19, r31
    377e:	28 17       	cp	r18, r24
    3780:	39 07       	cpc	r19, r25
    3782:	78 f0       	brcs	.+30     	; 0x37a2 <malloc+0x11e>
    3784:	ac 01       	movw	r20, r24
    3786:	4e 5f       	subi	r20, 0xFE	; 254
    3788:	5f 4f       	sbci	r21, 0xFF	; 255
    378a:	24 17       	cp	r18, r20
    378c:	35 07       	cpc	r19, r21
    378e:	48 f0       	brcs	.+18     	; 0x37a2 <malloc+0x11e>
    3790:	4e 0f       	add	r20, r30
    3792:	5f 1f       	adc	r21, r31
    3794:	40 93 ee 23 	sts	0x23EE, r20
    3798:	50 93 ef 23 	sts	0x23EF, r21
    379c:	81 93       	st	Z+, r24
    379e:	91 93       	st	Z+, r25
    37a0:	02 c0       	rjmp	.+4      	; 0x37a6 <malloc+0x122>
    37a2:	e0 e0       	ldi	r30, 0x00	; 0
    37a4:	f0 e0       	ldi	r31, 0x00	; 0
    37a6:	cf 01       	movw	r24, r30
    37a8:	df 91       	pop	r29
    37aa:	cf 91       	pop	r28
    37ac:	08 95       	ret

000037ae <free>:
    37ae:	0f 93       	push	r16
    37b0:	1f 93       	push	r17
    37b2:	cf 93       	push	r28
    37b4:	df 93       	push	r29
    37b6:	00 97       	sbiw	r24, 0x00	; 0
    37b8:	09 f4       	brne	.+2      	; 0x37bc <free+0xe>
    37ba:	8c c0       	rjmp	.+280    	; 0x38d4 <free+0x126>
    37bc:	fc 01       	movw	r30, r24
    37be:	32 97       	sbiw	r30, 0x02	; 2
    37c0:	12 82       	std	Z+2, r1	; 0x02
    37c2:	13 82       	std	Z+3, r1	; 0x03
    37c4:	00 91 f0 23 	lds	r16, 0x23F0
    37c8:	10 91 f1 23 	lds	r17, 0x23F1
    37cc:	01 15       	cp	r16, r1
    37ce:	11 05       	cpc	r17, r1
    37d0:	81 f4       	brne	.+32     	; 0x37f2 <free+0x44>
    37d2:	20 81       	ld	r18, Z
    37d4:	31 81       	ldd	r19, Z+1	; 0x01
    37d6:	82 0f       	add	r24, r18
    37d8:	93 1f       	adc	r25, r19
    37da:	20 91 ee 23 	lds	r18, 0x23EE
    37de:	30 91 ef 23 	lds	r19, 0x23EF
    37e2:	28 17       	cp	r18, r24
    37e4:	39 07       	cpc	r19, r25
    37e6:	79 f5       	brne	.+94     	; 0x3846 <free+0x98>
    37e8:	e0 93 ee 23 	sts	0x23EE, r30
    37ec:	f0 93 ef 23 	sts	0x23EF, r31
    37f0:	71 c0       	rjmp	.+226    	; 0x38d4 <free+0x126>
    37f2:	d8 01       	movw	r26, r16
    37f4:	40 e0       	ldi	r20, 0x00	; 0
    37f6:	50 e0       	ldi	r21, 0x00	; 0
    37f8:	ae 17       	cp	r26, r30
    37fa:	bf 07       	cpc	r27, r31
    37fc:	50 f4       	brcc	.+20     	; 0x3812 <free+0x64>
    37fe:	12 96       	adiw	r26, 0x02	; 2
    3800:	2d 91       	ld	r18, X+
    3802:	3c 91       	ld	r19, X
    3804:	13 97       	sbiw	r26, 0x03	; 3
    3806:	ad 01       	movw	r20, r26
    3808:	21 15       	cp	r18, r1
    380a:	31 05       	cpc	r19, r1
    380c:	09 f1       	breq	.+66     	; 0x3850 <free+0xa2>
    380e:	d9 01       	movw	r26, r18
    3810:	f3 cf       	rjmp	.-26     	; 0x37f8 <free+0x4a>
    3812:	9d 01       	movw	r18, r26
    3814:	da 01       	movw	r26, r20
    3816:	22 83       	std	Z+2, r18	; 0x02
    3818:	33 83       	std	Z+3, r19	; 0x03
    381a:	60 81       	ld	r22, Z
    381c:	71 81       	ldd	r23, Z+1	; 0x01
    381e:	86 0f       	add	r24, r22
    3820:	97 1f       	adc	r25, r23
    3822:	82 17       	cp	r24, r18
    3824:	93 07       	cpc	r25, r19
    3826:	69 f4       	brne	.+26     	; 0x3842 <free+0x94>
    3828:	ec 01       	movw	r28, r24
    382a:	28 81       	ld	r18, Y
    382c:	39 81       	ldd	r19, Y+1	; 0x01
    382e:	26 0f       	add	r18, r22
    3830:	37 1f       	adc	r19, r23
    3832:	2e 5f       	subi	r18, 0xFE	; 254
    3834:	3f 4f       	sbci	r19, 0xFF	; 255
    3836:	20 83       	st	Z, r18
    3838:	31 83       	std	Z+1, r19	; 0x01
    383a:	8a 81       	ldd	r24, Y+2	; 0x02
    383c:	9b 81       	ldd	r25, Y+3	; 0x03
    383e:	82 83       	std	Z+2, r24	; 0x02
    3840:	93 83       	std	Z+3, r25	; 0x03
    3842:	45 2b       	or	r20, r21
    3844:	29 f4       	brne	.+10     	; 0x3850 <free+0xa2>
    3846:	e0 93 f0 23 	sts	0x23F0, r30
    384a:	f0 93 f1 23 	sts	0x23F1, r31
    384e:	42 c0       	rjmp	.+132    	; 0x38d4 <free+0x126>
    3850:	12 96       	adiw	r26, 0x02	; 2
    3852:	ed 93       	st	X+, r30
    3854:	fc 93       	st	X, r31
    3856:	13 97       	sbiw	r26, 0x03	; 3
    3858:	ed 01       	movw	r28, r26
    385a:	49 91       	ld	r20, Y+
    385c:	59 91       	ld	r21, Y+
    385e:	9e 01       	movw	r18, r28
    3860:	24 0f       	add	r18, r20
    3862:	35 1f       	adc	r19, r21
    3864:	e2 17       	cp	r30, r18
    3866:	f3 07       	cpc	r31, r19
    3868:	71 f4       	brne	.+28     	; 0x3886 <free+0xd8>
    386a:	80 81       	ld	r24, Z
    386c:	91 81       	ldd	r25, Z+1	; 0x01
    386e:	84 0f       	add	r24, r20
    3870:	95 1f       	adc	r25, r21
    3872:	02 96       	adiw	r24, 0x02	; 2
    3874:	8d 93       	st	X+, r24
    3876:	9c 93       	st	X, r25
    3878:	11 97       	sbiw	r26, 0x01	; 1
    387a:	82 81       	ldd	r24, Z+2	; 0x02
    387c:	93 81       	ldd	r25, Z+3	; 0x03
    387e:	12 96       	adiw	r26, 0x02	; 2
    3880:	8d 93       	st	X+, r24
    3882:	9c 93       	st	X, r25
    3884:	13 97       	sbiw	r26, 0x03	; 3
    3886:	e0 e0       	ldi	r30, 0x00	; 0
    3888:	f0 e0       	ldi	r31, 0x00	; 0
    388a:	d8 01       	movw	r26, r16
    388c:	12 96       	adiw	r26, 0x02	; 2
    388e:	8d 91       	ld	r24, X+
    3890:	9c 91       	ld	r25, X
    3892:	13 97       	sbiw	r26, 0x03	; 3
    3894:	00 97       	sbiw	r24, 0x00	; 0
    3896:	19 f0       	breq	.+6      	; 0x389e <free+0xf0>
    3898:	f8 01       	movw	r30, r16
    389a:	8c 01       	movw	r16, r24
    389c:	f6 cf       	rjmp	.-20     	; 0x388a <free+0xdc>
    389e:	8d 91       	ld	r24, X+
    38a0:	9c 91       	ld	r25, X
    38a2:	98 01       	movw	r18, r16
    38a4:	2e 5f       	subi	r18, 0xFE	; 254
    38a6:	3f 4f       	sbci	r19, 0xFF	; 255
    38a8:	82 0f       	add	r24, r18
    38aa:	93 1f       	adc	r25, r19
    38ac:	20 91 ee 23 	lds	r18, 0x23EE
    38b0:	30 91 ef 23 	lds	r19, 0x23EF
    38b4:	28 17       	cp	r18, r24
    38b6:	39 07       	cpc	r19, r25
    38b8:	69 f4       	brne	.+26     	; 0x38d4 <free+0x126>
    38ba:	30 97       	sbiw	r30, 0x00	; 0
    38bc:	29 f4       	brne	.+10     	; 0x38c8 <free+0x11a>
    38be:	10 92 f0 23 	sts	0x23F0, r1
    38c2:	10 92 f1 23 	sts	0x23F1, r1
    38c6:	02 c0       	rjmp	.+4      	; 0x38cc <free+0x11e>
    38c8:	12 82       	std	Z+2, r1	; 0x02
    38ca:	13 82       	std	Z+3, r1	; 0x03
    38cc:	00 93 ee 23 	sts	0x23EE, r16
    38d0:	10 93 ef 23 	sts	0x23EF, r17
    38d4:	df 91       	pop	r29
    38d6:	cf 91       	pop	r28
    38d8:	1f 91       	pop	r17
    38da:	0f 91       	pop	r16
    38dc:	08 95       	ret

000038de <_exit>:
    38de:	f8 94       	cli

000038e0 <__stop_program>:
    38e0:	ff cf       	rjmp	.-2      	; 0x38e0 <__stop_program>
