
TestPratikum2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003fcc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000182  00802000  00003fcc  00004060  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e0  00802182  00802182  000041e2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000041e2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00004214  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007a8  00000000  00000000  00004258  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001397a  00000000  00000000  00004a00  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000376a  00000000  00000000  0001837a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000cc45  00000000  00000000  0001bae4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000017fc  00000000  00000000  0002872c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00034554  00000000  00000000  00029f28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008cd3  00000000  00000000  0005e47c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008e8  00000000  00000000  00067150  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000d4c7  00000000  00000000  00067a38  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	46 c2       	rjmp	.+1164   	; 0x48e <__ctors_end>
       2:	00 00       	nop
       4:	65 c2       	rjmp	.+1226   	; 0x4d0 <__bad_interrupt>
       6:	00 00       	nop
       8:	63 c2       	rjmp	.+1222   	; 0x4d0 <__bad_interrupt>
       a:	00 00       	nop
       c:	61 c2       	rjmp	.+1218   	; 0x4d0 <__bad_interrupt>
       e:	00 00       	nop
      10:	5f c2       	rjmp	.+1214   	; 0x4d0 <__bad_interrupt>
      12:	00 00       	nop
      14:	5d c2       	rjmp	.+1210   	; 0x4d0 <__bad_interrupt>
      16:	00 00       	nop
      18:	5b c2       	rjmp	.+1206   	; 0x4d0 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	59 c2       	rjmp	.+1202   	; 0x4d0 <__bad_interrupt>
      1e:	00 00       	nop
      20:	57 c2       	rjmp	.+1198   	; 0x4d0 <__bad_interrupt>
      22:	00 00       	nop
      24:	55 c2       	rjmp	.+1194   	; 0x4d0 <__bad_interrupt>
      26:	00 00       	nop
      28:	53 c2       	rjmp	.+1190   	; 0x4d0 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	51 c2       	rjmp	.+1186   	; 0x4d0 <__bad_interrupt>
      2e:	00 00       	nop
      30:	4f c2       	rjmp	.+1182   	; 0x4d0 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 4d 0f 	jmp	0x1e9a	; 0x1e9a <__vector_13>
      38:	0c 94 ba 14 	jmp	0x2974	; 0x2974 <__vector_14>
      3c:	49 c2       	rjmp	.+1170   	; 0x4d0 <__bad_interrupt>
      3e:	00 00       	nop
      40:	47 c2       	rjmp	.+1166   	; 0x4d0 <__bad_interrupt>
      42:	00 00       	nop
      44:	45 c2       	rjmp	.+1162   	; 0x4d0 <__bad_interrupt>
      46:	00 00       	nop
      48:	43 c2       	rjmp	.+1158   	; 0x4d0 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	41 c2       	rjmp	.+1154   	; 0x4d0 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3f c2       	rjmp	.+1150   	; 0x4d0 <__bad_interrupt>
      52:	00 00       	nop
      54:	3d c2       	rjmp	.+1146   	; 0x4d0 <__bad_interrupt>
      56:	00 00       	nop
      58:	3b c2       	rjmp	.+1142   	; 0x4d0 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	39 c2       	rjmp	.+1138   	; 0x4d0 <__bad_interrupt>
      5e:	00 00       	nop
      60:	37 c2       	rjmp	.+1134   	; 0x4d0 <__bad_interrupt>
      62:	00 00       	nop
      64:	35 c2       	rjmp	.+1130   	; 0x4d0 <__bad_interrupt>
      66:	00 00       	nop
      68:	33 c2       	rjmp	.+1126   	; 0x4d0 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	31 c2       	rjmp	.+1122   	; 0x4d0 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2f c2       	rjmp	.+1118   	; 0x4d0 <__bad_interrupt>
      72:	00 00       	nop
      74:	2d c2       	rjmp	.+1114   	; 0x4d0 <__bad_interrupt>
      76:	00 00       	nop
      78:	2b c2       	rjmp	.+1110   	; 0x4d0 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	29 c2       	rjmp	.+1106   	; 0x4d0 <__bad_interrupt>
      7e:	00 00       	nop
      80:	27 c2       	rjmp	.+1102   	; 0x4d0 <__bad_interrupt>
      82:	00 00       	nop
      84:	25 c2       	rjmp	.+1098   	; 0x4d0 <__bad_interrupt>
      86:	00 00       	nop
      88:	23 c2       	rjmp	.+1094   	; 0x4d0 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	21 c2       	rjmp	.+1090   	; 0x4d0 <__bad_interrupt>
      8e:	00 00       	nop
      90:	1f c2       	rjmp	.+1086   	; 0x4d0 <__bad_interrupt>
      92:	00 00       	nop
      94:	1d c2       	rjmp	.+1082   	; 0x4d0 <__bad_interrupt>
      96:	00 00       	nop
      98:	1b c2       	rjmp	.+1078   	; 0x4d0 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 05 0d 	jmp	0x1a0a	; 0x1a0a <__vector_39>
      a0:	0c 94 37 0d 	jmp	0x1a6e	; 0x1a6e <__vector_40>
      a4:	0c 94 69 0d 	jmp	0x1ad2	; 0x1ad2 <__vector_41>
      a8:	0c 94 9b 0d 	jmp	0x1b36	; 0x1b36 <__vector_42>
      ac:	11 c2       	rjmp	.+1058   	; 0x4d0 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	0f c2       	rjmp	.+1054   	; 0x4d0 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	0d c2       	rjmp	.+1050   	; 0x4d0 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	0c 94 74 0f 	jmp	0x1ee8	; 0x1ee8 <__vector_46>
      bc:	09 c2       	rjmp	.+1042   	; 0x4d0 <__bad_interrupt>
      be:	00 00       	nop
      c0:	07 c2       	rjmp	.+1038   	; 0x4d0 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	05 c2       	rjmp	.+1034   	; 0x4d0 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	03 c2       	rjmp	.+1030   	; 0x4d0 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	01 c2       	rjmp	.+1026   	; 0x4d0 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	ff c1       	rjmp	.+1022   	; 0x4d0 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	fd c1       	rjmp	.+1018   	; 0x4d0 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	fb c1       	rjmp	.+1014   	; 0x4d0 <__bad_interrupt>
      da:	00 00       	nop
      dc:	f9 c1       	rjmp	.+1010   	; 0x4d0 <__bad_interrupt>
      de:	00 00       	nop
      e0:	f7 c1       	rjmp	.+1006   	; 0x4d0 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	f5 c1       	rjmp	.+1002   	; 0x4d0 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	f3 c1       	rjmp	.+998    	; 0x4d0 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	f1 c1       	rjmp	.+994    	; 0x4d0 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	ef c1       	rjmp	.+990    	; 0x4d0 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	ed c1       	rjmp	.+986    	; 0x4d0 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	eb c1       	rjmp	.+982    	; 0x4d0 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	e9 c1       	rjmp	.+978    	; 0x4d0 <__bad_interrupt>
      fe:	00 00       	nop
     100:	e7 c1       	rjmp	.+974    	; 0x4d0 <__bad_interrupt>
     102:	00 00       	nop
     104:	e5 c1       	rjmp	.+970    	; 0x4d0 <__bad_interrupt>
     106:	00 00       	nop
     108:	e3 c1       	rjmp	.+966    	; 0x4d0 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	e1 c1       	rjmp	.+962    	; 0x4d0 <__bad_interrupt>
     10e:	00 00       	nop
     110:	df c1       	rjmp	.+958    	; 0x4d0 <__bad_interrupt>
     112:	00 00       	nop
     114:	dd c1       	rjmp	.+954    	; 0x4d0 <__bad_interrupt>
     116:	00 00       	nop
     118:	db c1       	rjmp	.+950    	; 0x4d0 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	0c 94 3d 0c 	jmp	0x187a	; 0x187a <__vector_71>
     120:	0c 94 6f 0c 	jmp	0x18de	; 0x18de <__vector_72>
     124:	0c 94 a1 0c 	jmp	0x1942	; 0x1942 <__vector_73>
     128:	0c 94 d3 0c 	jmp	0x19a6	; 0x19a6 <__vector_74>
     12c:	d1 c1       	rjmp	.+930    	; 0x4d0 <__bad_interrupt>
     12e:	00 00       	nop
     130:	cf c1       	rjmp	.+926    	; 0x4d0 <__bad_interrupt>
     132:	00 00       	nop
     134:	cd c1       	rjmp	.+922    	; 0x4d0 <__bad_interrupt>
     136:	00 00       	nop
     138:	cb c1       	rjmp	.+918    	; 0x4d0 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	c9 c1       	rjmp	.+914    	; 0x4d0 <__bad_interrupt>
     13e:	00 00       	nop
     140:	c7 c1       	rjmp	.+910    	; 0x4d0 <__bad_interrupt>
     142:	00 00       	nop
     144:	c5 c1       	rjmp	.+906    	; 0x4d0 <__bad_interrupt>
     146:	00 00       	nop
     148:	c3 c1       	rjmp	.+902    	; 0x4d0 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	c1 c1       	rjmp	.+898    	; 0x4d0 <__bad_interrupt>
     14e:	00 00       	nop
     150:	bf c1       	rjmp	.+894    	; 0x4d0 <__bad_interrupt>
     152:	00 00       	nop
     154:	bd c1       	rjmp	.+890    	; 0x4d0 <__bad_interrupt>
     156:	00 00       	nop
     158:	bb c1       	rjmp	.+886    	; 0x4d0 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	b9 c1       	rjmp	.+882    	; 0x4d0 <__bad_interrupt>
     15e:	00 00       	nop
     160:	b7 c1       	rjmp	.+878    	; 0x4d0 <__bad_interrupt>
     162:	00 00       	nop
     164:	b5 c1       	rjmp	.+874    	; 0x4d0 <__bad_interrupt>
     166:	00 00       	nop
     168:	b3 c1       	rjmp	.+870    	; 0x4d0 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	b1 c1       	rjmp	.+866    	; 0x4d0 <__bad_interrupt>
     16e:	00 00       	nop
     170:	af c1       	rjmp	.+862    	; 0x4d0 <__bad_interrupt>
     172:	00 00       	nop
     174:	ad c1       	rjmp	.+858    	; 0x4d0 <__bad_interrupt>
     176:	00 00       	nop
     178:	ab c1       	rjmp	.+854    	; 0x4d0 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	a9 c1       	rjmp	.+850    	; 0x4d0 <__bad_interrupt>
     17e:	00 00       	nop
     180:	a7 c1       	rjmp	.+846    	; 0x4d0 <__bad_interrupt>
     182:	00 00       	nop
     184:	a5 c1       	rjmp	.+842    	; 0x4d0 <__bad_interrupt>
     186:	00 00       	nop
     188:	a3 c1       	rjmp	.+838    	; 0x4d0 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	a1 c1       	rjmp	.+834    	; 0x4d0 <__bad_interrupt>
     18e:	00 00       	nop
     190:	9f c1       	rjmp	.+830    	; 0x4d0 <__bad_interrupt>
     192:	00 00       	nop
     194:	9d c1       	rjmp	.+826    	; 0x4d0 <__bad_interrupt>
     196:	00 00       	nop
     198:	9b c1       	rjmp	.+822    	; 0x4d0 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	99 c1       	rjmp	.+818    	; 0x4d0 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	97 c1       	rjmp	.+814    	; 0x4d0 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	95 c1       	rjmp	.+810    	; 0x4d0 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	93 c1       	rjmp	.+806    	; 0x4d0 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	91 c1       	rjmp	.+802    	; 0x4d0 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	8f c1       	rjmp	.+798    	; 0x4d0 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	8d c1       	rjmp	.+794    	; 0x4d0 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	8b c1       	rjmp	.+790    	; 0x4d0 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	89 c1       	rjmp	.+786    	; 0x4d0 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	87 c1       	rjmp	.+782    	; 0x4d0 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	85 c1       	rjmp	.+778    	; 0x4d0 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	83 c1       	rjmp	.+774    	; 0x4d0 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	81 c1       	rjmp	.+770    	; 0x4d0 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	7f c1       	rjmp	.+766    	; 0x4d0 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	7d c1       	rjmp	.+762    	; 0x4d0 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	7b c1       	rjmp	.+758    	; 0x4d0 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	79 c1       	rjmp	.+754    	; 0x4d0 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	77 c1       	rjmp	.+750    	; 0x4d0 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	75 c1       	rjmp	.+746    	; 0x4d0 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	73 c1       	rjmp	.+742    	; 0x4d0 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	71 c1       	rjmp	.+738    	; 0x4d0 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	6f c1       	rjmp	.+734    	; 0x4d0 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	6d c1       	rjmp	.+730    	; 0x4d0 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	6b c1       	rjmp	.+726    	; 0x4d0 <__bad_interrupt>
	...

000001fc <__trampolines_end>:
     1fc:	00 00       	nop
     1fe:	00 00       	nop
     200:	00 00       	nop
     202:	00 20       	and	r0, r0
     204:	20 20       	and	r2, r0
     206:	20 20       	and	r2, r0
     208:	00 20       	and	r0, r0
     20a:	50 50       	subi	r21, 0x00	; 0
     20c:	50 00       	.word	0x0050	; ????
     20e:	00 00       	nop
     210:	00 50       	subi	r16, 0x00	; 0
     212:	50 f8       	bld	r5, 0
     214:	50 f8       	bld	r5, 0
     216:	50 50       	subi	r21, 0x00	; 0
     218:	20 78       	andi	r18, 0x80	; 128
     21a:	a0 70       	andi	r26, 0x00	; 0
     21c:	28 f0       	brcs	.+10     	; 0x228 <__trampolines_end+0x2c>
     21e:	20 c0       	rjmp	.+64     	; 0x260 <__trampolines_end+0x64>
     220:	c8 10       	cpse	r12, r8
     222:	20 40       	sbci	r18, 0x00	; 0
     224:	98 18       	sub	r9, r8
     226:	60 90 a0 40 	lds	r6, 0x40A0
     22a:	a8 90       	.word	0x90a8	; ????
     22c:	68 60       	ori	r22, 0x08	; 8
     22e:	20 40       	sbci	r18, 0x00	; 0
     230:	00 00       	nop
     232:	00 00       	nop
     234:	10 20       	and	r1, r0
     236:	40 40       	sbci	r20, 0x00	; 0
     238:	40 20       	and	r4, r0
     23a:	10 40       	sbci	r17, 0x00	; 0
     23c:	20 10       	cpse	r2, r0
     23e:	10 10       	cpse	r1, r0
     240:	20 40       	sbci	r18, 0x00	; 0
     242:	00 50       	subi	r16, 0x00	; 0
     244:	20 f8       	bld	r2, 0
     246:	20 50       	subi	r18, 0x00	; 0
     248:	00 00       	nop
     24a:	20 20       	and	r2, r0
     24c:	f8 20       	and	r15, r8
     24e:	20 00       	.word	0x0020	; ????
     250:	00 00       	nop
     252:	00 00       	nop
     254:	60 20       	and	r6, r0
     256:	40 00       	.word	0x0040	; ????
     258:	00 00       	nop
     25a:	f8 00       	.word	0x00f8	; ????
     25c:	00 00       	nop
     25e:	00 00       	nop
     260:	00 00       	nop
     262:	00 60       	ori	r16, 0x00	; 0
     264:	60 00       	.word	0x0060	; ????
     266:	08 10       	cpse	r0, r8
     268:	20 40       	sbci	r18, 0x00	; 0
     26a:	80 00       	.word	0x0080	; ????
     26c:	70 88       	ldd	r7, Z+16	; 0x10
     26e:	98 a8       	ldd	r9, Y+48	; 0x30
     270:	c8 88       	ldd	r12, Y+16	; 0x10
     272:	70 20       	and	r7, r0
     274:	60 20       	and	r6, r0
     276:	20 20       	and	r2, r0
     278:	20 70       	andi	r18, 0x00	; 0
     27a:	70 88       	ldd	r7, Z+16	; 0x10
     27c:	08 10       	cpse	r0, r8
     27e:	20 40       	sbci	r18, 0x00	; 0
     280:	f8 f8       	.word	0xf8f8	; ????
     282:	10 20       	and	r1, r0
     284:	10 08       	sbc	r1, r0
     286:	88 70       	andi	r24, 0x08	; 8
     288:	10 30       	cpi	r17, 0x00	; 0
     28a:	50 90 f8 10 	lds	r5, 0x10F8
     28e:	10 f8       	bld	r1, 0
     290:	80 f0       	brcs	.+32     	; 0x2b2 <__trampolines_end+0xb6>
     292:	08 08       	sbc	r0, r8
     294:	88 70       	andi	r24, 0x08	; 8
     296:	30 40       	sbci	r19, 0x00	; 0
     298:	80 f0       	brcs	.+32     	; 0x2ba <__trampolines_end+0xbe>
     29a:	88 88       	ldd	r8, Y+16	; 0x10
     29c:	70 f8       	bld	r7, 0
     29e:	08 10       	cpse	r0, r8
     2a0:	20 40       	sbci	r18, 0x00	; 0
     2a2:	40 40       	sbci	r20, 0x00	; 0
     2a4:	70 88       	ldd	r7, Z+16	; 0x10
     2a6:	88 70       	andi	r24, 0x08	; 8
     2a8:	88 88       	ldd	r8, Y+16	; 0x10
     2aa:	70 70       	andi	r23, 0x00	; 0
     2ac:	88 88       	ldd	r8, Y+16	; 0x10
     2ae:	78 08       	sbc	r7, r8
     2b0:	10 60       	ori	r17, 0x00	; 0
     2b2:	00 60       	ori	r16, 0x00	; 0
     2b4:	60 00       	.word	0x0060	; ????
     2b6:	60 60       	ori	r22, 0x00	; 0
     2b8:	00 00       	nop
     2ba:	60 60       	ori	r22, 0x00	; 0
     2bc:	00 60       	ori	r16, 0x00	; 0
     2be:	20 40       	sbci	r18, 0x00	; 0
     2c0:	08 10       	cpse	r0, r8
     2c2:	20 40       	sbci	r18, 0x00	; 0
     2c4:	20 10       	cpse	r2, r0
     2c6:	08 00       	.word	0x0008	; ????
     2c8:	00 f8       	bld	r0, 0
     2ca:	00 f8       	bld	r0, 0
     2cc:	00 00       	nop
     2ce:	80 40       	sbci	r24, 0x00	; 0
     2d0:	20 10       	cpse	r2, r0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	80 70       	andi	r24, 0x00	; 0
     2d6:	88 08       	sbc	r8, r8
     2d8:	10 20       	and	r1, r0
     2da:	00 20       	and	r0, r0
     2dc:	70 88       	ldd	r7, Z+16	; 0x10
     2de:	08 68       	ori	r16, 0x88	; 136
     2e0:	a8 a8       	ldd	r10, Y+48	; 0x30
     2e2:	70 70       	andi	r23, 0x00	; 0
     2e4:	88 88       	ldd	r8, Y+16	; 0x10
     2e6:	88 f8       	.word	0xf888	; ????
     2e8:	88 88       	ldd	r8, Y+16	; 0x10
     2ea:	f0 88       	ldd	r15, Z+16	; 0x10
     2ec:	88 f0       	brcs	.+34     	; 0x310 <__trampolines_end+0x114>
     2ee:	88 88       	ldd	r8, Y+16	; 0x10
     2f0:	f0 70       	andi	r31, 0x00	; 0
     2f2:	88 80       	ld	r8, Y
     2f4:	80 80       	ld	r8, Z
     2f6:	88 70       	andi	r24, 0x08	; 8
     2f8:	e0 90 88 88 	lds	r14, 0x8888
     2fc:	88 90       	.word	0x9088	; ????
     2fe:	e0 f8       	bld	r14, 0
     300:	80 80       	ld	r8, Z
     302:	f0 80       	ld	r15, Z
     304:	80 f8       	bld	r8, 0
     306:	f8 80       	ld	r15, Y
     308:	80 e0       	ldi	r24, 0x00	; 0
     30a:	80 80       	ld	r8, Z
     30c:	80 70       	andi	r24, 0x00	; 0
     30e:	88 80       	ld	r8, Y
     310:	80 98       	cbi	0x10, 0	; 16
     312:	88 70       	andi	r24, 0x08	; 8
     314:	88 88       	ldd	r8, Y+16	; 0x10
     316:	88 f8       	.word	0xf888	; ????
     318:	88 88       	ldd	r8, Y+16	; 0x10
     31a:	88 70       	andi	r24, 0x08	; 8
     31c:	20 20       	and	r2, r0
     31e:	20 20       	and	r2, r0
     320:	20 70       	andi	r18, 0x00	; 0
     322:	38 10       	cpse	r3, r8
     324:	10 10       	cpse	r1, r0
     326:	10 90 60 88 	lds	r1, 0x8860
     32a:	90 a0       	ldd	r9, Z+32	; 0x20
     32c:	c0 a0       	ldd	r12, Z+32	; 0x20
     32e:	90 88       	ldd	r9, Z+16	; 0x10
     330:	80 80       	ld	r8, Z
     332:	80 80       	ld	r8, Z
     334:	80 80       	ld	r8, Z
     336:	f8 88       	ldd	r15, Y+16	; 0x10
     338:	d8 a8       	ldd	r13, Y+48	; 0x30
     33a:	88 88       	ldd	r8, Y+16	; 0x10
     33c:	88 88       	ldd	r8, Y+16	; 0x10
     33e:	88 88       	ldd	r8, Y+16	; 0x10
     340:	c8 a8       	ldd	r12, Y+48	; 0x30
     342:	98 88       	ldd	r9, Y+16	; 0x10
     344:	88 70       	andi	r24, 0x08	; 8
     346:	88 88       	ldd	r8, Y+16	; 0x10
     348:	88 88       	ldd	r8, Y+16	; 0x10
     34a:	88 70       	andi	r24, 0x08	; 8
     34c:	f0 88       	ldd	r15, Z+16	; 0x10
     34e:	88 f0       	brcs	.+34     	; 0x372 <__trampolines_end+0x176>
     350:	80 80       	ld	r8, Z
     352:	80 70       	andi	r24, 0x00	; 0
     354:	88 88       	ldd	r8, Y+16	; 0x10
     356:	88 a8       	ldd	r8, Y+48	; 0x30
     358:	90 68       	ori	r25, 0x80	; 128
     35a:	f0 88       	ldd	r15, Z+16	; 0x10
     35c:	88 f0       	brcs	.+34     	; 0x380 <__trampolines_end+0x184>
     35e:	a0 90 88 78 	lds	r10, 0x7888
     362:	80 80       	ld	r8, Z
     364:	70 08       	sbc	r7, r0
     366:	08 f0       	brcs	.+2      	; 0x36a <__trampolines_end+0x16e>
     368:	f8 20       	and	r15, r8
     36a:	20 20       	and	r2, r0
     36c:	20 20       	and	r2, r0
     36e:	20 88       	ldd	r2, Z+16	; 0x10
     370:	88 88       	ldd	r8, Y+16	; 0x10
     372:	88 88       	ldd	r8, Y+16	; 0x10
     374:	88 70       	andi	r24, 0x08	; 8
     376:	88 88       	ldd	r8, Y+16	; 0x10
     378:	88 88       	ldd	r8, Y+16	; 0x10
     37a:	88 50       	subi	r24, 0x08	; 8
     37c:	20 88       	ldd	r2, Z+16	; 0x10
     37e:	88 88       	ldd	r8, Y+16	; 0x10
     380:	a8 a8       	ldd	r10, Y+48	; 0x30
     382:	d8 88       	ldd	r13, Y+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	50 20       	and	r5, r0
     388:	50 88       	ldd	r5, Z+16	; 0x10
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 50       	subi	r24, 0x08	; 8
     38e:	20 20       	and	r2, r0
     390:	20 20       	and	r2, r0
     392:	f8 08       	sbc	r15, r8
     394:	10 20       	and	r1, r0
     396:	40 80       	ld	r4, Z
     398:	f8 38       	cpi	r31, 0x88	; 136
     39a:	20 20       	and	r2, r0
     39c:	20 20       	and	r2, r0
     39e:	20 38       	cpi	r18, 0x80	; 128
     3a0:	00 80       	ld	r0, Z
     3a2:	40 20       	and	r4, r0
     3a4:	10 08       	sbc	r1, r0
     3a6:	00 e0       	ldi	r16, 0x00	; 0
     3a8:	20 20       	and	r2, r0
     3aa:	20 20       	and	r2, r0
     3ac:	20 e0       	ldi	r18, 0x00	; 0
     3ae:	20 50       	subi	r18, 0x00	; 0
     3b0:	88 00       	.word	0x0088	; ????
	...
     3ba:	00 f8       	bld	r0, 0
     3bc:	40 20       	and	r4, r0
     3be:	10 00       	.word	0x0010	; ????
     3c0:	00 00       	nop
     3c2:	00 00       	nop
     3c4:	00 70       	andi	r16, 0x00	; 0
     3c6:	08 78       	andi	r16, 0x88	; 136
     3c8:	88 78       	andi	r24, 0x88	; 136
     3ca:	80 80       	ld	r8, Z
     3cc:	b0 c8       	rjmp	.-3744   	; 0xfffff52e <__eeprom_end+0xff7ef52e>
     3ce:	88 88       	ldd	r8, Y+16	; 0x10
     3d0:	f0 00       	.word	0x00f0	; ????
     3d2:	00 70       	andi	r16, 0x00	; 0
     3d4:	80 80       	ld	r8, Z
     3d6:	88 70       	andi	r24, 0x08	; 8
     3d8:	08 08       	sbc	r0, r8
     3da:	68 98       	cbi	0x0d, 0	; 13
     3dc:	88 88       	ldd	r8, Y+16	; 0x10
     3de:	78 00       	.word	0x0078	; ????
     3e0:	00 70       	andi	r16, 0x00	; 0
     3e2:	88 f8       	.word	0xf888	; ????
     3e4:	80 70       	andi	r24, 0x00	; 0
     3e6:	30 48       	sbci	r19, 0x80	; 128
     3e8:	40 e0       	ldi	r20, 0x00	; 0
     3ea:	40 40       	sbci	r20, 0x00	; 0
     3ec:	40 00       	.word	0x0040	; ????
     3ee:	00 78       	andi	r16, 0x80	; 128
     3f0:	88 78       	andi	r24, 0x88	; 136
     3f2:	08 30       	cpi	r16, 0x08	; 8
     3f4:	80 80       	ld	r8, Z
     3f6:	b0 c8       	rjmp	.-3744   	; 0xfffff558 <__eeprom_end+0xff7ef558>
     3f8:	88 88       	ldd	r8, Y+16	; 0x10
     3fa:	88 20       	and	r8, r8
     3fc:	00 60       	ori	r16, 0x00	; 0
     3fe:	20 20       	and	r2, r0
     400:	20 70       	andi	r18, 0x00	; 0
     402:	10 00       	.word	0x0010	; ????
     404:	30 10       	cpse	r3, r0
     406:	10 90 60 40 	lds	r1, 0x4060
     40a:	40 48       	sbci	r20, 0x80	; 128
     40c:	50 60       	ori	r21, 0x00	; 0
     40e:	50 48       	sbci	r21, 0x80	; 128
     410:	60 20       	and	r6, r0
     412:	20 20       	and	r2, r0
     414:	20 20       	and	r2, r0
     416:	70 00       	.word	0x0070	; ????
     418:	00 d0       	rcall	.+0      	; 0x41a <__trampolines_end+0x21e>
     41a:	a8 a8       	ldd	r10, Y+48	; 0x30
     41c:	88 88       	ldd	r8, Y+16	; 0x10
     41e:	00 00       	nop
     420:	b0 c8       	rjmp	.-3744   	; 0xfffff582 <__eeprom_end+0xff7ef582>
     422:	88 88       	ldd	r8, Y+16	; 0x10
     424:	88 00       	.word	0x0088	; ????
     426:	00 70       	andi	r16, 0x00	; 0
     428:	88 88       	ldd	r8, Y+16	; 0x10
     42a:	88 70       	andi	r24, 0x08	; 8
     42c:	00 00       	nop
     42e:	f0 88       	ldd	r15, Z+16	; 0x10
     430:	f0 80       	ld	r15, Z
     432:	80 00       	.word	0x0080	; ????
     434:	00 68       	ori	r16, 0x80	; 128
     436:	98 78       	andi	r25, 0x88	; 136
     438:	08 08       	sbc	r0, r8
     43a:	00 00       	nop
     43c:	b0 c8       	rjmp	.-3744   	; 0xfffff59e <__eeprom_end+0xff7ef59e>
     43e:	80 80       	ld	r8, Z
     440:	80 00       	.word	0x0080	; ????
     442:	00 70       	andi	r16, 0x00	; 0
     444:	80 70       	andi	r24, 0x00	; 0
     446:	08 f0       	brcs	.+2      	; 0x44a <__trampolines_end+0x24e>
     448:	40 40       	sbci	r20, 0x00	; 0
     44a:	e0 40       	sbci	r30, 0x00	; 0
     44c:	40 48       	sbci	r20, 0x80	; 128
     44e:	30 00       	.word	0x0030	; ????
     450:	00 88       	ldd	r0, Z+16	; 0x10
     452:	88 88       	ldd	r8, Y+16	; 0x10
     454:	98 68       	ori	r25, 0x88	; 136
     456:	00 00       	nop
     458:	88 88       	ldd	r8, Y+16	; 0x10
     45a:	88 50       	subi	r24, 0x08	; 8
     45c:	20 00       	.word	0x0020	; ????
     45e:	00 88       	ldd	r0, Z+16	; 0x10
     460:	88 a8       	ldd	r8, Y+48	; 0x30
     462:	a8 50       	subi	r26, 0x08	; 8
     464:	00 00       	nop
     466:	88 50       	subi	r24, 0x08	; 8
     468:	20 50       	subi	r18, 0x00	; 0
     46a:	88 00       	.word	0x0088	; ????
     46c:	00 88       	ldd	r0, Z+16	; 0x10
     46e:	88 78       	andi	r24, 0x88	; 136
     470:	08 70       	andi	r16, 0x08	; 8
     472:	00 00       	nop
     474:	f8 10       	cpse	r15, r8
     476:	20 40       	sbci	r18, 0x00	; 0
     478:	f8 10       	cpse	r15, r8
     47a:	20 20       	and	r2, r0
     47c:	40 20       	and	r4, r0
     47e:	20 10       	cpse	r2, r0
     480:	20 20       	and	r2, r0
     482:	20 20       	and	r2, r0
     484:	20 20       	and	r2, r0
     486:	20 40       	sbci	r18, 0x00	; 0
     488:	20 20       	and	r2, r0
     48a:	10 20       	and	r1, r0
     48c:	20 40       	sbci	r18, 0x00	; 0

0000048e <__ctors_end>:
     48e:	11 24       	eor	r1, r1
     490:	1f be       	out	0x3f, r1	; 63
     492:	cf ef       	ldi	r28, 0xFF	; 255
     494:	cd bf       	out	0x3d, r28	; 61
     496:	df e5       	ldi	r29, 0x5F	; 95
     498:	de bf       	out	0x3e, r29	; 62
     49a:	00 e0       	ldi	r16, 0x00	; 0
     49c:	0c bf       	out	0x3c, r16	; 60

0000049e <__do_copy_data>:
     49e:	11 e2       	ldi	r17, 0x21	; 33
     4a0:	a0 e0       	ldi	r26, 0x00	; 0
     4a2:	b0 e2       	ldi	r27, 0x20	; 32
     4a4:	ec ec       	ldi	r30, 0xCC	; 204
     4a6:	ff e3       	ldi	r31, 0x3F	; 63
     4a8:	00 e0       	ldi	r16, 0x00	; 0
     4aa:	0b bf       	out	0x3b, r16	; 59
     4ac:	02 c0       	rjmp	.+4      	; 0x4b2 <__do_copy_data+0x14>
     4ae:	07 90       	elpm	r0, Z+
     4b0:	0d 92       	st	X+, r0
     4b2:	a2 38       	cpi	r26, 0x82	; 130
     4b4:	b1 07       	cpc	r27, r17
     4b6:	d9 f7       	brne	.-10     	; 0x4ae <__do_copy_data+0x10>

000004b8 <__do_clear_bss>:
     4b8:	24 e2       	ldi	r18, 0x24	; 36
     4ba:	a2 e8       	ldi	r26, 0x82	; 130
     4bc:	b1 e2       	ldi	r27, 0x21	; 33
     4be:	01 c0       	rjmp	.+2      	; 0x4c2 <.do_clear_bss_start>

000004c0 <.do_clear_bss_loop>:
     4c0:	1d 92       	st	X+, r1

000004c2 <.do_clear_bss_start>:
     4c2:	a2 36       	cpi	r26, 0x62	; 98
     4c4:	b2 07       	cpc	r27, r18
     4c6:	e1 f7       	brne	.-8      	; 0x4c0 <.do_clear_bss_loop>
     4c8:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <main>
     4cc:	0c 94 e4 1f 	jmp	0x3fc8	; 0x3fc8 <_exit>

000004d0 <__bad_interrupt>:
     4d0:	97 cd       	rjmp	.-1234   	; 0x0 <__vectors>

000004d2 <_1101010101_>:

#if ((_STATIC_PORT_PIN_CONF_ == 1) && (QTOUCH_SNS_PORT_COUNT >= 1))

GLOBAL_FUNCTION _1101010101_
_1101010101_:
    sts	CONCAT( PORT, SNS1, _DIRCLR ), p_1
     4d2:	80 93 a2 06 	sts	0x06A2, r24
    sts	CONCAT( PORT, SNSK1, _DIRCLR ), p_2
     4d6:	60 93 a2 06 	sts	0x06A2, r22
    sts	CONCAT( PORT, SNS1, _OUTSET), p_1
     4da:	80 93 a5 06 	sts	0x06A5, r24
    sts	CONCAT( PORT, SNSK1, _OUTCLR), p_2    
     4de:	60 93 a6 06 	sts	0x06A6, r22
    sts	CONCAT( PORT, SNSK1, _DIRSET), p_2   
     4e2:	60 93 a1 06 	sts	0x06A1, r22
    ret
     4e6:	08 95       	ret

000004e8 <_1101010111_>:


GLOBAL_FUNCTION _1101010111_
_1101010111_:
    push r19
     4e8:	3f 93       	push	r19
    sts	CONCAT( PORT, SNSK1, _DIRCLR), p_2
     4ea:	60 93 a2 06 	sts	0x06A2, r22
    sts	CONCAT( PORT, SNS1, _DIRSET), p_1
     4ee:	80 93 a1 06 	sts	0x06A1, r24
    _10100011_
    _01101001_
    _00011001_
    _00011001_
#endif
    sts	CONCAT( PORT, SNS1, _DIRCLR ), p_1
     4f2:	80 93 a2 06 	sts	0x06A2, r24
    sts	CONCAT( PORT, SNSK1, _DIRSET ), p_2 
     4f6:	60 93 a1 06 	sts	0x06A1, r22
    pop  r19
     4fa:	3f 91       	pop	r19
    lds	r_v, CONCAT(PORT, SNS1, _IN )
     4fc:	80 91 a8 06 	lds	r24, 0x06A8
    and	r_v, p_3
     500:	84 23       	and	r24, r20
    ret
     502:	08 95       	ret

00000504 <_1101010110_>:

GLOBAL_FUNCTION _1101010110_
_1101010110_:
    sts	CONCAT( PORT, SNS1, _OUTCLR), p_1
     504:	80 93 a6 06 	sts	0x06A6, r24
    sts	CONCAT( PORT, SNS1, _DIRSET), p_1
     508:	80 93 a1 06 	sts	0x06A1, r24
    ret
     50c:	08 95       	ret

0000050e <burst_1_1_10_0_1>:
     50e:	a1 e0       	ldi	r26, 0x01	; 1
     510:	b0 e0       	ldi	r27, 0x00	; 0
     512:	ed e8       	ldi	r30, 0x8D	; 141
     514:	f2 e0       	ldi	r31, 0x02	; 2
     516:	0c 94 78 1e 	jmp	0x3cf0	; 0x3cf0 <__prologue_saves__+0xc>
     51a:	e8 2f       	mov	r30, r24
     51c:	0f b7       	in	r16, 0x3f	; 63
     51e:	00 78       	andi	r16, 0x80	; 128
     520:	19 82       	std	Y+1, r1	; 0x01
     522:	80 91 83 21 	lds	r24, 0x2183
     526:	81 30       	cpi	r24, 0x01	; 1
     528:	19 f0       	breq	.+6      	; 0x530 <burst_1_1_10_0_1+0x22>
     52a:	81 e0       	ldi	r24, 0x01	; 1
     52c:	80 93 83 21 	sts	0x2183, r24
     530:	ce 2e       	mov	r12, r30
     532:	dd 24       	eor	r13, r13
     534:	f6 01       	movw	r30, r12
     536:	eb 53       	subi	r30, 0x3B	; 59
     538:	fe 4d       	sbci	r31, 0xDE	; 222
     53a:	b0 80       	ld	r11, Z
     53c:	f6 01       	movw	r30, r12
     53e:	e7 53       	subi	r30, 0x37	; 55
     540:	fe 4d       	sbci	r31, 0xDE	; 222
     542:	a0 80       	ld	r10, Z
     544:	f8 94       	cli
     546:	bb 20       	and	r11, r11
     548:	09 f4       	brne	.+2      	; 0x54c <burst_1_1_10_0_1+0x3e>
     54a:	aa c0       	rjmp	.+340    	; 0x6a0 <burst_1_1_10_0_1+0x192>
     54c:	8b 2d       	mov	r24, r11
     54e:	da df       	rcall	.-76     	; 0x504 <_1101010110_>
     550:	8b 2d       	mov	r24, r11
     552:	6a 2d       	mov	r22, r10
     554:	be df       	rcall	.-132    	; 0x4d2 <_1101010101_>
     556:	1b 2d       	mov	r17, r11
     558:	ee 24       	eor	r14, r14
     55a:	ff 24       	eor	r15, r15
     55c:	60 e0       	ldi	r22, 0x00	; 0
     55e:	81 2c       	mov	r8, r1
     560:	30 e2       	ldi	r19, 0x20	; 32
     562:	93 2e       	mov	r9, r19
     564:	f5 fe       	sbrs	r15, 5
     566:	07 c0       	rjmp	.+14     	; 0x576 <burst_1_1_10_0_1+0x68>
     568:	90 91 c6 21 	lds	r25, 0x21C6
     56c:	80 91 c5 21 	lds	r24, 0x21C5
     570:	98 2b       	or	r25, r24
     572:	19 f5       	brne	.+70     	; 0x5ba <burst_1_1_10_0_1+0xac>
     574:	35 c0       	rjmp	.+106    	; 0x5e0 <burst_1_1_10_0_1+0xd2>
     576:	8f b7       	in	r24, 0x3f	; 63
     578:	80 2b       	or	r24, r16
     57a:	8f bf       	out	0x3f, r24	; 63
     57c:	00 00       	nop
     57e:	f8 94       	cli
     580:	8b 2d       	mov	r24, r11
     582:	6a 2d       	mov	r22, r10
     584:	41 2f       	mov	r20, r17
     586:	b0 df       	rcall	.-160    	; 0x4e8 <_1101010111_>
     588:	68 2f       	mov	r22, r24
     58a:	08 94       	sec
     58c:	e1 1c       	adc	r14, r1
     58e:	f1 1c       	adc	r15, r1
     590:	80 91 00 20 	lds	r24, 0x2000
     594:	8f 5f       	subi	r24, 0xFF	; 255
     596:	80 93 00 20 	sts	0x2000, r24
     59a:	82 30       	cpi	r24, 0x02	; 2
     59c:	30 f0       	brcs	.+12     	; 0x5aa <burst_1_1_10_0_1+0x9c>
     59e:	82 30       	cpi	r24, 0x02	; 2
     5a0:	21 f0       	breq	.+8      	; 0x5aa <burst_1_1_10_0_1+0x9c>
     5a2:	83 30       	cpi	r24, 0x03	; 3
     5a4:	11 f0       	breq	.+4      	; 0x5aa <burst_1_1_10_0_1+0x9c>
     5a6:	10 92 00 20 	sts	0x2000, r1
     5aa:	66 23       	and	r22, r22
     5ac:	d9 f2       	breq	.-74     	; 0x564 <burst_1_1_10_0_1+0x56>
     5ae:	20 91 c6 21 	lds	r18, 0x21C6
     5b2:	80 91 c5 21 	lds	r24, 0x21C5
     5b6:	28 2b       	or	r18, r24
     5b8:	15 c0       	rjmp	.+42     	; 0x5e4 <burst_1_1_10_0_1+0xd6>
     5ba:	41 2f       	mov	r20, r17
     5bc:	80 e0       	ldi	r24, 0x00	; 0
     5be:	40 ff       	sbrs	r20, 0
     5c0:	09 c0       	rjmp	.+18     	; 0x5d4 <burst_1_1_10_0_1+0xc6>
     5c2:	e8 2f       	mov	r30, r24
     5c4:	f0 e0       	ldi	r31, 0x00	; 0
     5c6:	ee 0f       	add	r30, r30
     5c8:	ff 1f       	adc	r31, r31
     5ca:	e2 57       	subi	r30, 0x72	; 114
     5cc:	fe 4d       	sbci	r31, 0xDE	; 222
     5ce:	80 82       	st	Z, r8
     5d0:	91 82       	std	Z+1, r9	; 0x01
     5d2:	01 c0       	rjmp	.+2      	; 0x5d6 <burst_1_1_10_0_1+0xc8>
     5d4:	90 fd       	sbrc	r25, 0
     5d6:	8f 5f       	subi	r24, 0xFF	; 255
     5d8:	96 95       	lsr	r25
     5da:	46 95       	lsr	r20
     5dc:	99 23       	and	r25, r25
     5de:	79 f7       	brne	.-34     	; 0x5be <burst_1_1_10_0_1+0xb0>
     5e0:	10 e0       	ldi	r17, 0x00	; 0
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	8f b7       	in	r24, 0x3f	; 63
     5e6:	80 2b       	or	r24, r16
     5e8:	8f bf       	out	0x3f, r24	; 63
     5ea:	10 92 84 21 	sts	0x2184, r1
     5ee:	22 23       	and	r18, r18
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <burst_1_1_10_0_1+0xe6>
     5f2:	3f c0       	rjmp	.+126    	; 0x672 <burst_1_1_10_0_1+0x164>
     5f4:	11 23       	and	r17, r17
     5f6:	09 f4       	brne	.+2      	; 0x5fa <burst_1_1_10_0_1+0xec>
     5f8:	3c c0       	rjmp	.+120    	; 0x672 <burst_1_1_10_0_1+0x164>
     5fa:	30 91 ca 21 	lds	r19, 0x21CA
     5fe:	80 91 c9 21 	lds	r24, 0x21C9
     602:	38 2b       	or	r19, r24
     604:	56 2f       	mov	r21, r22
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	80 e0       	ldi	r24, 0x00	; 0
     60a:	70 e0       	ldi	r23, 0x00	; 0
     60c:	40 e0       	ldi	r20, 0x00	; 0
     60e:	23 c0       	rjmp	.+70     	; 0x656 <burst_1_1_10_0_1+0x148>
     610:	50 fd       	sbrc	r21, 0
     612:	17 c0       	rjmp	.+46     	; 0x642 <burst_1_1_10_0_1+0x134>
     614:	19 c0       	rjmp	.+50     	; 0x648 <burst_1_1_10_0_1+0x13a>
     616:	30 ff       	sbrs	r19, 0
     618:	13 c0       	rjmp	.+38     	; 0x640 <burst_1_1_10_0_1+0x132>
     61a:	98 17       	cp	r25, r24
     61c:	81 f4       	brne	.+32     	; 0x63e <burst_1_1_10_0_1+0x130>
     61e:	e4 2f       	mov	r30, r20
     620:	f0 e0       	ldi	r31, 0x00	; 0
     622:	ee 0f       	add	r30, r30
     624:	ff 1f       	adc	r31, r31
     626:	e2 57       	subi	r30, 0x72	; 114
     628:	fe 4d       	sbci	r31, 0xDE	; 222
     62a:	e0 82       	st	Z, r14
     62c:	f1 82       	std	Z+1, r15	; 0x01
     62e:	85 2f       	mov	r24, r21
     630:	8e 7f       	andi	r24, 0xFE	; 254
     632:	19 f4       	brne	.+6      	; 0x63a <burst_1_1_10_0_1+0x12c>
     634:	89 2f       	mov	r24, r25
     636:	71 e0       	ldi	r23, 0x01	; 1
     638:	08 c0       	rjmp	.+16     	; 0x64a <burst_1_1_10_0_1+0x13c>
     63a:	89 2f       	mov	r24, r25
     63c:	06 c0       	rjmp	.+12     	; 0x64a <burst_1_1_10_0_1+0x13c>
     63e:	8f 5f       	subi	r24, 0xFF	; 255
     640:	36 95       	lsr	r19
     642:	33 23       	and	r19, r19
     644:	41 f7       	brne	.-48     	; 0x616 <burst_1_1_10_0_1+0x108>
     646:	01 c0       	rjmp	.+2      	; 0x64a <burst_1_1_10_0_1+0x13c>
     648:	20 fd       	sbrc	r18, 0
     64a:	9f 5f       	subi	r25, 0xFF	; 255
     64c:	20 fd       	sbrc	r18, 0
     64e:	4f 5f       	subi	r20, 0xFF	; 255
     650:	56 95       	lsr	r21
     652:	26 95       	lsr	r18
     654:	11 f0       	breq	.+4      	; 0x65a <burst_1_1_10_0_1+0x14c>
     656:	55 23       	and	r21, r21
     658:	d9 f6       	brne	.-74     	; 0x610 <burst_1_1_10_0_1+0x102>
     65a:	40 93 84 21 	sts	0x2184, r20
     65e:	60 95       	com	r22
     660:	16 23       	and	r17, r22
     662:	71 30       	cpi	r23, 0x01	; 1
     664:	21 f4       	brne	.+8      	; 0x66e <burst_1_1_10_0_1+0x160>
     666:	11 23       	and	r17, r17
     668:	11 f4       	brne	.+4      	; 0x66e <burst_1_1_10_0_1+0x160>
     66a:	ee 24       	eor	r14, r14
     66c:	ff 24       	eor	r15, r15
     66e:	60 e0       	ldi	r22, 0x00	; 0
     670:	13 c0       	rjmp	.+38     	; 0x698 <burst_1_1_10_0_1+0x18a>
     672:	80 91 c6 21 	lds	r24, 0x21C6
     676:	90 91 c5 21 	lds	r25, 0x21C5
     67a:	89 2b       	or	r24, r25
     67c:	89 83       	std	Y+1, r24	; 0x01
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	06 c0       	rjmp	.+12     	; 0x68e <burst_1_1_10_0_1+0x180>
     682:	89 81       	ldd	r24, Y+1	; 0x01
     684:	80 fd       	sbrc	r24, 0
     686:	9f 5f       	subi	r25, 0xFF	; 255
     688:	89 81       	ldd	r24, Y+1	; 0x01
     68a:	86 95       	lsr	r24
     68c:	89 83       	std	Y+1, r24	; 0x01
     68e:	89 81       	ldd	r24, Y+1	; 0x01
     690:	88 23       	and	r24, r24
     692:	b9 f7       	brne	.-18     	; 0x682 <burst_1_1_10_0_1+0x174>
     694:	90 93 84 21 	sts	0x2184, r25
     698:	f8 94       	cli
     69a:	11 23       	and	r17, r17
     69c:	09 f0       	breq	.+2      	; 0x6a0 <burst_1_1_10_0_1+0x192>
     69e:	62 cf       	rjmp	.-316    	; 0x564 <burst_1_1_10_0_1+0x56>
     6a0:	85 ec       	ldi	r24, 0xC5	; 197
     6a2:	91 e2       	ldi	r25, 0x21	; 33
     6a4:	c8 0e       	add	r12, r24
     6a6:	d9 1e       	adc	r13, r25
     6a8:	f6 01       	movw	r30, r12
     6aa:	80 81       	ld	r24, Z
     6ac:	2b df       	rcall	.-426    	; 0x504 <_1101010110_>
     6ae:	10 92 82 21 	sts	0x2182, r1
     6b2:	8f b7       	in	r24, 0x3f	; 63
     6b4:	08 2b       	or	r16, r24
     6b6:	0f bf       	out	0x3f, r16	; 63
     6b8:	21 96       	adiw	r28, 0x01	; 1
     6ba:	ec e0       	ldi	r30, 0x0C	; 12
     6bc:	0c 94 91 1e 	jmp	0x3d22	; 0x3d22 <__epilogue_restores__+0xc>

000006c0 <qt_get_library_sig>:
     6c0:	fc 01       	movw	r30, r24
     6c2:	80 e2       	ldi	r24, 0x20	; 32
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	80 83       	st	Z, r24
     6c8:	91 83       	std	Z+1, r25	; 0x01
     6ca:	12 82       	std	Z+2, r1	; 0x02
     6cc:	13 82       	std	Z+3, r1	; 0x03
     6ce:	80 e4       	ldi	r24, 0x40	; 64
     6d0:	94 e0       	ldi	r25, 0x04	; 4
     6d2:	84 83       	std	Z+4, r24	; 0x04
     6d4:	95 83       	std	Z+5, r25	; 0x05
     6d6:	08 95       	ret

000006d8 <qt_enable_key>:
     6d8:	90 91 bf 21 	lds	r25, 0x21BF
     6dc:	a9 2f       	mov	r26, r25
     6de:	b0 e0       	ldi	r27, 0x00	; 0
     6e0:	fd 01       	movw	r30, r26
     6e2:	ee 0f       	add	r30, r30
     6e4:	ff 1f       	adc	r31, r31
     6e6:	ea 0f       	add	r30, r26
     6e8:	fb 1f       	adc	r31, r27
     6ea:	ee 0f       	add	r30, r30
     6ec:	ff 1f       	adc	r31, r31
     6ee:	e9 55       	subi	r30, 0x59	; 89
     6f0:	fe 4d       	sbci	r31, 0xDE	; 222
     6f2:	43 83       	std	Z+3, r20	; 0x03
     6f4:	67 70       	andi	r22, 0x07	; 7
     6f6:	85 83       	std	Z+5, r24	; 0x05
     6f8:	23 70       	andi	r18, 0x03	; 3
     6fa:	66 0f       	add	r22, r22
     6fc:	66 0f       	add	r22, r22
     6fe:	66 0f       	add	r22, r22
     700:	26 2b       	or	r18, r22
     702:	24 83       	std	Z+4, r18	; 0x04
     704:	9f 5f       	subi	r25, 0xFF	; 255
     706:	90 93 bf 21 	sts	0x21BF, r25
     70a:	08 95       	ret

0000070c <qt_get_sensor_delta>:
     70c:	1f 93       	push	r17
     70e:	cf 93       	push	r28
     710:	df 93       	push	r29
     712:	28 2f       	mov	r18, r24
     714:	c8 2f       	mov	r28, r24
     716:	d0 e0       	ldi	r29, 0x00	; 0
     718:	fe 01       	movw	r30, r28
     71a:	ee 0f       	add	r30, r30
     71c:	ff 1f       	adc	r31, r31
     71e:	ec 0f       	add	r30, r28
     720:	fd 1f       	adc	r31, r29
     722:	ee 0f       	add	r30, r30
     724:	ff 1f       	adc	r31, r31
     726:	e9 55       	subi	r30, 0x59	; 89
     728:	fe 4d       	sbci	r31, 0xDE	; 222
     72a:	35 81       	ldd	r19, Z+5	; 0x05
     72c:	83 81       	ldd	r24, Z+3	; 0x03
     72e:	90 e0       	ldi	r25, 0x00	; 0
     730:	00 90 87 21 	lds	r0, 0x2187
     734:	02 c0       	rjmp	.+4      	; 0x73a <qt_get_sensor_delta+0x2e>
     736:	95 95       	asr	r25
     738:	87 95       	ror	r24
     73a:	0a 94       	dec	r0
     73c:	e2 f7       	brpl	.-8      	; 0x736 <qt_get_sensor_delta+0x2a>
     73e:	18 2f       	mov	r17, r24
     740:	84 30       	cpi	r24, 0x04	; 4
     742:	08 f4       	brcc	.+2      	; 0x746 <qt_get_sensor_delta+0x3a>
     744:	14 e0       	ldi	r17, 0x04	; 4
     746:	80 91 bf 21 	lds	r24, 0x21BF
     74a:	28 17       	cp	r18, r24
     74c:	18 f0       	brcs	.+6      	; 0x754 <qt_get_sensor_delta+0x48>
     74e:	20 e0       	ldi	r18, 0x00	; 0
     750:	30 e0       	ldi	r19, 0x00	; 0
     752:	2d c0       	rjmp	.+90     	; 0x7ae <qt_get_sensor_delta+0xa2>
     754:	83 2f       	mov	r24, r19
     756:	1d d1       	rcall	.+570    	; 0x992 <get_channel_delta>
     758:	9c 01       	movw	r18, r24
     75a:	41 2f       	mov	r20, r17
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	16 95       	lsr	r17
     760:	16 95       	lsr	r17
     762:	81 2f       	mov	r24, r17
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	84 1b       	sub	r24, r20
     768:	95 0b       	sbc	r25, r21
     76a:	82 17       	cp	r24, r18
     76c:	93 07       	cpc	r25, r19
     76e:	64 f4       	brge	.+24     	; 0x788 <qt_get_sensor_delta+0x7c>
     770:	fe 01       	movw	r30, r28
     772:	ee 0f       	add	r30, r30
     774:	ff 1f       	adc	r31, r31
     776:	ec 0f       	add	r30, r28
     778:	fd 1f       	adc	r31, r29
     77a:	ee 0f       	add	r30, r30
     77c:	ff 1f       	adc	r31, r31
     77e:	e9 55       	subi	r30, 0x59	; 89
     780:	fe 4d       	sbci	r31, 0xDE	; 222
     782:	84 81       	ldd	r24, Z+4	; 0x04
     784:	8b 7f       	andi	r24, 0xFB	; 251
     786:	84 83       	std	Z+4, r24	; 0x04
     788:	88 27       	eor	r24, r24
     78a:	99 27       	eor	r25, r25
     78c:	84 1b       	sub	r24, r20
     78e:	95 0b       	sbc	r25, r21
     790:	82 17       	cp	r24, r18
     792:	93 07       	cpc	r25, r19
     794:	64 f0       	brlt	.+24     	; 0x7ae <qt_get_sensor_delta+0xa2>
     796:	fe 01       	movw	r30, r28
     798:	ee 0f       	add	r30, r30
     79a:	ff 1f       	adc	r31, r31
     79c:	ec 0f       	add	r30, r28
     79e:	fd 1f       	adc	r31, r29
     7a0:	ee 0f       	add	r30, r30
     7a2:	ff 1f       	adc	r31, r31
     7a4:	e9 55       	subi	r30, 0x59	; 89
     7a6:	fe 4d       	sbci	r31, 0xDE	; 222
     7a8:	84 81       	ldd	r24, Z+4	; 0x04
     7aa:	84 60       	ori	r24, 0x04	; 4
     7ac:	84 83       	std	Z+4, r24	; 0x04
     7ae:	c9 01       	movw	r24, r18
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	1f 91       	pop	r17
     7b6:	08 95       	ret

000007b8 <qt_measure_sensors>:
     7b8:	ff 92       	push	r15
     7ba:	0f 93       	push	r16
     7bc:	1f 93       	push	r17
     7be:	cf 93       	push	r28
     7c0:	df 93       	push	r29
     7c2:	10 92 9f 21 	sts	0x219F, r1
     7c6:	10 92 a0 21 	sts	0x21A0, r1
     7ca:	20 91 a3 21 	lds	r18, 0x21A3
     7ce:	30 91 a4 21 	lds	r19, 0x21A4
     7d2:	80 93 a3 21 	sts	0x21A3, r24
     7d6:	90 93 a4 21 	sts	0x21A4, r25
     7da:	40 91 a5 21 	lds	r20, 0x21A5
     7de:	50 91 a6 21 	lds	r21, 0x21A6
     7e2:	42 1b       	sub	r20, r18
     7e4:	53 0b       	sbc	r21, r19
     7e6:	48 0f       	add	r20, r24
     7e8:	59 1f       	adc	r21, r25
     7ea:	ff 24       	eor	r15, r15
     7ec:	03 c0       	rjmp	.+6      	; 0x7f4 <qt_measure_sensors+0x3c>
     7ee:	f3 94       	inc	r15
     7f0:	48 5c       	subi	r20, 0xC8	; 200
     7f2:	50 40       	sbci	r21, 0x00	; 0
     7f4:	48 3c       	cpi	r20, 0xC8	; 200
     7f6:	51 05       	cpc	r21, r1
     7f8:	d0 f7       	brcc	.-12     	; 0x7ee <qt_measure_sensors+0x36>
     7fa:	40 93 a5 21 	sts	0x21A5, r20
     7fe:	50 93 a6 21 	sts	0x21A6, r21
     802:	80 91 c0 21 	lds	r24, 0x21C0
     806:	88 23       	and	r24, r24
     808:	41 f0       	breq	.+16     	; 0x81a <qt_measure_sensors+0x62>
     80a:	8f 15       	cp	r24, r15
     80c:	18 f4       	brcc	.+6      	; 0x814 <qt_measure_sensors+0x5c>
     80e:	10 92 c0 21 	sts	0x21C0, r1
     812:	03 c0       	rjmp	.+6      	; 0x81a <qt_measure_sensors+0x62>
     814:	8f 19       	sub	r24, r15
     816:	80 93 c0 21 	sts	0x21C0, r24
     81a:	c3 d3       	rcall	.+1926   	; 0xfa2 <burst>
     81c:	e0 91 a1 21 	lds	r30, 0x21A1
     820:	f0 91 a2 21 	lds	r31, 0x21A2
     824:	30 97       	sbiw	r30, 0x00	; 0
     826:	09 f0       	breq	.+2      	; 0x82a <qt_measure_sensors+0x72>
     828:	19 95       	eicall
     82a:	10 e0       	ldi	r17, 0x00	; 0
     82c:	00 e0       	ldi	r16, 0x00	; 0
     82e:	05 c0       	rjmp	.+10     	; 0x83a <qt_measure_sensors+0x82>
     830:	81 2f       	mov	r24, r17
     832:	6f 2d       	mov	r22, r15
     834:	c3 d0       	rcall	.+390    	; 0x9bc <process_sensor>
     836:	08 2b       	or	r16, r24
     838:	1f 5f       	subi	r17, 0xFF	; 255
     83a:	60 91 bf 21 	lds	r22, 0x21BF
     83e:	16 17       	cp	r17, r22
     840:	b8 f3       	brcs	.-18     	; 0x830 <qt_measure_sensors+0x78>
     842:	00 23       	and	r16, r16
     844:	49 f0       	breq	.+18     	; 0x858 <qt_measure_sensors+0xa0>
     846:	80 91 9f 21 	lds	r24, 0x219F
     84a:	90 91 a0 21 	lds	r25, 0x21A0
     84e:	91 60       	ori	r25, 0x01	; 1
     850:	80 93 9f 21 	sts	0x219F, r24
     854:	90 93 a0 21 	sts	0x21A0, r25
     858:	10 92 9e 21 	sts	0x219E, r1
     85c:	a7 ea       	ldi	r26, 0xA7	; 167
     85e:	b1 e2       	ldi	r27, 0x21	; 33
     860:	30 e0       	ldi	r19, 0x00	; 0
     862:	41 e0       	ldi	r20, 0x01	; 1
     864:	50 e0       	ldi	r21, 0x00	; 0
     866:	17 c0       	rjmp	.+46     	; 0x896 <qt_measure_sensors+0xde>
     868:	8c 91       	ld	r24, X
     86a:	88 71       	andi	r24, 0x18	; 24
     86c:	91 f0       	breq	.+36     	; 0x892 <qt_measure_sensors+0xda>
     86e:	e3 2f       	mov	r30, r19
     870:	e6 95       	lsr	r30
     872:	e6 95       	lsr	r30
     874:	e6 95       	lsr	r30
     876:	f0 e0       	ldi	r31, 0x00	; 0
     878:	e2 57       	subi	r30, 0x72	; 114
     87a:	fe 4d       	sbci	r31, 0xDE	; 222
     87c:	83 2f       	mov	r24, r19
     87e:	87 70       	andi	r24, 0x07	; 7
     880:	ea 01       	movw	r28, r20
     882:	02 c0       	rjmp	.+4      	; 0x888 <qt_measure_sensors+0xd0>
     884:	cc 0f       	add	r28, r28
     886:	dd 1f       	adc	r29, r29
     888:	8a 95       	dec	r24
     88a:	e2 f7       	brpl	.-8      	; 0x884 <qt_measure_sensors+0xcc>
     88c:	20 89       	ldd	r18, Z+16	; 0x10
     88e:	2c 2b       	or	r18, r28
     890:	20 8b       	std	Z+16, r18	; 0x10
     892:	3f 5f       	subi	r19, 0xFF	; 255
     894:	16 96       	adiw	r26, 0x06	; 6
     896:	36 17       	cp	r19, r22
     898:	38 f3       	brcs	.-50     	; 0x868 <qt_measure_sensors+0xb0>
     89a:	80 91 9f 21 	lds	r24, 0x219F
     89e:	90 91 a0 21 	lds	r25, 0x21A0
     8a2:	cd b7       	in	r28, 0x3d	; 61
     8a4:	de b7       	in	r29, 0x3e	; 62
     8a6:	e5 e0       	ldi	r30, 0x05	; 5
     8a8:	0c 94 98 1e 	jmp	0x3d30	; 0x3d30 <__epilogue_restores__+0x1a>

000008ac <qt_reset_sensing>:
     8ac:	10 92 bf 21 	sts	0x21BF, r1
     8b0:	84 e0       	ldi	r24, 0x04	; 4
     8b2:	80 93 88 21 	sts	0x2188, r24
     8b6:	94 e1       	ldi	r25, 0x14	; 20
     8b8:	90 93 8b 21 	sts	0x218B, r25
     8bc:	85 e0       	ldi	r24, 0x05	; 5
     8be:	80 93 8c 21 	sts	0x218C, r24
     8c2:	10 92 8a 21 	sts	0x218A, r1
     8c6:	90 93 89 21 	sts	0x2189, r25
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	80 93 87 21 	sts	0x2187, r24
     8d0:	83 e0       	ldi	r24, 0x03	; 3
     8d2:	80 93 8d 21 	sts	0x218D, r24
     8d6:	54 d3       	rcall	.+1704   	; 0xf80 <burst_reset>
     8d8:	10 92 a1 21 	sts	0x21A1, r1
     8dc:	10 92 a2 21 	sts	0x21A2, r1
     8e0:	08 95       	ret

000008e2 <qt_calibrate_sensing>:
     8e2:	1f 93       	push	r17
     8e4:	10 e0       	ldi	r17, 0x00	; 0
     8e6:	03 c0       	rjmp	.+6      	; 0x8ee <qt_calibrate_sensing+0xc>
     8e8:	81 2f       	mov	r24, r17
     8ea:	27 d0       	rcall	.+78     	; 0x93a <start_cal_sensor>
     8ec:	1f 5f       	subi	r17, 0xFF	; 255
     8ee:	80 91 bf 21 	lds	r24, 0x21BF
     8f2:	18 17       	cp	r17, r24
     8f4:	c8 f3       	brcs	.-14     	; 0x8e8 <qt_calibrate_sensing+0x6>
     8f6:	1f 91       	pop	r17
     8f8:	08 95       	ret

000008fa <qt_init_sensing_with_burst>:
     8fa:	ef 92       	push	r14
     8fc:	ff 92       	push	r15
     8fe:	1f 93       	push	r17
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
     904:	ec 01       	movw	r28, r24
     906:	7b 01       	movw	r14, r22
     908:	10 e0       	ldi	r17, 0x00	; 0
     90a:	03 c0       	rjmp	.+6      	; 0x912 <qt_init_sensing_with_burst+0x18>
     90c:	81 2f       	mov	r24, r17
     90e:	15 d0       	rcall	.+42     	; 0x93a <start_cal_sensor>
     910:	1f 5f       	subi	r17, 0xFF	; 255
     912:	80 91 bf 21 	lds	r24, 0x21BF
     916:	18 17       	cp	r17, r24
     918:	c8 f3       	brcs	.-14     	; 0x90c <qt_init_sensing_with_burst+0x12>
     91a:	10 92 a3 21 	sts	0x21A3, r1
     91e:	10 92 a4 21 	sts	0x21A4, r1
     922:	c0 93 85 21 	sts	0x2185, r28
     926:	d0 93 86 21 	sts	0x2186, r29
     92a:	c7 01       	movw	r24, r14
     92c:	24 d3       	rcall	.+1608   	; 0xf76 <burst_init>
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	1f 91       	pop	r17
     934:	ff 90       	pop	r15
     936:	ef 90       	pop	r14
     938:	08 95       	ret

0000093a <start_cal_sensor>:
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	e7 ea       	ldi	r30, 0xA7	; 167
     93e:	f1 e2       	ldi	r31, 0x21	; 33
     940:	9c 01       	movw	r18, r24
     942:	22 0f       	add	r18, r18
     944:	33 1f       	adc	r19, r19
     946:	28 0f       	add	r18, r24
     948:	39 1f       	adc	r19, r25
     94a:	d9 01       	movw	r26, r18
     94c:	aa 0f       	add	r26, r26
     94e:	bb 1f       	adc	r27, r27
     950:	ae 0f       	add	r26, r30
     952:	bf 1f       	adc	r27, r31
     954:	15 96       	adiw	r26, 0x05	; 5
     956:	4c 91       	ld	r20, X
     958:	15 97       	sbiw	r26, 0x05	; 5
     95a:	80 91 9f 21 	lds	r24, 0x219F
     95e:	90 91 a0 21 	lds	r25, 0x21A0
     962:	82 60       	ori	r24, 0x02	; 2
     964:	80 93 9f 21 	sts	0x219F, r24
     968:	90 93 a0 21 	sts	0x21A0, r25
     96c:	2f 5f       	subi	r18, 0xFF	; 255
     96e:	3f 4f       	sbci	r19, 0xFF	; 255
     970:	22 0f       	add	r18, r18
     972:	33 1f       	adc	r19, r19
     974:	e2 0f       	add	r30, r18
     976:	f3 1f       	adc	r31, r19
     978:	10 82       	st	Z, r1
     97a:	e1 ec       	ldi	r30, 0xC1	; 193
     97c:	f1 e2       	ldi	r31, 0x21	; 33
     97e:	e4 0f       	add	r30, r20
     980:	f1 1d       	adc	r31, r1
     982:	80 e8       	ldi	r24, 0x80	; 128
     984:	80 83       	st	Z, r24
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	8c 93       	st	X, r24
     98a:	8f e0       	ldi	r24, 0x0F	; 15
     98c:	11 96       	adiw	r26, 0x01	; 1
     98e:	8c 93       	st	X, r24
     990:	08 95       	ret

00000992 <get_channel_delta>:
     992:	90 e0       	ldi	r25, 0x00	; 0
     994:	fc 01       	movw	r30, r24
     996:	34 96       	adiw	r30, 0x04	; 4
     998:	ae e8       	ldi	r26, 0x8E	; 142
     99a:	b1 e2       	ldi	r27, 0x21	; 33
     99c:	ee 0f       	add	r30, r30
     99e:	ff 1f       	adc	r31, r31
     9a0:	ea 0f       	add	r30, r26
     9a2:	fb 1f       	adc	r31, r27
     9a4:	88 0f       	add	r24, r24
     9a6:	99 1f       	adc	r25, r25
     9a8:	a8 0f       	add	r26, r24
     9aa:	b9 1f       	adc	r27, r25
     9ac:	20 81       	ld	r18, Z
     9ae:	31 81       	ldd	r19, Z+1	; 0x01
     9b0:	8d 91       	ld	r24, X+
     9b2:	9c 91       	ld	r25, X
     9b4:	28 1b       	sub	r18, r24
     9b6:	39 0b       	sbc	r19, r25
     9b8:	c9 01       	movw	r24, r18
     9ba:	08 95       	ret

000009bc <process_sensor>:
     9bc:	a0 e0       	ldi	r26, 0x00	; 0
     9be:	b0 e0       	ldi	r27, 0x00	; 0
     9c0:	e4 ee       	ldi	r30, 0xE4	; 228
     9c2:	f4 e0       	ldi	r31, 0x04	; 4
     9c4:	0c 94 76 1e 	jmp	0x3cec	; 0x3cec <__prologue_saves__+0x8>
     9c8:	78 2e       	mov	r7, r24
     9ca:	f6 2e       	mov	r15, r22
     9cc:	9f de       	rcall	.-706    	; 0x70c <qt_get_sensor_delta>
     9ce:	5c 01       	movw	r10, r24
     9d0:	07 2d       	mov	r16, r7
     9d2:	10 e0       	ldi	r17, 0x00	; 0
     9d4:	f8 01       	movw	r30, r16
     9d6:	ee 0f       	add	r30, r30
     9d8:	ff 1f       	adc	r31, r31
     9da:	e0 0f       	add	r30, r16
     9dc:	f1 1f       	adc	r31, r17
     9de:	ee 0f       	add	r30, r30
     9e0:	ff 1f       	adc	r31, r31
     9e2:	e9 55       	subi	r30, 0x59	; 89
     9e4:	fe 4d       	sbci	r31, 0xDE	; 222
     9e6:	54 81       	ldd	r21, Z+4	; 0x04
     9e8:	43 81       	ldd	r20, Z+3	; 0x03
     9ea:	24 2f       	mov	r18, r20
     9ec:	30 e0       	ldi	r19, 0x00	; 0
     9ee:	85 2f       	mov	r24, r21
     9f0:	83 70       	andi	r24, 0x03	; 3
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	01 96       	adiw	r24, 0x01	; 1
     9f6:	02 c0       	rjmp	.+4      	; 0x9fc <process_sensor+0x40>
     9f8:	35 95       	asr	r19
     9fa:	27 95       	ror	r18
     9fc:	8a 95       	dec	r24
     9fe:	e2 f7       	brpl	.-8      	; 0x9f8 <process_sensor+0x3c>
     a00:	82 2f       	mov	r24, r18
     a02:	22 30       	cpi	r18, 0x02	; 2
     a04:	08 f4       	brcc	.+2      	; 0xa08 <process_sensor+0x4c>
     a06:	82 e0       	ldi	r24, 0x02	; 2
     a08:	24 2f       	mov	r18, r20
     a0a:	30 e0       	ldi	r19, 0x00	; 0
     a0c:	b9 01       	movw	r22, r18
     a0e:	68 1b       	sub	r22, r24
     a10:	71 09       	sbc	r23, r1
     a12:	f8 01       	movw	r30, r16
     a14:	ee 0f       	add	r30, r30
     a16:	ff 1f       	adc	r31, r31
     a18:	e0 0f       	add	r30, r16
     a1a:	f1 1f       	adc	r31, r17
     a1c:	ef 01       	movw	r28, r30
     a1e:	cc 0f       	add	r28, r28
     a20:	dd 1f       	adc	r29, r29
     a22:	c9 55       	subi	r28, 0x59	; 89
     a24:	de 4d       	sbci	r29, 0xDE	; 222
     a26:	88 81       	ld	r24, Y
     a28:	84 30       	cpi	r24, 0x04	; 4
     a2a:	09 f4       	brne	.+2      	; 0xa2e <process_sensor+0x72>
     a2c:	fb c0       	rjmp	.+502    	; 0xc24 <process_sensor+0x268>
     a2e:	85 30       	cpi	r24, 0x05	; 5
     a30:	30 f4       	brcc	.+12     	; 0xa3e <process_sensor+0x82>
     a32:	81 30       	cpi	r24, 0x01	; 1
     a34:	71 f0       	breq	.+28     	; 0xa52 <process_sensor+0x96>
     a36:	82 30       	cpi	r24, 0x02	; 2
     a38:	09 f0       	breq	.+2      	; 0xa3c <process_sensor+0x80>
     a3a:	96 c2       	rjmp	.+1324   	; 0xf68 <process_sensor+0x5ac>
     a3c:	6e c0       	rjmp	.+220    	; 0xb1a <process_sensor+0x15e>
     a3e:	80 31       	cpi	r24, 0x10	; 16
     a40:	09 f4       	brne	.+2      	; 0xa44 <process_sensor+0x88>
     a42:	a5 c1       	rjmp	.+842    	; 0xd8e <process_sensor+0x3d2>
     a44:	80 32       	cpi	r24, 0x20	; 32
     a46:	09 f4       	brne	.+2      	; 0xa4a <process_sensor+0x8e>
     a48:	56 c2       	rjmp	.+1196   	; 0xef6 <process_sensor+0x53a>
     a4a:	88 30       	cpi	r24, 0x08	; 8
     a4c:	09 f0       	breq	.+2      	; 0xa50 <process_sensor+0x94>
     a4e:	8c c2       	rjmp	.+1304   	; 0xf68 <process_sensor+0x5ac>
     a50:	02 c2       	rjmp	.+1028   	; 0xe56 <process_sensor+0x49a>
     a52:	40 91 9f 21 	lds	r20, 0x219F
     a56:	50 91 a0 21 	lds	r21, 0x21A0
     a5a:	ca 01       	movw	r24, r20
     a5c:	92 60       	ori	r25, 0x02	; 2
     a5e:	80 93 9f 21 	sts	0x219F, r24
     a62:	90 93 a0 21 	sts	0x21A0, r25
     a66:	8d 81       	ldd	r24, Y+5	; 0x05
     a68:	69 81       	ldd	r22, Y+1	; 0x01
     a6a:	a8 2f       	mov	r26, r24
     a6c:	b0 e0       	ldi	r27, 0x00	; 0
     a6e:	6a 30       	cpi	r22, 0x0A	; 10
     a70:	60 f0       	brcs	.+24     	; 0xa8a <process_sensor+0xce>
     a72:	aa 0f       	add	r26, r26
     a74:	bb 1f       	adc	r27, r27
     a76:	fd 01       	movw	r30, r26
     a78:	e2 57       	subi	r30, 0x72	; 114
     a7a:	fe 4d       	sbci	r31, 0xDE	; 222
     a7c:	80 81       	ld	r24, Z
     a7e:	91 81       	ldd	r25, Z+1	; 0x01
     a80:	aa 56       	subi	r26, 0x6A	; 106
     a82:	be 4d       	sbci	r27, 0xDE	; 222
     a84:	8d 93       	st	X+, r24
     a86:	9c 93       	st	X, r25
     a88:	18 c0       	rjmp	.+48     	; 0xaba <process_sensor+0xfe>
     a8a:	aa 0f       	add	r26, r26
     a8c:	bb 1f       	adc	r27, r27
     a8e:	fd 01       	movw	r30, r26
     a90:	ea 56       	subi	r30, 0x6A	; 106
     a92:	fe 4d       	sbci	r31, 0xDE	; 222
     a94:	20 81       	ld	r18, Z
     a96:	31 81       	ldd	r19, Z+1	; 0x01
     a98:	a2 57       	subi	r26, 0x72	; 114
     a9a:	be 4d       	sbci	r27, 0xDE	; 222
     a9c:	8d 91       	ld	r24, X+
     a9e:	9c 91       	ld	r25, X
     aa0:	82 17       	cp	r24, r18
     aa2:	93 07       	cpc	r25, r19
     aa4:	18 f4       	brcc	.+6      	; 0xaac <process_sensor+0xf0>
     aa6:	21 50       	subi	r18, 0x01	; 1
     aa8:	30 40       	sbci	r19, 0x00	; 0
     aaa:	05 c0       	rjmp	.+10     	; 0xab6 <process_sensor+0xfa>
     aac:	28 17       	cp	r18, r24
     aae:	39 07       	cpc	r19, r25
     ab0:	50 f4       	brcc	.+20     	; 0xac6 <process_sensor+0x10a>
     ab2:	2f 5f       	subi	r18, 0xFF	; 255
     ab4:	3f 4f       	sbci	r19, 0xFF	; 255
     ab6:	20 83       	st	Z, r18
     ab8:	31 83       	std	Z+1, r19	; 0x01
     aba:	48 60       	ori	r20, 0x08	; 8
     abc:	52 60       	ori	r21, 0x02	; 2
     abe:	40 93 9f 21 	sts	0x219F, r20
     ac2:	50 93 a0 21 	sts	0x21A0, r21
     ac6:	86 2f       	mov	r24, r22
     ac8:	81 50       	subi	r24, 0x01	; 1
     aca:	f8 01       	movw	r30, r16
     acc:	ee 0f       	add	r30, r30
     ace:	ff 1f       	adc	r31, r31
     ad0:	e0 0f       	add	r30, r16
     ad2:	f1 1f       	adc	r31, r17
     ad4:	ef 01       	movw	r28, r30
     ad6:	cc 0f       	add	r28, r28
     ad8:	dd 1f       	adc	r29, r29
     ada:	c9 55       	subi	r28, 0x59	; 89
     adc:	de 4d       	sbci	r29, 0xDE	; 222
     ade:	89 83       	std	Y+1, r24	; 0x01
     ae0:	88 23       	and	r24, r24
     ae2:	b1 f4       	brne	.+44     	; 0xb10 <process_sensor+0x154>
     ae4:	ad 81       	ldd	r26, Y+5	; 0x05
     ae6:	82 e0       	ldi	r24, 0x02	; 2
     ae8:	88 83       	st	Y, r24
     aea:	80 91 9f 21 	lds	r24, 0x219F
     aee:	90 91 a0 21 	lds	r25, 0x21A0
     af2:	82 60       	ori	r24, 0x02	; 2
     af4:	80 93 9f 21 	sts	0x219F, r24
     af8:	90 93 a0 21 	sts	0x21A0, r25
     afc:	ee 0f       	add	r30, r30
     afe:	ff 1f       	adc	r31, r31
     b00:	e7 55       	subi	r30, 0x57	; 87
     b02:	fe 4d       	sbci	r31, 0xDE	; 222
     b04:	10 82       	st	Z, r1
     b06:	b0 e0       	ldi	r27, 0x00	; 0
     b08:	af 53       	subi	r26, 0x3F	; 63
     b0a:	be 4d       	sbci	r27, 0xDE	; 222
     b0c:	80 e8       	ldi	r24, 0x80	; 128
     b0e:	8c 93       	st	X, r24
     b10:	80 91 89 21 	lds	r24, 0x2189
     b14:	80 93 c0 21 	sts	0x21C0, r24
     b18:	25 c2       	rjmp	.+1098   	; 0xf64 <process_sensor+0x5a8>
     b1a:	52 ff       	sbrs	r21, 2
     b1c:	08 c0       	rjmp	.+16     	; 0xb2e <process_sensor+0x172>
     b1e:	ed 81       	ldd	r30, Y+5	; 0x05
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	ef 53       	subi	r30, 0x3F	; 63
     b24:	fe 4d       	sbci	r31, 0xDE	; 222
     b26:	10 82       	st	Z, r1
     b28:	80 e2       	ldi	r24, 0x20	; 32
     b2a:	88 83       	st	Y, r24
     b2c:	0c c2       	rjmp	.+1048   	; 0xf46 <process_sensor+0x58a>
     b2e:	c5 01       	movw	r24, r10
     b30:	b7 fe       	sbrs	r11, 7
     b32:	02 c0       	rjmp	.+4      	; 0xb38 <process_sensor+0x17c>
     b34:	80 e0       	ldi	r24, 0x00	; 0
     b36:	90 e0       	ldi	r25, 0x00	; 0
     b38:	82 17       	cp	r24, r18
     b3a:	93 07       	cpc	r25, r19
     b3c:	80 f0       	brcs	.+32     	; 0xb5e <process_sensor+0x1a2>
     b3e:	f8 01       	movw	r30, r16
     b40:	ee 0f       	add	r30, r30
     b42:	ff 1f       	adc	r31, r31
     b44:	e0 0f       	add	r30, r16
     b46:	f1 1f       	adc	r31, r17
     b48:	ee 0f       	add	r30, r30
     b4a:	ff 1f       	adc	r31, r31
     b4c:	df 01       	movw	r26, r30
     b4e:	a9 55       	subi	r26, 0x59	; 89
     b50:	be 4d       	sbci	r27, 0xDE	; 222
     b52:	84 e0       	ldi	r24, 0x04	; 4
     b54:	8c 93       	st	X, r24
     b56:	e7 55       	subi	r30, 0x57	; 87
     b58:	fe 4d       	sbci	r31, 0xDE	; 222
     b5a:	10 82       	st	Z, r1
     b5c:	fa c1       	rjmp	.+1012   	; 0xf52 <process_sensor+0x596>
     b5e:	ff 20       	and	r15, r15
     b60:	09 f4       	brne	.+2      	; 0xb64 <process_sensor+0x1a8>
     b62:	02 c2       	rjmp	.+1028   	; 0xf68 <process_sensor+0x5ac>
     b64:	80 91 c0 21 	lds	r24, 0x21C0
     b68:	88 23       	and	r24, r24
     b6a:	09 f0       	breq	.+2      	; 0xb6e <process_sensor+0x1b2>
     b6c:	fd c1       	rjmp	.+1018   	; 0xf68 <process_sensor+0x5ac>
     b6e:	f8 01       	movw	r30, r16
     b70:	ee 0f       	add	r30, r30
     b72:	ff 1f       	adc	r31, r31
     b74:	e0 0f       	add	r30, r16
     b76:	f1 1f       	adc	r31, r17
     b78:	ee 0f       	add	r30, r30
     b7a:	ff 1f       	adc	r31, r31
     b7c:	e9 55       	subi	r30, 0x59	; 89
     b7e:	fe 4d       	sbci	r31, 0xDE	; 222
     b80:	85 81       	ldd	r24, Z+5	; 0x05
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	ec 01       	movw	r28, r24
     b86:	cc 0f       	add	r28, r28
     b88:	dd 1f       	adc	r29, r29
     b8a:	ca 56       	subi	r28, 0x6A	; 106
     b8c:	de 4d       	sbci	r29, 0xDE	; 222
     b8e:	28 81       	ld	r18, Y
     b90:	39 81       	ldd	r19, Y+1	; 0x01
     b92:	fc 01       	movw	r30, r24
     b94:	ee 0f       	add	r30, r30
     b96:	ff 1f       	adc	r31, r31
     b98:	e2 57       	subi	r30, 0x72	; 114
     b9a:	fe 4d       	sbci	r31, 0xDE	; 222
     b9c:	01 90       	ld	r0, Z+
     b9e:	f0 81       	ld	r31, Z
     ba0:	e0 2d       	mov	r30, r0
     ba2:	2e 17       	cp	r18, r30
     ba4:	3f 07       	cpc	r19, r31
     ba6:	88 f4       	brcc	.+34     	; 0xbca <process_sensor+0x20e>
     ba8:	fc 01       	movw	r30, r24
     baa:	ef 53       	subi	r30, 0x3F	; 63
     bac:	fe 4d       	sbci	r31, 0xDE	; 222
     bae:	90 81       	ld	r25, Z
     bb0:	9f 0d       	add	r25, r15
     bb2:	90 83       	st	Z, r25
     bb4:	80 91 8c 21 	lds	r24, 0x218C
     bb8:	80 58       	subi	r24, 0x80	; 128
     bba:	98 17       	cp	r25, r24
     bbc:	08 f4       	brcc	.+2      	; 0xbc0 <process_sensor+0x204>
     bbe:	d4 c1       	rjmp	.+936    	; 0xf68 <process_sensor+0x5ac>
     bc0:	80 e8       	ldi	r24, 0x80	; 128
     bc2:	80 83       	st	Z, r24
     bc4:	2f 5f       	subi	r18, 0xFF	; 255
     bc6:	3f 4f       	sbci	r19, 0xFF	; 255
     bc8:	14 c0       	rjmp	.+40     	; 0xbf2 <process_sensor+0x236>
     bca:	dc 01       	movw	r26, r24
     bcc:	af 53       	subi	r26, 0x3F	; 63
     bce:	be 4d       	sbci	r27, 0xDE	; 222
     bd0:	e2 17       	cp	r30, r18
     bd2:	f3 07       	cpc	r31, r19
     bd4:	d0 f4       	brcc	.+52     	; 0xc0a <process_sensor+0x24e>
     bd6:	8c 91       	ld	r24, X
     bd8:	8f 19       	sub	r24, r15
     bda:	8c 93       	st	X, r24
     bdc:	40 e8       	ldi	r20, 0x80	; 128
     bde:	90 91 8b 21 	lds	r25, 0x218B
     be2:	54 2f       	mov	r21, r20
     be4:	59 1b       	sub	r21, r25
     be6:	58 17       	cp	r21, r24
     be8:	08 f4       	brcc	.+2      	; 0xbec <process_sensor+0x230>
     bea:	be c1       	rjmp	.+892    	; 0xf68 <process_sensor+0x5ac>
     bec:	4c 93       	st	X, r20
     bee:	21 50       	subi	r18, 0x01	; 1
     bf0:	30 40       	sbci	r19, 0x00	; 0
     bf2:	28 83       	st	Y, r18
     bf4:	39 83       	std	Y+1, r19	; 0x01
     bf6:	80 91 9f 21 	lds	r24, 0x219F
     bfa:	90 91 a0 21 	lds	r25, 0x21A0
     bfe:	88 60       	ori	r24, 0x08	; 8
     c00:	80 93 9f 21 	sts	0x219F, r24
     c04:	90 93 a0 21 	sts	0x21A0, r25
     c08:	af c1       	rjmp	.+862    	; 0xf68 <process_sensor+0x5ac>
     c0a:	2c 91       	ld	r18, X
     c0c:	21 38       	cpi	r18, 0x81	; 129
     c0e:	10 f0       	brcs	.+4      	; 0xc14 <process_sensor+0x258>
     c10:	21 50       	subi	r18, 0x01	; 1
     c12:	2c 93       	st	X, r18
     c14:	fc 01       	movw	r30, r24
     c16:	ef 53       	subi	r30, 0x3F	; 63
     c18:	fe 4d       	sbci	r31, 0xDE	; 222
     c1a:	80 81       	ld	r24, Z
     c1c:	87 fd       	sbrc	r24, 7
     c1e:	a4 c1       	rjmp	.+840    	; 0xf68 <process_sensor+0x5ac>
     c20:	8f 5f       	subi	r24, 0xFF	; 255
     c22:	67 c1       	rjmp	.+718    	; 0xef2 <process_sensor+0x536>
     c24:	c5 01       	movw	r24, r10
     c26:	b7 fe       	sbrs	r11, 7
     c28:	02 c0       	rjmp	.+4      	; 0xc2e <process_sensor+0x272>
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	90 e0       	ldi	r25, 0x00	; 0
     c2e:	f8 01       	movw	r30, r16
     c30:	ee 0f       	add	r30, r30
     c32:	ff 1f       	adc	r31, r31
     c34:	82 17       	cp	r24, r18
     c36:	93 07       	cpc	r25, r19
     c38:	08 f4       	brcc	.+2      	; 0xc3c <process_sensor+0x280>
     c3a:	8f c0       	rjmp	.+286    	; 0xd5a <process_sensor+0x39e>
     c3c:	80 91 89 21 	lds	r24, 0x2189
     c40:	80 93 c0 21 	sts	0x21C0, r24
     c44:	9f 01       	movw	r18, r30
     c46:	20 0f       	add	r18, r16
     c48:	31 1f       	adc	r19, r17
     c4a:	22 0f       	add	r18, r18
     c4c:	33 1f       	adc	r19, r19
     c4e:	d9 01       	movw	r26, r18
     c50:	a7 55       	subi	r26, 0x57	; 87
     c52:	be 4d       	sbci	r27, 0xDE	; 222
     c54:	8c 91       	ld	r24, X
     c56:	8f 5f       	subi	r24, 0xFF	; 255
     c58:	8c 93       	st	X, r24
     c5a:	f9 01       	movw	r30, r18
     c5c:	e9 55       	subi	r30, 0x59	; 89
     c5e:	fe 4d       	sbci	r31, 0xDE	; 222
     c60:	84 81       	ldd	r24, Z+4	; 0x04
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	88 73       	andi	r24, 0x38	; 56
     c66:	90 70       	andi	r25, 0x00	; 0
     c68:	23 e0       	ldi	r18, 0x03	; 3
     c6a:	96 95       	lsr	r25
     c6c:	87 95       	ror	r24
     c6e:	2a 95       	dec	r18
     c70:	e1 f7       	brne	.-8      	; 0xc6a <process_sensor+0x2ae>
     c72:	68 2e       	mov	r6, r24
     c74:	88 23       	and	r24, r24
     c76:	09 f4       	brne	.+2      	; 0xc7a <process_sensor+0x2be>
     c78:	3e c0       	rjmp	.+124    	; 0xcf6 <process_sensor+0x33a>
     c7a:	cc 24       	eor	r12, r12
     c7c:	dd 24       	eor	r13, r13
     c7e:	7f 01       	movw	r14, r30
     c80:	83 e0       	ldi	r24, 0x03	; 3
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	e8 0e       	add	r14, r24
     c86:	f9 1e       	adc	r15, r25
     c88:	4d 01       	movw	r8, r26
     c8a:	2f c0       	rjmp	.+94     	; 0xcea <process_sensor+0x32e>
     c8c:	d7 14       	cp	r13, r7
     c8e:	61 f1       	breq	.+88     	; 0xce8 <process_sensor+0x32c>
     c90:	8d 2d       	mov	r24, r13
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	ec 01       	movw	r28, r24
     c96:	cc 0f       	add	r28, r28
     c98:	dd 1f       	adc	r29, r29
     c9a:	c8 0f       	add	r28, r24
     c9c:	d9 1f       	adc	r29, r25
     c9e:	cc 0f       	add	r28, r28
     ca0:	dd 1f       	adc	r29, r29
     ca2:	c9 55       	subi	r28, 0x59	; 89
     ca4:	de 4d       	sbci	r29, 0xDE	; 222
     ca6:	8c 81       	ldd	r24, Y+4	; 0x04
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	88 73       	andi	r24, 0x38	; 56
     cac:	90 70       	andi	r25, 0x00	; 0
     cae:	73 e0       	ldi	r23, 0x03	; 3
     cb0:	96 95       	lsr	r25
     cb2:	87 95       	ror	r24
     cb4:	7a 95       	dec	r23
     cb6:	e1 f7       	brne	.-8      	; 0xcb0 <process_sensor+0x2f4>
     cb8:	68 16       	cp	r6, r24
     cba:	b1 f4       	brne	.+44     	; 0xce8 <process_sensor+0x32c>
     cbc:	8d 2d       	mov	r24, r13
     cbe:	26 dd       	rcall	.-1460   	; 0x70c <qt_get_sensor_delta>
     cc0:	2b 81       	ldd	r18, Y+3	; 0x03
     cc2:	82 1b       	sub	r24, r18
     cc4:	91 09       	sbc	r25, r1
     cc6:	f7 01       	movw	r30, r14
     cc8:	20 81       	ld	r18, Z
     cca:	a5 01       	movw	r20, r10
     ccc:	42 1b       	sub	r20, r18
     cce:	51 09       	sbc	r21, r1
     cd0:	48 17       	cp	r20, r24
     cd2:	59 07       	cpc	r21, r25
     cd4:	2c f0       	brlt	.+10     	; 0xce0 <process_sensor+0x324>
     cd6:	88 81       	ld	r24, Y
     cd8:	80 31       	cpi	r24, 0x10	; 16
     cda:	11 f0       	breq	.+4      	; 0xce0 <process_sensor+0x324>
     cdc:	88 30       	cpi	r24, 0x08	; 8
     cde:	21 f4       	brne	.+8      	; 0xce8 <process_sensor+0x32c>
     ce0:	f4 01       	movw	r30, r8
     ce2:	10 82       	st	Z, r1
     ce4:	cc 24       	eor	r12, r12
     ce6:	c3 94       	inc	r12
     ce8:	d3 94       	inc	r13
     cea:	80 91 bf 21 	lds	r24, 0x21BF
     cee:	d8 16       	cp	r13, r24
     cf0:	68 f2       	brcs	.-102    	; 0xc8c <process_sensor+0x2d0>
     cf2:	cc 20       	and	r12, r12
     cf4:	79 f4       	brne	.+30     	; 0xd14 <process_sensor+0x358>
     cf6:	80 91 88 21 	lds	r24, 0x2188
     cfa:	88 23       	and	r24, r24
     cfc:	59 f0       	breq	.+22     	; 0xd14 <process_sensor+0x358>
     cfe:	80 91 9f 21 	lds	r24, 0x219F
     d02:	90 91 a0 21 	lds	r25, 0x21A0
     d06:	98 60       	ori	r25, 0x08	; 8
     d08:	80 93 9f 21 	sts	0x219F, r24
     d0c:	90 93 a0 21 	sts	0x21A0, r25
     d10:	41 e0       	ldi	r20, 0x01	; 1
     d12:	01 c0       	rjmp	.+2      	; 0xd16 <process_sensor+0x35a>
     d14:	40 e0       	ldi	r20, 0x00	; 0
     d16:	98 01       	movw	r18, r16
     d18:	22 0f       	add	r18, r18
     d1a:	33 1f       	adc	r19, r19
     d1c:	20 0f       	add	r18, r16
     d1e:	31 1f       	adc	r19, r17
     d20:	f9 01       	movw	r30, r18
     d22:	ee 0f       	add	r30, r30
     d24:	ff 1f       	adc	r31, r31
     d26:	e7 55       	subi	r30, 0x57	; 87
     d28:	fe 4d       	sbci	r31, 0xDE	; 222
     d2a:	90 81       	ld	r25, Z
     d2c:	80 91 88 21 	lds	r24, 0x2188
     d30:	98 17       	cp	r25, r24
     d32:	08 f4       	brcc	.+2      	; 0xd36 <process_sensor+0x37a>
     d34:	1a c1       	rjmp	.+564    	; 0xf6a <process_sensor+0x5ae>
     d36:	80 91 9f 21 	lds	r24, 0x219F
     d3a:	90 91 a0 21 	lds	r25, 0x21A0
     d3e:	83 60       	ori	r24, 0x03	; 3
     d40:	80 93 9f 21 	sts	0x219F, r24
     d44:	90 93 a0 21 	sts	0x21A0, r25
     d48:	f9 01       	movw	r30, r18
     d4a:	ee 0f       	add	r30, r30
     d4c:	ff 1f       	adc	r31, r31
     d4e:	e9 55       	subi	r30, 0x59	; 89
     d50:	fe 4d       	sbci	r31, 0xDE	; 222
     d52:	80 e1       	ldi	r24, 0x10	; 16
     d54:	80 83       	st	Z, r24
     d56:	11 82       	std	Z+1, r1	; 0x01
     d58:	08 c1       	rjmp	.+528    	; 0xf6a <process_sensor+0x5ae>
     d5a:	e0 0f       	add	r30, r16
     d5c:	f1 1f       	adc	r31, r17
     d5e:	ee 0f       	add	r30, r30
     d60:	ff 1f       	adc	r31, r31
     d62:	df 01       	movw	r26, r30
     d64:	a9 55       	subi	r26, 0x59	; 89
     d66:	be 4d       	sbci	r27, 0xDE	; 222
     d68:	15 96       	adiw	r26, 0x05	; 5
     d6a:	2c 91       	ld	r18, X
     d6c:	15 97       	sbiw	r26, 0x05	; 5
     d6e:	82 e0       	ldi	r24, 0x02	; 2
     d70:	8c 93       	st	X, r24
     d72:	80 91 9f 21 	lds	r24, 0x219F
     d76:	90 91 a0 21 	lds	r25, 0x21A0
     d7a:	82 60       	ori	r24, 0x02	; 2
     d7c:	80 93 9f 21 	sts	0x219F, r24
     d80:	90 93 a0 21 	sts	0x21A0, r25
     d84:	e7 55       	subi	r30, 0x57	; 87
     d86:	fe 4d       	sbci	r31, 0xDE	; 222
     d88:	10 82       	st	Z, r1
     d8a:	e2 2f       	mov	r30, r18
     d8c:	ae c0       	rjmp	.+348    	; 0xeea <process_sensor+0x52e>
     d8e:	52 ff       	sbrs	r21, 2
     d90:	0e c0       	rjmp	.+28     	; 0xdae <process_sensor+0x3f2>
     d92:	ed 81       	ldd	r30, Y+5	; 0x05
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	ef 53       	subi	r30, 0x3F	; 63
     d98:	fe 4d       	sbci	r31, 0xDE	; 222
     d9a:	80 e8       	ldi	r24, 0x80	; 128
     d9c:	80 83       	st	Z, r24
     d9e:	80 e2       	ldi	r24, 0x20	; 32
     da0:	88 83       	st	Y, r24
     da2:	80 91 9f 21 	lds	r24, 0x219F
     da6:	90 91 a0 21 	lds	r25, 0x21A0
     daa:	90 61       	ori	r25, 0x10	; 16
     dac:	4a c0       	rjmp	.+148    	; 0xe42 <process_sensor+0x486>
     dae:	c5 01       	movw	r24, r10
     db0:	b7 fe       	sbrs	r11, 7
     db2:	02 c0       	rjmp	.+4      	; 0xdb8 <process_sensor+0x3fc>
     db4:	80 e0       	ldi	r24, 0x00	; 0
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	f8 01       	movw	r30, r16
     dba:	ee 0f       	add	r30, r30
     dbc:	ff 1f       	adc	r31, r31
     dbe:	40 91 9f 21 	lds	r20, 0x219F
     dc2:	50 91 a0 21 	lds	r21, 0x21A0
     dc6:	86 17       	cp	r24, r22
     dc8:	97 07       	cpc	r25, r23
     dca:	70 f4       	brcc	.+28     	; 0xde8 <process_sensor+0x42c>
     dcc:	e0 0f       	add	r30, r16
     dce:	f1 1f       	adc	r31, r17
     dd0:	ee 0f       	add	r30, r30
     dd2:	ff 1f       	adc	r31, r31
     dd4:	e9 55       	subi	r30, 0x59	; 89
     dd6:	fe 4d       	sbci	r31, 0xDE	; 222
     dd8:	88 e0       	ldi	r24, 0x08	; 8
     dda:	80 83       	st	Z, r24
     ddc:	54 60       	ori	r21, 0x04	; 4
     dde:	40 93 9f 21 	sts	0x219F, r20
     de2:	50 93 a0 21 	sts	0x21A0, r21
     de6:	31 c0       	rjmp	.+98     	; 0xe4a <process_sensor+0x48e>
     de8:	41 60       	ori	r20, 0x01	; 1
     dea:	40 93 9f 21 	sts	0x219F, r20
     dee:	50 93 a0 21 	sts	0x21A0, r21
     df2:	e0 0f       	add	r30, r16
     df4:	f1 1f       	adc	r31, r17
     df6:	ee 0f       	add	r30, r30
     df8:	ff 1f       	adc	r31, r31
     dfa:	e7 55       	subi	r30, 0x57	; 87
     dfc:	fe 4d       	sbci	r31, 0xDE	; 222
     dfe:	90 81       	ld	r25, Z
     e00:	80 91 88 21 	lds	r24, 0x2188
     e04:	98 17       	cp	r25, r24
     e06:	10 f4       	brcc	.+4      	; 0xe0c <process_sensor+0x450>
     e08:	9f 5f       	subi	r25, 0xFF	; 255
     e0a:	90 83       	st	Z, r25
     e0c:	90 91 8a 21 	lds	r25, 0x218A
     e10:	99 23       	and	r25, r25
     e12:	71 f0       	breq	.+28     	; 0xe30 <process_sensor+0x474>
     e14:	f8 01       	movw	r30, r16
     e16:	ee 0f       	add	r30, r30
     e18:	ff 1f       	adc	r31, r31
     e1a:	e0 0f       	add	r30, r16
     e1c:	f1 1f       	adc	r31, r17
     e1e:	ee 0f       	add	r30, r30
     e20:	ff 1f       	adc	r31, r31
     e22:	e9 55       	subi	r30, 0x59	; 89
     e24:	fe 4d       	sbci	r31, 0xDE	; 222
     e26:	81 81       	ldd	r24, Z+1	; 0x01
     e28:	89 17       	cp	r24, r25
     e2a:	20 f4       	brcc	.+8      	; 0xe34 <process_sensor+0x478>
     e2c:	8f 0d       	add	r24, r15
     e2e:	81 83       	std	Z+1, r24	; 0x01
     e30:	40 e0       	ldi	r20, 0x00	; 0
     e32:	0c c0       	rjmp	.+24     	; 0xe4c <process_sensor+0x490>
     e34:	87 2d       	mov	r24, r7
     e36:	81 dd       	rcall	.-1278   	; 0x93a <start_cal_sensor>
     e38:	80 91 9f 21 	lds	r24, 0x219F
     e3c:	90 91 a0 21 	lds	r25, 0x21A0
     e40:	92 60       	ori	r25, 0x02	; 2
     e42:	80 93 9f 21 	sts	0x219F, r24
     e46:	90 93 a0 21 	sts	0x21A0, r25
     e4a:	41 e0       	ldi	r20, 0x01	; 1
     e4c:	80 91 89 21 	lds	r24, 0x2189
     e50:	80 93 c0 21 	sts	0x21C0, r24
     e54:	8a c0       	rjmp	.+276    	; 0xf6a <process_sensor+0x5ae>
     e56:	80 91 89 21 	lds	r24, 0x2189
     e5a:	80 93 c0 21 	sts	0x21C0, r24
     e5e:	df 01       	movw	r26, r30
     e60:	aa 0f       	add	r26, r26
     e62:	bb 1f       	adc	r27, r27
     e64:	a7 55       	subi	r26, 0x57	; 87
     e66:	be 4d       	sbci	r27, 0xDE	; 222
     e68:	8c 91       	ld	r24, X
     e6a:	88 23       	and	r24, r24
     e6c:	89 f1       	breq	.+98     	; 0xed0 <process_sensor+0x514>
     e6e:	c5 01       	movw	r24, r10
     e70:	b7 fe       	sbrs	r11, 7
     e72:	02 c0       	rjmp	.+4      	; 0xe78 <process_sensor+0x4bc>
     e74:	80 e0       	ldi	r24, 0x00	; 0
     e76:	90 e0       	ldi	r25, 0x00	; 0
     e78:	40 91 9f 21 	lds	r20, 0x219F
     e7c:	50 91 a0 21 	lds	r21, 0x21A0
     e80:	68 17       	cp	r22, r24
     e82:	79 07       	cpc	r23, r25
     e84:	90 f4       	brcc	.+36     	; 0xeaa <process_sensor+0x4ee>
     e86:	f8 01       	movw	r30, r16
     e88:	ee 0f       	add	r30, r30
     e8a:	ff 1f       	adc	r31, r31
     e8c:	e0 0f       	add	r30, r16
     e8e:	f1 1f       	adc	r31, r17
     e90:	ee 0f       	add	r30, r30
     e92:	ff 1f       	adc	r31, r31
     e94:	e9 55       	subi	r30, 0x59	; 89
     e96:	fe 4d       	sbci	r31, 0xDE	; 222
     e98:	80 e1       	ldi	r24, 0x10	; 16
     e9a:	80 83       	st	Z, r24
     e9c:	41 60       	ori	r20, 0x01	; 1
     e9e:	40 93 9f 21 	sts	0x219F, r20
     ea2:	50 93 a0 21 	sts	0x21A0, r21
     ea6:	40 e0       	ldi	r20, 0x00	; 0
     ea8:	06 c0       	rjmp	.+12     	; 0xeb6 <process_sensor+0x4fa>
     eaa:	54 60       	ori	r21, 0x04	; 4
     eac:	40 93 9f 21 	sts	0x219F, r20
     eb0:	50 93 a0 21 	sts	0x21A0, r21
     eb4:	41 e0       	ldi	r20, 0x01	; 1
     eb6:	f8 01       	movw	r30, r16
     eb8:	ee 0f       	add	r30, r30
     eba:	ff 1f       	adc	r31, r31
     ebc:	e0 0f       	add	r30, r16
     ebe:	f1 1f       	adc	r31, r17
     ec0:	ee 0f       	add	r30, r30
     ec2:	ff 1f       	adc	r31, r31
     ec4:	e7 55       	subi	r30, 0x57	; 87
     ec6:	fe 4d       	sbci	r31, 0xDE	; 222
     ec8:	80 81       	ld	r24, Z
     eca:	81 50       	subi	r24, 0x01	; 1
     ecc:	80 83       	st	Z, r24
     ece:	4d c0       	rjmp	.+154    	; 0xf6a <process_sensor+0x5ae>
     ed0:	ed 81       	ldd	r30, Y+5	; 0x05
     ed2:	82 e0       	ldi	r24, 0x02	; 2
     ed4:	88 83       	st	Y, r24
     ed6:	80 91 9f 21 	lds	r24, 0x219F
     eda:	90 91 a0 21 	lds	r25, 0x21A0
     ede:	82 60       	ori	r24, 0x02	; 2
     ee0:	80 93 9f 21 	sts	0x219F, r24
     ee4:	90 93 a0 21 	sts	0x21A0, r25
     ee8:	1c 92       	st	X, r1
     eea:	f0 e0       	ldi	r31, 0x00	; 0
     eec:	ef 53       	subi	r30, 0x3F	; 63
     eee:	fe 4d       	sbci	r31, 0xDE	; 222
     ef0:	80 e8       	ldi	r24, 0x80	; 128
     ef2:	80 83       	st	Z, r24
     ef4:	39 c0       	rjmp	.+114    	; 0xf68 <process_sensor+0x5ac>
     ef6:	8d 81       	ldd	r24, Y+5	; 0x05
     ef8:	a8 2f       	mov	r26, r24
     efa:	b0 e0       	ldi	r27, 0x00	; 0
     efc:	af 53       	subi	r26, 0x3F	; 63
     efe:	be 4d       	sbci	r27, 0xDE	; 222
     f00:	9c 91       	ld	r25, X
     f02:	9f 5f       	subi	r25, 0xFF	; 255
     f04:	9c 93       	st	X, r25
     f06:	52 fd       	sbrc	r21, 2
     f08:	18 c0       	rjmp	.+48     	; 0xf3a <process_sensor+0x57e>
     f0a:	97 ff       	sbrs	r25, 7
     f0c:	03 c0       	rjmp	.+6      	; 0xf14 <process_sensor+0x558>
     f0e:	80 e1       	ldi	r24, 0x10	; 16
     f10:	88 83       	st	Y, r24
     f12:	2a c0       	rjmp	.+84     	; 0xf68 <process_sensor+0x5ac>
     f14:	82 e0       	ldi	r24, 0x02	; 2
     f16:	88 83       	st	Y, r24
     f18:	80 91 9f 21 	lds	r24, 0x219F
     f1c:	90 91 a0 21 	lds	r25, 0x21A0
     f20:	82 60       	ori	r24, 0x02	; 2
     f22:	80 93 9f 21 	sts	0x219F, r24
     f26:	90 93 a0 21 	sts	0x21A0, r25
     f2a:	ee 0f       	add	r30, r30
     f2c:	ff 1f       	adc	r31, r31
     f2e:	e7 55       	subi	r30, 0x57	; 87
     f30:	fe 4d       	sbci	r31, 0xDE	; 222
     f32:	10 82       	st	Z, r1
     f34:	80 e8       	ldi	r24, 0x80	; 128
     f36:	8c 93       	st	X, r24
     f38:	17 c0       	rjmp	.+46     	; 0xf68 <process_sensor+0x5ac>
     f3a:	80 91 8d 21 	lds	r24, 0x218D
     f3e:	98 17       	cp	r25, r24
     f40:	40 f0       	brcs	.+16     	; 0xf52 <process_sensor+0x596>
     f42:	87 2d       	mov	r24, r7
     f44:	fa dc       	rcall	.-1548   	; 0x93a <start_cal_sensor>
     f46:	80 91 9f 21 	lds	r24, 0x219F
     f4a:	90 91 a0 21 	lds	r25, 0x21A0
     f4e:	90 61       	ori	r25, 0x10	; 16
     f50:	05 c0       	rjmp	.+10     	; 0xf5c <process_sensor+0x5a0>
     f52:	80 91 9f 21 	lds	r24, 0x219F
     f56:	90 91 a0 21 	lds	r25, 0x21A0
     f5a:	94 60       	ori	r25, 0x04	; 4
     f5c:	80 93 9f 21 	sts	0x219F, r24
     f60:	90 93 a0 21 	sts	0x21A0, r25
     f64:	41 e0       	ldi	r20, 0x01	; 1
     f66:	01 c0       	rjmp	.+2      	; 0xf6a <process_sensor+0x5ae>
     f68:	40 e0       	ldi	r20, 0x00	; 0
     f6a:	84 2f       	mov	r24, r20
     f6c:	cd b7       	in	r28, 0x3d	; 61
     f6e:	de b7       	in	r29, 0x3e	; 62
     f70:	ee e0       	ldi	r30, 0x0E	; 14
     f72:	0c 94 8f 1e 	jmp	0x3d1e	; 0x3d1e <__epilogue_restores__+0x8>

00000f76 <burst_init>:
     f76:	fc 01       	movw	r30, r24
     f78:	00 97       	sbiw	r24, 0x00	; 0
     f7a:	09 f0       	breq	.+2      	; 0xf7e <burst_init+0x8>
     f7c:	19 95       	eicall
     f7e:	08 95       	ret

00000f80 <burst_reset>:
     f80:	10 92 c5 21 	sts	0x21C5, r1
     f84:	10 92 c6 21 	sts	0x21C6, r1
     f88:	10 92 c9 21 	sts	0x21C9, r1
     f8c:	10 92 ca 21 	sts	0x21CA, r1
     f90:	10 92 c7 21 	sts	0x21C7, r1
     f94:	10 92 c8 21 	sts	0x21C8, r1
     f98:	10 92 cb 21 	sts	0x21CB, r1
     f9c:	10 92 cc 21 	sts	0x21CC, r1
     fa0:	08 95       	ret

00000fa2 <burst>:
     fa2:	80 91 c7 21 	lds	r24, 0x21C7
     fa6:	90 91 c5 21 	lds	r25, 0x21C5
     faa:	89 2b       	or	r24, r25
     fac:	41 f0       	breq	.+16     	; 0xfbe <burst+0x1c>
     fae:	e0 91 85 21 	lds	r30, 0x2185
     fb2:	f0 91 86 21 	lds	r31, 0x2186
     fb6:	30 97       	sbiw	r30, 0x00	; 0
     fb8:	11 f0       	breq	.+4      	; 0xfbe <burst+0x1c>
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	19 95       	eicall
     fbe:	80 91 c8 21 	lds	r24, 0x21C8
     fc2:	90 91 c6 21 	lds	r25, 0x21C6
     fc6:	89 2b       	or	r24, r25
     fc8:	41 f0       	breq	.+16     	; 0xfda <burst+0x38>
     fca:	e0 91 85 21 	lds	r30, 0x2185
     fce:	f0 91 86 21 	lds	r31, 0x2186
     fd2:	30 97       	sbiw	r30, 0x00	; 0
     fd4:	11 f0       	breq	.+4      	; 0xfda <burst+0x38>
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	19 95       	eicall
     fda:	08 95       	ret

00000fdc <adc_handler>:
		retval = (int8_t)((-0.0474 * ntc_sample) + 53.3);
	} else {
		retval = (int8_t)((-0.0777 * ntc_sample) + 65.1);
	}
	return retval;
}
     fdc:	61 30       	cpi	r22, 0x01	; 1
     fde:	69 f5       	brne	.+90     	; 0x103a <adc_handler+0x5e>
     fe0:	80 91 ce 21 	lds	r24, 0x21CE
     fe4:	8f 5f       	subi	r24, 0xFF	; 255
     fe6:	80 93 ce 21 	sts	0x21CE, r24
     fea:	81 30       	cpi	r24, 0x01	; 1
     fec:	39 f4       	brne	.+14     	; 0xffc <adc_handler+0x20>
     fee:	40 93 cf 21 	sts	0x21CF, r20
     ff2:	50 93 d0 21 	sts	0x21D0, r21
     ff6:	10 92 d3 21 	sts	0x21D3, r1
     ffa:	0c c0       	rjmp	.+24     	; 0x1014 <adc_handler+0x38>
     ffc:	80 91 cf 21 	lds	r24, 0x21CF
    1000:	90 91 d0 21 	lds	r25, 0x21D0
    1004:	48 0f       	add	r20, r24
    1006:	59 1f       	adc	r21, r25
    1008:	56 95       	lsr	r21
    100a:	47 95       	ror	r20
    100c:	40 93 cf 21 	sts	0x21CF, r20
    1010:	50 93 d0 21 	sts	0x21D0, r21
    1014:	80 91 ce 21 	lds	r24, 0x21CE
    1018:	84 30       	cpi	r24, 0x04	; 4
    101a:	31 f4       	brne	.+12     	; 0x1028 <adc_handler+0x4c>
    101c:	10 92 ce 21 	sts	0x21CE, r1
    1020:	81 e0       	ldi	r24, 0x01	; 1
    1022:	80 93 d3 21 	sts	0x21D3, r24
    1026:	08 95       	ret
    1028:	9f b7       	in	r25, 0x3f	; 63
    102a:	f8 94       	cli
    102c:	e0 e0       	ldi	r30, 0x00	; 0
    102e:	f2 e0       	ldi	r31, 0x02	; 2
    1030:	80 81       	ld	r24, Z
    1032:	84 60       	ori	r24, 0x04	; 4
    1034:	80 83       	st	Z, r24
    1036:	9f bf       	out	0x3f, r25	; 63
    1038:	08 95       	ret
    103a:	62 30       	cpi	r22, 0x02	; 2
    103c:	61 f5       	brne	.+88     	; 0x1096 <adc_handler+0xba>
    103e:	80 91 cd 21 	lds	r24, 0x21CD
    1042:	8f 5f       	subi	r24, 0xFF	; 255
    1044:	80 93 cd 21 	sts	0x21CD, r24
    1048:	81 30       	cpi	r24, 0x01	; 1
    104a:	39 f4       	brne	.+14     	; 0x105a <adc_handler+0x7e>
    104c:	40 93 d1 21 	sts	0x21D1, r20
    1050:	50 93 d2 21 	sts	0x21D2, r21
    1054:	10 92 d4 21 	sts	0x21D4, r1
    1058:	0c c0       	rjmp	.+24     	; 0x1072 <adc_handler+0x96>
    105a:	80 91 d1 21 	lds	r24, 0x21D1
    105e:	90 91 d2 21 	lds	r25, 0x21D2
    1062:	48 0f       	add	r20, r24
    1064:	59 1f       	adc	r21, r25
    1066:	56 95       	lsr	r21
    1068:	47 95       	ror	r20
    106a:	40 93 d1 21 	sts	0x21D1, r20
    106e:	50 93 d2 21 	sts	0x21D2, r21
    1072:	80 91 cd 21 	lds	r24, 0x21CD
    1076:	84 30       	cpi	r24, 0x04	; 4
    1078:	31 f4       	brne	.+12     	; 0x1086 <adc_handler+0xaa>
    107a:	10 92 cd 21 	sts	0x21CD, r1
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	80 93 d4 21 	sts	0x21D4, r24
    1084:	08 95       	ret
    1086:	9f b7       	in	r25, 0x3f	; 63
    1088:	f8 94       	cli
    108a:	e0 e0       	ldi	r30, 0x00	; 0
    108c:	f2 e0       	ldi	r31, 0x02	; 2
    108e:	80 81       	ld	r24, Z
    1090:	88 60       	ori	r24, 0x08	; 8
    1092:	80 83       	st	Z, r24
    1094:	9f bf       	out	0x3f, r25	; 63
    1096:	08 95       	ret

00001098 <lightsensor_data_is_ready>:
    1098:	9f b7       	in	r25, 0x3f	; 63
    109a:	f8 94       	cli
    109c:	80 91 d3 21 	lds	r24, 0x21D3
    10a0:	88 23       	and	r24, r24
    10a2:	21 f0       	breq	.+8      	; 0x10ac <lightsensor_data_is_ready+0x14>
    10a4:	10 92 d3 21 	sts	0x21D3, r1
    10a8:	9f bf       	out	0x3f, r25	; 63
    10aa:	08 95       	ret
    10ac:	9f bf       	out	0x3f, r25	; 63
    10ae:	08 95       	ret

000010b0 <adc_sensors_init>:
    10b0:	1f 93       	push	r17
    10b2:	cf 93       	push	r28
    10b4:	df 93       	push	r29
    10b6:	cd b7       	in	r28, 0x3d	; 61
    10b8:	de b7       	in	r29, 0x3e	; 62
    10ba:	2b 97       	sbiw	r28, 0x0b	; 11
    10bc:	cd bf       	out	0x3d, r28	; 61
    10be:	de bf       	out	0x3e, r29	; 62
    10c0:	be 01       	movw	r22, r28
    10c2:	6f 5f       	subi	r22, 0xFF	; 255
    10c4:	7f 4f       	sbci	r23, 0xFF	; 255
    10c6:	80 e0       	ldi	r24, 0x00	; 0
    10c8:	92 e0       	ldi	r25, 0x02	; 2
    10ca:	bb d5       	rcall	.+2934   	; 0x1c42 <adc_read_configuration>
    10cc:	ae 01       	movw	r20, r28
    10ce:	48 5f       	subi	r20, 0xF8	; 248
    10d0:	5f 4f       	sbci	r21, 0xFF	; 255
    10d2:	61 e0       	ldi	r22, 0x01	; 1
    10d4:	80 e0       	ldi	r24, 0x00	; 0
    10d6:	92 e0       	ldi	r25, 0x02	; 2
    10d8:	10 d6       	rcall	.+3104   	; 0x1cfa <adcch_read_configuration>
    10da:	8a 81       	ldd	r24, Y+2	; 0x02
    10dc:	9b 81       	ldd	r25, Y+3	; 0x03
    10de:	9f 78       	andi	r25, 0x8F	; 143
    10e0:	90 61       	ori	r25, 0x10	; 16
    10e2:	9b 83       	std	Y+3, r25	; 0x03
    10e4:	96 e0       	ldi	r25, 0x06	; 6
    10e6:	9d 83       	std	Y+5, r25	; 0x05
    10e8:	81 7e       	andi	r24, 0xE1	; 225
    10ea:	80 61       	ori	r24, 0x10	; 16
    10ec:	8a 83       	std	Y+2, r24	; 0x02
    10ee:	1c 82       	std	Y+4, r1	; 0x04
    10f0:	be 01       	movw	r22, r28
    10f2:	6f 5f       	subi	r22, 0xFF	; 255
    10f4:	7f 4f       	sbci	r23, 0xFF	; 255
    10f6:	80 e0       	ldi	r24, 0x00	; 0
    10f8:	92 e0       	ldi	r25, 0x02	; 2
    10fa:	4f d5       	rcall	.+2718   	; 0x1b9a <adc_write_configuration>
    10fc:	6e ee       	ldi	r22, 0xEE	; 238
    10fe:	77 e0       	ldi	r23, 0x07	; 7
    1100:	80 e0       	ldi	r24, 0x00	; 0
    1102:	92 e0       	ldi	r25, 0x02	; 2
    1104:	4d d3       	rcall	.+1690   	; 0x17a0 <adc_set_callback>
    1106:	11 e0       	ldi	r17, 0x01	; 1
    1108:	18 87       	std	Y+8, r17	; 0x08
    110a:	19 86       	std	Y+9, r1	; 0x09
    110c:	8a 85       	ldd	r24, Y+10	; 0x0a
    110e:	80 7f       	andi	r24, 0xF0	; 240
    1110:	81 60       	ori	r24, 0x01	; 1
    1112:	8a 87       	std	Y+10, r24	; 0x0a
    1114:	ae 01       	movw	r20, r28
    1116:	48 5f       	subi	r20, 0xF8	; 248
    1118:	5f 4f       	sbci	r21, 0xFF	; 255
    111a:	61 e0       	ldi	r22, 0x01	; 1
    111c:	80 e0       	ldi	r24, 0x00	; 0
    111e:	92 e0       	ldi	r25, 0x02	; 2
    1120:	b3 d5       	rcall	.+2918   	; 0x1c88 <adcch_write_configuration>
    1122:	18 87       	std	Y+8, r17	; 0x08
    1124:	88 e0       	ldi	r24, 0x08	; 8
    1126:	89 87       	std	Y+9, r24	; 0x09
    1128:	ae 01       	movw	r20, r28
    112a:	48 5f       	subi	r20, 0xF8	; 248
    112c:	5f 4f       	sbci	r21, 0xFF	; 255
    112e:	62 e0       	ldi	r22, 0x02	; 2
    1130:	80 e0       	ldi	r24, 0x00	; 0
    1132:	92 e0       	ldi	r25, 0x02	; 2
    1134:	a9 d5       	rcall	.+2898   	; 0x1c88 <adcch_write_configuration>
    1136:	80 e0       	ldi	r24, 0x00	; 0
    1138:	92 e0       	ldi	r25, 0x02	; 2
    113a:	88 d3       	rcall	.+1808   	; 0x184c <adc_enable>
    113c:	2b 96       	adiw	r28, 0x0b	; 11
    113e:	cd bf       	out	0x3d, r28	; 61
    1140:	de bf       	out	0x3e, r29	; 62
    1142:	df 91       	pop	r29
    1144:	cf 91       	pop	r28
    1146:	1f 91       	pop	r17
    1148:	08 95       	ret

0000114a <lightsensor_get_raw_value>:
 * \retval the raw ADC value from the current ntc_sensor_sample
 */
int16_t lightsensor_get_raw_value(void)
{
	return light_sensor_sample;
}
    114a:	80 91 cf 21 	lds	r24, 0x21CF
    114e:	90 91 d0 21 	lds	r25, 0x21D0
    1152:	08 95       	ret

00001154 <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
    1154:	bf 92       	push	r11
    1156:	cf 92       	push	r12
    1158:	df 92       	push	r13
    115a:	ef 92       	push	r14
    115c:	ff 92       	push	r15
    115e:	0f 93       	push	r16
    1160:	1f 93       	push	r17
    1162:	cf 93       	push	r28
    1164:	df 93       	push	r29
    1166:	1f 92       	push	r1
    1168:	cd b7       	in	r28, 0x3d	; 61
    116a:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    116c:	88 e0       	ldi	r24, 0x08	; 8
    116e:	80 93 06 06 	sts	0x0606, r24
    1172:	80 e0       	ldi	r24, 0x00	; 0
    1174:	90 e0       	ldi	r25, 0x00	; 0
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	do { barrier(); } while (--n);
    1176:	01 96       	adiw	r24, 0x01	; 1
    1178:	85 33       	cpi	r24, 0x35	; 53
    117a:	91 05       	cpc	r25, r1
    117c:	e1 f7       	brne	.-8      	; 0x1176 <st7565r_init+0x22>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    117e:	88 e0       	ldi	r24, 0x08	; 8
    1180:	80 93 05 06 	sts	0x0605, r24
    1184:	80 e0       	ldi	r24, 0x00	; 0
    1186:	90 e0       	ldi	r25, 0x00	; 0
    1188:	01 96       	adiw	r24, 0x01	; 1
    118a:	85 33       	cpi	r24, 0x35	; 53
    118c:	91 05       	cpc	r25, r1
    118e:	e1 f7       	brne	.-8      	; 0x1188 <st7565r_init+0x34>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
    1190:	0f 2e       	mov	r0, r31
    1192:	fb e2       	ldi	r31, 0x2B	; 43
    1194:	bf 2e       	mov	r11, r31
    1196:	f0 2d       	mov	r31, r0
    1198:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
    119a:	80 ea       	ldi	r24, 0xA0	; 160
    119c:	99 e0       	ldi	r25, 0x09	; 9
    119e:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
    11a2:	c1 2c       	mov	r12, r1
    11a4:	d1 2c       	mov	r13, r1
    11a6:	76 01       	movw	r14, r12
    11a8:	00 e4       	ldi	r16, 0x40	; 64
    11aa:	12 e4       	ldi	r17, 0x42	; 66
    11ac:	2f e0       	ldi	r18, 0x0F	; 15
    11ae:	30 e0       	ldi	r19, 0x00	; 0
    11b0:	43 e0       	ldi	r20, 0x03	; 3
    11b2:	be 01       	movw	r22, r28
    11b4:	6f 5f       	subi	r22, 0xFF	; 255
    11b6:	7f 4f       	sbci	r23, 0xFF	; 255
    11b8:	80 ea       	ldi	r24, 0xA0	; 160
    11ba:	99 e0       	ldi	r25, 0x09	; 9
    11bc:	0e 94 aa 11 	call	0x2354	; 0x2354 <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    11c0:	00 e6       	ldi	r16, 0x60	; 96
    11c2:	16 e0       	ldi	r17, 0x06	; 6
    11c4:	ff 24       	eor	r15, r15
    11c6:	f3 94       	inc	r15
    11c8:	f8 01       	movw	r30, r16
    11ca:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    11cc:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    11ce:	be 01       	movw	r22, r28
    11d0:	6f 5f       	subi	r22, 0xFF	; 255
    11d2:	7f 4f       	sbci	r23, 0xFF	; 255
    11d4:	80 ea       	ldi	r24, 0xA0	; 160
    11d6:	99 e0       	ldi	r25, 0x09	; 9
    11d8:	0e 94 c4 11 	call	0x2388	; 0x2388 <usart_spi_select_device>
    11dc:	f8 01       	movw	r30, r16
    11de:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    11e0:	e0 ea       	ldi	r30, 0xA0	; 160
    11e2:	f9 e0       	ldi	r31, 0x09	; 9
    11e4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    11e6:	85 ff       	sbrs	r24, 5
    11e8:	fd cf       	rjmp	.-6      	; 0x11e4 <st7565r_init+0x90>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    11ea:	80 ea       	ldi	r24, 0xA0	; 160
    11ec:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    11f0:	e0 ea       	ldi	r30, 0xA0	; 160
    11f2:	f9 e0       	ldi	r31, 0x09	; 9
    11f4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    11f6:	86 ff       	sbrs	r24, 6
    11f8:	fd cf       	rjmp	.-6      	; 0x11f4 <st7565r_init+0xa0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    11fa:	e0 ea       	ldi	r30, 0xA0	; 160
    11fc:	f9 e0       	ldi	r31, 0x09	; 9
    11fe:	80 e4       	ldi	r24, 0x40	; 64
    1200:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1202:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1204:	be 01       	movw	r22, r28
    1206:	6f 5f       	subi	r22, 0xFF	; 255
    1208:	7f 4f       	sbci	r23, 0xFF	; 255
    120a:	80 ea       	ldi	r24, 0xA0	; 160
    120c:	99 e0       	ldi	r25, 0x09	; 9
    120e:	0e 94 da 11 	call	0x23b4	; 0x23b4 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1212:	8b e2       	ldi	r24, 0x2B	; 43
    1214:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1216:	be 01       	movw	r22, r28
    1218:	6f 5f       	subi	r22, 0xFF	; 255
    121a:	7f 4f       	sbci	r23, 0xFF	; 255
    121c:	80 ea       	ldi	r24, 0xA0	; 160
    121e:	99 e0       	ldi	r25, 0x09	; 9
    1220:	0e 94 c4 11 	call	0x2388	; 0x2388 <usart_spi_select_device>
    1224:	81 e0       	ldi	r24, 0x01	; 1
    1226:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    122a:	e0 ea       	ldi	r30, 0xA0	; 160
    122c:	f9 e0       	ldi	r31, 0x09	; 9
    122e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1230:	85 ff       	sbrs	r24, 5
    1232:	fd cf       	rjmp	.-6      	; 0x122e <st7565r_init+0xda>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1234:	86 ea       	ldi	r24, 0xA6	; 166
    1236:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    123a:	e0 ea       	ldi	r30, 0xA0	; 160
    123c:	f9 e0       	ldi	r31, 0x09	; 9
    123e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1240:	86 ff       	sbrs	r24, 6
    1242:	fd cf       	rjmp	.-6      	; 0x123e <st7565r_init+0xea>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1244:	e0 ea       	ldi	r30, 0xA0	; 160
    1246:	f9 e0       	ldi	r31, 0x09	; 9
    1248:	80 e4       	ldi	r24, 0x40	; 64
    124a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    124c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    124e:	be 01       	movw	r22, r28
    1250:	6f 5f       	subi	r22, 0xFF	; 255
    1252:	7f 4f       	sbci	r23, 0xFF	; 255
    1254:	80 ea       	ldi	r24, 0xA0	; 160
    1256:	99 e0       	ldi	r25, 0x09	; 9
    1258:	0e 94 da 11 	call	0x23b4	; 0x23b4 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    125c:	8b e2       	ldi	r24, 0x2B	; 43
    125e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1260:	be 01       	movw	r22, r28
    1262:	6f 5f       	subi	r22, 0xFF	; 255
    1264:	7f 4f       	sbci	r23, 0xFF	; 255
    1266:	80 ea       	ldi	r24, 0xA0	; 160
    1268:	99 e0       	ldi	r25, 0x09	; 9
    126a:	0e 94 c4 11 	call	0x2388	; 0x2388 <usart_spi_select_device>
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1274:	e0 ea       	ldi	r30, 0xA0	; 160
    1276:	f9 e0       	ldi	r31, 0x09	; 9
    1278:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    127a:	85 ff       	sbrs	r24, 5
    127c:	fd cf       	rjmp	.-6      	; 0x1278 <st7565r_init+0x124>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    127e:	88 ec       	ldi	r24, 0xC8	; 200
    1280:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1284:	e0 ea       	ldi	r30, 0xA0	; 160
    1286:	f9 e0       	ldi	r31, 0x09	; 9
    1288:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    128a:	86 ff       	sbrs	r24, 6
    128c:	fd cf       	rjmp	.-6      	; 0x1288 <st7565r_init+0x134>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    128e:	e0 ea       	ldi	r30, 0xA0	; 160
    1290:	f9 e0       	ldi	r31, 0x09	; 9
    1292:	80 e4       	ldi	r24, 0x40	; 64
    1294:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1296:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1298:	be 01       	movw	r22, r28
    129a:	6f 5f       	subi	r22, 0xFF	; 255
    129c:	7f 4f       	sbci	r23, 0xFF	; 255
    129e:	80 ea       	ldi	r24, 0xA0	; 160
    12a0:	99 e0       	ldi	r25, 0x09	; 9
    12a2:	0e 94 da 11 	call	0x23b4	; 0x23b4 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    12a6:	8b e2       	ldi	r24, 0x2B	; 43
    12a8:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    12aa:	be 01       	movw	r22, r28
    12ac:	6f 5f       	subi	r22, 0xFF	; 255
    12ae:	7f 4f       	sbci	r23, 0xFF	; 255
    12b0:	80 ea       	ldi	r24, 0xA0	; 160
    12b2:	99 e0       	ldi	r25, 0x09	; 9
    12b4:	0e 94 c4 11 	call	0x2388	; 0x2388 <usart_spi_select_device>
    12b8:	81 e0       	ldi	r24, 0x01	; 1
    12ba:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    12be:	e0 ea       	ldi	r30, 0xA0	; 160
    12c0:	f9 e0       	ldi	r31, 0x09	; 9
    12c2:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    12c4:	85 ff       	sbrs	r24, 5
    12c6:	fd cf       	rjmp	.-6      	; 0x12c2 <st7565r_init+0x16e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    12c8:	82 ea       	ldi	r24, 0xA2	; 162
    12ca:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    12ce:	e0 ea       	ldi	r30, 0xA0	; 160
    12d0:	f9 e0       	ldi	r31, 0x09	; 9
    12d2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    12d4:	86 ff       	sbrs	r24, 6
    12d6:	fd cf       	rjmp	.-6      	; 0x12d2 <st7565r_init+0x17e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    12d8:	e0 ea       	ldi	r30, 0xA0	; 160
    12da:	f9 e0       	ldi	r31, 0x09	; 9
    12dc:	80 e4       	ldi	r24, 0x40	; 64
    12de:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    12e0:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    12e2:	be 01       	movw	r22, r28
    12e4:	6f 5f       	subi	r22, 0xFF	; 255
    12e6:	7f 4f       	sbci	r23, 0xFF	; 255
    12e8:	80 ea       	ldi	r24, 0xA0	; 160
    12ea:	99 e0       	ldi	r25, 0x09	; 9
    12ec:	0e 94 da 11 	call	0x23b4	; 0x23b4 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    12f0:	8b e2       	ldi	r24, 0x2B	; 43
    12f2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    12f4:	be 01       	movw	r22, r28
    12f6:	6f 5f       	subi	r22, 0xFF	; 255
    12f8:	7f 4f       	sbci	r23, 0xFF	; 255
    12fa:	80 ea       	ldi	r24, 0xA0	; 160
    12fc:	99 e0       	ldi	r25, 0x09	; 9
    12fe:	0e 94 c4 11 	call	0x2388	; 0x2388 <usart_spi_select_device>
    1302:	81 e0       	ldi	r24, 0x01	; 1
    1304:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1308:	e0 ea       	ldi	r30, 0xA0	; 160
    130a:	f9 e0       	ldi	r31, 0x09	; 9
    130c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    130e:	85 ff       	sbrs	r24, 5
    1310:	fd cf       	rjmp	.-6      	; 0x130c <st7565r_init+0x1b8>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1312:	8f e2       	ldi	r24, 0x2F	; 47
    1314:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1318:	e0 ea       	ldi	r30, 0xA0	; 160
    131a:	f9 e0       	ldi	r31, 0x09	; 9
    131c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    131e:	86 ff       	sbrs	r24, 6
    1320:	fd cf       	rjmp	.-6      	; 0x131c <st7565r_init+0x1c8>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1322:	e0 ea       	ldi	r30, 0xA0	; 160
    1324:	f9 e0       	ldi	r31, 0x09	; 9
    1326:	80 e4       	ldi	r24, 0x40	; 64
    1328:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    132a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    132c:	be 01       	movw	r22, r28
    132e:	6f 5f       	subi	r22, 0xFF	; 255
    1330:	7f 4f       	sbci	r23, 0xFF	; 255
    1332:	80 ea       	ldi	r24, 0xA0	; 160
    1334:	99 e0       	ldi	r25, 0x09	; 9
    1336:	0e 94 da 11 	call	0x23b4	; 0x23b4 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    133a:	8b e2       	ldi	r24, 0x2B	; 43
    133c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    133e:	be 01       	movw	r22, r28
    1340:	6f 5f       	subi	r22, 0xFF	; 255
    1342:	7f 4f       	sbci	r23, 0xFF	; 255
    1344:	80 ea       	ldi	r24, 0xA0	; 160
    1346:	99 e0       	ldi	r25, 0x09	; 9
    1348:	0e 94 c4 11 	call	0x2388	; 0x2388 <usart_spi_select_device>
    134c:	81 e0       	ldi	r24, 0x01	; 1
    134e:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1352:	e0 ea       	ldi	r30, 0xA0	; 160
    1354:	f9 e0       	ldi	r31, 0x09	; 9
    1356:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1358:	85 ff       	sbrs	r24, 5
    135a:	fd cf       	rjmp	.-6      	; 0x1356 <st7565r_init+0x202>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    135c:	88 ef       	ldi	r24, 0xF8	; 248
    135e:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1362:	e0 ea       	ldi	r30, 0xA0	; 160
    1364:	f9 e0       	ldi	r31, 0x09	; 9
    1366:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1368:	86 ff       	sbrs	r24, 6
    136a:	fd cf       	rjmp	.-6      	; 0x1366 <st7565r_init+0x212>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    136c:	e0 ea       	ldi	r30, 0xA0	; 160
    136e:	f9 e0       	ldi	r31, 0x09	; 9
    1370:	80 e4       	ldi	r24, 0x40	; 64
    1372:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1374:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1376:	be 01       	movw	r22, r28
    1378:	6f 5f       	subi	r22, 0xFF	; 255
    137a:	7f 4f       	sbci	r23, 0xFF	; 255
    137c:	80 ea       	ldi	r24, 0xA0	; 160
    137e:	99 e0       	ldi	r25, 0x09	; 9
    1380:	0e 94 da 11 	call	0x23b4	; 0x23b4 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1384:	8b e2       	ldi	r24, 0x2B	; 43
    1386:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1388:	be 01       	movw	r22, r28
    138a:	6f 5f       	subi	r22, 0xFF	; 255
    138c:	7f 4f       	sbci	r23, 0xFF	; 255
    138e:	80 ea       	ldi	r24, 0xA0	; 160
    1390:	99 e0       	ldi	r25, 0x09	; 9
    1392:	fa d7       	rcall	.+4084   	; 0x2388 <usart_spi_select_device>
    1394:	81 e0       	ldi	r24, 0x01	; 1
    1396:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    139a:	e0 ea       	ldi	r30, 0xA0	; 160
    139c:	f9 e0       	ldi	r31, 0x09	; 9
    139e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    13a0:	85 ff       	sbrs	r24, 5
    13a2:	fd cf       	rjmp	.-6      	; 0x139e <st7565r_init+0x24a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    13a4:	10 92 a0 09 	sts	0x09A0, r1
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    13a8:	e0 ea       	ldi	r30, 0xA0	; 160
    13aa:	f9 e0       	ldi	r31, 0x09	; 9
    13ac:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    13ae:	86 ff       	sbrs	r24, 6
    13b0:	fd cf       	rjmp	.-6      	; 0x13ac <st7565r_init+0x258>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    13b2:	e0 ea       	ldi	r30, 0xA0	; 160
    13b4:	f9 e0       	ldi	r31, 0x09	; 9
    13b6:	80 e4       	ldi	r24, 0x40	; 64
    13b8:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    13ba:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    13bc:	be 01       	movw	r22, r28
    13be:	6f 5f       	subi	r22, 0xFF	; 255
    13c0:	7f 4f       	sbci	r23, 0xFF	; 255
    13c2:	80 ea       	ldi	r24, 0xA0	; 160
    13c4:	99 e0       	ldi	r25, 0x09	; 9
    13c6:	f6 d7       	rcall	.+4076   	; 0x23b4 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    13c8:	8b e2       	ldi	r24, 0x2B	; 43
    13ca:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    13cc:	be 01       	movw	r22, r28
    13ce:	6f 5f       	subi	r22, 0xFF	; 255
    13d0:	7f 4f       	sbci	r23, 0xFF	; 255
    13d2:	80 ea       	ldi	r24, 0xA0	; 160
    13d4:	99 e0       	ldi	r25, 0x09	; 9
    13d6:	d8 d7       	rcall	.+4016   	; 0x2388 <usart_spi_select_device>
    13d8:	81 e0       	ldi	r24, 0x01	; 1
    13da:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    13de:	e0 ea       	ldi	r30, 0xA0	; 160
    13e0:	f9 e0       	ldi	r31, 0x09	; 9
    13e2:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    13e4:	85 ff       	sbrs	r24, 5
    13e6:	fd cf       	rjmp	.-6      	; 0x13e2 <st7565r_init+0x28e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    13e8:	81 e2       	ldi	r24, 0x21	; 33
    13ea:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    13ee:	e0 ea       	ldi	r30, 0xA0	; 160
    13f0:	f9 e0       	ldi	r31, 0x09	; 9
    13f2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    13f4:	86 ff       	sbrs	r24, 6
    13f6:	fd cf       	rjmp	.-6      	; 0x13f2 <st7565r_init+0x29e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    13f8:	e0 ea       	ldi	r30, 0xA0	; 160
    13fa:	f9 e0       	ldi	r31, 0x09	; 9
    13fc:	80 e4       	ldi	r24, 0x40	; 64
    13fe:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1400:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1402:	be 01       	movw	r22, r28
    1404:	6f 5f       	subi	r22, 0xFF	; 255
    1406:	7f 4f       	sbci	r23, 0xFF	; 255
    1408:	80 ea       	ldi	r24, 0xA0	; 160
    140a:	99 e0       	ldi	r25, 0x09	; 9
    140c:	d3 d7       	rcall	.+4006   	; 0x23b4 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    140e:	8b e2       	ldi	r24, 0x2B	; 43
    1410:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1412:	be 01       	movw	r22, r28
    1414:	6f 5f       	subi	r22, 0xFF	; 255
    1416:	7f 4f       	sbci	r23, 0xFF	; 255
    1418:	80 ea       	ldi	r24, 0xA0	; 160
    141a:	99 e0       	ldi	r25, 0x09	; 9
    141c:	b5 d7       	rcall	.+3946   	; 0x2388 <usart_spi_select_device>
    141e:	81 e0       	ldi	r24, 0x01	; 1
    1420:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1424:	e0 ea       	ldi	r30, 0xA0	; 160
    1426:	f9 e0       	ldi	r31, 0x09	; 9
    1428:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    142a:	85 ff       	sbrs	r24, 5
    142c:	fd cf       	rjmp	.-6      	; 0x1428 <st7565r_init+0x2d4>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    142e:	81 e8       	ldi	r24, 0x81	; 129
    1430:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1434:	e0 ea       	ldi	r30, 0xA0	; 160
    1436:	f9 e0       	ldi	r31, 0x09	; 9
    1438:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    143a:	86 ff       	sbrs	r24, 6
    143c:	fd cf       	rjmp	.-6      	; 0x1438 <st7565r_init+0x2e4>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    143e:	e0 ea       	ldi	r30, 0xA0	; 160
    1440:	f9 e0       	ldi	r31, 0x09	; 9
    1442:	80 e4       	ldi	r24, 0x40	; 64
    1444:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1446:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1448:	be 01       	movw	r22, r28
    144a:	6f 5f       	subi	r22, 0xFF	; 255
    144c:	7f 4f       	sbci	r23, 0xFF	; 255
    144e:	80 ea       	ldi	r24, 0xA0	; 160
    1450:	99 e0       	ldi	r25, 0x09	; 9
    1452:	b0 d7       	rcall	.+3936   	; 0x23b4 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1454:	8b e2       	ldi	r24, 0x2B	; 43
    1456:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1458:	be 01       	movw	r22, r28
    145a:	6f 5f       	subi	r22, 0xFF	; 255
    145c:	7f 4f       	sbci	r23, 0xFF	; 255
    145e:	80 ea       	ldi	r24, 0xA0	; 160
    1460:	99 e0       	ldi	r25, 0x09	; 9
    1462:	92 d7       	rcall	.+3876   	; 0x2388 <usart_spi_select_device>
    1464:	81 e0       	ldi	r24, 0x01	; 1
    1466:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    146a:	e0 ea       	ldi	r30, 0xA0	; 160
    146c:	f9 e0       	ldi	r31, 0x09	; 9
    146e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1470:	85 ff       	sbrs	r24, 5
    1472:	fd cf       	rjmp	.-6      	; 0x146e <st7565r_init+0x31a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1474:	81 e2       	ldi	r24, 0x21	; 33
    1476:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    147a:	e0 ea       	ldi	r30, 0xA0	; 160
    147c:	f9 e0       	ldi	r31, 0x09	; 9
    147e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1480:	86 ff       	sbrs	r24, 6
    1482:	fd cf       	rjmp	.-6      	; 0x147e <st7565r_init+0x32a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1484:	e0 ea       	ldi	r30, 0xA0	; 160
    1486:	f9 e0       	ldi	r31, 0x09	; 9
    1488:	80 e4       	ldi	r24, 0x40	; 64
    148a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    148c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    148e:	be 01       	movw	r22, r28
    1490:	6f 5f       	subi	r22, 0xFF	; 255
    1492:	7f 4f       	sbci	r23, 0xFF	; 255
    1494:	80 ea       	ldi	r24, 0xA0	; 160
    1496:	99 e0       	ldi	r25, 0x09	; 9
    1498:	8d d7       	rcall	.+3866   	; 0x23b4 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    149a:	8b e2       	ldi	r24, 0x2B	; 43
    149c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    149e:	be 01       	movw	r22, r28
    14a0:	6f 5f       	subi	r22, 0xFF	; 255
    14a2:	7f 4f       	sbci	r23, 0xFF	; 255
    14a4:	80 ea       	ldi	r24, 0xA0	; 160
    14a6:	99 e0       	ldi	r25, 0x09	; 9
    14a8:	6f d7       	rcall	.+3806   	; 0x2388 <usart_spi_select_device>
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    14b0:	e0 ea       	ldi	r30, 0xA0	; 160
    14b2:	f9 e0       	ldi	r31, 0x09	; 9
    14b4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    14b6:	85 ff       	sbrs	r24, 5
    14b8:	fd cf       	rjmp	.-6      	; 0x14b4 <st7565r_init+0x360>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    14ba:	8f ea       	ldi	r24, 0xAF	; 175
    14bc:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    14c0:	e0 ea       	ldi	r30, 0xA0	; 160
    14c2:	f9 e0       	ldi	r31, 0x09	; 9
    14c4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    14c6:	86 ff       	sbrs	r24, 6
    14c8:	fd cf       	rjmp	.-6      	; 0x14c4 <st7565r_init+0x370>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    14ca:	e0 ea       	ldi	r30, 0xA0	; 160
    14cc:	f9 e0       	ldi	r31, 0x09	; 9
    14ce:	80 e4       	ldi	r24, 0x40	; 64
    14d0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    14d2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    14d4:	be 01       	movw	r22, r28
    14d6:	6f 5f       	subi	r22, 0xFF	; 255
    14d8:	7f 4f       	sbci	r23, 0xFF	; 255
    14da:	80 ea       	ldi	r24, 0xA0	; 160
    14dc:	99 e0       	ldi	r25, 0x09	; 9
    14de:	6a d7       	rcall	.+3796   	; 0x23b4 <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
    14e0:	0f 90       	pop	r0
    14e2:	df 91       	pop	r29
    14e4:	cf 91       	pop	r28
    14e6:	1f 91       	pop	r17
    14e8:	0f 91       	pop	r16
    14ea:	ff 90       	pop	r15
    14ec:	ef 90       	pop	r14
    14ee:	df 90       	pop	r13
    14f0:	cf 90       	pop	r12
    14f2:	bf 90       	pop	r11
    14f4:	08 95       	ret

000014f6 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
    14f6:	ff 92       	push	r15
    14f8:	0f 93       	push	r16
    14fa:	1f 93       	push	r17
    14fc:	cf 93       	push	r28
    14fe:	df 93       	push	r29
    1500:	1f 92       	push	r1
    1502:	cd b7       	in	r28, 0x3d	; 61
    1504:	de b7       	in	r29, 0x3e	; 62
    1506:	08 2f       	mov	r16, r24
    1508:	f6 2e       	mov	r15, r22
    150a:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
    150c:	6e d7       	rcall	.+3804   	; 0x23ea <gfx_mono_framebuffer_put_byte>
 * \param address the page address
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
    150e:	0f 70       	andi	r16, 0x0F	; 15
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
    1510:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1512:	8b e2       	ldi	r24, 0x2B	; 43
    1514:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1516:	be 01       	movw	r22, r28
    1518:	6f 5f       	subi	r22, 0xFF	; 255
    151a:	7f 4f       	sbci	r23, 0xFF	; 255
    151c:	80 ea       	ldi	r24, 0xA0	; 160
    151e:	99 e0       	ldi	r25, 0x09	; 9
    1520:	33 d7       	rcall	.+3686   	; 0x2388 <usart_spi_select_device>
    1522:	81 e0       	ldi	r24, 0x01	; 1
    1524:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1528:	e0 ea       	ldi	r30, 0xA0	; 160
    152a:	f9 e0       	ldi	r31, 0x09	; 9
    152c:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    152e:	95 ff       	sbrs	r25, 5
    1530:	fd cf       	rjmp	.-6      	; 0x152c <gfx_mono_st7565r_put_byte+0x36>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1532:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1536:	e0 ea       	ldi	r30, 0xA0	; 160
    1538:	f9 e0       	ldi	r31, 0x09	; 9
    153a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    153c:	86 ff       	sbrs	r24, 6
    153e:	fd cf       	rjmp	.-6      	; 0x153a <gfx_mono_st7565r_put_byte+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1540:	e0 ea       	ldi	r30, 0xA0	; 160
    1542:	f9 e0       	ldi	r31, 0x09	; 9
    1544:	80 e4       	ldi	r24, 0x40	; 64
    1546:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1548:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    154a:	be 01       	movw	r22, r28
    154c:	6f 5f       	subi	r22, 0xFF	; 255
    154e:	7f 4f       	sbci	r23, 0xFF	; 255
    1550:	80 ea       	ldi	r24, 0xA0	; 160
    1552:	99 e0       	ldi	r25, 0x09	; 9
    1554:	2f d7       	rcall	.+3678   	; 0x23b4 <usart_spi_deselect_device>
 * \param address the column address
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
    1556:	0f 2d       	mov	r16, r15
    1558:	0f 77       	andi	r16, 0x7F	; 127
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
    155a:	02 95       	swap	r16
    155c:	0f 70       	andi	r16, 0x0F	; 15
    155e:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1560:	8b e2       	ldi	r24, 0x2B	; 43
    1562:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1564:	be 01       	movw	r22, r28
    1566:	6f 5f       	subi	r22, 0xFF	; 255
    1568:	7f 4f       	sbci	r23, 0xFF	; 255
    156a:	80 ea       	ldi	r24, 0xA0	; 160
    156c:	99 e0       	ldi	r25, 0x09	; 9
    156e:	0c d7       	rcall	.+3608   	; 0x2388 <usart_spi_select_device>
    1570:	81 e0       	ldi	r24, 0x01	; 1
    1572:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1576:	e0 ea       	ldi	r30, 0xA0	; 160
    1578:	f9 e0       	ldi	r31, 0x09	; 9
    157a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    157c:	85 ff       	sbrs	r24, 5
    157e:	fd cf       	rjmp	.-6      	; 0x157a <gfx_mono_st7565r_put_byte+0x84>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1580:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1584:	e0 ea       	ldi	r30, 0xA0	; 160
    1586:	f9 e0       	ldi	r31, 0x09	; 9
    1588:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    158a:	86 ff       	sbrs	r24, 6
    158c:	fd cf       	rjmp	.-6      	; 0x1588 <gfx_mono_st7565r_put_byte+0x92>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    158e:	e0 ea       	ldi	r30, 0xA0	; 160
    1590:	f9 e0       	ldi	r31, 0x09	; 9
    1592:	80 e4       	ldi	r24, 0x40	; 64
    1594:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1596:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1598:	be 01       	movw	r22, r28
    159a:	6f 5f       	subi	r22, 0xFF	; 255
    159c:	7f 4f       	sbci	r23, 0xFF	; 255
    159e:	80 ea       	ldi	r24, 0xA0	; 160
    15a0:	99 e0       	ldi	r25, 0x09	; 9
    15a2:	08 d7       	rcall	.+3600   	; 0x23b4 <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
    15a4:	0f 2d       	mov	r16, r15
    15a6:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    15a8:	8b e2       	ldi	r24, 0x2B	; 43
    15aa:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    15ac:	be 01       	movw	r22, r28
    15ae:	6f 5f       	subi	r22, 0xFF	; 255
    15b0:	7f 4f       	sbci	r23, 0xFF	; 255
    15b2:	80 ea       	ldi	r24, 0xA0	; 160
    15b4:	99 e0       	ldi	r25, 0x09	; 9
    15b6:	e8 d6       	rcall	.+3536   	; 0x2388 <usart_spi_select_device>
    15b8:	81 e0       	ldi	r24, 0x01	; 1
    15ba:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    15be:	e0 ea       	ldi	r30, 0xA0	; 160
    15c0:	f9 e0       	ldi	r31, 0x09	; 9
    15c2:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    15c4:	85 ff       	sbrs	r24, 5
    15c6:	fd cf       	rjmp	.-6      	; 0x15c2 <gfx_mono_st7565r_put_byte+0xcc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    15c8:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    15cc:	e0 ea       	ldi	r30, 0xA0	; 160
    15ce:	f9 e0       	ldi	r31, 0x09	; 9
    15d0:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    15d2:	86 ff       	sbrs	r24, 6
    15d4:	fd cf       	rjmp	.-6      	; 0x15d0 <gfx_mono_st7565r_put_byte+0xda>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    15d6:	e0 ea       	ldi	r30, 0xA0	; 160
    15d8:	f9 e0       	ldi	r31, 0x09	; 9
    15da:	80 e4       	ldi	r24, 0x40	; 64
    15dc:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    15de:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    15e0:	be 01       	movw	r22, r28
    15e2:	6f 5f       	subi	r22, 0xFF	; 255
    15e4:	7f 4f       	sbci	r23, 0xFF	; 255
    15e6:	80 ea       	ldi	r24, 0xA0	; 160
    15e8:	99 e0       	ldi	r25, 0x09	; 9
    15ea:	e4 d6       	rcall	.+3528   	; 0x23b4 <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    15ec:	8b e2       	ldi	r24, 0x2B	; 43
    15ee:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    15f0:	be 01       	movw	r22, r28
    15f2:	6f 5f       	subi	r22, 0xFF	; 255
    15f4:	7f 4f       	sbci	r23, 0xFF	; 255
    15f6:	80 ea       	ldi	r24, 0xA0	; 160
    15f8:	99 e0       	ldi	r25, 0x09	; 9
    15fa:	c6 d6       	rcall	.+3468   	; 0x2388 <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    15fc:	81 e0       	ldi	r24, 0x01	; 1
    15fe:	80 93 65 06 	sts	0x0665, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1602:	e0 ea       	ldi	r30, 0xA0	; 160
    1604:	f9 e0       	ldi	r31, 0x09	; 9
    1606:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1608:	85 ff       	sbrs	r24, 5
    160a:	fd cf       	rjmp	.-6      	; 0x1606 <gfx_mono_st7565r_put_byte+0x110>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    160c:	10 93 a0 09 	sts	0x09A0, r17
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1610:	e0 ea       	ldi	r30, 0xA0	; 160
    1612:	f9 e0       	ldi	r31, 0x09	; 9
    1614:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1616:	86 ff       	sbrs	r24, 6
    1618:	fd cf       	rjmp	.-6      	; 0x1614 <gfx_mono_st7565r_put_byte+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    161a:	e0 ea       	ldi	r30, 0xA0	; 160
    161c:	f9 e0       	ldi	r31, 0x09	; 9
    161e:	80 e4       	ldi	r24, 0x40	; 64
    1620:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1622:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	80 93 66 06 	sts	0x0666, r24
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    162a:	be 01       	movw	r22, r28
    162c:	6f 5f       	subi	r22, 0xFF	; 255
    162e:	7f 4f       	sbci	r23, 0xFF	; 255
    1630:	80 ea       	ldi	r24, 0xA0	; 160
    1632:	99 e0       	ldi	r25, 0x09	; 9
    1634:	bf d6       	rcall	.+3454   	; 0x23b4 <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
    1636:	0f 90       	pop	r0
    1638:	df 91       	pop	r29
    163a:	cf 91       	pop	r28
    163c:	1f 91       	pop	r17
    163e:	0f 91       	pop	r16
    1640:	ff 90       	pop	r15
    1642:	08 95       	ret

00001644 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
    1644:	0f 93       	push	r16
    1646:	1f 93       	push	r17
    1648:	cf 93       	push	r28
    164a:	df 93       	push	r29
    164c:	1f 92       	push	r1
    164e:	cd b7       	in	r28, 0x3d	; 61
    1650:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
    1652:	85 ed       	ldi	r24, 0xD5	; 213
    1654:	91 e2       	ldi	r25, 0x21	; 33
    1656:	c4 d6       	rcall	.+3464   	; 0x23e0 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
    1658:	7d dd       	rcall	.-1286   	; 0x1154 <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    165a:	8b e2       	ldi	r24, 0x2B	; 43
    165c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    165e:	be 01       	movw	r22, r28
    1660:	6f 5f       	subi	r22, 0xFF	; 255
    1662:	7f 4f       	sbci	r23, 0xFF	; 255
    1664:	80 ea       	ldi	r24, 0xA0	; 160
    1666:	99 e0       	ldi	r25, 0x09	; 9
    1668:	8f d6       	rcall	.+3358   	; 0x2388 <usart_spi_select_device>
    166a:	81 e0       	ldi	r24, 0x01	; 1
    166c:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1670:	e0 ea       	ldi	r30, 0xA0	; 160
    1672:	f9 e0       	ldi	r31, 0x09	; 9
    1674:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1676:	85 ff       	sbrs	r24, 5
    1678:	fd cf       	rjmp	.-6      	; 0x1674 <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    167a:	80 e4       	ldi	r24, 0x40	; 64
    167c:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1680:	e0 ea       	ldi	r30, 0xA0	; 160
    1682:	f9 e0       	ldi	r31, 0x09	; 9
    1684:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1686:	86 ff       	sbrs	r24, 6
    1688:	fd cf       	rjmp	.-6      	; 0x1684 <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    168a:	e0 ea       	ldi	r30, 0xA0	; 160
    168c:	f9 e0       	ldi	r31, 0x09	; 9
    168e:	80 e4       	ldi	r24, 0x40	; 64
    1690:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1692:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1694:	be 01       	movw	r22, r28
    1696:	6f 5f       	subi	r22, 0xFF	; 255
    1698:	7f 4f       	sbci	r23, 0xFF	; 255
    169a:	80 ea       	ldi	r24, 0xA0	; 160
    169c:	99 e0       	ldi	r25, 0x09	; 9
    169e:	8a d6       	rcall	.+3348   	; 0x23b4 <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    16a0:	00 e0       	ldi	r16, 0x00	; 0
    16a2:	0a c0       	rjmp	.+20     	; 0x16b8 <gfx_mono_st7565r_init+0x74>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
    16a4:	40 e0       	ldi	r20, 0x00	; 0
    16a6:	61 2f       	mov	r22, r17
    16a8:	80 2f       	mov	r24, r16
    16aa:	25 df       	rcall	.-438    	; 0x14f6 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
    16ac:	1f 5f       	subi	r17, 0xFF	; 255
    16ae:	10 38       	cpi	r17, 0x80	; 128
    16b0:	c9 f7       	brne	.-14     	; 0x16a4 <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    16b2:	0f 5f       	subi	r16, 0xFF	; 255
    16b4:	04 30       	cpi	r16, 0x04	; 4
    16b6:	11 f0       	breq	.+4      	; 0x16bc <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
    16b8:	10 e0       	ldi	r17, 0x00	; 0
    16ba:	f4 cf       	rjmp	.-24     	; 0x16a4 <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
    16bc:	0f 90       	pop	r0
    16be:	df 91       	pop	r29
    16c0:	cf 91       	pop	r28
    16c2:	1f 91       	pop	r17
    16c4:	0f 91       	pop	r16
    16c6:	08 95       	ret

000016c8 <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
    16c8:	ff 92       	push	r15
    16ca:	0f 93       	push	r16
    16cc:	1f 93       	push	r17
    16ce:	cf 93       	push	r28
    16d0:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
    16d2:	88 23       	and	r24, r24
    16d4:	8c f1       	brlt	.+98     	; 0x1738 <gfx_mono_st7565r_draw_pixel+0x70>
    16d6:	60 32       	cpi	r22, 0x20	; 32
    16d8:	78 f5       	brcc	.+94     	; 0x1738 <gfx_mono_st7565r_draw_pixel+0x70>
    16da:	d4 2f       	mov	r29, r20
    16dc:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
    16de:	f6 2e       	mov	r15, r22
    16e0:	f6 94       	lsr	r15
    16e2:	f6 94       	lsr	r15
    16e4:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
    16e6:	2f 2d       	mov	r18, r15
    16e8:	30 e0       	ldi	r19, 0x00	; 0
    16ea:	31 95       	neg	r19
    16ec:	21 95       	neg	r18
    16ee:	31 09       	sbc	r19, r1
    16f0:	22 0f       	add	r18, r18
    16f2:	33 1f       	adc	r19, r19
    16f4:	22 0f       	add	r18, r18
    16f6:	33 1f       	adc	r19, r19
    16f8:	22 0f       	add	r18, r18
    16fa:	33 1f       	adc	r19, r19
    16fc:	26 0f       	add	r18, r22
    16fe:	31 1d       	adc	r19, r1
    1700:	61 e0       	ldi	r22, 0x01	; 1
    1702:	70 e0       	ldi	r23, 0x00	; 0
    1704:	8b 01       	movw	r16, r22
    1706:	02 c0       	rjmp	.+4      	; 0x170c <gfx_mono_st7565r_draw_pixel+0x44>
    1708:	00 0f       	add	r16, r16
    170a:	11 1f       	adc	r17, r17
    170c:	2a 95       	dec	r18
    170e:	e2 f7       	brpl	.-8      	; 0x1708 <gfx_mono_st7565r_draw_pixel+0x40>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
    1710:	68 2f       	mov	r22, r24
    1712:	8f 2d       	mov	r24, r15
    1714:	78 d6       	rcall	.+3312   	; 0x2406 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
    1716:	d1 30       	cpi	r29, 0x01	; 1
    1718:	21 f0       	breq	.+8      	; 0x1722 <gfx_mono_st7565r_draw_pixel+0x5a>
    171a:	28 f0       	brcs	.+10     	; 0x1726 <gfx_mono_st7565r_draw_pixel+0x5e>
    171c:	d2 30       	cpi	r29, 0x02	; 2
    171e:	39 f0       	breq	.+14     	; 0x172e <gfx_mono_st7565r_draw_pixel+0x66>
    1720:	07 c0       	rjmp	.+14     	; 0x1730 <gfx_mono_st7565r_draw_pixel+0x68>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
    1722:	80 2b       	or	r24, r16
		break;
    1724:	05 c0       	rjmp	.+10     	; 0x1730 <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
    1726:	60 2f       	mov	r22, r16
    1728:	60 95       	com	r22
    172a:	86 23       	and	r24, r22
		break;
    172c:	01 c0       	rjmp	.+2      	; 0x1730 <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
    172e:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
    1730:	48 2f       	mov	r20, r24
    1732:	6c 2f       	mov	r22, r28
    1734:	8f 2d       	mov	r24, r15
    1736:	df de       	rcall	.-578    	; 0x14f6 <gfx_mono_st7565r_put_byte>
}
    1738:	df 91       	pop	r29
    173a:	cf 91       	pop	r28
    173c:	1f 91       	pop	r17
    173e:	0f 91       	pop	r16
    1740:	ff 90       	pop	r15
    1742:	08 95       	ret

00001744 <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
    1744:	60 c6       	rjmp	.+3264   	; 0x2406 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
    1746:	08 95       	ret

00001748 <tb_init>:


uint16_t qt_measurement_period_msec = 25;

void tb_init(void) {
	qt_config_data.qt_di				= DEF_QT_DI;
    1748:	e7 e8       	ldi	r30, 0x87	; 135
    174a:	f1 e2       	ldi	r31, 0x21	; 33
    174c:	84 e0       	ldi	r24, 0x04	; 4
    174e:	81 83       	std	Z+1, r24	; 0x01
	qt_config_data.qt_neg_drift_rate	= DEF_QT_NEG_DRIFT_RATE;
    1750:	84 e1       	ldi	r24, 0x14	; 20
    1752:	84 83       	std	Z+4, r24	; 0x04
	qt_config_data.qt_pos_drift_rate	= DEF_QT_POS_DRIFT_RATE;
    1754:	95 e0       	ldi	r25, 0x05	; 5
    1756:	95 83       	std	Z+5, r25	; 0x05
	qt_config_data.qt_max_on_duration	= DEF_QT_MAX_ON_DURATION;
    1758:	13 82       	std	Z+3, r1	; 0x03
	qt_config_data.qt_drift_hold_time	= DEF_QT_DRIFT_HOLD_TIME;
    175a:	82 83       	std	Z+2, r24	; 0x02
	qt_config_data.qt_recal_threshold	= DEF_QT_RECAL_THRESHOLD;
    175c:	81 e0       	ldi	r24, 0x01	; 1
    175e:	80 83       	st	Z, r24
	qt_config_data.qt_pos_recal_delay	= DEF_QT_POS_RECAL_DELAY;
    1760:	83 e0       	ldi	r24, 0x03	; 3
    1762:	86 83       	std	Z+6, r24	; 0x06
	qt_filter_callback					= 0;
    1764:	10 92 a1 21 	sts	0x21A1, r1
    1768:	10 92 a2 21 	sts	0x21A2, r1


	#ifdef QTOUCH_STUDIO_MASKS
		SNS_array[0][0] = 0x40;
    176c:	e5 ec       	ldi	r30, 0xC5	; 197
    176e:	f1 e2       	ldi	r31, 0x21	; 33
    1770:	80 e4       	ldi	r24, 0x40	; 64
    1772:	80 83       	st	Z, r24
		SNS_array[0][1] = 0x0;
    1774:	11 82       	std	Z+1, r1	; 0x01
		SNS_array[1][0] = 0x0;
    1776:	12 82       	std	Z+2, r1	; 0x02
		SNS_array[1][1] = 0x0;
    1778:	13 82       	std	Z+3, r1	; 0x03

		SNSK_array[0][0] = 0x80;
    177a:	e9 ec       	ldi	r30, 0xC9	; 201
    177c:	f1 e2       	ldi	r31, 0x21	; 33
    177e:	80 e8       	ldi	r24, 0x80	; 128
    1780:	80 83       	st	Z, r24
		SNSK_array[0][1] = 0x0;
    1782:	11 82       	std	Z+1, r1	; 0x01
		SNSK_array[1][0] = 0x0;
    1784:	12 82       	std	Z+2, r1	; 0x02
		SNSK_array[1][1] = 0x0;
    1786:	13 82       	std	Z+3, r1	; 0x03
	 * When using "pin configurability" this will result in channel 0
	 * because it is the first and only channel that is used.
	 * For the standard qtouch library setup we would need to use
	 * channel 3 since we are using the last two pins on the port.
	 */
	qt_enable_key(CHANNEL_0, NO_AKS_GROUP, 10, HYST_6_25);
    1788:	23 e0       	ldi	r18, 0x03	; 3
    178a:	4a e0       	ldi	r20, 0x0A	; 10
    178c:	60 e0       	ldi	r22, 0x00	; 0
    178e:	80 e0       	ldi	r24, 0x00	; 0
    1790:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <qt_enable_key>

	qt_init_sensing();
    1794:	60 e0       	ldi	r22, 0x00	; 0
    1796:	70 e0       	ldi	r23, 0x00	; 0
    1798:	87 e8       	ldi	r24, 0x87	; 135
    179a:	92 e0       	ldi	r25, 0x02	; 2
    179c:	ae c8       	rjmp	.-3748   	; 0x8fa <qt_init_sensing_with_burst>
    179e:	08 95       	ret

000017a0 <adc_set_callback>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    17a0:	4f b7       	in	r20, 0x3f	; 63
	cpu_irq_disable();
    17a2:	f8 94       	cli
	Assert(callback);

	flags = cpu_irq_save();

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    17a4:	28 2f       	mov	r18, r24
    17a6:	39 2f       	mov	r19, r25
    17a8:	21 15       	cp	r18, r1
    17aa:	82 e0       	ldi	r24, 0x02	; 2
    17ac:	38 07       	cpc	r19, r24
    17ae:	29 f4       	brne	.+10     	; 0x17ba <adc_set_callback+0x1a>
		adca_callback = callback;
    17b0:	60 93 5c 24 	sts	0x245C, r22
    17b4:	70 93 5d 24 	sts	0x245D, r23
    17b8:	07 c0       	rjmp	.+14     	; 0x17c8 <adc_set_callback+0x28>
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    17ba:	20 34       	cpi	r18, 0x40	; 64
    17bc:	32 40       	sbci	r19, 0x02	; 2
    17be:	21 f4       	brne	.+8      	; 0x17c8 <adc_set_callback+0x28>
		adcb_callback = callback;
    17c0:	60 93 5a 24 	sts	0x245A, r22
    17c4:	70 93 5b 24 	sts	0x245B, r23
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    17c8:	4f bf       	out	0x3f, r20	; 63
    17ca:	08 95       	ret

000017cc <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
    17cc:	81 15       	cp	r24, r1
    17ce:	22 e0       	ldi	r18, 0x02	; 2
    17d0:	92 07       	cpc	r25, r18
    17d2:	69 f4       	brne	.+26     	; 0x17ee <adc_enable_clock+0x22>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
    17d4:	80 91 d6 23 	lds	r24, 0x23D6
    17d8:	91 e0       	ldi	r25, 0x01	; 1
    17da:	98 0f       	add	r25, r24
    17dc:	90 93 d6 23 	sts	0x23D6, r25
    17e0:	81 11       	cpse	r24, r1
    17e2:	14 c0       	rjmp	.+40     	; 0x180c <adc_enable_clock+0x40>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    17e4:	62 e0       	ldi	r22, 0x02	; 2
    17e6:	81 e0       	ldi	r24, 0x01	; 1
    17e8:	0c 94 72 18 	jmp	0x30e4	; 0x30e4 <sysclk_enable_module>
    17ec:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
    17ee:	80 34       	cpi	r24, 0x40	; 64
    17f0:	92 40       	sbci	r25, 0x02	; 2
    17f2:	61 f4       	brne	.+24     	; 0x180c <adc_enable_clock+0x40>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
    17f4:	80 91 d5 23 	lds	r24, 0x23D5
    17f8:	91 e0       	ldi	r25, 0x01	; 1
    17fa:	98 0f       	add	r25, r24
    17fc:	90 93 d5 23 	sts	0x23D5, r25
    1800:	81 11       	cpse	r24, r1
    1802:	04 c0       	rjmp	.+8      	; 0x180c <adc_enable_clock+0x40>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1804:	62 e0       	ldi	r22, 0x02	; 2
    1806:	82 e0       	ldi	r24, 0x02	; 2
    1808:	0c 94 72 18 	jmp	0x30e4	; 0x30e4 <sysclk_enable_module>
    180c:	08 95       	ret

0000180e <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
    180e:	81 15       	cp	r24, r1
    1810:	22 e0       	ldi	r18, 0x02	; 2
    1812:	92 07       	cpc	r25, r18
    1814:	61 f4       	brne	.+24     	; 0x182e <adc_disable_clock+0x20>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
    1816:	80 91 d6 23 	lds	r24, 0x23D6
    181a:	81 50       	subi	r24, 0x01	; 1
    181c:	80 93 d6 23 	sts	0x23D6, r24
    1820:	81 11       	cpse	r24, r1
    1822:	13 c0       	rjmp	.+38     	; 0x184a <adc_disable_clock+0x3c>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1824:	62 e0       	ldi	r22, 0x02	; 2
    1826:	81 e0       	ldi	r24, 0x01	; 1
    1828:	0c 94 7e 18 	jmp	0x30fc	; 0x30fc <sysclk_disable_module>
    182c:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
    182e:	80 34       	cpi	r24, 0x40	; 64
    1830:	92 40       	sbci	r25, 0x02	; 2
    1832:	59 f4       	brne	.+22     	; 0x184a <adc_disable_clock+0x3c>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
    1834:	80 91 d5 23 	lds	r24, 0x23D5
    1838:	81 50       	subi	r24, 0x01	; 1
    183a:	80 93 d5 23 	sts	0x23D5, r24
    183e:	81 11       	cpse	r24, r1
    1840:	04 c0       	rjmp	.+8      	; 0x184a <adc_disable_clock+0x3c>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1842:	62 e0       	ldi	r22, 0x02	; 2
    1844:	82 e0       	ldi	r24, 0x02	; 2
    1846:	0c 94 7e 18 	jmp	0x30fc	; 0x30fc <sysclk_disable_module>
    184a:	08 95       	ret

0000184c <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
    184c:	1f 93       	push	r17
    184e:	cf 93       	push	r28
    1850:	df 93       	push	r29
    1852:	ec 01       	movw	r28, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1854:	1f b7       	in	r17, 0x3f	; 63
	cpu_irq_disable();
    1856:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
    1858:	b9 df       	rcall	.-142    	; 0x17cc <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
    185a:	88 81       	ld	r24, Y
    185c:	81 60       	ori	r24, 0x01	; 1
    185e:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1860:	1f bf       	out	0x3f, r17	; 63

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1862:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    1864:	f8 94       	cli
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
    1866:	e4 e5       	ldi	r30, 0x54	; 84
    1868:	f4 e2       	ldi	r31, 0x24	; 36
    186a:	81 81       	ldd	r24, Z+1	; 0x01
    186c:	8f 5f       	subi	r24, 0xFF	; 255
    186e:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1870:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
    1872:	df 91       	pop	r29
    1874:	cf 91       	pop	r28
    1876:	1f 91       	pop	r17
    1878:	08 95       	ret

0000187a <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
    187a:	1f 92       	push	r1
    187c:	0f 92       	push	r0
    187e:	0f b6       	in	r0, 0x3f	; 63
    1880:	0f 92       	push	r0
    1882:	11 24       	eor	r1, r1
    1884:	0b b6       	in	r0, 0x3b	; 59
    1886:	0f 92       	push	r0
    1888:	2f 93       	push	r18
    188a:	3f 93       	push	r19
    188c:	4f 93       	push	r20
    188e:	5f 93       	push	r21
    1890:	6f 93       	push	r22
    1892:	7f 93       	push	r23
    1894:	8f 93       	push	r24
    1896:	9f 93       	push	r25
    1898:	af 93       	push	r26
    189a:	bf 93       	push	r27
    189c:	ef 93       	push	r30
    189e:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
    18a0:	40 91 24 02 	lds	r20, 0x0224
    18a4:	50 91 25 02 	lds	r21, 0x0225
    18a8:	e0 91 5c 24 	lds	r30, 0x245C
    18ac:	f0 91 5d 24 	lds	r31, 0x245D
    18b0:	61 e0       	ldi	r22, 0x01	; 1
    18b2:	80 e0       	ldi	r24, 0x00	; 0
    18b4:	92 e0       	ldi	r25, 0x02	; 2
    18b6:	19 95       	eicall
}
    18b8:	ff 91       	pop	r31
    18ba:	ef 91       	pop	r30
    18bc:	bf 91       	pop	r27
    18be:	af 91       	pop	r26
    18c0:	9f 91       	pop	r25
    18c2:	8f 91       	pop	r24
    18c4:	7f 91       	pop	r23
    18c6:	6f 91       	pop	r22
    18c8:	5f 91       	pop	r21
    18ca:	4f 91       	pop	r20
    18cc:	3f 91       	pop	r19
    18ce:	2f 91       	pop	r18
    18d0:	0f 90       	pop	r0
    18d2:	0b be       	out	0x3b, r0	; 59
    18d4:	0f 90       	pop	r0
    18d6:	0f be       	out	0x3f, r0	; 63
    18d8:	0f 90       	pop	r0
    18da:	1f 90       	pop	r1
    18dc:	18 95       	reti

000018de <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
    18de:	1f 92       	push	r1
    18e0:	0f 92       	push	r0
    18e2:	0f b6       	in	r0, 0x3f	; 63
    18e4:	0f 92       	push	r0
    18e6:	11 24       	eor	r1, r1
    18e8:	0b b6       	in	r0, 0x3b	; 59
    18ea:	0f 92       	push	r0
    18ec:	2f 93       	push	r18
    18ee:	3f 93       	push	r19
    18f0:	4f 93       	push	r20
    18f2:	5f 93       	push	r21
    18f4:	6f 93       	push	r22
    18f6:	7f 93       	push	r23
    18f8:	8f 93       	push	r24
    18fa:	9f 93       	push	r25
    18fc:	af 93       	push	r26
    18fe:	bf 93       	push	r27
    1900:	ef 93       	push	r30
    1902:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
    1904:	40 91 2c 02 	lds	r20, 0x022C
    1908:	50 91 2d 02 	lds	r21, 0x022D
    190c:	e0 91 5c 24 	lds	r30, 0x245C
    1910:	f0 91 5d 24 	lds	r31, 0x245D
    1914:	62 e0       	ldi	r22, 0x02	; 2
    1916:	80 e0       	ldi	r24, 0x00	; 0
    1918:	92 e0       	ldi	r25, 0x02	; 2
    191a:	19 95       	eicall
}
    191c:	ff 91       	pop	r31
    191e:	ef 91       	pop	r30
    1920:	bf 91       	pop	r27
    1922:	af 91       	pop	r26
    1924:	9f 91       	pop	r25
    1926:	8f 91       	pop	r24
    1928:	7f 91       	pop	r23
    192a:	6f 91       	pop	r22
    192c:	5f 91       	pop	r21
    192e:	4f 91       	pop	r20
    1930:	3f 91       	pop	r19
    1932:	2f 91       	pop	r18
    1934:	0f 90       	pop	r0
    1936:	0b be       	out	0x3b, r0	; 59
    1938:	0f 90       	pop	r0
    193a:	0f be       	out	0x3f, r0	; 63
    193c:	0f 90       	pop	r0
    193e:	1f 90       	pop	r1
    1940:	18 95       	reti

00001942 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
    1942:	1f 92       	push	r1
    1944:	0f 92       	push	r0
    1946:	0f b6       	in	r0, 0x3f	; 63
    1948:	0f 92       	push	r0
    194a:	11 24       	eor	r1, r1
    194c:	0b b6       	in	r0, 0x3b	; 59
    194e:	0f 92       	push	r0
    1950:	2f 93       	push	r18
    1952:	3f 93       	push	r19
    1954:	4f 93       	push	r20
    1956:	5f 93       	push	r21
    1958:	6f 93       	push	r22
    195a:	7f 93       	push	r23
    195c:	8f 93       	push	r24
    195e:	9f 93       	push	r25
    1960:	af 93       	push	r26
    1962:	bf 93       	push	r27
    1964:	ef 93       	push	r30
    1966:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
    1968:	40 91 34 02 	lds	r20, 0x0234
    196c:	50 91 35 02 	lds	r21, 0x0235
    1970:	e0 91 5c 24 	lds	r30, 0x245C
    1974:	f0 91 5d 24 	lds	r31, 0x245D
    1978:	64 e0       	ldi	r22, 0x04	; 4
    197a:	80 e0       	ldi	r24, 0x00	; 0
    197c:	92 e0       	ldi	r25, 0x02	; 2
    197e:	19 95       	eicall
}
    1980:	ff 91       	pop	r31
    1982:	ef 91       	pop	r30
    1984:	bf 91       	pop	r27
    1986:	af 91       	pop	r26
    1988:	9f 91       	pop	r25
    198a:	8f 91       	pop	r24
    198c:	7f 91       	pop	r23
    198e:	6f 91       	pop	r22
    1990:	5f 91       	pop	r21
    1992:	4f 91       	pop	r20
    1994:	3f 91       	pop	r19
    1996:	2f 91       	pop	r18
    1998:	0f 90       	pop	r0
    199a:	0b be       	out	0x3b, r0	; 59
    199c:	0f 90       	pop	r0
    199e:	0f be       	out	0x3f, r0	; 63
    19a0:	0f 90       	pop	r0
    19a2:	1f 90       	pop	r1
    19a4:	18 95       	reti

000019a6 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    19a6:	1f 92       	push	r1
    19a8:	0f 92       	push	r0
    19aa:	0f b6       	in	r0, 0x3f	; 63
    19ac:	0f 92       	push	r0
    19ae:	11 24       	eor	r1, r1
    19b0:	0b b6       	in	r0, 0x3b	; 59
    19b2:	0f 92       	push	r0
    19b4:	2f 93       	push	r18
    19b6:	3f 93       	push	r19
    19b8:	4f 93       	push	r20
    19ba:	5f 93       	push	r21
    19bc:	6f 93       	push	r22
    19be:	7f 93       	push	r23
    19c0:	8f 93       	push	r24
    19c2:	9f 93       	push	r25
    19c4:	af 93       	push	r26
    19c6:	bf 93       	push	r27
    19c8:	ef 93       	push	r30
    19ca:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    19cc:	40 91 3c 02 	lds	r20, 0x023C
    19d0:	50 91 3d 02 	lds	r21, 0x023D
    19d4:	e0 91 5c 24 	lds	r30, 0x245C
    19d8:	f0 91 5d 24 	lds	r31, 0x245D
    19dc:	68 e0       	ldi	r22, 0x08	; 8
    19de:	80 e0       	ldi	r24, 0x00	; 0
    19e0:	92 e0       	ldi	r25, 0x02	; 2
    19e2:	19 95       	eicall
}
    19e4:	ff 91       	pop	r31
    19e6:	ef 91       	pop	r30
    19e8:	bf 91       	pop	r27
    19ea:	af 91       	pop	r26
    19ec:	9f 91       	pop	r25
    19ee:	8f 91       	pop	r24
    19f0:	7f 91       	pop	r23
    19f2:	6f 91       	pop	r22
    19f4:	5f 91       	pop	r21
    19f6:	4f 91       	pop	r20
    19f8:	3f 91       	pop	r19
    19fa:	2f 91       	pop	r18
    19fc:	0f 90       	pop	r0
    19fe:	0b be       	out	0x3b, r0	; 59
    1a00:	0f 90       	pop	r0
    1a02:	0f be       	out	0x3f, r0	; 63
    1a04:	0f 90       	pop	r0
    1a06:	1f 90       	pop	r1
    1a08:	18 95       	reti

00001a0a <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    1a0a:	1f 92       	push	r1
    1a0c:	0f 92       	push	r0
    1a0e:	0f b6       	in	r0, 0x3f	; 63
    1a10:	0f 92       	push	r0
    1a12:	11 24       	eor	r1, r1
    1a14:	0b b6       	in	r0, 0x3b	; 59
    1a16:	0f 92       	push	r0
    1a18:	2f 93       	push	r18
    1a1a:	3f 93       	push	r19
    1a1c:	4f 93       	push	r20
    1a1e:	5f 93       	push	r21
    1a20:	6f 93       	push	r22
    1a22:	7f 93       	push	r23
    1a24:	8f 93       	push	r24
    1a26:	9f 93       	push	r25
    1a28:	af 93       	push	r26
    1a2a:	bf 93       	push	r27
    1a2c:	ef 93       	push	r30
    1a2e:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1a30:	40 91 64 02 	lds	r20, 0x0264
    1a34:	50 91 65 02 	lds	r21, 0x0265
    1a38:	e0 91 5a 24 	lds	r30, 0x245A
    1a3c:	f0 91 5b 24 	lds	r31, 0x245B
    1a40:	61 e0       	ldi	r22, 0x01	; 1
    1a42:	80 e4       	ldi	r24, 0x40	; 64
    1a44:	92 e0       	ldi	r25, 0x02	; 2
    1a46:	19 95       	eicall
}
    1a48:	ff 91       	pop	r31
    1a4a:	ef 91       	pop	r30
    1a4c:	bf 91       	pop	r27
    1a4e:	af 91       	pop	r26
    1a50:	9f 91       	pop	r25
    1a52:	8f 91       	pop	r24
    1a54:	7f 91       	pop	r23
    1a56:	6f 91       	pop	r22
    1a58:	5f 91       	pop	r21
    1a5a:	4f 91       	pop	r20
    1a5c:	3f 91       	pop	r19
    1a5e:	2f 91       	pop	r18
    1a60:	0f 90       	pop	r0
    1a62:	0b be       	out	0x3b, r0	; 59
    1a64:	0f 90       	pop	r0
    1a66:	0f be       	out	0x3f, r0	; 63
    1a68:	0f 90       	pop	r0
    1a6a:	1f 90       	pop	r1
    1a6c:	18 95       	reti

00001a6e <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    1a6e:	1f 92       	push	r1
    1a70:	0f 92       	push	r0
    1a72:	0f b6       	in	r0, 0x3f	; 63
    1a74:	0f 92       	push	r0
    1a76:	11 24       	eor	r1, r1
    1a78:	0b b6       	in	r0, 0x3b	; 59
    1a7a:	0f 92       	push	r0
    1a7c:	2f 93       	push	r18
    1a7e:	3f 93       	push	r19
    1a80:	4f 93       	push	r20
    1a82:	5f 93       	push	r21
    1a84:	6f 93       	push	r22
    1a86:	7f 93       	push	r23
    1a88:	8f 93       	push	r24
    1a8a:	9f 93       	push	r25
    1a8c:	af 93       	push	r26
    1a8e:	bf 93       	push	r27
    1a90:	ef 93       	push	r30
    1a92:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    1a94:	40 91 6c 02 	lds	r20, 0x026C
    1a98:	50 91 6d 02 	lds	r21, 0x026D
    1a9c:	e0 91 5a 24 	lds	r30, 0x245A
    1aa0:	f0 91 5b 24 	lds	r31, 0x245B
    1aa4:	62 e0       	ldi	r22, 0x02	; 2
    1aa6:	80 e4       	ldi	r24, 0x40	; 64
    1aa8:	92 e0       	ldi	r25, 0x02	; 2
    1aaa:	19 95       	eicall
}
    1aac:	ff 91       	pop	r31
    1aae:	ef 91       	pop	r30
    1ab0:	bf 91       	pop	r27
    1ab2:	af 91       	pop	r26
    1ab4:	9f 91       	pop	r25
    1ab6:	8f 91       	pop	r24
    1ab8:	7f 91       	pop	r23
    1aba:	6f 91       	pop	r22
    1abc:	5f 91       	pop	r21
    1abe:	4f 91       	pop	r20
    1ac0:	3f 91       	pop	r19
    1ac2:	2f 91       	pop	r18
    1ac4:	0f 90       	pop	r0
    1ac6:	0b be       	out	0x3b, r0	; 59
    1ac8:	0f 90       	pop	r0
    1aca:	0f be       	out	0x3f, r0	; 63
    1acc:	0f 90       	pop	r0
    1ace:	1f 90       	pop	r1
    1ad0:	18 95       	reti

00001ad2 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    1ad2:	1f 92       	push	r1
    1ad4:	0f 92       	push	r0
    1ad6:	0f b6       	in	r0, 0x3f	; 63
    1ad8:	0f 92       	push	r0
    1ada:	11 24       	eor	r1, r1
    1adc:	0b b6       	in	r0, 0x3b	; 59
    1ade:	0f 92       	push	r0
    1ae0:	2f 93       	push	r18
    1ae2:	3f 93       	push	r19
    1ae4:	4f 93       	push	r20
    1ae6:	5f 93       	push	r21
    1ae8:	6f 93       	push	r22
    1aea:	7f 93       	push	r23
    1aec:	8f 93       	push	r24
    1aee:	9f 93       	push	r25
    1af0:	af 93       	push	r26
    1af2:	bf 93       	push	r27
    1af4:	ef 93       	push	r30
    1af6:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    1af8:	40 91 74 02 	lds	r20, 0x0274
    1afc:	50 91 75 02 	lds	r21, 0x0275
    1b00:	e0 91 5a 24 	lds	r30, 0x245A
    1b04:	f0 91 5b 24 	lds	r31, 0x245B
    1b08:	64 e0       	ldi	r22, 0x04	; 4
    1b0a:	80 e4       	ldi	r24, 0x40	; 64
    1b0c:	92 e0       	ldi	r25, 0x02	; 2
    1b0e:	19 95       	eicall
}
    1b10:	ff 91       	pop	r31
    1b12:	ef 91       	pop	r30
    1b14:	bf 91       	pop	r27
    1b16:	af 91       	pop	r26
    1b18:	9f 91       	pop	r25
    1b1a:	8f 91       	pop	r24
    1b1c:	7f 91       	pop	r23
    1b1e:	6f 91       	pop	r22
    1b20:	5f 91       	pop	r21
    1b22:	4f 91       	pop	r20
    1b24:	3f 91       	pop	r19
    1b26:	2f 91       	pop	r18
    1b28:	0f 90       	pop	r0
    1b2a:	0b be       	out	0x3b, r0	; 59
    1b2c:	0f 90       	pop	r0
    1b2e:	0f be       	out	0x3f, r0	; 63
    1b30:	0f 90       	pop	r0
    1b32:	1f 90       	pop	r1
    1b34:	18 95       	reti

00001b36 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1b36:	1f 92       	push	r1
    1b38:	0f 92       	push	r0
    1b3a:	0f b6       	in	r0, 0x3f	; 63
    1b3c:	0f 92       	push	r0
    1b3e:	11 24       	eor	r1, r1
    1b40:	0b b6       	in	r0, 0x3b	; 59
    1b42:	0f 92       	push	r0
    1b44:	2f 93       	push	r18
    1b46:	3f 93       	push	r19
    1b48:	4f 93       	push	r20
    1b4a:	5f 93       	push	r21
    1b4c:	6f 93       	push	r22
    1b4e:	7f 93       	push	r23
    1b50:	8f 93       	push	r24
    1b52:	9f 93       	push	r25
    1b54:	af 93       	push	r26
    1b56:	bf 93       	push	r27
    1b58:	ef 93       	push	r30
    1b5a:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    1b5c:	40 91 7c 02 	lds	r20, 0x027C
    1b60:	50 91 7d 02 	lds	r21, 0x027D
    1b64:	e0 91 5a 24 	lds	r30, 0x245A
    1b68:	f0 91 5b 24 	lds	r31, 0x245B
    1b6c:	68 e0       	ldi	r22, 0x08	; 8
    1b6e:	80 e4       	ldi	r24, 0x40	; 64
    1b70:	92 e0       	ldi	r25, 0x02	; 2
    1b72:	19 95       	eicall
}
    1b74:	ff 91       	pop	r31
    1b76:	ef 91       	pop	r30
    1b78:	bf 91       	pop	r27
    1b7a:	af 91       	pop	r26
    1b7c:	9f 91       	pop	r25
    1b7e:	8f 91       	pop	r24
    1b80:	7f 91       	pop	r23
    1b82:	6f 91       	pop	r22
    1b84:	5f 91       	pop	r21
    1b86:	4f 91       	pop	r20
    1b88:	3f 91       	pop	r19
    1b8a:	2f 91       	pop	r18
    1b8c:	0f 90       	pop	r0
    1b8e:	0b be       	out	0x3b, r0	; 59
    1b90:	0f 90       	pop	r0
    1b92:	0f be       	out	0x3f, r0	; 63
    1b94:	0f 90       	pop	r0
    1b96:	1f 90       	pop	r1
    1b98:	18 95       	reti

00001b9a <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    1b9a:	df 92       	push	r13
    1b9c:	ef 92       	push	r14
    1b9e:	ff 92       	push	r15
    1ba0:	0f 93       	push	r16
    1ba2:	1f 93       	push	r17
    1ba4:	cf 93       	push	r28
    1ba6:	df 93       	push	r29
    1ba8:	ec 01       	movw	r28, r24
    1baa:	8b 01       	movw	r16, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    1bac:	c1 15       	cp	r28, r1
    1bae:	22 e0       	ldi	r18, 0x02	; 2
    1bb0:	d2 07       	cpc	r29, r18
    1bb2:	81 f4       	brne	.+32     	; 0x1bd4 <adc_write_configuration+0x3a>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    1bb4:	61 e2       	ldi	r22, 0x21	; 33
    1bb6:	70 e0       	ldi	r23, 0x00	; 0
    1bb8:	82 e0       	ldi	r24, 0x02	; 2
    1bba:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    1bbe:	e8 2e       	mov	r14, r24
    1bc0:	f1 2c       	mov	r15, r1
    1bc2:	60 e2       	ldi	r22, 0x20	; 32
    1bc4:	70 e0       	ldi	r23, 0x00	; 0
    1bc6:	82 e0       	ldi	r24, 0x02	; 2
    1bc8:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <nvm_read_byte>
		data <<= 8;
    1bcc:	fe 2c       	mov	r15, r14
    1bce:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCACAL0);
    1bd0:	e8 2a       	or	r14, r24
    1bd2:	12 c0       	rjmp	.+36     	; 0x1bf8 <adc_write_configuration+0x5e>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1bd4:	80 34       	cpi	r24, 0x40	; 64
    1bd6:	92 40       	sbci	r25, 0x02	; 2
    1bd8:	61 f5       	brne	.+88     	; 0x1c32 <adc_write_configuration+0x98>
    1bda:	65 e2       	ldi	r22, 0x25	; 37
    1bdc:	70 e0       	ldi	r23, 0x00	; 0
    1bde:	82 e0       	ldi	r24, 0x02	; 2
    1be0:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    1be4:	e8 2e       	mov	r14, r24
    1be6:	f1 2c       	mov	r15, r1
    1be8:	64 e2       	ldi	r22, 0x24	; 36
    1bea:	70 e0       	ldi	r23, 0x00	; 0
    1bec:	82 e0       	ldi	r24, 0x02	; 2
    1bee:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <nvm_read_byte>
		data <<= 8;
    1bf2:	fe 2c       	mov	r15, r14
    1bf4:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCBCAL0);
    1bf6:	e8 2a       	or	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1bf8:	df b6       	in	r13, 0x3f	; 63
	cpu_irq_disable();
    1bfa:	f8 94       	cli
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    1bfc:	ce 01       	movw	r24, r28
    1bfe:	e6 dd       	rcall	.-1076   	; 0x17cc <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
    1c00:	88 81       	ld	r24, Y

	adc->CTRLA = ADC_FLUSH_bm;
    1c02:	92 e0       	ldi	r25, 0x02	; 2
    1c04:	98 83       	st	Y, r25
	adc->CAL = cal;
    1c06:	ec 86       	std	Y+12, r14	; 0x0c
    1c08:	fd 86       	std	Y+13, r15	; 0x0d
	adc->CMP = conf->cmp;
    1c0a:	f8 01       	movw	r30, r16
    1c0c:	25 81       	ldd	r18, Z+5	; 0x05
    1c0e:	36 81       	ldd	r19, Z+6	; 0x06
    1c10:	28 8f       	std	Y+24, r18	; 0x18
    1c12:	39 8f       	std	Y+25, r19	; 0x19
	adc->REFCTRL = conf->refctrl;
    1c14:	92 81       	ldd	r25, Z+2	; 0x02
    1c16:	9a 83       	std	Y+2, r25	; 0x02
	adc->PRESCALER = conf->prescaler;
    1c18:	94 81       	ldd	r25, Z+4	; 0x04
    1c1a:	9c 83       	std	Y+4, r25	; 0x04
	adc->EVCTRL = conf->evctrl;
    1c1c:	93 81       	ldd	r25, Z+3	; 0x03
    1c1e:	9b 83       	std	Y+3, r25	; 0x03
	adc->CTRLB = conf->ctrlb;
    1c20:	91 81       	ldd	r25, Z+1	; 0x01
    1c22:	99 83       	std	Y+1, r25	; 0x01
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
	enable = adc->CTRLA & ADC_ENABLE_bm;
    1c24:	81 70       	andi	r24, 0x01	; 1
	adc->REFCTRL = conf->refctrl;
	adc->PRESCALER = conf->prescaler;
	adc->EVCTRL = conf->evctrl;
	adc->CTRLB = conf->ctrlb;

	adc->CTRLA = enable | conf->ctrla;
    1c26:	90 81       	ld	r25, Z
    1c28:	89 2b       	or	r24, r25
    1c2a:	88 83       	st	Y, r24

	adc_disable_clock(adc);
    1c2c:	ce 01       	movw	r24, r28
    1c2e:	ef dd       	rcall	.-1058   	; 0x180e <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1c30:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    1c32:	df 91       	pop	r29
    1c34:	cf 91       	pop	r28
    1c36:	1f 91       	pop	r17
    1c38:	0f 91       	pop	r16
    1c3a:	ff 90       	pop	r15
    1c3c:	ef 90       	pop	r14
    1c3e:	df 90       	pop	r13
    1c40:	08 95       	ret

00001c42 <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    1c42:	ff 92       	push	r15
    1c44:	0f 93       	push	r16
    1c46:	1f 93       	push	r17
    1c48:	cf 93       	push	r28
    1c4a:	df 93       	push	r29
    1c4c:	ec 01       	movw	r28, r24
    1c4e:	8b 01       	movw	r16, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1c50:	ff b6       	in	r15, 0x3f	; 63
	cpu_irq_disable();
    1c52:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    1c54:	bb dd       	rcall	.-1162   	; 0x17cc <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    1c56:	88 81       	ld	r24, Y
    1c58:	80 7c       	andi	r24, 0xC0	; 192
    1c5a:	f8 01       	movw	r30, r16
    1c5c:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    1c5e:	88 8d       	ldd	r24, Y+24	; 0x18
    1c60:	99 8d       	ldd	r25, Y+25	; 0x19
    1c62:	85 83       	std	Z+5, r24	; 0x05
    1c64:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    1c66:	8a 81       	ldd	r24, Y+2	; 0x02
    1c68:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    1c6a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c6c:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    1c6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c70:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    1c72:	89 81       	ldd	r24, Y+1	; 0x01
    1c74:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    1c76:	ce 01       	movw	r24, r28
    1c78:	ca dd       	rcall	.-1132   	; 0x180e <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1c7a:	ff be       	out	0x3f, r15	; 63

	cpu_irq_restore(flags);
}
    1c7c:	df 91       	pop	r29
    1c7e:	cf 91       	pop	r28
    1c80:	1f 91       	pop	r17
    1c82:	0f 91       	pop	r16
    1c84:	ff 90       	pop	r15
    1c86:	08 95       	ret

00001c88 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    1c88:	cf 92       	push	r12
    1c8a:	df 92       	push	r13
    1c8c:	ef 92       	push	r14
    1c8e:	ff 92       	push	r15
    1c90:	0f 93       	push	r16
    1c92:	1f 93       	push	r17
    1c94:	cf 93       	push	r28
    1c96:	df 93       	push	r29
    1c98:	7c 01       	movw	r14, r24
    1c9a:	d6 2e       	mov	r13, r22
    1c9c:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1c9e:	86 2f       	mov	r24, r22
    1ca0:	83 70       	andi	r24, 0x03	; 3
    1ca2:	29 f4       	brne	.+10     	; 0x1cae <adcch_write_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    1ca4:	96 2f       	mov	r25, r22
    1ca6:	96 95       	lsr	r25
    1ca8:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1caa:	82 e0       	ldi	r24, 0x02	; 2
    1cac:	02 c0       	rjmp	.+4      	; 0x1cb2 <adcch_write_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1cae:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1cb0:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1cb2:	90 ff       	sbrs	r25, 0
		index++;
    1cb4:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1cb6:	e7 01       	movw	r28, r14
    1cb8:	a0 96       	adiw	r28, 0x20	; 32
    1cba:	98 e0       	ldi	r25, 0x08	; 8
    1cbc:	89 9f       	mul	r24, r25
    1cbe:	c0 0d       	add	r28, r0
    1cc0:	d1 1d       	adc	r29, r1
    1cc2:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1cc4:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1cc6:	f8 94       	cli
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    1cc8:	c7 01       	movw	r24, r14
    1cca:	80 dd       	rcall	.-1280   	; 0x17cc <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    1ccc:	f8 01       	movw	r30, r16
    1cce:	80 81       	ld	r24, Z
    1cd0:	88 83       	st	Y, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    1cd2:	82 81       	ldd	r24, Z+2	; 0x02
    1cd4:	8a 83       	std	Y+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    1cd6:	81 81       	ldd	r24, Z+1	; 0x01
    1cd8:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1cda:	d0 fe       	sbrs	r13, 0
    1cdc:	02 c0       	rjmp	.+4      	; 0x1ce2 <adcch_write_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    1cde:	83 81       	ldd	r24, Z+3	; 0x03
    1ce0:	8e 83       	std	Y+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    1ce2:	c7 01       	movw	r24, r14
    1ce4:	94 dd       	rcall	.-1240   	; 0x180e <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1ce6:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1ce8:	df 91       	pop	r29
    1cea:	cf 91       	pop	r28
    1cec:	1f 91       	pop	r17
    1cee:	0f 91       	pop	r16
    1cf0:	ff 90       	pop	r15
    1cf2:	ef 90       	pop	r14
    1cf4:	df 90       	pop	r13
    1cf6:	cf 90       	pop	r12
    1cf8:	08 95       	ret

00001cfa <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    1cfa:	cf 92       	push	r12
    1cfc:	df 92       	push	r13
    1cfe:	ef 92       	push	r14
    1d00:	ff 92       	push	r15
    1d02:	0f 93       	push	r16
    1d04:	1f 93       	push	r17
    1d06:	cf 93       	push	r28
    1d08:	df 93       	push	r29
    1d0a:	7c 01       	movw	r14, r24
    1d0c:	d6 2e       	mov	r13, r22
    1d0e:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1d10:	86 2f       	mov	r24, r22
    1d12:	83 70       	andi	r24, 0x03	; 3
    1d14:	29 f4       	brne	.+10     	; 0x1d20 <adcch_read_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    1d16:	96 2f       	mov	r25, r22
    1d18:	96 95       	lsr	r25
    1d1a:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1d1c:	82 e0       	ldi	r24, 0x02	; 2
    1d1e:	02 c0       	rjmp	.+4      	; 0x1d24 <adcch_read_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1d20:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1d22:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1d24:	90 ff       	sbrs	r25, 0
		index++;
    1d26:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1d28:	e7 01       	movw	r28, r14
    1d2a:	a0 96       	adiw	r28, 0x20	; 32
    1d2c:	98 e0       	ldi	r25, 0x08	; 8
    1d2e:	89 9f       	mul	r24, r25
    1d30:	c0 0d       	add	r28, r0
    1d32:	d1 1d       	adc	r29, r1
    1d34:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1d36:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1d38:	f8 94       	cli

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1d3a:	c7 01       	movw	r24, r14
    1d3c:	47 dd       	rcall	.-1394   	; 0x17cc <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    1d3e:	88 81       	ld	r24, Y
    1d40:	f8 01       	movw	r30, r16
    1d42:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    1d44:	8a 81       	ldd	r24, Y+2	; 0x02
    1d46:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    1d48:	89 81       	ldd	r24, Y+1	; 0x01
    1d4a:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1d4c:	d0 fe       	sbrs	r13, 0
    1d4e:	02 c0       	rjmp	.+4      	; 0x1d54 <adcch_read_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    1d50:	8e 81       	ldd	r24, Y+6	; 0x06
    1d52:	83 83       	std	Z+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    1d54:	c7 01       	movw	r24, r14
    1d56:	5b dd       	rcall	.-1354   	; 0x180e <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1d58:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1d5a:	df 91       	pop	r29
    1d5c:	cf 91       	pop	r28
    1d5e:	1f 91       	pop	r17
    1d60:	0f 91       	pop	r16
    1d62:	ff 90       	pop	r15
    1d64:	ef 90       	pop	r14
    1d66:	df 90       	pop	r13
    1d68:	cf 90       	pop	r12
    1d6a:	08 95       	ret

00001d6c <twim_interrupt_handler>:
 * \brief Common TWI master interrupt service routine.
 *
 *  Check current status and calls the appropriate handler.
 */
static void twim_interrupt_handler(void)
{
    1d6c:	cf 93       	push	r28
    1d6e:	df 93       	push	r29
	uint8_t const master_status = transfer.bus->MASTER.STATUS;
    1d70:	e0 91 d7 23 	lds	r30, 0x23D7
    1d74:	f0 91 d8 23 	lds	r31, 0x23D8
    1d78:	84 81       	ldd	r24, Z+4	; 0x04

	if (master_status & TWI_MASTER_ARBLOST_bm) {
    1d7a:	83 ff       	sbrs	r24, 3
    1d7c:	08 c0       	rjmp	.+16     	; 0x1d8e <twim_interrupt_handler+0x22>

		transfer.bus->MASTER.STATUS = master_status | TWI_MASTER_ARBLOST_bm;
    1d7e:	88 60       	ori	r24, 0x08	; 8
    1d80:	84 83       	std	Z+4, r24	; 0x04
		transfer.bus->MASTER.CTRLC  = TWI_MASTER_CMD_STOP_gc;
    1d82:	83 e0       	ldi	r24, 0x03	; 3
    1d84:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_BUSY;
    1d86:	86 ef       	ldi	r24, 0xF6	; 246
    1d88:	80 93 e1 23 	sts	0x23E1, r24
    1d8c:	83 c0       	rjmp	.+262    	; 0x1e94 <twim_interrupt_handler+0x128>
    1d8e:	98 2f       	mov	r25, r24
    1d90:	94 71       	andi	r25, 0x14	; 20

	} else if ((master_status & TWI_MASTER_BUSERR_bm) ||
    1d92:	31 f0       	breq	.+12     	; 0x1da0 <twim_interrupt_handler+0x34>
		(master_status & TWI_MASTER_RXACK_bm)) {

		transfer.bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1d94:	83 e0       	ldi	r24, 0x03	; 3
    1d96:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_IO_ERROR;
    1d98:	8f ef       	ldi	r24, 0xFF	; 255
    1d9a:	80 93 e1 23 	sts	0x23E1, r24
    1d9e:	7a c0       	rjmp	.+244    	; 0x1e94 <twim_interrupt_handler+0x128>

	} else if (master_status & TWI_MASTER_WIF_bm) {
    1da0:	86 ff       	sbrs	r24, 6
    1da2:	43 c0       	rjmp	.+134    	; 0x1e2a <twim_interrupt_handler+0xbe>
 *  Handles TWI transactions (master write) and responses to (N)ACK.
 */
static inline void twim_write_handler(void)
{
	TWI_t * const         bus = transfer.bus;
	twi_package_t * const pkg = transfer.pkg;
    1da4:	c7 ed       	ldi	r28, 0xD7	; 215
    1da6:	d3 e2       	ldi	r29, 0x23	; 35
    1da8:	aa 81       	ldd	r26, Y+2	; 0x02
    1daa:	bb 81       	ldd	r27, Y+3	; 0x03

	if (transfer.addr_count < pkg->addr_length) {
    1dac:	8c 81       	ldd	r24, Y+4	; 0x04
    1dae:	9d 81       	ldd	r25, Y+5	; 0x05
    1db0:	14 96       	adiw	r26, 0x04	; 4
    1db2:	2d 91       	ld	r18, X+
    1db4:	3c 91       	ld	r19, X
    1db6:	15 97       	sbiw	r26, 0x05	; 5
    1db8:	82 17       	cp	r24, r18
    1dba:	93 07       	cpc	r25, r19
    1dbc:	6c f4       	brge	.+26     	; 0x1dd8 <twim_interrupt_handler+0x6c>

		const uint8_t * const data = pkg->addr;
		bus->MASTER.DATA = data[transfer.addr_count++];
    1dbe:	9c 01       	movw	r18, r24
    1dc0:	2f 5f       	subi	r18, 0xFF	; 255
    1dc2:	3f 4f       	sbci	r19, 0xFF	; 255
    1dc4:	20 93 db 23 	sts	0x23DB, r18
    1dc8:	30 93 dc 23 	sts	0x23DC, r19
    1dcc:	a8 0f       	add	r26, r24
    1dce:	b9 1f       	adc	r27, r25
    1dd0:	11 96       	adiw	r26, 0x01	; 1
    1dd2:	8c 91       	ld	r24, X
    1dd4:	87 83       	std	Z+7, r24	; 0x07
    1dd6:	5e c0       	rjmp	.+188    	; 0x1e94 <twim_interrupt_handler+0x128>

	} else if (transfer.data_count < pkg->length) {
    1dd8:	80 91 dd 23 	lds	r24, 0x23DD
    1ddc:	90 91 de 23 	lds	r25, 0x23DE
    1de0:	18 96       	adiw	r26, 0x08	; 8
    1de2:	2d 91       	ld	r18, X+
    1de4:	3c 91       	ld	r19, X
    1de6:	19 97       	sbiw	r26, 0x09	; 9
    1de8:	82 17       	cp	r24, r18
    1dea:	93 07       	cpc	r25, r19
    1dec:	c8 f4       	brcc	.+50     	; 0x1e20 <twim_interrupt_handler+0xb4>

		if (transfer.read) {
    1dee:	20 91 df 23 	lds	r18, 0x23DF
    1df2:	22 23       	and	r18, r18
    1df4:	21 f0       	breq	.+8      	; 0x1dfe <twim_interrupt_handler+0x92>

			/* Send repeated START condition (Address|R/W=1). */

			bus->MASTER.ADDR |= 0x01;
    1df6:	86 81       	ldd	r24, Z+6	; 0x06
    1df8:	81 60       	ori	r24, 0x01	; 1
    1dfa:	86 83       	std	Z+6, r24	; 0x06
    1dfc:	4b c0       	rjmp	.+150    	; 0x1e94 <twim_interrupt_handler+0x128>

		} else {
			const uint8_t * const data = pkg->buffer;
    1dfe:	16 96       	adiw	r26, 0x06	; 6
    1e00:	2d 91       	ld	r18, X+
    1e02:	3c 91       	ld	r19, X
    1e04:	17 97       	sbiw	r26, 0x07	; 7
			bus->MASTER.DATA = data[transfer.data_count++];
    1e06:	ac 01       	movw	r20, r24
    1e08:	4f 5f       	subi	r20, 0xFF	; 255
    1e0a:	5f 4f       	sbci	r21, 0xFF	; 255
    1e0c:	40 93 dd 23 	sts	0x23DD, r20
    1e10:	50 93 de 23 	sts	0x23DE, r21
    1e14:	d9 01       	movw	r26, r18
    1e16:	a8 0f       	add	r26, r24
    1e18:	b9 1f       	adc	r27, r25
    1e1a:	8c 91       	ld	r24, X
    1e1c:	87 83       	std	Z+7, r24	; 0x07
    1e1e:	3a c0       	rjmp	.+116    	; 0x1e94 <twim_interrupt_handler+0x128>

	} else {

		/* Send STOP condition to complete the transaction. */

		bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1e20:	83 e0       	ldi	r24, 0x03	; 3
    1e22:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = STATUS_OK;
    1e24:	10 92 e1 23 	sts	0x23E1, r1
    1e28:	35 c0       	rjmp	.+106    	; 0x1e94 <twim_interrupt_handler+0x128>

	} else if (master_status & TWI_MASTER_WIF_bm) {

		twim_write_handler();

	} else if (master_status & TWI_MASTER_RIF_bm) {
    1e2a:	88 23       	and	r24, r24
    1e2c:	84 f5       	brge	.+96     	; 0x1e8e <twim_interrupt_handler+0x122>
 *  reading bytes from the TWI slave.
 */
static inline void twim_read_handler(void)
{
	TWI_t * const         bus = transfer.bus;
	twi_package_t * const pkg = transfer.pkg;
    1e2e:	a7 ed       	ldi	r26, 0xD7	; 215
    1e30:	b3 e2       	ldi	r27, 0x23	; 35
    1e32:	12 96       	adiw	r26, 0x02	; 2
    1e34:	cd 91       	ld	r28, X+
    1e36:	dc 91       	ld	r29, X
    1e38:	13 97       	sbiw	r26, 0x03	; 3

	if (transfer.data_count < pkg->length) {
    1e3a:	16 96       	adiw	r26, 0x06	; 6
    1e3c:	8d 91       	ld	r24, X+
    1e3e:	9c 91       	ld	r25, X
    1e40:	17 97       	sbiw	r26, 0x07	; 7
    1e42:	28 85       	ldd	r18, Y+8	; 0x08
    1e44:	39 85       	ldd	r19, Y+9	; 0x09
    1e46:	82 17       	cp	r24, r18
    1e48:	93 07       	cpc	r25, r19
    1e4a:	d8 f4       	brcc	.+54     	; 0x1e82 <twim_interrupt_handler+0x116>

		uint8_t * const data = pkg->buffer;
    1e4c:	6e 81       	ldd	r22, Y+6	; 0x06
    1e4e:	7f 81       	ldd	r23, Y+7	; 0x07
		data[transfer.data_count++] = bus->MASTER.DATA;
    1e50:	9c 01       	movw	r18, r24
    1e52:	2f 5f       	subi	r18, 0xFF	; 255
    1e54:	3f 4f       	sbci	r19, 0xFF	; 255
    1e56:	20 93 dd 23 	sts	0x23DD, r18
    1e5a:	30 93 de 23 	sts	0x23DE, r19
    1e5e:	47 81       	ldd	r20, Z+7	; 0x07
    1e60:	db 01       	movw	r26, r22
    1e62:	a8 0f       	add	r26, r24
    1e64:	b9 1f       	adc	r27, r25
    1e66:	4c 93       	st	X, r20

		/* If there is more to read, issue ACK and start a byte read.
		 * Otherwise, issue NACK and STOP to complete the transaction.
		 */
		if (transfer.data_count < pkg->length) {
    1e68:	88 85       	ldd	r24, Y+8	; 0x08
    1e6a:	99 85       	ldd	r25, Y+9	; 0x09
    1e6c:	28 17       	cp	r18, r24
    1e6e:	39 07       	cpc	r19, r25
    1e70:	18 f4       	brcc	.+6      	; 0x1e78 <twim_interrupt_handler+0x10c>

			bus->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
    1e72:	82 e0       	ldi	r24, 0x02	; 2
    1e74:	83 83       	std	Z+3, r24	; 0x03
    1e76:	0e c0       	rjmp	.+28     	; 0x1e94 <twim_interrupt_handler+0x128>

		} else {

			bus->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    1e78:	87 e0       	ldi	r24, 0x07	; 7
    1e7a:	83 83       	std	Z+3, r24	; 0x03
			transfer.status = STATUS_OK;
    1e7c:	10 92 e1 23 	sts	0x23E1, r1
    1e80:	09 c0       	rjmp	.+18     	; 0x1e94 <twim_interrupt_handler+0x128>

	} else {

		/* Issue STOP and buffer overflow condition. */

		bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1e82:	83 e0       	ldi	r24, 0x03	; 3
    1e84:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_NO_MEMORY;
    1e86:	89 ef       	ldi	r24, 0xF9	; 249
    1e88:	80 93 e1 23 	sts	0x23E1, r24
    1e8c:	03 c0       	rjmp	.+6      	; 0x1e94 <twim_interrupt_handler+0x128>

		twim_read_handler();

	} else {

		transfer.status = ERR_PROTOCOL;
    1e8e:	8b ef       	ldi	r24, 0xFB	; 251
    1e90:	80 93 e1 23 	sts	0x23E1, r24
	}
}
    1e94:	df 91       	pop	r29
    1e96:	cf 91       	pop	r28
    1e98:	08 95       	ret

00001e9a <__vector_13>:
 * parameters specified in the global \c transfer structure.
 */
static void twim_interrupt_handler(void);

#ifdef TWIC
ISR(TWIC_TWIM_vect) { twim_interrupt_handler(); }
    1e9a:	1f 92       	push	r1
    1e9c:	0f 92       	push	r0
    1e9e:	0f b6       	in	r0, 0x3f	; 63
    1ea0:	0f 92       	push	r0
    1ea2:	11 24       	eor	r1, r1
    1ea4:	0b b6       	in	r0, 0x3b	; 59
    1ea6:	0f 92       	push	r0
    1ea8:	2f 93       	push	r18
    1eaa:	3f 93       	push	r19
    1eac:	4f 93       	push	r20
    1eae:	5f 93       	push	r21
    1eb0:	6f 93       	push	r22
    1eb2:	7f 93       	push	r23
    1eb4:	8f 93       	push	r24
    1eb6:	9f 93       	push	r25
    1eb8:	af 93       	push	r26
    1eba:	bf 93       	push	r27
    1ebc:	ef 93       	push	r30
    1ebe:	ff 93       	push	r31
    1ec0:	55 df       	rcall	.-342    	; 0x1d6c <twim_interrupt_handler>
    1ec2:	ff 91       	pop	r31
    1ec4:	ef 91       	pop	r30
    1ec6:	bf 91       	pop	r27
    1ec8:	af 91       	pop	r26
    1eca:	9f 91       	pop	r25
    1ecc:	8f 91       	pop	r24
    1ece:	7f 91       	pop	r23
    1ed0:	6f 91       	pop	r22
    1ed2:	5f 91       	pop	r21
    1ed4:	4f 91       	pop	r20
    1ed6:	3f 91       	pop	r19
    1ed8:	2f 91       	pop	r18
    1eda:	0f 90       	pop	r0
    1edc:	0b be       	out	0x3b, r0	; 59
    1ede:	0f 90       	pop	r0
    1ee0:	0f be       	out	0x3f, r0	; 63
    1ee2:	0f 90       	pop	r0
    1ee4:	1f 90       	pop	r1
    1ee6:	18 95       	reti

00001ee8 <__vector_46>:
#endif
#ifdef TWID
ISR(TWID_TWIM_vect) { twim_interrupt_handler(); }
#endif
#ifdef TWIE
ISR(TWIE_TWIM_vect) { twim_interrupt_handler(); }
    1ee8:	1f 92       	push	r1
    1eea:	0f 92       	push	r0
    1eec:	0f b6       	in	r0, 0x3f	; 63
    1eee:	0f 92       	push	r0
    1ef0:	11 24       	eor	r1, r1
    1ef2:	0b b6       	in	r0, 0x3b	; 59
    1ef4:	0f 92       	push	r0
    1ef6:	2f 93       	push	r18
    1ef8:	3f 93       	push	r19
    1efa:	4f 93       	push	r20
    1efc:	5f 93       	push	r21
    1efe:	6f 93       	push	r22
    1f00:	7f 93       	push	r23
    1f02:	8f 93       	push	r24
    1f04:	9f 93       	push	r25
    1f06:	af 93       	push	r26
    1f08:	bf 93       	push	r27
    1f0a:	ef 93       	push	r30
    1f0c:	ff 93       	push	r31
    1f0e:	2e df       	rcall	.-420    	; 0x1d6c <twim_interrupt_handler>
    1f10:	ff 91       	pop	r31
    1f12:	ef 91       	pop	r30
    1f14:	bf 91       	pop	r27
    1f16:	af 91       	pop	r26
    1f18:	9f 91       	pop	r25
    1f1a:	8f 91       	pop	r24
    1f1c:	7f 91       	pop	r23
    1f1e:	6f 91       	pop	r22
    1f20:	5f 91       	pop	r21
    1f22:	4f 91       	pop	r20
    1f24:	3f 91       	pop	r19
    1f26:	2f 91       	pop	r18
    1f28:	0f 90       	pop	r0
    1f2a:	0b be       	out	0x3b, r0	; 59
    1f2c:	0f 90       	pop	r0
    1f2e:	0f be       	out	0x3f, r0	; 63
    1f30:	0f 90       	pop	r0
    1f32:	1f 90       	pop	r1
    1f34:	18 95       	reti

00001f36 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1f36:	cf 92       	push	r12
    1f38:	df 92       	push	r13
    1f3a:	ef 92       	push	r14
    1f3c:	ff 92       	push	r15
    1f3e:	0f 93       	push	r16
    1f40:	1f 93       	push	r17
    1f42:	cf 93       	push	r28
    1f44:	df 93       	push	r29
    1f46:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    1f48:	d9 01       	movw	r26, r18
    1f4a:	c8 01       	movw	r24, r16
    1f4c:	b6 95       	lsr	r27
    1f4e:	a7 95       	ror	r26
    1f50:	97 95       	ror	r25
    1f52:	87 95       	ror	r24
    1f54:	48 17       	cp	r20, r24
    1f56:	59 07       	cpc	r21, r25
    1f58:	6a 07       	cpc	r22, r26
    1f5a:	7b 07       	cpc	r23, r27
    1f5c:	78 f4       	brcc	.+30     	; 0x1f7c <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1f5e:	6a 01       	movw	r12, r20
    1f60:	7b 01       	movw	r14, r22
    1f62:	cc 0c       	add	r12, r12
    1f64:	dd 1c       	adc	r13, r13
    1f66:	ee 1c       	adc	r14, r14
    1f68:	ff 1c       	adc	r15, r15
    1f6a:	c9 01       	movw	r24, r18
    1f6c:	b8 01       	movw	r22, r16
    1f6e:	a7 01       	movw	r20, r14
    1f70:	96 01       	movw	r18, r12
    1f72:	0e 94 41 1e 	call	0x3c82	; 0x3c82 <__udivmodsi4>
    1f76:	21 50       	subi	r18, 0x01	; 1
    1f78:	31 09       	sbc	r19, r1
    1f7a:	02 c0       	rjmp	.+4      	; 0x1f80 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1f7c:	20 e0       	ldi	r18, 0x00	; 0
    1f7e:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1f80:	83 2f       	mov	r24, r19
    1f82:	8f 70       	andi	r24, 0x0F	; 15
    1f84:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1f86:	2e 83       	std	Y+6, r18	; 0x06
}
    1f88:	df 91       	pop	r29
    1f8a:	cf 91       	pop	r28
    1f8c:	1f 91       	pop	r17
    1f8e:	0f 91       	pop	r16
    1f90:	ff 90       	pop	r15
    1f92:	ef 90       	pop	r14
    1f94:	df 90       	pop	r13
    1f96:	cf 90       	pop	r12
    1f98:	08 95       	ret

00001f9a <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1f9a:	ef 92       	push	r14
    1f9c:	ff 92       	push	r15
    1f9e:	0f 93       	push	r16
    1fa0:	1f 93       	push	r17
    1fa2:	cf 93       	push	r28
    1fa4:	df 93       	push	r29
    1fa6:	ec 01       	movw	r28, r24
    1fa8:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1faa:	00 97       	sbiw	r24, 0x00	; 0
    1fac:	09 f4       	brne	.+2      	; 0x1fb0 <usart_init_spi+0x16>
    1fae:	8c c1       	rjmp	.+792    	; 0x22c8 <usart_init_spi+0x32e>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1fb0:	80 3c       	cpi	r24, 0xC0	; 192
    1fb2:	91 05       	cpc	r25, r1
    1fb4:	29 f4       	brne	.+10     	; 0x1fc0 <usart_init_spi+0x26>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1fb6:	60 e1       	ldi	r22, 0x10	; 16
    1fb8:	80 e0       	ldi	r24, 0x00	; 0
    1fba:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    1fbe:	84 c1       	rjmp	.+776    	; 0x22c8 <usart_init_spi+0x32e>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1fc0:	80 38       	cpi	r24, 0x80	; 128
    1fc2:	91 40       	sbci	r25, 0x01	; 1
    1fc4:	29 f4       	brne	.+10     	; 0x1fd0 <usart_init_spi+0x36>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1fc6:	62 e0       	ldi	r22, 0x02	; 2
    1fc8:	80 e0       	ldi	r24, 0x00	; 0
    1fca:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    1fce:	7c c1       	rjmp	.+760    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1fd0:	c1 15       	cp	r28, r1
    1fd2:	81 e0       	ldi	r24, 0x01	; 1
    1fd4:	d8 07       	cpc	r29, r24
    1fd6:	29 f4       	brne	.+10     	; 0x1fe2 <usart_init_spi+0x48>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1fd8:	61 e0       	ldi	r22, 0x01	; 1
    1fda:	80 e0       	ldi	r24, 0x00	; 0
    1fdc:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    1fe0:	73 c1       	rjmp	.+742    	; 0x22c8 <usart_init_spi+0x32e>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1fe2:	c0 38       	cpi	r28, 0x80	; 128
    1fe4:	e3 e0       	ldi	r30, 0x03	; 3
    1fe6:	de 07       	cpc	r29, r30
    1fe8:	29 f4       	brne	.+10     	; 0x1ff4 <usart_init_spi+0x5a>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1fea:	61 e0       	ldi	r22, 0x01	; 1
    1fec:	81 e0       	ldi	r24, 0x01	; 1
    1fee:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    1ff2:	6a c1       	rjmp	.+724    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1ff4:	c0 39       	cpi	r28, 0x90	; 144
    1ff6:	f3 e0       	ldi	r31, 0x03	; 3
    1ff8:	df 07       	cpc	r29, r31
    1ffa:	29 f4       	brne	.+10     	; 0x2006 <usart_init_spi+0x6c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1ffc:	61 e0       	ldi	r22, 0x01	; 1
    1ffe:	82 e0       	ldi	r24, 0x02	; 2
    2000:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    2004:	61 c1       	rjmp	.+706    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    2006:	c1 15       	cp	r28, r1
    2008:	32 e0       	ldi	r19, 0x02	; 2
    200a:	d3 07       	cpc	r29, r19
    200c:	29 f4       	brne	.+10     	; 0x2018 <usart_init_spi+0x7e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    200e:	62 e0       	ldi	r22, 0x02	; 2
    2010:	81 e0       	ldi	r24, 0x01	; 1
    2012:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    2016:	58 c1       	rjmp	.+688    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    2018:	c0 34       	cpi	r28, 0x40	; 64
    201a:	82 e0       	ldi	r24, 0x02	; 2
    201c:	d8 07       	cpc	r29, r24
    201e:	29 f4       	brne	.+10     	; 0x202a <usart_init_spi+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    2020:	62 e0       	ldi	r22, 0x02	; 2
    2022:	82 e0       	ldi	r24, 0x02	; 2
    2024:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    2028:	4f c1       	rjmp	.+670    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    202a:	c0 32       	cpi	r28, 0x20	; 32
    202c:	e3 e0       	ldi	r30, 0x03	; 3
    202e:	de 07       	cpc	r29, r30
    2030:	29 f4       	brne	.+10     	; 0x203c <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    2032:	64 e0       	ldi	r22, 0x04	; 4
    2034:	82 e0       	ldi	r24, 0x02	; 2
    2036:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    203a:	46 c1       	rjmp	.+652    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    203c:	c1 15       	cp	r28, r1
    203e:	f8 e0       	ldi	r31, 0x08	; 8
    2040:	df 07       	cpc	r29, r31
    2042:	29 f4       	brne	.+10     	; 0x204e <usart_init_spi+0xb4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    2044:	61 e0       	ldi	r22, 0x01	; 1
    2046:	83 e0       	ldi	r24, 0x03	; 3
    2048:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    204c:	3d c1       	rjmp	.+634    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    204e:	c1 15       	cp	r28, r1
    2050:	39 e0       	ldi	r19, 0x09	; 9
    2052:	d3 07       	cpc	r29, r19
    2054:	29 f4       	brne	.+10     	; 0x2060 <usart_init_spi+0xc6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    2056:	61 e0       	ldi	r22, 0x01	; 1
    2058:	84 e0       	ldi	r24, 0x04	; 4
    205a:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    205e:	34 c1       	rjmp	.+616    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    2060:	c1 15       	cp	r28, r1
    2062:	8a e0       	ldi	r24, 0x0A	; 10
    2064:	d8 07       	cpc	r29, r24
    2066:	29 f4       	brne	.+10     	; 0x2072 <usart_init_spi+0xd8>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    2068:	61 e0       	ldi	r22, 0x01	; 1
    206a:	85 e0       	ldi	r24, 0x05	; 5
    206c:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    2070:	2b c1       	rjmp	.+598    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    2072:	c1 15       	cp	r28, r1
    2074:	eb e0       	ldi	r30, 0x0B	; 11
    2076:	de 07       	cpc	r29, r30
    2078:	29 f4       	brne	.+10     	; 0x2084 <usart_init_spi+0xea>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    207a:	61 e0       	ldi	r22, 0x01	; 1
    207c:	86 e0       	ldi	r24, 0x06	; 6
    207e:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    2082:	22 c1       	rjmp	.+580    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    2084:	c0 34       	cpi	r28, 0x40	; 64
    2086:	f8 e0       	ldi	r31, 0x08	; 8
    2088:	df 07       	cpc	r29, r31
    208a:	29 f4       	brne	.+10     	; 0x2096 <usart_init_spi+0xfc>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    208c:	62 e0       	ldi	r22, 0x02	; 2
    208e:	83 e0       	ldi	r24, 0x03	; 3
    2090:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    2094:	19 c1       	rjmp	.+562    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    2096:	c0 34       	cpi	r28, 0x40	; 64
    2098:	39 e0       	ldi	r19, 0x09	; 9
    209a:	d3 07       	cpc	r29, r19
    209c:	29 f4       	brne	.+10     	; 0x20a8 <usart_init_spi+0x10e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    209e:	62 e0       	ldi	r22, 0x02	; 2
    20a0:	84 e0       	ldi	r24, 0x04	; 4
    20a2:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    20a6:	10 c1       	rjmp	.+544    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    20a8:	c0 34       	cpi	r28, 0x40	; 64
    20aa:	8a e0       	ldi	r24, 0x0A	; 10
    20ac:	d8 07       	cpc	r29, r24
    20ae:	29 f4       	brne	.+10     	; 0x20ba <usart_init_spi+0x120>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    20b0:	62 e0       	ldi	r22, 0x02	; 2
    20b2:	85 e0       	ldi	r24, 0x05	; 5
    20b4:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    20b8:	07 c1       	rjmp	.+526    	; 0x22c8 <usart_init_spi+0x32e>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    20ba:	c0 39       	cpi	r28, 0x90	; 144
    20bc:	e8 e0       	ldi	r30, 0x08	; 8
    20be:	de 07       	cpc	r29, r30
    20c0:	29 f4       	brne	.+10     	; 0x20cc <usart_init_spi+0x132>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    20c2:	64 e0       	ldi	r22, 0x04	; 4
    20c4:	83 e0       	ldi	r24, 0x03	; 3
    20c6:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    20ca:	fe c0       	rjmp	.+508    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    20cc:	c0 39       	cpi	r28, 0x90	; 144
    20ce:	f9 e0       	ldi	r31, 0x09	; 9
    20d0:	df 07       	cpc	r29, r31
    20d2:	29 f4       	brne	.+10     	; 0x20de <usart_init_spi+0x144>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    20d4:	64 e0       	ldi	r22, 0x04	; 4
    20d6:	84 e0       	ldi	r24, 0x04	; 4
    20d8:	0e 94 72 18 	call	0x30e4	; 0x30e4 <sysclk_enable_module>
    20dc:	f5 c0       	rjmp	.+490    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    20de:	c0 39       	cpi	r28, 0x90	; 144
    20e0:	3a e0       	ldi	r19, 0x0A	; 10
    20e2:	d3 07       	cpc	r29, r19
    20e4:	21 f4       	brne	.+8      	; 0x20ee <usart_init_spi+0x154>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    20e6:	64 e0       	ldi	r22, 0x04	; 4
    20e8:	85 e0       	ldi	r24, 0x05	; 5
    20ea:	fc d7       	rcall	.+4088   	; 0x30e4 <sysclk_enable_module>
    20ec:	ed c0       	rjmp	.+474    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    20ee:	c0 39       	cpi	r28, 0x90	; 144
    20f0:	8b e0       	ldi	r24, 0x0B	; 11
    20f2:	d8 07       	cpc	r29, r24
    20f4:	21 f4       	brne	.+8      	; 0x20fe <usart_init_spi+0x164>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    20f6:	64 e0       	ldi	r22, 0x04	; 4
    20f8:	86 e0       	ldi	r24, 0x06	; 6
    20fa:	f4 d7       	rcall	.+4072   	; 0x30e4 <sysclk_enable_module>
    20fc:	e5 c0       	rjmp	.+458    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    20fe:	c0 3c       	cpi	r28, 0xC0	; 192
    2100:	e8 e0       	ldi	r30, 0x08	; 8
    2102:	de 07       	cpc	r29, r30
    2104:	21 f4       	brne	.+8      	; 0x210e <usart_init_spi+0x174>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    2106:	68 e0       	ldi	r22, 0x08	; 8
    2108:	83 e0       	ldi	r24, 0x03	; 3
    210a:	ec d7       	rcall	.+4056   	; 0x30e4 <sysclk_enable_module>
    210c:	dd c0       	rjmp	.+442    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    210e:	c0 3c       	cpi	r28, 0xC0	; 192
    2110:	f9 e0       	ldi	r31, 0x09	; 9
    2112:	df 07       	cpc	r29, r31
    2114:	21 f4       	brne	.+8      	; 0x211e <usart_init_spi+0x184>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    2116:	68 e0       	ldi	r22, 0x08	; 8
    2118:	84 e0       	ldi	r24, 0x04	; 4
    211a:	e4 d7       	rcall	.+4040   	; 0x30e4 <sysclk_enable_module>
    211c:	d5 c0       	rjmp	.+426    	; 0x22c8 <usart_init_spi+0x32e>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    211e:	c0 3a       	cpi	r28, 0xA0	; 160
    2120:	38 e0       	ldi	r19, 0x08	; 8
    2122:	d3 07       	cpc	r29, r19
    2124:	61 f4       	brne	.+24     	; 0x213e <usart_init_spi+0x1a4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    2126:	60 e1       	ldi	r22, 0x10	; 16
    2128:	83 e0       	ldi	r24, 0x03	; 3
    212a:	dc d7       	rcall	.+4024   	; 0x30e4 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    212c:	e0 ea       	ldi	r30, 0xA0	; 160
    212e:	f8 e0       	ldi	r31, 0x08	; 8
    2130:	84 81       	ldd	r24, Z+4	; 0x04
    2132:	8f 7e       	andi	r24, 0xEF	; 239
    2134:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    2136:	f7 01       	movw	r30, r14
    2138:	24 81       	ldd	r18, Z+4	; 0x04
    213a:	22 50       	subi	r18, 0x02	; 2
    213c:	43 c0       	rjmp	.+134    	; 0x21c4 <usart_init_spi+0x22a>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    213e:	c0 3a       	cpi	r28, 0xA0	; 160
    2140:	f9 e0       	ldi	r31, 0x09	; 9
    2142:	df 07       	cpc	r29, r31
    2144:	21 f4       	brne	.+8      	; 0x214e <usart_init_spi+0x1b4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    2146:	60 e1       	ldi	r22, 0x10	; 16
    2148:	84 e0       	ldi	r24, 0x04	; 4
    214a:	cc d7       	rcall	.+3992   	; 0x30e4 <sysclk_enable_module>
    214c:	bd c0       	rjmp	.+378    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    214e:	c0 3a       	cpi	r28, 0xA0	; 160
    2150:	3a e0       	ldi	r19, 0x0A	; 10
    2152:	d3 07       	cpc	r29, r19
    2154:	21 f4       	brne	.+8      	; 0x215e <usart_init_spi+0x1c4>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    2156:	60 e1       	ldi	r22, 0x10	; 16
    2158:	85 e0       	ldi	r24, 0x05	; 5
    215a:	c4 d7       	rcall	.+3976   	; 0x30e4 <sysclk_enable_module>
    215c:	b5 c0       	rjmp	.+362    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    215e:	c0 3a       	cpi	r28, 0xA0	; 160
    2160:	8b e0       	ldi	r24, 0x0B	; 11
    2162:	d8 07       	cpc	r29, r24
    2164:	21 f4       	brne	.+8      	; 0x216e <usart_init_spi+0x1d4>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    2166:	60 e1       	ldi	r22, 0x10	; 16
    2168:	86 e0       	ldi	r24, 0x06	; 6
    216a:	bc d7       	rcall	.+3960   	; 0x30e4 <sysclk_enable_module>
    216c:	ad c0       	rjmp	.+346    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    216e:	c0 3b       	cpi	r28, 0xB0	; 176
    2170:	e8 e0       	ldi	r30, 0x08	; 8
    2172:	de 07       	cpc	r29, r30
    2174:	21 f4       	brne	.+8      	; 0x217e <usart_init_spi+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    2176:	60 e2       	ldi	r22, 0x20	; 32
    2178:	83 e0       	ldi	r24, 0x03	; 3
    217a:	b4 d7       	rcall	.+3944   	; 0x30e4 <sysclk_enable_module>
    217c:	a5 c0       	rjmp	.+330    	; 0x22c8 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    217e:	c0 3b       	cpi	r28, 0xB0	; 176
    2180:	f9 e0       	ldi	r31, 0x09	; 9
    2182:	df 07       	cpc	r29, r31
    2184:	21 f4       	brne	.+8      	; 0x218e <usart_init_spi+0x1f4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    2186:	60 e2       	ldi	r22, 0x20	; 32
    2188:	84 e0       	ldi	r24, 0x04	; 4
    218a:	ac d7       	rcall	.+3928   	; 0x30e4 <sysclk_enable_module>
    218c:	9d c0       	rjmp	.+314    	; 0x22c8 <usart_init_spi+0x32e>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    218e:	c0 38       	cpi	r28, 0x80	; 128
    2190:	34 e0       	ldi	r19, 0x04	; 4
    2192:	d3 07       	cpc	r29, r19
    2194:	21 f4       	brne	.+8      	; 0x219e <usart_init_spi+0x204>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    2196:	60 e4       	ldi	r22, 0x40	; 64
    2198:	83 e0       	ldi	r24, 0x03	; 3
    219a:	a4 d7       	rcall	.+3912   	; 0x30e4 <sysclk_enable_module>
    219c:	95 c0       	rjmp	.+298    	; 0x22c8 <usart_init_spi+0x32e>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    219e:	c0 3a       	cpi	r28, 0xA0	; 160
    21a0:	84 e0       	ldi	r24, 0x04	; 4
    21a2:	d8 07       	cpc	r29, r24
    21a4:	21 f4       	brne	.+8      	; 0x21ae <usart_init_spi+0x214>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    21a6:	60 e4       	ldi	r22, 0x40	; 64
    21a8:	85 e0       	ldi	r24, 0x05	; 5
    21aa:	9c d7       	rcall	.+3896   	; 0x30e4 <sysclk_enable_module>
    21ac:	8d c0       	rjmp	.+282    	; 0x22c8 <usart_init_spi+0x32e>
    21ae:	8c 81       	ldd	r24, Y+4	; 0x04
    21b0:	8f 7e       	andi	r24, 0xEF	; 239
    21b2:	8c 83       	std	Y+4, r24	; 0x04
    21b4:	fb 01       	movw	r30, r22
    21b6:	24 81       	ldd	r18, Z+4	; 0x04
    21b8:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    21ba:	ce 01       	movw	r24, r28
    21bc:	c0 3a       	cpi	r28, 0xA0	; 160
    21be:	f8 e0       	ldi	r31, 0x08	; 8
    21c0:	df 07       	cpc	r29, r31
    21c2:	31 f4       	brne	.+12     	; 0x21d0 <usart_init_spi+0x236>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    21c4:	80 91 4e 06 	lds	r24, 0x064E
    21c8:	84 fd       	sbrc	r24, 4
    21ca:	86 c0       	rjmp	.+268    	; 0x22d8 <usart_init_spi+0x33e>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    21cc:	11 e1       	ldi	r17, 0x11	; 17
    21ce:	85 c0       	rjmp	.+266    	; 0x22da <usart_init_spi+0x340>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    21d0:	80 3b       	cpi	r24, 0xB0	; 176
    21d2:	38 e0       	ldi	r19, 0x08	; 8
    21d4:	93 07       	cpc	r25, r19
    21d6:	79 f0       	breq	.+30     	; 0x21f6 <usart_init_spi+0x25c>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    21d8:	80 3a       	cpi	r24, 0xA0	; 160
    21da:	e9 e0       	ldi	r30, 0x09	; 9
    21dc:	9e 07       	cpc	r25, r30
    21de:	31 f4       	brne	.+12     	; 0x21ec <usart_init_spi+0x252>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    21e0:	30 91 6e 06 	lds	r19, 0x066E
    21e4:	34 fd       	sbrc	r19, 4
    21e6:	7c c0       	rjmp	.+248    	; 0x22e0 <usart_init_spi+0x346>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    21e8:	19 e1       	ldi	r17, 0x19	; 25
    21ea:	10 c0       	rjmp	.+32     	; 0x220c <usart_init_spi+0x272>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    21ec:	80 3b       	cpi	r24, 0xB0	; 176
    21ee:	f9 e0       	ldi	r31, 0x09	; 9
    21f0:	9f 07       	cpc	r25, r31
    21f2:	a9 f0       	breq	.+42     	; 0x221e <usart_init_spi+0x284>
    21f4:	01 c0       	rjmp	.+2      	; 0x21f8 <usart_init_spi+0x25e>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    21f6:	15 e1       	ldi	r17, 0x15	; 21
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    21f8:	80 3a       	cpi	r24, 0xA0	; 160
    21fa:	3a e0       	ldi	r19, 0x0A	; 10
    21fc:	93 07       	cpc	r25, r19
    21fe:	31 f4       	brne	.+12     	; 0x220c <usart_init_spi+0x272>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    2200:	80 91 8e 06 	lds	r24, 0x068E
    2204:	84 fd       	sbrc	r24, 4
    2206:	6e c0       	rjmp	.+220    	; 0x22e4 <usart_init_spi+0x34a>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    2208:	11 e2       	ldi	r17, 0x21	; 33
    220a:	0c c0       	rjmp	.+24     	; 0x2224 <usart_init_spi+0x28a>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    220c:	80 3a       	cpi	r24, 0xA0	; 160
    220e:	9b 40       	sbci	r25, 0x0B	; 11
    2210:	49 f4       	brne	.+18     	; 0x2224 <usart_init_spi+0x28a>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    2212:	80 91 ae 06 	lds	r24, 0x06AE
    2216:	84 fd       	sbrc	r24, 4
    2218:	04 c0       	rjmp	.+8      	; 0x2222 <usart_init_spi+0x288>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    221a:	19 e2       	ldi	r17, 0x29	; 41
    221c:	03 c0       	rjmp	.+6      	; 0x2224 <usart_init_spi+0x28a>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    221e:	1d e1       	ldi	r17, 0x1D	; 29
    2220:	01 c0       	rjmp	.+2      	; 0x2224 <usart_init_spi+0x28a>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    2222:	1d e2       	ldi	r17, 0x2D	; 45
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    2224:	e1 2f       	mov	r30, r17
    2226:	e6 95       	lsr	r30
    2228:	e6 95       	lsr	r30
    222a:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    222c:	30 e2       	ldi	r19, 0x20	; 32
    222e:	e3 9f       	mul	r30, r19
    2230:	f0 01       	movw	r30, r0
    2232:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2234:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    2236:	17 70       	andi	r17, 0x07	; 7
    2238:	81 e0       	ldi	r24, 0x01	; 1
    223a:	90 e0       	ldi	r25, 0x00	; 0
    223c:	01 2e       	mov	r0, r17
    223e:	02 c0       	rjmp	.+4      	; 0x2244 <usart_init_spi+0x2aa>
    2240:	88 0f       	add	r24, r24
    2242:	99 1f       	adc	r25, r25
    2244:	0a 94       	dec	r0
    2246:	e2 f7       	brpl	.-8      	; 0x2240 <usart_init_spi+0x2a6>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    2248:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    224a:	22 30       	cpi	r18, 0x02	; 2
    224c:	10 f0       	brcs	.+4      	; 0x2252 <usart_init_spi+0x2b8>
    224e:	40 e0       	ldi	r20, 0x00	; 0
    2250:	01 c0       	rjmp	.+2      	; 0x2254 <usart_init_spi+0x2ba>
    2252:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    2254:	df 01       	movw	r26, r30
    2256:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    2258:	a1 0f       	add	r26, r17
    225a:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    225c:	3f b7       	in	r19, 0x3f	; 63
	cpu_irq_disable();
    225e:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    2260:	2c 91       	ld	r18, X
    2262:	27 70       	andi	r18, 0x07	; 7
    2264:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    2266:	9c 91       	ld	r25, X
    2268:	94 2b       	or	r25, r20
    226a:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    226c:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    226e:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    2270:	8d 81       	ldd	r24, Y+5	; 0x05
    2272:	80 6c       	ori	r24, 0xC0	; 192
    2274:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    2276:	f7 01       	movw	r30, r14
    2278:	84 81       	ldd	r24, Z+4	; 0x04
    227a:	8d 7f       	andi	r24, 0xFD	; 253
    227c:	81 30       	cpi	r24, 0x01	; 1
    227e:	21 f4       	brne	.+8      	; 0x2288 <usart_init_spi+0x2ee>
		usart->CTRLC |= USART_UCPHA_bm;
    2280:	8d 81       	ldd	r24, Y+5	; 0x05
    2282:	82 60       	ori	r24, 0x02	; 2
    2284:	8d 83       	std	Y+5, r24	; 0x05
    2286:	03 c0       	rjmp	.+6      	; 0x228e <usart_init_spi+0x2f4>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    2288:	8d 81       	ldd	r24, Y+5	; 0x05
    228a:	8d 7f       	andi	r24, 0xFD	; 253
    228c:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    228e:	f7 01       	movw	r30, r14
    2290:	85 81       	ldd	r24, Z+5	; 0x05
    2292:	88 23       	and	r24, r24
    2294:	21 f0       	breq	.+8      	; 0x229e <usart_init_spi+0x304>
		(usart)->CTRLC |= USART_DORD_bm;
    2296:	8d 81       	ldd	r24, Y+5	; 0x05
    2298:	84 60       	ori	r24, 0x04	; 4
    229a:	8d 83       	std	Y+5, r24	; 0x05
    229c:	03 c0       	rjmp	.+6      	; 0x22a4 <usart_init_spi+0x30a>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    229e:	8d 81       	ldd	r24, Y+5	; 0x05
    22a0:	8b 7f       	andi	r24, 0xFB	; 251
    22a2:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    22a4:	f7 01       	movw	r30, r14
    22a6:	40 81       	ld	r20, Z
    22a8:	51 81       	ldd	r21, Z+1	; 0x01
    22aa:	62 81       	ldd	r22, Z+2	; 0x02
    22ac:	73 81       	ldd	r23, Z+3	; 0x03
    22ae:	00 e0       	ldi	r16, 0x00	; 0
    22b0:	18 e4       	ldi	r17, 0x48	; 72
    22b2:	28 ee       	ldi	r18, 0xE8	; 232
    22b4:	31 e0       	ldi	r19, 0x01	; 1
    22b6:	ce 01       	movw	r24, r28
    22b8:	3e de       	rcall	.-900    	; 0x1f36 <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    22ba:	8c 81       	ldd	r24, Y+4	; 0x04
    22bc:	88 60       	ori	r24, 0x08	; 8
    22be:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    22c0:	8c 81       	ldd	r24, Y+4	; 0x04
    22c2:	80 61       	ori	r24, 0x10	; 16
    22c4:	8c 83       	std	Y+4, r24	; 0x04
    22c6:	10 c0       	rjmp	.+32     	; 0x22e8 <usart_init_spi+0x34e>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    22c8:	8c 81       	ldd	r24, Y+4	; 0x04
    22ca:	8f 7e       	andi	r24, 0xEF	; 239
    22cc:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    22ce:	f7 01       	movw	r30, r14
    22d0:	24 81       	ldd	r18, Z+4	; 0x04
    22d2:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    22d4:	ce 01       	movw	r24, r28
    22d6:	7c cf       	rjmp	.-264    	; 0x21d0 <usart_init_spi+0x236>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    22d8:	15 e1       	ldi	r17, 0x15	; 21
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    22da:	80 ea       	ldi	r24, 0xA0	; 160
    22dc:	98 e0       	ldi	r25, 0x08	; 8
    22de:	86 cf       	rjmp	.-244    	; 0x21ec <usart_init_spi+0x252>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    22e0:	1d e1       	ldi	r17, 0x1D	; 29
    22e2:	94 cf       	rjmp	.-216    	; 0x220c <usart_init_spi+0x272>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    22e4:	15 e2       	ldi	r17, 0x25	; 37
    22e6:	9e cf       	rjmp	.-196    	; 0x2224 <usart_init_spi+0x28a>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    22e8:	df 91       	pop	r29
    22ea:	cf 91       	pop	r28
    22ec:	1f 91       	pop	r17
    22ee:	0f 91       	pop	r16
    22f0:	ff 90       	pop	r15
    22f2:	ef 90       	pop	r14
    22f4:	08 95       	ret

000022f6 <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
    22f6:	80 3a       	cpi	r24, 0xA0	; 160
    22f8:	28 e0       	ldi	r18, 0x08	; 8
    22fa:	92 07       	cpc	r25, r18
    22fc:	21 f4       	brne	.+8      	; 0x2306 <usart_spi_init+0x10>
    22fe:	60 e1       	ldi	r22, 0x10	; 16
    2300:	83 e0       	ldi	r24, 0x03	; 3
    2302:	f0 c6       	rjmp	.+3552   	; 0x30e4 <sysclk_enable_module>
    2304:	08 95       	ret
    2306:	80 3b       	cpi	r24, 0xB0	; 176
    2308:	28 e0       	ldi	r18, 0x08	; 8
    230a:	92 07       	cpc	r25, r18
    230c:	21 f4       	brne	.+8      	; 0x2316 <usart_spi_init+0x20>
    230e:	60 e2       	ldi	r22, 0x20	; 32
    2310:	83 e0       	ldi	r24, 0x03	; 3
    2312:	e8 c6       	rjmp	.+3536   	; 0x30e4 <sysclk_enable_module>
    2314:	08 95       	ret
    2316:	80 3a       	cpi	r24, 0xA0	; 160
    2318:	29 e0       	ldi	r18, 0x09	; 9
    231a:	92 07       	cpc	r25, r18
    231c:	21 f4       	brne	.+8      	; 0x2326 <usart_spi_init+0x30>
    231e:	60 e1       	ldi	r22, 0x10	; 16
    2320:	84 e0       	ldi	r24, 0x04	; 4
    2322:	e0 c6       	rjmp	.+3520   	; 0x30e4 <sysclk_enable_module>
    2324:	08 95       	ret
    2326:	80 3b       	cpi	r24, 0xB0	; 176
    2328:	29 e0       	ldi	r18, 0x09	; 9
    232a:	92 07       	cpc	r25, r18
    232c:	21 f4       	brne	.+8      	; 0x2336 <usart_spi_init+0x40>
    232e:	60 e2       	ldi	r22, 0x20	; 32
    2330:	84 e0       	ldi	r24, 0x04	; 4
    2332:	d8 c6       	rjmp	.+3504   	; 0x30e4 <sysclk_enable_module>
    2334:	08 95       	ret
    2336:	80 3a       	cpi	r24, 0xA0	; 160
    2338:	2a e0       	ldi	r18, 0x0A	; 10
    233a:	92 07       	cpc	r25, r18
    233c:	21 f4       	brne	.+8      	; 0x2346 <usart_spi_init+0x50>
    233e:	60 e1       	ldi	r22, 0x10	; 16
    2340:	85 e0       	ldi	r24, 0x05	; 5
    2342:	d0 c6       	rjmp	.+3488   	; 0x30e4 <sysclk_enable_module>
    2344:	08 95       	ret
    2346:	80 3a       	cpi	r24, 0xA0	; 160
    2348:	9b 40       	sbci	r25, 0x0B	; 11
    234a:	19 f4       	brne	.+6      	; 0x2352 <usart_spi_init+0x5c>
    234c:	60 e1       	ldi	r22, 0x10	; 16
    234e:	86 e0       	ldi	r24, 0x06	; 6
    2350:	c9 c6       	rjmp	.+3474   	; 0x30e4 <sysclk_enable_module>
    2352:	08 95       	ret

00002354 <usart_spi_setup_device>:
    2354:	0f 93       	push	r16
    2356:	1f 93       	push	r17
    2358:	cf 93       	push	r28
    235a:	df 93       	push	r29
    235c:	00 d0       	rcall	.+0      	; 0x235e <usart_spi_setup_device+0xa>
    235e:	00 d0       	rcall	.+0      	; 0x2360 <usart_spi_setup_device+0xc>
    2360:	cd b7       	in	r28, 0x3d	; 61
    2362:	de b7       	in	r29, 0x3e	; 62
    2364:	09 83       	std	Y+1, r16	; 0x01
    2366:	1a 83       	std	Y+2, r17	; 0x02
    2368:	2b 83       	std	Y+3, r18	; 0x03
    236a:	3c 83       	std	Y+4, r19	; 0x04
    236c:	4d 83       	std	Y+5, r20	; 0x05
    236e:	1e 82       	std	Y+6, r1	; 0x06
    2370:	be 01       	movw	r22, r28
    2372:	6f 5f       	subi	r22, 0xFF	; 255
    2374:	7f 4f       	sbci	r23, 0xFF	; 255
    2376:	11 de       	rcall	.-990    	; 0x1f9a <usart_init_spi>
    2378:	26 96       	adiw	r28, 0x06	; 6
    237a:	cd bf       	out	0x3d, r28	; 61
    237c:	de bf       	out	0x3e, r29	; 62
    237e:	df 91       	pop	r29
    2380:	cf 91       	pop	r28
    2382:	1f 91       	pop	r17
    2384:	0f 91       	pop	r16
    2386:	08 95       	ret

00002388 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
    2388:	fb 01       	movw	r30, r22
    238a:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    238c:	e8 2f       	mov	r30, r24
    238e:	e6 95       	lsr	r30
    2390:	e6 95       	lsr	r30
    2392:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    2394:	40 e2       	ldi	r20, 0x20	; 32
    2396:	e4 9f       	mul	r30, r20
    2398:	f0 01       	movw	r30, r0
    239a:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    239c:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    239e:	87 70       	andi	r24, 0x07	; 7
    23a0:	21 e0       	ldi	r18, 0x01	; 1
    23a2:	30 e0       	ldi	r19, 0x00	; 0
    23a4:	a9 01       	movw	r20, r18
    23a6:	02 c0       	rjmp	.+4      	; 0x23ac <usart_spi_select_device+0x24>
    23a8:	44 0f       	add	r20, r20
    23aa:	55 1f       	adc	r21, r21
    23ac:	8a 95       	dec	r24
    23ae:	e2 f7       	brpl	.-8      	; 0x23a8 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    23b0:	46 83       	std	Z+6, r20	; 0x06
    23b2:	08 95       	ret

000023b4 <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
    23b4:	fb 01       	movw	r30, r22
    23b6:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    23b8:	e8 2f       	mov	r30, r24
    23ba:	e6 95       	lsr	r30
    23bc:	e6 95       	lsr	r30
    23be:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    23c0:	40 e2       	ldi	r20, 0x20	; 32
    23c2:	e4 9f       	mul	r30, r20
    23c4:	f0 01       	movw	r30, r0
    23c6:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    23c8:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    23ca:	87 70       	andi	r24, 0x07	; 7
    23cc:	21 e0       	ldi	r18, 0x01	; 1
    23ce:	30 e0       	ldi	r19, 0x00	; 0
    23d0:	a9 01       	movw	r20, r18
    23d2:	02 c0       	rjmp	.+4      	; 0x23d8 <usart_spi_deselect_device+0x24>
    23d4:	44 0f       	add	r20, r20
    23d6:	55 1f       	adc	r21, r21
    23d8:	8a 95       	dec	r24
    23da:	e2 f7       	brpl	.-8      	; 0x23d4 <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    23dc:	45 83       	std	Z+5, r20	; 0x05
    23de:	08 95       	ret

000023e0 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
    23e0:	80 93 e2 23 	sts	0x23E2, r24
    23e4:	90 93 e3 23 	sts	0x23E3, r25
    23e8:	08 95       	ret

000023ea <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    23ea:	20 e8       	ldi	r18, 0x80	; 128
    23ec:	82 9f       	mul	r24, r18
    23ee:	c0 01       	movw	r24, r0
    23f0:	11 24       	eor	r1, r1
    23f2:	86 0f       	add	r24, r22
    23f4:	91 1d       	adc	r25, r1
    23f6:	e0 91 e2 23 	lds	r30, 0x23E2
    23fa:	f0 91 e3 23 	lds	r31, 0x23E3
    23fe:	e8 0f       	add	r30, r24
    2400:	f9 1f       	adc	r31, r25
    2402:	40 83       	st	Z, r20
    2404:	08 95       	ret

00002406 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
    2406:	20 e8       	ldi	r18, 0x80	; 128
    2408:	82 9f       	mul	r24, r18
    240a:	c0 01       	movw	r24, r0
    240c:	11 24       	eor	r1, r1
    240e:	86 0f       	add	r24, r22
    2410:	91 1d       	adc	r25, r1
    2412:	e0 91 e2 23 	lds	r30, 0x23E2
    2416:	f0 91 e3 23 	lds	r31, 0x23E3
    241a:	e8 0f       	add	r30, r24
    241c:	f9 1f       	adc	r31, r25
}
    241e:	80 81       	ld	r24, Z
    2420:	08 95       	ret

00002422 <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
    2422:	ff 92       	push	r15
    2424:	0f 93       	push	r16
    2426:	1f 93       	push	r17
    2428:	cf 93       	push	r28
    242a:	df 93       	push	r29
    242c:	e4 2f       	mov	r30, r20
    242e:	f0 e0       	ldi	r31, 0x00	; 0
    2430:	e8 0f       	add	r30, r24
    2432:	f1 1d       	adc	r31, r1
    2434:	e1 38       	cpi	r30, 0x81	; 129
    2436:	f1 05       	cpc	r31, r1
    2438:	1c f0       	brlt	.+6      	; 0x2440 <gfx_mono_generic_draw_horizontal_line+0x1e>
    243a:	c0 e8       	ldi	r28, 0x80	; 128
    243c:	4c 2f       	mov	r20, r28
    243e:	48 1b       	sub	r20, r24
    2440:	44 23       	and	r20, r20
    2442:	09 f4       	brne	.+2      	; 0x2446 <gfx_mono_generic_draw_horizontal_line+0x24>
    2444:	53 c0       	rjmp	.+166    	; 0x24ec <gfx_mono_generic_draw_horizontal_line+0xca>
    2446:	d6 2f       	mov	r29, r22
    2448:	d6 95       	lsr	r29
    244a:	d6 95       	lsr	r29
    244c:	d6 95       	lsr	r29
    244e:	ed 2f       	mov	r30, r29
    2450:	f0 e0       	ldi	r31, 0x00	; 0
    2452:	f1 95       	neg	r31
    2454:	e1 95       	neg	r30
    2456:	f1 09       	sbc	r31, r1
    2458:	ee 0f       	add	r30, r30
    245a:	ff 1f       	adc	r31, r31
    245c:	ee 0f       	add	r30, r30
    245e:	ff 1f       	adc	r31, r31
    2460:	ee 0f       	add	r30, r30
    2462:	ff 1f       	adc	r31, r31
    2464:	df 01       	movw	r26, r30
    2466:	a6 0f       	add	r26, r22
    2468:	b1 1d       	adc	r27, r1
    246a:	bd 01       	movw	r22, r26
    246c:	e1 e0       	ldi	r30, 0x01	; 1
    246e:	f0 e0       	ldi	r31, 0x00	; 0
    2470:	df 01       	movw	r26, r30
    2472:	02 c0       	rjmp	.+4      	; 0x2478 <gfx_mono_generic_draw_horizontal_line+0x56>
    2474:	aa 0f       	add	r26, r26
    2476:	bb 1f       	adc	r27, r27
    2478:	6a 95       	dec	r22
    247a:	e2 f7       	brpl	.-8      	; 0x2474 <gfx_mono_generic_draw_horizontal_line+0x52>
    247c:	fa 2e       	mov	r15, r26
    247e:	21 30       	cpi	r18, 0x01	; 1
    2480:	21 f0       	breq	.+8      	; 0x248a <gfx_mono_generic_draw_horizontal_line+0x68>
    2482:	98 f0       	brcs	.+38     	; 0x24aa <gfx_mono_generic_draw_horizontal_line+0x88>
    2484:	22 30       	cpi	r18, 0x02	; 2
    2486:	19 f1       	breq	.+70     	; 0x24ce <gfx_mono_generic_draw_horizontal_line+0xac>
    2488:	31 c0       	rjmp	.+98     	; 0x24ec <gfx_mono_generic_draw_horizontal_line+0xca>
    248a:	c4 2f       	mov	r28, r20
    248c:	1f ef       	ldi	r17, 0xFF	; 255
    248e:	18 0f       	add	r17, r24
    2490:	01 2f       	mov	r16, r17
    2492:	0c 0f       	add	r16, r28
    2494:	60 2f       	mov	r22, r16
    2496:	8d 2f       	mov	r24, r29
    2498:	55 d9       	rcall	.-3414   	; 0x1744 <gfx_mono_st7565r_get_byte>
    249a:	48 2f       	mov	r20, r24
    249c:	4f 29       	or	r20, r15
    249e:	60 2f       	mov	r22, r16
    24a0:	8d 2f       	mov	r24, r29
    24a2:	29 d8       	rcall	.-4014   	; 0x14f6 <gfx_mono_st7565r_put_byte>
    24a4:	c1 50       	subi	r28, 0x01	; 1
    24a6:	a1 f7       	brne	.-24     	; 0x2490 <gfx_mono_generic_draw_horizontal_line+0x6e>
    24a8:	21 c0       	rjmp	.+66     	; 0x24ec <gfx_mono_generic_draw_horizontal_line+0xca>
    24aa:	c4 2f       	mov	r28, r20
    24ac:	1f ef       	ldi	r17, 0xFF	; 255
    24ae:	18 0f       	add	r17, r24
    24b0:	fa 2e       	mov	r15, r26
    24b2:	f0 94       	com	r15
    24b4:	01 2f       	mov	r16, r17
    24b6:	0c 0f       	add	r16, r28
    24b8:	60 2f       	mov	r22, r16
    24ba:	8d 2f       	mov	r24, r29
    24bc:	43 d9       	rcall	.-3450   	; 0x1744 <gfx_mono_st7565r_get_byte>
    24be:	48 2f       	mov	r20, r24
    24c0:	4f 21       	and	r20, r15
    24c2:	60 2f       	mov	r22, r16
    24c4:	8d 2f       	mov	r24, r29
    24c6:	17 d8       	rcall	.-4050   	; 0x14f6 <gfx_mono_st7565r_put_byte>
    24c8:	c1 50       	subi	r28, 0x01	; 1
    24ca:	a1 f7       	brne	.-24     	; 0x24b4 <gfx_mono_generic_draw_horizontal_line+0x92>
    24cc:	0f c0       	rjmp	.+30     	; 0x24ec <gfx_mono_generic_draw_horizontal_line+0xca>
    24ce:	c4 2f       	mov	r28, r20
    24d0:	1f ef       	ldi	r17, 0xFF	; 255
    24d2:	18 0f       	add	r17, r24
    24d4:	01 2f       	mov	r16, r17
    24d6:	0c 0f       	add	r16, r28
    24d8:	60 2f       	mov	r22, r16
    24da:	8d 2f       	mov	r24, r29
    24dc:	33 d9       	rcall	.-3482   	; 0x1744 <gfx_mono_st7565r_get_byte>
    24de:	48 2f       	mov	r20, r24
    24e0:	4f 25       	eor	r20, r15
    24e2:	60 2f       	mov	r22, r16
    24e4:	8d 2f       	mov	r24, r29
    24e6:	07 d8       	rcall	.-4082   	; 0x14f6 <gfx_mono_st7565r_put_byte>
    24e8:	c1 50       	subi	r28, 0x01	; 1
    24ea:	a1 f7       	brne	.-24     	; 0x24d4 <gfx_mono_generic_draw_horizontal_line+0xb2>
    24ec:	df 91       	pop	r29
    24ee:	cf 91       	pop	r28
    24f0:	1f 91       	pop	r17
    24f2:	0f 91       	pop	r16
    24f4:	ff 90       	pop	r15
    24f6:	08 95       	ret

000024f8 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
    24f8:	ff 92       	push	r15
    24fa:	0f 93       	push	r16
    24fc:	1f 93       	push	r17
    24fe:	cf 93       	push	r28
    2500:	df 93       	push	r29
	if (height == 0) {
    2502:	22 23       	and	r18, r18
    2504:	69 f0       	breq	.+26     	; 0x2520 <gfx_mono_generic_draw_filled_rect+0x28>
    2506:	c2 2f       	mov	r28, r18
    2508:	f4 2e       	mov	r15, r20
    250a:	18 2f       	mov	r17, r24
    250c:	df ef       	ldi	r29, 0xFF	; 255
    250e:	d6 0f       	add	r29, r22
    2510:	6d 2f       	mov	r22, r29
    2512:	6c 0f       	add	r22, r28
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
    2514:	20 2f       	mov	r18, r16
    2516:	4f 2d       	mov	r20, r15
    2518:	81 2f       	mov	r24, r17
    251a:	83 df       	rcall	.-250    	; 0x2422 <gfx_mono_generic_draw_horizontal_line>
    251c:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
    251e:	c1 f7       	brne	.-16     	; 0x2510 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
    2520:	df 91       	pop	r29
    2522:	cf 91       	pop	r28
    2524:	1f 91       	pop	r17
    2526:	0f 91       	pop	r16
    2528:	ff 90       	pop	r15
    252a:	08 95       	ret

0000252c <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
    252c:	af 92       	push	r10
    252e:	bf 92       	push	r11
    2530:	cf 92       	push	r12
    2532:	df 92       	push	r13
    2534:	ef 92       	push	r14
    2536:	ff 92       	push	r15
    2538:	0f 93       	push	r16
    253a:	1f 93       	push	r17
    253c:	cf 93       	push	r28
    253e:	df 93       	push	r29
    2540:	c8 2f       	mov	r28, r24
    2542:	e6 2e       	mov	r14, r22
    2544:	b4 2e       	mov	r11, r20
    2546:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
    2548:	00 e0       	ldi	r16, 0x00	; 0
    254a:	f9 01       	movw	r30, r18
    254c:	24 81       	ldd	r18, Z+4	; 0x04
    254e:	43 81       	ldd	r20, Z+3	; 0x03
    2550:	6b 2d       	mov	r22, r11
    2552:	8e 2d       	mov	r24, r14
    2554:	d1 df       	rcall	.-94     	; 0x24f8 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
    2556:	f6 01       	movw	r30, r12
    2558:	80 81       	ld	r24, Z
    255a:	81 11       	cpse	r24, r1
    255c:	39 c0       	rjmp	.+114    	; 0x25d0 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
    255e:	83 81       	ldd	r24, Z+3	; 0x03
    2560:	28 2f       	mov	r18, r24
    2562:	26 95       	lsr	r18
    2564:	26 95       	lsr	r18
    2566:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
    2568:	87 70       	andi	r24, 0x07	; 7
    256a:	09 f0       	breq	.+2      	; 0x256e <gfx_mono_draw_char+0x42>
		char_row_size++;
    256c:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
    256e:	f6 01       	movw	r30, r12
    2570:	a4 80       	ldd	r10, Z+4	; 0x04
    2572:	2a 9d       	mul	r18, r10
    2574:	90 01       	movw	r18, r0
    2576:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
    2578:	8c 2f       	mov	r24, r28
    257a:	90 e0       	ldi	r25, 0x00	; 0
    257c:	45 81       	ldd	r20, Z+5	; 0x05
    257e:	84 1b       	sub	r24, r20
    2580:	91 09       	sbc	r25, r1
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
    2582:	28 9f       	mul	r18, r24
    2584:	a0 01       	movw	r20, r0
    2586:	29 9f       	mul	r18, r25
    2588:	50 0d       	add	r21, r0
    258a:	38 9f       	mul	r19, r24
    258c:	50 0d       	add	r21, r0
    258e:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
    2590:	01 81       	ldd	r16, Z+1	; 0x01
    2592:	12 81       	ldd	r17, Z+2	; 0x02
    2594:	04 0f       	add	r16, r20
    2596:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
    2598:	f6 01       	movw	r30, r12
    259a:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
    259c:	ff 20       	and	r15, r15
    259e:	a1 f0       	breq	.+40     	; 0x25c8 <gfx_mono_draw_char+0x9c>
    25a0:	d0 e0       	ldi	r29, 0x00	; 0
    25a2:	c0 e0       	ldi	r28, 0x00	; 0
    25a4:	8c 2f       	mov	r24, r28
    25a6:	8e 0d       	add	r24, r14
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
    25a8:	9c 2f       	mov	r25, r28
    25aa:	97 70       	andi	r25, 0x07	; 7
    25ac:	21 f4       	brne	.+8      	; 0x25b6 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
    25ae:	f8 01       	movw	r30, r16
    25b0:	d4 91       	lpm	r29, Z
				glyph_data++;
    25b2:	0f 5f       	subi	r16, 0xFF	; 255
    25b4:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
    25b6:	dd 23       	and	r29, r29
    25b8:	1c f4       	brge	.+6      	; 0x25c0 <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
    25ba:	41 e0       	ldi	r20, 0x01	; 1
    25bc:	6b 2d       	mov	r22, r11
    25be:	84 d8       	rcall	.-3832   	; 0x16c8 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
    25c0:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
    25c2:	cf 5f       	subi	r28, 0xFF	; 255
    25c4:	cf 11       	cpse	r28, r15
    25c6:	ee cf       	rjmp	.-36     	; 0x25a4 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
    25c8:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
    25ca:	aa 94       	dec	r10
	} while (rows_left > 0);
    25cc:	a1 10       	cpse	r10, r1
    25ce:	e4 cf       	rjmp	.-56     	; 0x2598 <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
    25d0:	df 91       	pop	r29
    25d2:	cf 91       	pop	r28
    25d4:	1f 91       	pop	r17
    25d6:	0f 91       	pop	r16
    25d8:	ff 90       	pop	r15
    25da:	ef 90       	pop	r14
    25dc:	df 90       	pop	r13
    25de:	cf 90       	pop	r12
    25e0:	bf 90       	pop	r11
    25e2:	af 90       	pop	r10
    25e4:	08 95       	ret

000025e6 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
    25e6:	df 92       	push	r13
    25e8:	ef 92       	push	r14
    25ea:	ff 92       	push	r15
    25ec:	0f 93       	push	r16
    25ee:	1f 93       	push	r17
    25f0:	cf 93       	push	r28
    25f2:	df 93       	push	r29
    25f4:	04 2f       	mov	r16, r20
    25f6:	79 01       	movw	r14, r18
    25f8:	ec 01       	movw	r28, r24
    25fa:	16 2f       	mov	r17, r22

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    25fc:	d6 2e       	mov	r13, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
    25fe:	89 91       	ld	r24, Y+
    2600:	8a 30       	cpi	r24, 0x0A	; 10
    2602:	31 f4       	brne	.+12     	; 0x2610 <gfx_mono_draw_string+0x2a>
    2604:	f7 01       	movw	r30, r14
    2606:	84 81       	ldd	r24, Z+4	; 0x04
    2608:	8f 5f       	subi	r24, 0xFF	; 255
			x = start_of_string_position_x;
			y += font->height + 1;
    260a:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    260c:	1d 2d       	mov	r17, r13
    260e:	09 c0       	rjmp	.+18     	; 0x2622 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
    2610:	8d 30       	cpi	r24, 0x0D	; 13
    2612:	39 f0       	breq	.+14     	; 0x2622 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
    2614:	97 01       	movw	r18, r14
    2616:	40 2f       	mov	r20, r16
    2618:	61 2f       	mov	r22, r17
    261a:	88 df       	rcall	.-240    	; 0x252c <gfx_mono_draw_char>
			x += font->width;
    261c:	f7 01       	movw	r30, r14
    261e:	83 81       	ldd	r24, Z+3	; 0x03
    2620:	18 0f       	add	r17, r24
		}
	} while (*(++str));
    2622:	88 81       	ld	r24, Y
    2624:	81 11       	cpse	r24, r1
    2626:	eb cf       	rjmp	.-42     	; 0x25fe <gfx_mono_draw_string+0x18>
}
    2628:	df 91       	pop	r29
    262a:	cf 91       	pop	r28
    262c:	1f 91       	pop	r17
    262e:	0f 91       	pop	r16
    2630:	ff 90       	pop	r15
    2632:	ef 90       	pop	r14
    2634:	df 90       	pop	r13
    2636:	08 95       	ret

00002638 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2638:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    263a:	03 96       	adiw	r24, 0x03	; 3
    263c:	81 83       	std	Z+1, r24	; 0x01
    263e:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2640:	2f ef       	ldi	r18, 0xFF	; 255
    2642:	3f ef       	ldi	r19, 0xFF	; 255
    2644:	23 83       	std	Z+3, r18	; 0x03
    2646:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2648:	85 83       	std	Z+5, r24	; 0x05
    264a:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    264c:	87 83       	std	Z+7, r24	; 0x07
    264e:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2650:	10 82       	st	Z, r1
    2652:	08 95       	ret

00002654 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2654:	fc 01       	movw	r30, r24
    2656:	10 86       	std	Z+8, r1	; 0x08
    2658:	11 86       	std	Z+9, r1	; 0x09
    265a:	08 95       	ret

0000265c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    265c:	cf 93       	push	r28
    265e:	df 93       	push	r29
    2660:	9c 01       	movw	r18, r24
    2662:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2664:	dc 01       	movw	r26, r24
    2666:	11 96       	adiw	r26, 0x01	; 1
    2668:	cd 91       	ld	r28, X+
    266a:	dc 91       	ld	r29, X
    266c:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    266e:	c2 83       	std	Z+2, r28	; 0x02
    2670:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2672:	8c 81       	ldd	r24, Y+4	; 0x04
    2674:	9d 81       	ldd	r25, Y+5	; 0x05
    2676:	84 83       	std	Z+4, r24	; 0x04
    2678:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    267a:	8c 81       	ldd	r24, Y+4	; 0x04
    267c:	9d 81       	ldd	r25, Y+5	; 0x05
    267e:	dc 01       	movw	r26, r24
    2680:	12 96       	adiw	r26, 0x02	; 2
    2682:	6d 93       	st	X+, r22
    2684:	7c 93       	st	X, r23
    2686:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    2688:	6c 83       	std	Y+4, r22	; 0x04
    268a:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    268c:	20 87       	std	Z+8, r18	; 0x08
    268e:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    2690:	f9 01       	movw	r30, r18
    2692:	80 81       	ld	r24, Z
    2694:	8f 5f       	subi	r24, 0xFF	; 255
    2696:	80 83       	st	Z, r24
}
    2698:	df 91       	pop	r29
    269a:	cf 91       	pop	r28
    269c:	08 95       	ret

0000269e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    269e:	cf 93       	push	r28
    26a0:	df 93       	push	r29
    26a2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    26a4:	48 81       	ld	r20, Y
    26a6:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    26a8:	4f 3f       	cpi	r20, 0xFF	; 255
    26aa:	2f ef       	ldi	r18, 0xFF	; 255
    26ac:	52 07       	cpc	r21, r18
    26ae:	21 f4       	brne	.+8      	; 0x26b8 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    26b0:	fc 01       	movw	r30, r24
    26b2:	a7 81       	ldd	r26, Z+7	; 0x07
    26b4:	b0 85       	ldd	r27, Z+8	; 0x08
    26b6:	0d c0       	rjmp	.+26     	; 0x26d2 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    26b8:	dc 01       	movw	r26, r24
    26ba:	13 96       	adiw	r26, 0x03	; 3
    26bc:	01 c0       	rjmp	.+2      	; 0x26c0 <vListInsert+0x22>
    26be:	df 01       	movw	r26, r30
    26c0:	12 96       	adiw	r26, 0x02	; 2
    26c2:	ed 91       	ld	r30, X+
    26c4:	fc 91       	ld	r31, X
    26c6:	13 97       	sbiw	r26, 0x03	; 3
    26c8:	20 81       	ld	r18, Z
    26ca:	31 81       	ldd	r19, Z+1	; 0x01
    26cc:	42 17       	cp	r20, r18
    26ce:	53 07       	cpc	r21, r19
    26d0:	b0 f7       	brcc	.-20     	; 0x26be <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    26d2:	12 96       	adiw	r26, 0x02	; 2
    26d4:	ed 91       	ld	r30, X+
    26d6:	fc 91       	ld	r31, X
    26d8:	13 97       	sbiw	r26, 0x03	; 3
    26da:	ea 83       	std	Y+2, r30	; 0x02
    26dc:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    26de:	c4 83       	std	Z+4, r28	; 0x04
    26e0:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    26e2:	ac 83       	std	Y+4, r26	; 0x04
    26e4:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    26e6:	12 96       	adiw	r26, 0x02	; 2
    26e8:	cd 93       	st	X+, r28
    26ea:	dc 93       	st	X, r29
    26ec:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    26ee:	88 87       	std	Y+8, r24	; 0x08
    26f0:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    26f2:	fc 01       	movw	r30, r24
    26f4:	20 81       	ld	r18, Z
    26f6:	2f 5f       	subi	r18, 0xFF	; 255
    26f8:	20 83       	st	Z, r18
}
    26fa:	df 91       	pop	r29
    26fc:	cf 91       	pop	r28
    26fe:	08 95       	ret

00002700 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2700:	cf 93       	push	r28
    2702:	df 93       	push	r29
    2704:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    2706:	a0 85       	ldd	r26, Z+8	; 0x08
    2708:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    270a:	c2 81       	ldd	r28, Z+2	; 0x02
    270c:	d3 81       	ldd	r29, Z+3	; 0x03
    270e:	84 81       	ldd	r24, Z+4	; 0x04
    2710:	95 81       	ldd	r25, Z+5	; 0x05
    2712:	8c 83       	std	Y+4, r24	; 0x04
    2714:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2716:	c4 81       	ldd	r28, Z+4	; 0x04
    2718:	d5 81       	ldd	r29, Z+5	; 0x05
    271a:	82 81       	ldd	r24, Z+2	; 0x02
    271c:	93 81       	ldd	r25, Z+3	; 0x03
    271e:	8a 83       	std	Y+2, r24	; 0x02
    2720:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2722:	11 96       	adiw	r26, 0x01	; 1
    2724:	cd 91       	ld	r28, X+
    2726:	dc 91       	ld	r29, X
    2728:	12 97       	sbiw	r26, 0x02	; 2
    272a:	ce 17       	cp	r28, r30
    272c:	df 07       	cpc	r29, r31
    272e:	31 f4       	brne	.+12     	; 0x273c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2730:	8c 81       	ldd	r24, Y+4	; 0x04
    2732:	9d 81       	ldd	r25, Y+5	; 0x05
    2734:	11 96       	adiw	r26, 0x01	; 1
    2736:	8d 93       	st	X+, r24
    2738:	9c 93       	st	X, r25
    273a:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    273c:	10 86       	std	Z+8, r1	; 0x08
    273e:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    2740:	8c 91       	ld	r24, X
    2742:	81 50       	subi	r24, 0x01	; 1
    2744:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    2746:	df 91       	pop	r29
    2748:	cf 91       	pop	r28
    274a:	08 95       	ret

0000274c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    274c:	0f 93       	push	r16
    274e:	1f 93       	push	r17
    2750:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    2752:	71 e1       	ldi	r23, 0x11	; 17
    2754:	fc 01       	movw	r30, r24
    2756:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    2758:	31 97       	sbiw	r30, 0x01	; 1
    275a:	62 e2       	ldi	r22, 0x22	; 34
    275c:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    275e:	31 97       	sbiw	r30, 0x01	; 1
    2760:	23 e3       	ldi	r18, 0x33	; 51
    2762:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    2764:	01 2e       	mov	r0, r17
    2766:	00 0c       	add	r0, r0
    2768:	22 0b       	sbc	r18, r18
    276a:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    276c:	31 97       	sbiw	r30, 0x01	; 1
    276e:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    2770:	31 97       	sbiw	r30, 0x01	; 1
    2772:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    2774:	31 97       	sbiw	r30, 0x01	; 1
    2776:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    2778:	31 97       	sbiw	r30, 0x01	; 1
    277a:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    277c:	31 97       	sbiw	r30, 0x01	; 1
    277e:	20 e8       	ldi	r18, 0x80	; 128
    2780:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    2782:	31 97       	sbiw	r30, 0x01	; 1
    2784:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    2786:	31 97       	sbiw	r30, 0x01	; 1
    2788:	22 e0       	ldi	r18, 0x02	; 2
    278a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    278c:	31 97       	sbiw	r30, 0x01	; 1
    278e:	23 e0       	ldi	r18, 0x03	; 3
    2790:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    2792:	31 97       	sbiw	r30, 0x01	; 1
    2794:	24 e0       	ldi	r18, 0x04	; 4
    2796:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    2798:	31 97       	sbiw	r30, 0x01	; 1
    279a:	25 e0       	ldi	r18, 0x05	; 5
    279c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    279e:	31 97       	sbiw	r30, 0x01	; 1
    27a0:	26 e0       	ldi	r18, 0x06	; 6
    27a2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    27a4:	31 97       	sbiw	r30, 0x01	; 1
    27a6:	27 e0       	ldi	r18, 0x07	; 7
    27a8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    27aa:	31 97       	sbiw	r30, 0x01	; 1
    27ac:	28 e0       	ldi	r18, 0x08	; 8
    27ae:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    27b0:	31 97       	sbiw	r30, 0x01	; 1
    27b2:	29 e0       	ldi	r18, 0x09	; 9
    27b4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    27b6:	31 97       	sbiw	r30, 0x01	; 1
    27b8:	20 e1       	ldi	r18, 0x10	; 16
    27ba:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    27bc:	31 97       	sbiw	r30, 0x01	; 1
    27be:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    27c0:	31 97       	sbiw	r30, 0x01	; 1
    27c2:	22 e1       	ldi	r18, 0x12	; 18
    27c4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    27c6:	31 97       	sbiw	r30, 0x01	; 1
    27c8:	23 e1       	ldi	r18, 0x13	; 19
    27ca:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    27cc:	31 97       	sbiw	r30, 0x01	; 1
    27ce:	24 e1       	ldi	r18, 0x14	; 20
    27d0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    27d2:	31 97       	sbiw	r30, 0x01	; 1
    27d4:	25 e1       	ldi	r18, 0x15	; 21
    27d6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    27d8:	31 97       	sbiw	r30, 0x01	; 1
    27da:	26 e1       	ldi	r18, 0x16	; 22
    27dc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    27de:	31 97       	sbiw	r30, 0x01	; 1
    27e0:	27 e1       	ldi	r18, 0x17	; 23
    27e2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    27e4:	31 97       	sbiw	r30, 0x01	; 1
    27e6:	28 e1       	ldi	r18, 0x18	; 24
    27e8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    27ea:	31 97       	sbiw	r30, 0x01	; 1
    27ec:	29 e1       	ldi	r18, 0x19	; 25
    27ee:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    27f0:	31 97       	sbiw	r30, 0x01	; 1
    27f2:	20 e2       	ldi	r18, 0x20	; 32
    27f4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    27f6:	31 97       	sbiw	r30, 0x01	; 1
    27f8:	21 e2       	ldi	r18, 0x21	; 33
    27fa:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    27fc:	31 97       	sbiw	r30, 0x01	; 1
    27fe:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    2800:	31 97       	sbiw	r30, 0x01	; 1
    2802:	23 e2       	ldi	r18, 0x23	; 35
    2804:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    2806:	31 97       	sbiw	r30, 0x01	; 1
    2808:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    280a:	31 97       	sbiw	r30, 0x01	; 1
    280c:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    280e:	31 97       	sbiw	r30, 0x01	; 1
    2810:	26 e2       	ldi	r18, 0x26	; 38
    2812:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    2814:	31 97       	sbiw	r30, 0x01	; 1
    2816:	27 e2       	ldi	r18, 0x27	; 39
    2818:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    281a:	31 97       	sbiw	r30, 0x01	; 1
    281c:	28 e2       	ldi	r18, 0x28	; 40
    281e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    2820:	31 97       	sbiw	r30, 0x01	; 1
    2822:	29 e2       	ldi	r18, 0x29	; 41
    2824:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    2826:	31 97       	sbiw	r30, 0x01	; 1
    2828:	20 e3       	ldi	r18, 0x30	; 48
    282a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    282c:	31 97       	sbiw	r30, 0x01	; 1
    282e:	21 e3       	ldi	r18, 0x31	; 49
    2830:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    2832:	87 97       	sbiw	r24, 0x27	; 39
    2834:	1f 91       	pop	r17
    2836:	0f 91       	pop	r16
    2838:	08 95       	ret

0000283a <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    283a:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    283c:	e0 e7       	ldi	r30, 0x70	; 112
    283e:	f0 e0       	ldi	r31, 0x00	; 0
    2840:	83 81       	ldd	r24, Z+3	; 0x03
    2842:	8a 7f       	andi	r24, 0xFA	; 250
    2844:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    2846:	e0 e0       	ldi	r30, 0x00	; 0
    2848:	f8 e0       	ldi	r31, 0x08	; 8
    284a:	80 ea       	ldi	r24, 0xA0	; 160
    284c:	9f e0       	ldi	r25, 0x0F	; 15
    284e:	86 a3       	std	Z+38, r24	; 0x26
    2850:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    2852:	91 e0       	ldi	r25, 0x01	; 1
    2854:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    2856:	a0 ea       	ldi	r26, 0xA0	; 160
    2858:	b0 e0       	ldi	r27, 0x00	; 0
    285a:	12 96       	adiw	r26, 0x02	; 2
    285c:	8c 91       	ld	r24, X
    285e:	12 97       	sbiw	r26, 0x02	; 2
    2860:	81 60       	ori	r24, 0x01	; 1
    2862:	12 96       	adiw	r26, 0x02	; 2
    2864:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    2866:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    2868:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    286a:	a0 91 3a 24 	lds	r26, 0x243A
    286e:	b0 91 3b 24 	lds	r27, 0x243B
    2872:	0d 90       	ld	r0, X+
    2874:	0d be       	out	0x3d, r0	; 61
    2876:	0d 90       	ld	r0, X+
    2878:	0e be       	out	0x3e, r0	; 62
    287a:	ff 91       	pop	r31
    287c:	ef 91       	pop	r30
    287e:	df 91       	pop	r29
    2880:	cf 91       	pop	r28
    2882:	bf 91       	pop	r27
    2884:	af 91       	pop	r26
    2886:	9f 91       	pop	r25
    2888:	8f 91       	pop	r24
    288a:	7f 91       	pop	r23
    288c:	6f 91       	pop	r22
    288e:	5f 91       	pop	r21
    2890:	4f 91       	pop	r20
    2892:	3f 91       	pop	r19
    2894:	2f 91       	pop	r18
    2896:	1f 91       	pop	r17
    2898:	0f 91       	pop	r16
    289a:	ff 90       	pop	r15
    289c:	ef 90       	pop	r14
    289e:	df 90       	pop	r13
    28a0:	cf 90       	pop	r12
    28a2:	bf 90       	pop	r11
    28a4:	af 90       	pop	r10
    28a6:	9f 90       	pop	r9
    28a8:	8f 90       	pop	r8
    28aa:	7f 90       	pop	r7
    28ac:	6f 90       	pop	r6
    28ae:	5f 90       	pop	r5
    28b0:	4f 90       	pop	r4
    28b2:	3f 90       	pop	r3
    28b4:	2f 90       	pop	r2
    28b6:	1f 90       	pop	r1
    28b8:	0f 90       	pop	r0
    28ba:	0f be       	out	0x3f, r0	; 63
    28bc:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    28be:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    28c0:	81 e0       	ldi	r24, 0x01	; 1
    28c2:	08 95       	ret

000028c4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    28c4:	0f 92       	push	r0
    28c6:	0f b6       	in	r0, 0x3f	; 63
    28c8:	f8 94       	cli
    28ca:	0f 92       	push	r0
    28cc:	1f 92       	push	r1
    28ce:	11 24       	eor	r1, r1
    28d0:	2f 92       	push	r2
    28d2:	3f 92       	push	r3
    28d4:	4f 92       	push	r4
    28d6:	5f 92       	push	r5
    28d8:	6f 92       	push	r6
    28da:	7f 92       	push	r7
    28dc:	8f 92       	push	r8
    28de:	9f 92       	push	r9
    28e0:	af 92       	push	r10
    28e2:	bf 92       	push	r11
    28e4:	cf 92       	push	r12
    28e6:	df 92       	push	r13
    28e8:	ef 92       	push	r14
    28ea:	ff 92       	push	r15
    28ec:	0f 93       	push	r16
    28ee:	1f 93       	push	r17
    28f0:	2f 93       	push	r18
    28f2:	3f 93       	push	r19
    28f4:	4f 93       	push	r20
    28f6:	5f 93       	push	r21
    28f8:	6f 93       	push	r22
    28fa:	7f 93       	push	r23
    28fc:	8f 93       	push	r24
    28fe:	9f 93       	push	r25
    2900:	af 93       	push	r26
    2902:	bf 93       	push	r27
    2904:	cf 93       	push	r28
    2906:	df 93       	push	r29
    2908:	ef 93       	push	r30
    290a:	ff 93       	push	r31
    290c:	a0 91 3a 24 	lds	r26, 0x243A
    2910:	b0 91 3b 24 	lds	r27, 0x243B
    2914:	0d b6       	in	r0, 0x3d	; 61
    2916:	0d 92       	st	X+, r0
    2918:	0e b6       	in	r0, 0x3e	; 62
    291a:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    291c:	76 d3       	rcall	.+1772   	; 0x300a <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    291e:	a0 91 3a 24 	lds	r26, 0x243A
    2922:	b0 91 3b 24 	lds	r27, 0x243B
    2926:	0d 90       	ld	r0, X+
    2928:	0d be       	out	0x3d, r0	; 61
    292a:	0d 90       	ld	r0, X+
    292c:	0e be       	out	0x3e, r0	; 62
    292e:	ff 91       	pop	r31
    2930:	ef 91       	pop	r30
    2932:	df 91       	pop	r29
    2934:	cf 91       	pop	r28
    2936:	bf 91       	pop	r27
    2938:	af 91       	pop	r26
    293a:	9f 91       	pop	r25
    293c:	8f 91       	pop	r24
    293e:	7f 91       	pop	r23
    2940:	6f 91       	pop	r22
    2942:	5f 91       	pop	r21
    2944:	4f 91       	pop	r20
    2946:	3f 91       	pop	r19
    2948:	2f 91       	pop	r18
    294a:	1f 91       	pop	r17
    294c:	0f 91       	pop	r16
    294e:	ff 90       	pop	r15
    2950:	ef 90       	pop	r14
    2952:	df 90       	pop	r13
    2954:	cf 90       	pop	r12
    2956:	bf 90       	pop	r11
    2958:	af 90       	pop	r10
    295a:	9f 90       	pop	r9
    295c:	8f 90       	pop	r8
    295e:	7f 90       	pop	r7
    2960:	6f 90       	pop	r6
    2962:	5f 90       	pop	r5
    2964:	4f 90       	pop	r4
    2966:	3f 90       	pop	r3
    2968:	2f 90       	pop	r2
    296a:	1f 90       	pop	r1
    296c:	0f 90       	pop	r0
    296e:	0f be       	out	0x3f, r0	; 63
    2970:	0f 90       	pop	r0

    asm volatile ( "ret" );
    2972:	08 95       	ret

00002974 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    2974:	0f 92       	push	r0
    2976:	0f b6       	in	r0, 0x3f	; 63
    2978:	f8 94       	cli
    297a:	0f 92       	push	r0
    297c:	1f 92       	push	r1
    297e:	11 24       	eor	r1, r1
    2980:	2f 92       	push	r2
    2982:	3f 92       	push	r3
    2984:	4f 92       	push	r4
    2986:	5f 92       	push	r5
    2988:	6f 92       	push	r6
    298a:	7f 92       	push	r7
    298c:	8f 92       	push	r8
    298e:	9f 92       	push	r9
    2990:	af 92       	push	r10
    2992:	bf 92       	push	r11
    2994:	cf 92       	push	r12
    2996:	df 92       	push	r13
    2998:	ef 92       	push	r14
    299a:	ff 92       	push	r15
    299c:	0f 93       	push	r16
    299e:	1f 93       	push	r17
    29a0:	2f 93       	push	r18
    29a2:	3f 93       	push	r19
    29a4:	4f 93       	push	r20
    29a6:	5f 93       	push	r21
    29a8:	6f 93       	push	r22
    29aa:	7f 93       	push	r23
    29ac:	8f 93       	push	r24
    29ae:	9f 93       	push	r25
    29b0:	af 93       	push	r26
    29b2:	bf 93       	push	r27
    29b4:	cf 93       	push	r28
    29b6:	df 93       	push	r29
    29b8:	ef 93       	push	r30
    29ba:	ff 93       	push	r31
    29bc:	a0 91 3a 24 	lds	r26, 0x243A
    29c0:	b0 91 3b 24 	lds	r27, 0x243B
    29c4:	0d b6       	in	r0, 0x3d	; 61
    29c6:	0d 92       	st	X+, r0
    29c8:	0e b6       	in	r0, 0x3e	; 62
    29ca:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    29cc:	b3 d1       	rcall	.+870    	; 0x2d34 <xTaskIncrementTick>
    29ce:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    29d0:	1c d3       	rcall	.+1592   	; 0x300a <vTaskSwitchContext>
        }
        portRESTORE_CONTEXT();
    29d2:	a0 91 3a 24 	lds	r26, 0x243A
    29d6:	b0 91 3b 24 	lds	r27, 0x243B
    29da:	0d 90       	ld	r0, X+
    29dc:	0d be       	out	0x3d, r0	; 61
    29de:	0d 90       	ld	r0, X+
    29e0:	0e be       	out	0x3e, r0	; 62
    29e2:	ff 91       	pop	r31
    29e4:	ef 91       	pop	r30
    29e6:	df 91       	pop	r29
    29e8:	cf 91       	pop	r28
    29ea:	bf 91       	pop	r27
    29ec:	af 91       	pop	r26
    29ee:	9f 91       	pop	r25
    29f0:	8f 91       	pop	r24
    29f2:	7f 91       	pop	r23
    29f4:	6f 91       	pop	r22
    29f6:	5f 91       	pop	r21
    29f8:	4f 91       	pop	r20
    29fa:	3f 91       	pop	r19
    29fc:	2f 91       	pop	r18
    29fe:	1f 91       	pop	r17
    2a00:	0f 91       	pop	r16
    2a02:	ff 90       	pop	r15
    2a04:	ef 90       	pop	r14
    2a06:	df 90       	pop	r13
    2a08:	cf 90       	pop	r12
    2a0a:	bf 90       	pop	r11
    2a0c:	af 90       	pop	r10
    2a0e:	9f 90       	pop	r9
    2a10:	8f 90       	pop	r8
    2a12:	7f 90       	pop	r7
    2a14:	6f 90       	pop	r6
    2a16:	5f 90       	pop	r5
    2a18:	4f 90       	pop	r4
    2a1a:	3f 90       	pop	r3
    2a1c:	2f 90       	pop	r2
    2a1e:	1f 90       	pop	r1
    2a20:	0f 90       	pop	r0
    2a22:	0f be       	out	0x3f, r0	; 63
    2a24:	0f 90       	pop	r0

        asm volatile ( "reti" );
    2a26:	18 95       	reti

00002a28 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2a28:	cf 93       	push	r28
    2a2a:	df 93       	push	r29
    2a2c:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    2a2e:	7c d1       	rcall	.+760    	; 0x2d28 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    2a30:	ce 01       	movw	r24, r28
    2a32:	0e 94 b7 1e 	call	0x3d6e	; 0x3d6e <malloc>
    2a36:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2a38:	50 d2       	rcall	.+1184   	; 0x2eda <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2a3a:	ce 01       	movw	r24, r28
    2a3c:	df 91       	pop	r29
    2a3e:	cf 91       	pop	r28
    2a40:	08 95       	ret

00002a42 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2a42:	cf 93       	push	r28
    2a44:	df 93       	push	r29
	if( pv )
    2a46:	00 97       	sbiw	r24, 0x00	; 0
    2a48:	31 f0       	breq	.+12     	; 0x2a56 <vPortFree+0x14>
    2a4a:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    2a4c:	6d d1       	rcall	.+730    	; 0x2d28 <vTaskSuspendAll>
		{
			free( pv );
    2a4e:	ce 01       	movw	r24, r28
    2a50:	0e 94 4c 1f 	call	0x3e98	; 0x3e98 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    2a54:	42 d2       	rcall	.+1156   	; 0x2eda <xTaskResumeAll>
	}
}
    2a56:	df 91       	pop	r29
    2a58:	cf 91       	pop	r28
    2a5a:	08 95       	ret

00002a5c <prvIdleTask>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2a5c:	cd e0       	ldi	r28, 0x0D	; 13
    2a5e:	d4 e2       	ldi	r29, 0x24	; 36
    2a60:	88 81       	ld	r24, Y
    2a62:	82 30       	cpi	r24, 0x02	; 2
    2a64:	f0 f3       	brcs	.-4      	; 0x2a62 <prvIdleTask+0x6>
    2a66:	2e df       	rcall	.-420    	; 0x28c4 <vPortYield>
    2a68:	fb cf       	rjmp	.-10     	; 0x2a60 <prvIdleTask+0x4>

00002a6a <prvAddCurrentTaskToDelayedList>:
    2a6a:	cf 93       	push	r28
    2a6c:	df 93       	push	r29
    2a6e:	ec 01       	movw	r28, r24
    2a70:	e0 91 3a 24 	lds	r30, 0x243A
    2a74:	f0 91 3b 24 	lds	r31, 0x243B
    2a78:	82 83       	std	Z+2, r24	; 0x02
    2a7a:	93 83       	std	Z+3, r25	; 0x03
    2a7c:	80 91 eb 23 	lds	r24, 0x23EB
    2a80:	90 91 ec 23 	lds	r25, 0x23EC
    2a84:	c8 17       	cp	r28, r24
    2a86:	d9 07       	cpc	r29, r25
    2a88:	60 f4       	brcc	.+24     	; 0x2aa2 <prvAddCurrentTaskToDelayedList+0x38>
    2a8a:	60 91 3a 24 	lds	r22, 0x243A
    2a8e:	70 91 3b 24 	lds	r23, 0x243B
    2a92:	80 91 f7 23 	lds	r24, 0x23F7
    2a96:	90 91 f8 23 	lds	r25, 0x23F8
    2a9a:	6e 5f       	subi	r22, 0xFE	; 254
    2a9c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a9e:	ff dd       	rcall	.-1026   	; 0x269e <vListInsert>
    2aa0:	16 c0       	rjmp	.+44     	; 0x2ace <prvAddCurrentTaskToDelayedList+0x64>
    2aa2:	60 91 3a 24 	lds	r22, 0x243A
    2aa6:	70 91 3b 24 	lds	r23, 0x243B
    2aaa:	80 91 f9 23 	lds	r24, 0x23F9
    2aae:	90 91 fa 23 	lds	r25, 0x23FA
    2ab2:	6e 5f       	subi	r22, 0xFE	; 254
    2ab4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ab6:	f3 dd       	rcall	.-1050   	; 0x269e <vListInsert>
    2ab8:	80 91 0e 20 	lds	r24, 0x200E
    2abc:	90 91 0f 20 	lds	r25, 0x200F
    2ac0:	c8 17       	cp	r28, r24
    2ac2:	d9 07       	cpc	r29, r25
    2ac4:	20 f4       	brcc	.+8      	; 0x2ace <prvAddCurrentTaskToDelayedList+0x64>
    2ac6:	c0 93 0e 20 	sts	0x200E, r28
    2aca:	d0 93 0f 20 	sts	0x200F, r29
    2ace:	df 91       	pop	r29
    2ad0:	cf 91       	pop	r28
    2ad2:	08 95       	ret

00002ad4 <xTaskGenericCreate>:
    2ad4:	4f 92       	push	r4
    2ad6:	5f 92       	push	r5
    2ad8:	6f 92       	push	r6
    2ada:	7f 92       	push	r7
    2adc:	8f 92       	push	r8
    2ade:	9f 92       	push	r9
    2ae0:	af 92       	push	r10
    2ae2:	bf 92       	push	r11
    2ae4:	cf 92       	push	r12
    2ae6:	df 92       	push	r13
    2ae8:	ef 92       	push	r14
    2aea:	ff 92       	push	r15
    2aec:	0f 93       	push	r16
    2aee:	1f 93       	push	r17
    2af0:	cf 93       	push	r28
    2af2:	df 93       	push	r29
    2af4:	4c 01       	movw	r8, r24
    2af6:	eb 01       	movw	r28, r22
    2af8:	5a 01       	movw	r10, r20
    2afa:	29 01       	movw	r4, r18
    2afc:	81 e2       	ldi	r24, 0x21	; 33
    2afe:	90 e0       	ldi	r25, 0x00	; 0
    2b00:	93 df       	rcall	.-218    	; 0x2a28 <pvPortMalloc>
    2b02:	3c 01       	movw	r6, r24
    2b04:	00 97       	sbiw	r24, 0x00	; 0
    2b06:	09 f4       	brne	.+2      	; 0x2b0a <xTaskGenericCreate+0x36>
    2b08:	d4 c0       	rjmp	.+424    	; 0x2cb2 <xTaskGenericCreate+0x1de>
    2b0a:	c1 14       	cp	r12, r1
    2b0c:	d1 04       	cpc	r13, r1
    2b0e:	09 f0       	breq	.+2      	; 0x2b12 <xTaskGenericCreate+0x3e>
    2b10:	cc c0       	rjmp	.+408    	; 0x2caa <xTaskGenericCreate+0x1d6>
    2b12:	c5 01       	movw	r24, r10
    2b14:	89 df       	rcall	.-238    	; 0x2a28 <pvPortMalloc>
    2b16:	f3 01       	movw	r30, r6
    2b18:	87 8b       	std	Z+23, r24	; 0x17
    2b1a:	90 8f       	std	Z+24, r25	; 0x18
    2b1c:	89 2b       	or	r24, r25
    2b1e:	19 f4       	brne	.+6      	; 0x2b26 <xTaskGenericCreate+0x52>
    2b20:	c3 01       	movw	r24, r6
    2b22:	8f df       	rcall	.-226    	; 0x2a42 <vPortFree>
    2b24:	c6 c0       	rjmp	.+396    	; 0x2cb2 <xTaskGenericCreate+0x1de>
    2b26:	f1 e0       	ldi	r31, 0x01	; 1
    2b28:	af 1a       	sub	r10, r31
    2b2a:	b1 08       	sbc	r11, r1
    2b2c:	f3 01       	movw	r30, r6
    2b2e:	87 89       	ldd	r24, Z+23	; 0x17
    2b30:	90 8d       	ldd	r25, Z+24	; 0x18
    2b32:	a8 0e       	add	r10, r24
    2b34:	b9 1e       	adc	r11, r25
    2b36:	88 81       	ld	r24, Y
    2b38:	81 8f       	std	Z+25, r24	; 0x19
    2b3a:	88 81       	ld	r24, Y
    2b3c:	88 23       	and	r24, r24
    2b3e:	81 f0       	breq	.+32     	; 0x2b60 <xTaskGenericCreate+0x8c>
    2b40:	d3 01       	movw	r26, r6
    2b42:	5a 96       	adiw	r26, 0x1a	; 26
    2b44:	fe 01       	movw	r30, r28
    2b46:	31 96       	adiw	r30, 0x01	; 1
    2b48:	9e 01       	movw	r18, r28
    2b4a:	28 5f       	subi	r18, 0xF8	; 248
    2b4c:	3f 4f       	sbci	r19, 0xFF	; 255
    2b4e:	ef 01       	movw	r28, r30
    2b50:	81 91       	ld	r24, Z+
    2b52:	8d 93       	st	X+, r24
    2b54:	88 81       	ld	r24, Y
    2b56:	88 23       	and	r24, r24
    2b58:	19 f0       	breq	.+6      	; 0x2b60 <xTaskGenericCreate+0x8c>
    2b5a:	e2 17       	cp	r30, r18
    2b5c:	f3 07       	cpc	r31, r19
    2b5e:	b9 f7       	brne	.-18     	; 0x2b4e <xTaskGenericCreate+0x7a>
    2b60:	f3 01       	movw	r30, r6
    2b62:	10 a2       	std	Z+32, r1	; 0x20
    2b64:	10 2f       	mov	r17, r16
    2b66:	05 30       	cpi	r16, 0x05	; 5
    2b68:	08 f0       	brcs	.+2      	; 0x2b6c <xTaskGenericCreate+0x98>
    2b6a:	14 e0       	ldi	r17, 0x04	; 4
    2b6c:	f3 01       	movw	r30, r6
    2b6e:	16 8b       	std	Z+22, r17	; 0x16
    2b70:	e3 01       	movw	r28, r6
    2b72:	22 96       	adiw	r28, 0x02	; 2
    2b74:	ce 01       	movw	r24, r28
    2b76:	6e dd       	rcall	.-1316   	; 0x2654 <vListInitialiseItem>
    2b78:	c3 01       	movw	r24, r6
    2b7a:	0c 96       	adiw	r24, 0x0c	; 12
    2b7c:	6b dd       	rcall	.-1322   	; 0x2654 <vListInitialiseItem>
    2b7e:	f3 01       	movw	r30, r6
    2b80:	60 86       	std	Z+8, r6	; 0x08
    2b82:	71 86       	std	Z+9, r7	; 0x09
    2b84:	85 e0       	ldi	r24, 0x05	; 5
    2b86:	90 e0       	ldi	r25, 0x00	; 0
    2b88:	81 1b       	sub	r24, r17
    2b8a:	91 09       	sbc	r25, r1
    2b8c:	84 87       	std	Z+12, r24	; 0x0c
    2b8e:	95 87       	std	Z+13, r25	; 0x0d
    2b90:	62 8a       	std	Z+18, r6	; 0x12
    2b92:	73 8a       	std	Z+19, r7	; 0x13
    2b94:	a2 01       	movw	r20, r4
    2b96:	b4 01       	movw	r22, r8
    2b98:	c5 01       	movw	r24, r10
    2b9a:	d8 dd       	rcall	.-1104   	; 0x274c <pxPortInitialiseStack>
    2b9c:	f3 01       	movw	r30, r6
    2b9e:	80 83       	st	Z, r24
    2ba0:	91 83       	std	Z+1, r25	; 0x01
    2ba2:	e1 14       	cp	r14, r1
    2ba4:	f1 04       	cpc	r15, r1
    2ba6:	19 f0       	breq	.+6      	; 0x2bae <xTaskGenericCreate+0xda>
    2ba8:	f7 01       	movw	r30, r14
    2baa:	60 82       	st	Z, r6
    2bac:	71 82       	std	Z+1, r7	; 0x01
    2bae:	0f b6       	in	r0, 0x3f	; 63
    2bb0:	f8 94       	cli
    2bb2:	0f 92       	push	r0
    2bb4:	80 91 ed 23 	lds	r24, 0x23ED
    2bb8:	8f 5f       	subi	r24, 0xFF	; 255
    2bba:	80 93 ed 23 	sts	0x23ED, r24
    2bbe:	80 91 3a 24 	lds	r24, 0x243A
    2bc2:	90 91 3b 24 	lds	r25, 0x243B
    2bc6:	89 2b       	or	r24, r25
    2bc8:	91 f5       	brne	.+100    	; 0x2c2e <xTaskGenericCreate+0x15a>
    2bca:	60 92 3a 24 	sts	0x243A, r6
    2bce:	70 92 3b 24 	sts	0x243B, r7
    2bd2:	80 91 ed 23 	lds	r24, 0x23ED
    2bd6:	81 30       	cpi	r24, 0x01	; 1
    2bd8:	c9 f5       	brne	.+114    	; 0x2c4c <xTaskGenericCreate+0x178>
    2bda:	0f 2e       	mov	r0, r31
    2bdc:	fd e0       	ldi	r31, 0x0D	; 13
    2bde:	ef 2e       	mov	r14, r31
    2be0:	f4 e2       	ldi	r31, 0x24	; 36
    2be2:	ff 2e       	mov	r15, r31
    2be4:	f0 2d       	mov	r31, r0
    2be6:	0f 2e       	mov	r0, r31
    2be8:	fa e3       	ldi	r31, 0x3A	; 58
    2bea:	cf 2e       	mov	r12, r31
    2bec:	f4 e2       	ldi	r31, 0x24	; 36
    2bee:	df 2e       	mov	r13, r31
    2bf0:	f0 2d       	mov	r31, r0
    2bf2:	c7 01       	movw	r24, r14
    2bf4:	21 dd       	rcall	.-1470   	; 0x2638 <vListInitialise>
    2bf6:	f9 e0       	ldi	r31, 0x09	; 9
    2bf8:	ef 0e       	add	r14, r31
    2bfa:	f1 1c       	adc	r15, r1
    2bfc:	ec 14       	cp	r14, r12
    2bfe:	fd 04       	cpc	r15, r13
    2c00:	c1 f7       	brne	.-16     	; 0x2bf2 <xTaskGenericCreate+0x11e>
    2c02:	84 e0       	ldi	r24, 0x04	; 4
    2c04:	94 e2       	ldi	r25, 0x24	; 36
    2c06:	18 dd       	rcall	.-1488   	; 0x2638 <vListInitialise>
    2c08:	8b ef       	ldi	r24, 0xFB	; 251
    2c0a:	93 e2       	ldi	r25, 0x23	; 35
    2c0c:	15 dd       	rcall	.-1494   	; 0x2638 <vListInitialise>
    2c0e:	8e ee       	ldi	r24, 0xEE	; 238
    2c10:	93 e2       	ldi	r25, 0x23	; 35
    2c12:	12 dd       	rcall	.-1500   	; 0x2638 <vListInitialise>
    2c14:	84 e0       	ldi	r24, 0x04	; 4
    2c16:	94 e2       	ldi	r25, 0x24	; 36
    2c18:	80 93 f9 23 	sts	0x23F9, r24
    2c1c:	90 93 fa 23 	sts	0x23FA, r25
    2c20:	8b ef       	ldi	r24, 0xFB	; 251
    2c22:	93 e2       	ldi	r25, 0x23	; 35
    2c24:	80 93 f7 23 	sts	0x23F7, r24
    2c28:	90 93 f8 23 	sts	0x23F8, r25
    2c2c:	0f c0       	rjmp	.+30     	; 0x2c4c <xTaskGenericCreate+0x178>
    2c2e:	80 91 e9 23 	lds	r24, 0x23E9
    2c32:	81 11       	cpse	r24, r1
    2c34:	0b c0       	rjmp	.+22     	; 0x2c4c <xTaskGenericCreate+0x178>
    2c36:	e0 91 3a 24 	lds	r30, 0x243A
    2c3a:	f0 91 3b 24 	lds	r31, 0x243B
    2c3e:	86 89       	ldd	r24, Z+22	; 0x16
    2c40:	08 17       	cp	r16, r24
    2c42:	20 f0       	brcs	.+8      	; 0x2c4c <xTaskGenericCreate+0x178>
    2c44:	60 92 3a 24 	sts	0x243A, r6
    2c48:	70 92 3b 24 	sts	0x243B, r7
    2c4c:	80 91 e5 23 	lds	r24, 0x23E5
    2c50:	8f 5f       	subi	r24, 0xFF	; 255
    2c52:	80 93 e5 23 	sts	0x23E5, r24
    2c56:	f3 01       	movw	r30, r6
    2c58:	86 89       	ldd	r24, Z+22	; 0x16
    2c5a:	90 91 ea 23 	lds	r25, 0x23EA
    2c5e:	98 17       	cp	r25, r24
    2c60:	10 f4       	brcc	.+4      	; 0x2c66 <xTaskGenericCreate+0x192>
    2c62:	80 93 ea 23 	sts	0x23EA, r24
    2c66:	90 e0       	ldi	r25, 0x00	; 0
    2c68:	9c 01       	movw	r18, r24
    2c6a:	22 0f       	add	r18, r18
    2c6c:	33 1f       	adc	r19, r19
    2c6e:	22 0f       	add	r18, r18
    2c70:	33 1f       	adc	r19, r19
    2c72:	22 0f       	add	r18, r18
    2c74:	33 1f       	adc	r19, r19
    2c76:	82 0f       	add	r24, r18
    2c78:	93 1f       	adc	r25, r19
    2c7a:	be 01       	movw	r22, r28
    2c7c:	83 5f       	subi	r24, 0xF3	; 243
    2c7e:	9b 4d       	sbci	r25, 0xDB	; 219
    2c80:	ed dc       	rcall	.-1574   	; 0x265c <vListInsertEnd>
    2c82:	0f 90       	pop	r0
    2c84:	0f be       	out	0x3f, r0	; 63
    2c86:	80 91 e9 23 	lds	r24, 0x23E9
    2c8a:	88 23       	and	r24, r24
    2c8c:	51 f0       	breq	.+20     	; 0x2ca2 <xTaskGenericCreate+0x1ce>
    2c8e:	e0 91 3a 24 	lds	r30, 0x243A
    2c92:	f0 91 3b 24 	lds	r31, 0x243B
    2c96:	86 89       	ldd	r24, Z+22	; 0x16
    2c98:	80 17       	cp	r24, r16
    2c9a:	28 f4       	brcc	.+10     	; 0x2ca6 <xTaskGenericCreate+0x1d2>
    2c9c:	13 de       	rcall	.-986    	; 0x28c4 <vPortYield>
    2c9e:	81 e0       	ldi	r24, 0x01	; 1
    2ca0:	09 c0       	rjmp	.+18     	; 0x2cb4 <xTaskGenericCreate+0x1e0>
    2ca2:	81 e0       	ldi	r24, 0x01	; 1
    2ca4:	07 c0       	rjmp	.+14     	; 0x2cb4 <xTaskGenericCreate+0x1e0>
    2ca6:	81 e0       	ldi	r24, 0x01	; 1
    2ca8:	05 c0       	rjmp	.+10     	; 0x2cb4 <xTaskGenericCreate+0x1e0>
    2caa:	fc 01       	movw	r30, r24
    2cac:	c7 8a       	std	Z+23, r12	; 0x17
    2cae:	d0 8e       	std	Z+24, r13	; 0x18
    2cb0:	3a cf       	rjmp	.-396    	; 0x2b26 <xTaskGenericCreate+0x52>
    2cb2:	8f ef       	ldi	r24, 0xFF	; 255
    2cb4:	df 91       	pop	r29
    2cb6:	cf 91       	pop	r28
    2cb8:	1f 91       	pop	r17
    2cba:	0f 91       	pop	r16
    2cbc:	ff 90       	pop	r15
    2cbe:	ef 90       	pop	r14
    2cc0:	df 90       	pop	r13
    2cc2:	cf 90       	pop	r12
    2cc4:	bf 90       	pop	r11
    2cc6:	af 90       	pop	r10
    2cc8:	9f 90       	pop	r9
    2cca:	8f 90       	pop	r8
    2ccc:	7f 90       	pop	r7
    2cce:	6f 90       	pop	r6
    2cd0:	5f 90       	pop	r5
    2cd2:	4f 90       	pop	r4
    2cd4:	08 95       	ret

00002cd6 <vTaskStartScheduler>:
    2cd6:	af 92       	push	r10
    2cd8:	bf 92       	push	r11
    2cda:	cf 92       	push	r12
    2cdc:	df 92       	push	r13
    2cde:	ef 92       	push	r14
    2ce0:	ff 92       	push	r15
    2ce2:	0f 93       	push	r16
    2ce4:	a1 2c       	mov	r10, r1
    2ce6:	b1 2c       	mov	r11, r1
    2ce8:	c1 2c       	mov	r12, r1
    2cea:	d1 2c       	mov	r13, r1
    2cec:	e1 2c       	mov	r14, r1
    2cee:	f1 2c       	mov	r15, r1
    2cf0:	00 e0       	ldi	r16, 0x00	; 0
    2cf2:	20 e0       	ldi	r18, 0x00	; 0
    2cf4:	30 e0       	ldi	r19, 0x00	; 0
    2cf6:	45 e5       	ldi	r20, 0x55	; 85
    2cf8:	50 e0       	ldi	r21, 0x00	; 0
    2cfa:	60 e1       	ldi	r22, 0x10	; 16
    2cfc:	70 e2       	ldi	r23, 0x20	; 32
    2cfe:	8e e2       	ldi	r24, 0x2E	; 46
    2d00:	95 e1       	ldi	r25, 0x15	; 21
    2d02:	e8 de       	rcall	.-560    	; 0x2ad4 <xTaskGenericCreate>
    2d04:	81 30       	cpi	r24, 0x01	; 1
    2d06:	41 f4       	brne	.+16     	; 0x2d18 <vTaskStartScheduler+0x42>
    2d08:	f8 94       	cli
    2d0a:	80 93 e9 23 	sts	0x23E9, r24
    2d0e:	10 92 eb 23 	sts	0x23EB, r1
    2d12:	10 92 ec 23 	sts	0x23EC, r1
    2d16:	91 dd       	rcall	.-1246   	; 0x283a <xPortStartScheduler>
    2d18:	0f 91       	pop	r16
    2d1a:	ff 90       	pop	r15
    2d1c:	ef 90       	pop	r14
    2d1e:	df 90       	pop	r13
    2d20:	cf 90       	pop	r12
    2d22:	bf 90       	pop	r11
    2d24:	af 90       	pop	r10
    2d26:	08 95       	ret

00002d28 <vTaskSuspendAll>:
    2d28:	80 91 e4 23 	lds	r24, 0x23E4
    2d2c:	8f 5f       	subi	r24, 0xFF	; 255
    2d2e:	80 93 e4 23 	sts	0x23E4, r24
    2d32:	08 95       	ret

00002d34 <xTaskIncrementTick>:
    2d34:	df 92       	push	r13
    2d36:	ef 92       	push	r14
    2d38:	ff 92       	push	r15
    2d3a:	0f 93       	push	r16
    2d3c:	1f 93       	push	r17
    2d3e:	cf 93       	push	r28
    2d40:	df 93       	push	r29
    2d42:	80 91 e4 23 	lds	r24, 0x23E4
    2d46:	81 11       	cpse	r24, r1
    2d48:	b3 c0       	rjmp	.+358    	; 0x2eb0 <xTaskIncrementTick+0x17c>
    2d4a:	80 91 eb 23 	lds	r24, 0x23EB
    2d4e:	90 91 ec 23 	lds	r25, 0x23EC
    2d52:	01 96       	adiw	r24, 0x01	; 1
    2d54:	80 93 eb 23 	sts	0x23EB, r24
    2d58:	90 93 ec 23 	sts	0x23EC, r25
    2d5c:	e0 90 eb 23 	lds	r14, 0x23EB
    2d60:	f0 90 ec 23 	lds	r15, 0x23EC
    2d64:	e1 14       	cp	r14, r1
    2d66:	f1 04       	cpc	r15, r1
    2d68:	99 f5       	brne	.+102    	; 0x2dd0 <xTaskIncrementTick+0x9c>
    2d6a:	80 91 f9 23 	lds	r24, 0x23F9
    2d6e:	90 91 fa 23 	lds	r25, 0x23FA
    2d72:	20 91 f7 23 	lds	r18, 0x23F7
    2d76:	30 91 f8 23 	lds	r19, 0x23F8
    2d7a:	20 93 f9 23 	sts	0x23F9, r18
    2d7e:	30 93 fa 23 	sts	0x23FA, r19
    2d82:	80 93 f7 23 	sts	0x23F7, r24
    2d86:	90 93 f8 23 	sts	0x23F8, r25
    2d8a:	80 91 e6 23 	lds	r24, 0x23E6
    2d8e:	8f 5f       	subi	r24, 0xFF	; 255
    2d90:	80 93 e6 23 	sts	0x23E6, r24
    2d94:	e0 91 f9 23 	lds	r30, 0x23F9
    2d98:	f0 91 fa 23 	lds	r31, 0x23FA
    2d9c:	80 81       	ld	r24, Z
    2d9e:	81 11       	cpse	r24, r1
    2da0:	07 c0       	rjmp	.+14     	; 0x2db0 <xTaskIncrementTick+0x7c>
    2da2:	8f ef       	ldi	r24, 0xFF	; 255
    2da4:	9f ef       	ldi	r25, 0xFF	; 255
    2da6:	80 93 0e 20 	sts	0x200E, r24
    2daa:	90 93 0f 20 	sts	0x200F, r25
    2dae:	10 c0       	rjmp	.+32     	; 0x2dd0 <xTaskIncrementTick+0x9c>
    2db0:	e0 91 f9 23 	lds	r30, 0x23F9
    2db4:	f0 91 fa 23 	lds	r31, 0x23FA
    2db8:	05 80       	ldd	r0, Z+5	; 0x05
    2dba:	f6 81       	ldd	r31, Z+6	; 0x06
    2dbc:	e0 2d       	mov	r30, r0
    2dbe:	06 80       	ldd	r0, Z+6	; 0x06
    2dc0:	f7 81       	ldd	r31, Z+7	; 0x07
    2dc2:	e0 2d       	mov	r30, r0
    2dc4:	82 81       	ldd	r24, Z+2	; 0x02
    2dc6:	93 81       	ldd	r25, Z+3	; 0x03
    2dc8:	80 93 0e 20 	sts	0x200E, r24
    2dcc:	90 93 0f 20 	sts	0x200F, r25
    2dd0:	80 91 0e 20 	lds	r24, 0x200E
    2dd4:	90 91 0f 20 	lds	r25, 0x200F
    2dd8:	e8 16       	cp	r14, r24
    2dda:	f9 06       	cpc	r15, r25
    2ddc:	10 f4       	brcc	.+4      	; 0x2de2 <xTaskIncrementTick+0xae>
    2dde:	d1 2c       	mov	r13, r1
    2de0:	4f c0       	rjmp	.+158    	; 0x2e80 <xTaskIncrementTick+0x14c>
    2de2:	d1 2c       	mov	r13, r1
    2de4:	e0 91 f9 23 	lds	r30, 0x23F9
    2de8:	f0 91 fa 23 	lds	r31, 0x23FA
    2dec:	90 81       	ld	r25, Z
    2dee:	91 11       	cpse	r25, r1
    2df0:	07 c0       	rjmp	.+14     	; 0x2e00 <xTaskIncrementTick+0xcc>
    2df2:	8f ef       	ldi	r24, 0xFF	; 255
    2df4:	9f ef       	ldi	r25, 0xFF	; 255
    2df6:	80 93 0e 20 	sts	0x200E, r24
    2dfa:	90 93 0f 20 	sts	0x200F, r25
    2dfe:	40 c0       	rjmp	.+128    	; 0x2e80 <xTaskIncrementTick+0x14c>
    2e00:	e0 91 f9 23 	lds	r30, 0x23F9
    2e04:	f0 91 fa 23 	lds	r31, 0x23FA
    2e08:	05 80       	ldd	r0, Z+5	; 0x05
    2e0a:	f6 81       	ldd	r31, Z+6	; 0x06
    2e0c:	e0 2d       	mov	r30, r0
    2e0e:	c6 81       	ldd	r28, Z+6	; 0x06
    2e10:	d7 81       	ldd	r29, Z+7	; 0x07
    2e12:	2a 81       	ldd	r18, Y+2	; 0x02
    2e14:	3b 81       	ldd	r19, Y+3	; 0x03
    2e16:	e2 16       	cp	r14, r18
    2e18:	f3 06       	cpc	r15, r19
    2e1a:	28 f4       	brcc	.+10     	; 0x2e26 <xTaskIncrementTick+0xf2>
    2e1c:	20 93 0e 20 	sts	0x200E, r18
    2e20:	30 93 0f 20 	sts	0x200F, r19
    2e24:	2d c0       	rjmp	.+90     	; 0x2e80 <xTaskIncrementTick+0x14c>
    2e26:	8e 01       	movw	r16, r28
    2e28:	0e 5f       	subi	r16, 0xFE	; 254
    2e2a:	1f 4f       	sbci	r17, 0xFF	; 255
    2e2c:	c8 01       	movw	r24, r16
    2e2e:	68 dc       	rcall	.-1840   	; 0x2700 <uxListRemove>
    2e30:	8c 89       	ldd	r24, Y+20	; 0x14
    2e32:	9d 89       	ldd	r25, Y+21	; 0x15
    2e34:	89 2b       	or	r24, r25
    2e36:	19 f0       	breq	.+6      	; 0x2e3e <xTaskIncrementTick+0x10a>
    2e38:	ce 01       	movw	r24, r28
    2e3a:	0c 96       	adiw	r24, 0x0c	; 12
    2e3c:	61 dc       	rcall	.-1854   	; 0x2700 <uxListRemove>
    2e3e:	2e 89       	ldd	r18, Y+22	; 0x16
    2e40:	80 91 ea 23 	lds	r24, 0x23EA
    2e44:	82 17       	cp	r24, r18
    2e46:	10 f4       	brcc	.+4      	; 0x2e4c <xTaskIncrementTick+0x118>
    2e48:	20 93 ea 23 	sts	0x23EA, r18
    2e4c:	30 e0       	ldi	r19, 0x00	; 0
    2e4e:	c9 01       	movw	r24, r18
    2e50:	88 0f       	add	r24, r24
    2e52:	99 1f       	adc	r25, r25
    2e54:	88 0f       	add	r24, r24
    2e56:	99 1f       	adc	r25, r25
    2e58:	88 0f       	add	r24, r24
    2e5a:	99 1f       	adc	r25, r25
    2e5c:	82 0f       	add	r24, r18
    2e5e:	93 1f       	adc	r25, r19
    2e60:	b8 01       	movw	r22, r16
    2e62:	83 5f       	subi	r24, 0xF3	; 243
    2e64:	9b 4d       	sbci	r25, 0xDB	; 219
    2e66:	fa db       	rcall	.-2060   	; 0x265c <vListInsertEnd>
    2e68:	e0 91 3a 24 	lds	r30, 0x243A
    2e6c:	f0 91 3b 24 	lds	r31, 0x243B
    2e70:	9e 89       	ldd	r25, Y+22	; 0x16
    2e72:	86 89       	ldd	r24, Z+22	; 0x16
    2e74:	98 17       	cp	r25, r24
    2e76:	08 f4       	brcc	.+2      	; 0x2e7a <xTaskIncrementTick+0x146>
    2e78:	b5 cf       	rjmp	.-150    	; 0x2de4 <xTaskIncrementTick+0xb0>
    2e7a:	dd 24       	eor	r13, r13
    2e7c:	d3 94       	inc	r13
    2e7e:	b2 cf       	rjmp	.-156    	; 0x2de4 <xTaskIncrementTick+0xb0>
    2e80:	e0 91 3a 24 	lds	r30, 0x243A
    2e84:	f0 91 3b 24 	lds	r31, 0x243B
    2e88:	86 89       	ldd	r24, Z+22	; 0x16
    2e8a:	90 e0       	ldi	r25, 0x00	; 0
    2e8c:	fc 01       	movw	r30, r24
    2e8e:	ee 0f       	add	r30, r30
    2e90:	ff 1f       	adc	r31, r31
    2e92:	ee 0f       	add	r30, r30
    2e94:	ff 1f       	adc	r31, r31
    2e96:	ee 0f       	add	r30, r30
    2e98:	ff 1f       	adc	r31, r31
    2e9a:	8e 0f       	add	r24, r30
    2e9c:	9f 1f       	adc	r25, r31
    2e9e:	fc 01       	movw	r30, r24
    2ea0:	e3 5f       	subi	r30, 0xF3	; 243
    2ea2:	fb 4d       	sbci	r31, 0xDB	; 219
    2ea4:	80 81       	ld	r24, Z
    2ea6:	82 30       	cpi	r24, 0x02	; 2
    2ea8:	48 f0       	brcs	.+18     	; 0x2ebc <xTaskIncrementTick+0x188>
    2eaa:	dd 24       	eor	r13, r13
    2eac:	d3 94       	inc	r13
    2eae:	06 c0       	rjmp	.+12     	; 0x2ebc <xTaskIncrementTick+0x188>
    2eb0:	80 91 e8 23 	lds	r24, 0x23E8
    2eb4:	8f 5f       	subi	r24, 0xFF	; 255
    2eb6:	80 93 e8 23 	sts	0x23E8, r24
    2eba:	d1 2c       	mov	r13, r1
    2ebc:	80 91 e7 23 	lds	r24, 0x23E7
    2ec0:	88 23       	and	r24, r24
    2ec2:	11 f0       	breq	.+4      	; 0x2ec8 <xTaskIncrementTick+0x194>
    2ec4:	dd 24       	eor	r13, r13
    2ec6:	d3 94       	inc	r13
    2ec8:	8d 2d       	mov	r24, r13
    2eca:	df 91       	pop	r29
    2ecc:	cf 91       	pop	r28
    2ece:	1f 91       	pop	r17
    2ed0:	0f 91       	pop	r16
    2ed2:	ff 90       	pop	r15
    2ed4:	ef 90       	pop	r14
    2ed6:	df 90       	pop	r13
    2ed8:	08 95       	ret

00002eda <xTaskResumeAll>:
    2eda:	df 92       	push	r13
    2edc:	ef 92       	push	r14
    2ede:	ff 92       	push	r15
    2ee0:	0f 93       	push	r16
    2ee2:	1f 93       	push	r17
    2ee4:	cf 93       	push	r28
    2ee6:	df 93       	push	r29
    2ee8:	0f b6       	in	r0, 0x3f	; 63
    2eea:	f8 94       	cli
    2eec:	0f 92       	push	r0
    2eee:	80 91 e4 23 	lds	r24, 0x23E4
    2ef2:	81 50       	subi	r24, 0x01	; 1
    2ef4:	80 93 e4 23 	sts	0x23E4, r24
    2ef8:	80 91 e4 23 	lds	r24, 0x23E4
    2efc:	81 11       	cpse	r24, r1
    2efe:	5d c0       	rjmp	.+186    	; 0x2fba <xTaskResumeAll+0xe0>
    2f00:	80 91 ed 23 	lds	r24, 0x23ED
    2f04:	81 11       	cpse	r24, r1
    2f06:	30 c0       	rjmp	.+96     	; 0x2f68 <xTaskResumeAll+0x8e>
    2f08:	5b c0       	rjmp	.+182    	; 0x2fc0 <xTaskResumeAll+0xe6>
    2f0a:	d7 01       	movw	r26, r14
    2f0c:	15 96       	adiw	r26, 0x05	; 5
    2f0e:	ed 91       	ld	r30, X+
    2f10:	fc 91       	ld	r31, X
    2f12:	16 97       	sbiw	r26, 0x06	; 6
    2f14:	c6 81       	ldd	r28, Z+6	; 0x06
    2f16:	d7 81       	ldd	r29, Z+7	; 0x07
    2f18:	ce 01       	movw	r24, r28
    2f1a:	0c 96       	adiw	r24, 0x0c	; 12
    2f1c:	f1 db       	rcall	.-2078   	; 0x2700 <uxListRemove>
    2f1e:	8e 01       	movw	r16, r28
    2f20:	0e 5f       	subi	r16, 0xFE	; 254
    2f22:	1f 4f       	sbci	r17, 0xFF	; 255
    2f24:	c8 01       	movw	r24, r16
    2f26:	ec db       	rcall	.-2088   	; 0x2700 <uxListRemove>
    2f28:	2e 89       	ldd	r18, Y+22	; 0x16
    2f2a:	80 91 ea 23 	lds	r24, 0x23EA
    2f2e:	82 17       	cp	r24, r18
    2f30:	10 f4       	brcc	.+4      	; 0x2f36 <xTaskResumeAll+0x5c>
    2f32:	20 93 ea 23 	sts	0x23EA, r18
    2f36:	30 e0       	ldi	r19, 0x00	; 0
    2f38:	c9 01       	movw	r24, r18
    2f3a:	88 0f       	add	r24, r24
    2f3c:	99 1f       	adc	r25, r25
    2f3e:	88 0f       	add	r24, r24
    2f40:	99 1f       	adc	r25, r25
    2f42:	88 0f       	add	r24, r24
    2f44:	99 1f       	adc	r25, r25
    2f46:	82 0f       	add	r24, r18
    2f48:	93 1f       	adc	r25, r19
    2f4a:	b8 01       	movw	r22, r16
    2f4c:	83 5f       	subi	r24, 0xF3	; 243
    2f4e:	9b 4d       	sbci	r25, 0xDB	; 219
    2f50:	85 db       	rcall	.-2294   	; 0x265c <vListInsertEnd>
    2f52:	e0 91 3a 24 	lds	r30, 0x243A
    2f56:	f0 91 3b 24 	lds	r31, 0x243B
    2f5a:	9e 89       	ldd	r25, Y+22	; 0x16
    2f5c:	86 89       	ldd	r24, Z+22	; 0x16
    2f5e:	98 17       	cp	r25, r24
    2f60:	58 f0       	brcs	.+22     	; 0x2f78 <xTaskResumeAll+0x9e>
    2f62:	d0 92 e7 23 	sts	0x23E7, r13
    2f66:	08 c0       	rjmp	.+16     	; 0x2f78 <xTaskResumeAll+0x9e>
    2f68:	0f 2e       	mov	r0, r31
    2f6a:	fe ee       	ldi	r31, 0xEE	; 238
    2f6c:	ef 2e       	mov	r14, r31
    2f6e:	f3 e2       	ldi	r31, 0x23	; 35
    2f70:	ff 2e       	mov	r15, r31
    2f72:	f0 2d       	mov	r31, r0
    2f74:	dd 24       	eor	r13, r13
    2f76:	d3 94       	inc	r13
    2f78:	f7 01       	movw	r30, r14
    2f7a:	80 81       	ld	r24, Z
    2f7c:	81 11       	cpse	r24, r1
    2f7e:	c5 cf       	rjmp	.-118    	; 0x2f0a <xTaskResumeAll+0x30>
    2f80:	80 91 e8 23 	lds	r24, 0x23E8
    2f84:	88 23       	and	r24, r24
    2f86:	91 f0       	breq	.+36     	; 0x2fac <xTaskResumeAll+0xd2>
    2f88:	80 91 e8 23 	lds	r24, 0x23E8
    2f8c:	88 23       	and	r24, r24
    2f8e:	71 f0       	breq	.+28     	; 0x2fac <xTaskResumeAll+0xd2>
    2f90:	c1 e0       	ldi	r28, 0x01	; 1
    2f92:	d0 de       	rcall	.-608    	; 0x2d34 <xTaskIncrementTick>
    2f94:	81 11       	cpse	r24, r1
    2f96:	c0 93 e7 23 	sts	0x23E7, r28
    2f9a:	80 91 e8 23 	lds	r24, 0x23E8
    2f9e:	81 50       	subi	r24, 0x01	; 1
    2fa0:	80 93 e8 23 	sts	0x23E8, r24
    2fa4:	80 91 e8 23 	lds	r24, 0x23E8
    2fa8:	81 11       	cpse	r24, r1
    2faa:	f3 cf       	rjmp	.-26     	; 0x2f92 <xTaskResumeAll+0xb8>
    2fac:	80 91 e7 23 	lds	r24, 0x23E7
    2fb0:	81 30       	cpi	r24, 0x01	; 1
    2fb2:	29 f4       	brne	.+10     	; 0x2fbe <xTaskResumeAll+0xe4>
    2fb4:	87 dc       	rcall	.-1778   	; 0x28c4 <vPortYield>
    2fb6:	81 e0       	ldi	r24, 0x01	; 1
    2fb8:	03 c0       	rjmp	.+6      	; 0x2fc0 <xTaskResumeAll+0xe6>
    2fba:	80 e0       	ldi	r24, 0x00	; 0
    2fbc:	01 c0       	rjmp	.+2      	; 0x2fc0 <xTaskResumeAll+0xe6>
    2fbe:	80 e0       	ldi	r24, 0x00	; 0
    2fc0:	0f 90       	pop	r0
    2fc2:	0f be       	out	0x3f, r0	; 63
    2fc4:	df 91       	pop	r29
    2fc6:	cf 91       	pop	r28
    2fc8:	1f 91       	pop	r17
    2fca:	0f 91       	pop	r16
    2fcc:	ff 90       	pop	r15
    2fce:	ef 90       	pop	r14
    2fd0:	df 90       	pop	r13
    2fd2:	08 95       	ret

00002fd4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2fd4:	cf 93       	push	r28
    2fd6:	df 93       	push	r29
    2fd8:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2fda:	89 2b       	or	r24, r25
    2fdc:	91 f0       	breq	.+36     	; 0x3002 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2fde:	a4 de       	rcall	.-696    	; 0x2d28 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2fe0:	80 91 eb 23 	lds	r24, 0x23EB
    2fe4:	90 91 ec 23 	lds	r25, 0x23EC
    2fe8:	c8 0f       	add	r28, r24
    2fea:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2fec:	80 91 3a 24 	lds	r24, 0x243A
    2ff0:	90 91 3b 24 	lds	r25, 0x243B
    2ff4:	02 96       	adiw	r24, 0x02	; 2
    2ff6:	84 db       	rcall	.-2296   	; 0x2700 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2ff8:	ce 01       	movw	r24, r28
    2ffa:	37 dd       	rcall	.-1426   	; 0x2a6a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2ffc:	6e df       	rcall	.-292    	; 0x2eda <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2ffe:	81 11       	cpse	r24, r1
    3000:	01 c0       	rjmp	.+2      	; 0x3004 <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    3002:	60 dc       	rcall	.-1856   	; 0x28c4 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3004:	df 91       	pop	r29
    3006:	cf 91       	pop	r28
    3008:	08 95       	ret

0000300a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    300a:	80 91 e4 23 	lds	r24, 0x23E4
    300e:	88 23       	and	r24, r24
    3010:	21 f0       	breq	.+8      	; 0x301a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3012:	81 e0       	ldi	r24, 0x01	; 1
    3014:	80 93 e7 23 	sts	0x23E7, r24
    3018:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    301a:	10 92 e7 23 	sts	0x23E7, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    301e:	80 91 ea 23 	lds	r24, 0x23EA
    3022:	90 e0       	ldi	r25, 0x00	; 0
    3024:	fc 01       	movw	r30, r24
    3026:	ee 0f       	add	r30, r30
    3028:	ff 1f       	adc	r31, r31
    302a:	ee 0f       	add	r30, r30
    302c:	ff 1f       	adc	r31, r31
    302e:	ee 0f       	add	r30, r30
    3030:	ff 1f       	adc	r31, r31
    3032:	8e 0f       	add	r24, r30
    3034:	9f 1f       	adc	r25, r31
    3036:	fc 01       	movw	r30, r24
    3038:	e3 5f       	subi	r30, 0xF3	; 243
    303a:	fb 4d       	sbci	r31, 0xDB	; 219
    303c:	80 81       	ld	r24, Z
    303e:	81 11       	cpse	r24, r1
    3040:	17 c0       	rjmp	.+46     	; 0x3070 <vTaskSwitchContext+0x66>
    3042:	80 91 ea 23 	lds	r24, 0x23EA
    3046:	81 50       	subi	r24, 0x01	; 1
    3048:	80 93 ea 23 	sts	0x23EA, r24
    304c:	80 91 ea 23 	lds	r24, 0x23EA
    3050:	90 e0       	ldi	r25, 0x00	; 0
    3052:	fc 01       	movw	r30, r24
    3054:	ee 0f       	add	r30, r30
    3056:	ff 1f       	adc	r31, r31
    3058:	ee 0f       	add	r30, r30
    305a:	ff 1f       	adc	r31, r31
    305c:	ee 0f       	add	r30, r30
    305e:	ff 1f       	adc	r31, r31
    3060:	8e 0f       	add	r24, r30
    3062:	9f 1f       	adc	r25, r31
    3064:	fc 01       	movw	r30, r24
    3066:	e3 5f       	subi	r30, 0xF3	; 243
    3068:	fb 4d       	sbci	r31, 0xDB	; 219
    306a:	80 81       	ld	r24, Z
    306c:	88 23       	and	r24, r24
    306e:	49 f3       	breq	.-46     	; 0x3042 <vTaskSwitchContext+0x38>
    3070:	80 91 ea 23 	lds	r24, 0x23EA
    3074:	90 e0       	ldi	r25, 0x00	; 0
    3076:	9c 01       	movw	r18, r24
    3078:	22 0f       	add	r18, r18
    307a:	33 1f       	adc	r19, r19
    307c:	22 0f       	add	r18, r18
    307e:	33 1f       	adc	r19, r19
    3080:	22 0f       	add	r18, r18
    3082:	33 1f       	adc	r19, r19
    3084:	28 0f       	add	r18, r24
    3086:	39 1f       	adc	r19, r25
    3088:	d9 01       	movw	r26, r18
    308a:	a3 5f       	subi	r26, 0xF3	; 243
    308c:	bb 4d       	sbci	r27, 0xDB	; 219
    308e:	11 96       	adiw	r26, 0x01	; 1
    3090:	ed 91       	ld	r30, X+
    3092:	fc 91       	ld	r31, X
    3094:	12 97       	sbiw	r26, 0x02	; 2
    3096:	02 80       	ldd	r0, Z+2	; 0x02
    3098:	f3 81       	ldd	r31, Z+3	; 0x03
    309a:	e0 2d       	mov	r30, r0
    309c:	11 96       	adiw	r26, 0x01	; 1
    309e:	ed 93       	st	X+, r30
    30a0:	fc 93       	st	X, r31
    30a2:	12 97       	sbiw	r26, 0x02	; 2
    30a4:	20 5f       	subi	r18, 0xF0	; 240
    30a6:	3b 4d       	sbci	r19, 0xDB	; 219
    30a8:	e2 17       	cp	r30, r18
    30aa:	f3 07       	cpc	r31, r19
    30ac:	29 f4       	brne	.+10     	; 0x30b8 <vTaskSwitchContext+0xae>
    30ae:	22 81       	ldd	r18, Z+2	; 0x02
    30b0:	33 81       	ldd	r19, Z+3	; 0x03
    30b2:	fd 01       	movw	r30, r26
    30b4:	21 83       	std	Z+1, r18	; 0x01
    30b6:	32 83       	std	Z+2, r19	; 0x02
    30b8:	fc 01       	movw	r30, r24
    30ba:	ee 0f       	add	r30, r30
    30bc:	ff 1f       	adc	r31, r31
    30be:	ee 0f       	add	r30, r30
    30c0:	ff 1f       	adc	r31, r31
    30c2:	ee 0f       	add	r30, r30
    30c4:	ff 1f       	adc	r31, r31
    30c6:	8e 0f       	add	r24, r30
    30c8:	9f 1f       	adc	r25, r31
    30ca:	fc 01       	movw	r30, r24
    30cc:	e3 5f       	subi	r30, 0xF3	; 243
    30ce:	fb 4d       	sbci	r31, 0xDB	; 219
    30d0:	01 80       	ldd	r0, Z+1	; 0x01
    30d2:	f2 81       	ldd	r31, Z+2	; 0x02
    30d4:	e0 2d       	mov	r30, r0
    30d6:	86 81       	ldd	r24, Z+6	; 0x06
    30d8:	97 81       	ldd	r25, Z+7	; 0x07
    30da:	80 93 3a 24 	sts	0x243A, r24
    30de:	90 93 3b 24 	sts	0x243B, r25
    30e2:	08 95       	ret

000030e4 <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    30e4:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    30e6:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    30e8:	e8 2f       	mov	r30, r24
    30ea:	f0 e0       	ldi	r31, 0x00	; 0
    30ec:	e0 59       	subi	r30, 0x90	; 144
    30ee:	ff 4f       	sbci	r31, 0xFF	; 255
    30f0:	60 95       	com	r22
    30f2:	80 81       	ld	r24, Z
    30f4:	68 23       	and	r22, r24
    30f6:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    30f8:	9f bf       	out	0x3f, r25	; 63
    30fa:	08 95       	ret

000030fc <sysclk_disable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    30fc:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    30fe:	f8 94       	cli

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
    3100:	e8 2f       	mov	r30, r24
    3102:	f0 e0       	ldi	r31, 0x00	; 0
    3104:	e0 59       	subi	r30, 0x90	; 144
    3106:	ff 4f       	sbci	r31, 0xFF	; 255
    3108:	80 81       	ld	r24, Z
    310a:	68 2b       	or	r22, r24
    310c:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    310e:	9f bf       	out	0x3f, r25	; 63
    3110:	08 95       	ret

00003112 <nvm_eeprom_read_byte>:
{
	nvm_wait_until_ready();
	eeprom_enable_mapping();
	memcpy( buf,(void*)(address+MAPPED_EEPROM_START), len );
	eeprom_disable_mapping();
}
    3112:	dc 01       	movw	r26, r24
    3114:	e0 ec       	ldi	r30, 0xC0	; 192
    3116:	f1 e0       	ldi	r31, 0x01	; 1
    3118:	97 85       	ldd	r25, Z+15	; 0x0f
    311a:	99 23       	and	r25, r25
    311c:	ec f3       	brlt	.-6      	; 0x3118 <nvm_eeprom_read_byte+0x6>
    311e:	ec ec       	ldi	r30, 0xCC	; 204
    3120:	f1 e0       	ldi	r31, 0x01	; 1
    3122:	80 81       	ld	r24, Z
    3124:	88 60       	ori	r24, 0x08	; 8
    3126:	80 83       	st	Z, r24
    3128:	b0 5f       	subi	r27, 0xF0	; 240
    312a:	8c 91       	ld	r24, X
    312c:	90 81       	ld	r25, Z
    312e:	97 7f       	andi	r25, 0xF7	; 247
    3130:	90 83       	st	Z, r25
    3132:	08 95       	ret

00003134 <nvm_eeprom_flush_buffer>:
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3134:	e0 ec       	ldi	r30, 0xC0	; 192
    3136:	f1 e0       	ldi	r31, 0x01	; 1
    3138:	87 85       	ldd	r24, Z+15	; 0x0f
    313a:	88 23       	and	r24, r24
    313c:	ec f3       	brlt	.-6      	; 0x3138 <nvm_eeprom_flush_buffer+0x4>
{
	// Wait until NVM is ready
	nvm_wait_until_ready();

	// Flush EEPROM page buffer if necessary
	if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    313e:	80 91 cf 01 	lds	r24, 0x01CF
    3142:	81 ff       	sbrs	r24, 1
    3144:	07 c0       	rjmp	.+14     	; 0x3154 <nvm_eeprom_flush_buffer+0x20>
		NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3146:	86 e3       	ldi	r24, 0x36	; 54
    3148:	80 93 ca 01 	sts	0x01CA, r24
 * \note The correct NVM command must be set in the NVM.CMD register before
 *       calling this function.
 */
static inline void nvm_exec(void)
{
	ccp_write_io((uint8_t *)&NVM.CTRLA, NVM_CMDEX_bm);
    314c:	61 e0       	ldi	r22, 0x01	; 1
    314e:	8b ec       	ldi	r24, 0xCB	; 203
    3150:	91 e0       	ldi	r25, 0x01	; 1
    3152:	42 c0       	rjmp	.+132    	; 0x31d8 <ccp_write_io>
    3154:	08 95       	ret

00003156 <nvm_eeprom_load_byte_to_buffer>:
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3156:	e0 ec       	ldi	r30, 0xC0	; 192
    3158:	f1 e0       	ldi	r31, 0x01	; 1
    315a:	97 85       	ldd	r25, Z+15	; 0x0f
    315c:	99 23       	and	r25, r25
    315e:	ec f3       	brlt	.-6      	; 0x315a <nvm_eeprom_load_byte_to_buffer+0x4>
 *        write operations still needs to be done through IO register.
 */
static inline void eeprom_enable_mapping(void)
{
#if !XMEGA_E
	NVM_CTRLB = NVM_CTRLB | NVM_EEMAPEN_bm;
    3160:	ac ec       	ldi	r26, 0xCC	; 204
    3162:	b1 e0       	ldi	r27, 0x01	; 1
    3164:	9c 91       	ld	r25, X
    3166:	98 60       	ori	r25, 0x08	; 8
    3168:	9c 93       	st	X, r25
{
	// Wait until NVM is ready
	nvm_wait_until_ready();

	eeprom_enable_mapping();
	*(uint8_t*)(byte_addr + MAPPED_EEPROM_START) = value;
    316a:	e8 2f       	mov	r30, r24
    316c:	f0 e0       	ldi	r31, 0x00	; 0
    316e:	f0 5f       	subi	r31, 0xF0	; 240
    3170:	60 83       	st	Z, r22
 *  IO mapped access is now enabled.
 */
static inline void eeprom_disable_mapping(void)
{
#if !XMEGA_E
	NVM_CTRLB = NVM_CTRLB & ~NVM_EEMAPEN_bm;
    3172:	8c 91       	ld	r24, X
    3174:	87 7f       	andi	r24, 0xF7	; 247
    3176:	8c 93       	st	X, r24
    3178:	08 95       	ret

0000317a <nvm_eeprom_write_byte>:
 *
 * \param  address    EEPROM address (max EEPROM_SIZE)
 * \param  value      Byte value to write to EEPROM.
 */
void nvm_eeprom_write_byte(eeprom_addr_t address, uint8_t value)
{
    317a:	ff 92       	push	r15
    317c:	0f 93       	push	r16
    317e:	1f 93       	push	r17
    3180:	cf 93       	push	r28
    3182:	df 93       	push	r29
    3184:	18 2f       	mov	r17, r24
    3186:	f9 2e       	mov	r15, r25
    3188:	c6 2f       	mov	r28, r22

	Assert(address <= EEPROM_SIZE);
	/*  Flush buffer to make sure no unintentional data is written and load
	 *  the "Page Load" command into the command register.
	 */
	old_cmd = NVM.CMD;
    318a:	00 91 ca 01 	lds	r16, 0x01CA
	nvm_eeprom_flush_buffer();
    318e:	d2 df       	rcall	.-92     	; 0x3134 <nvm_eeprom_flush_buffer>
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3190:	e0 ec       	ldi	r30, 0xC0	; 192
    3192:	f1 e0       	ldi	r31, 0x01	; 1
    3194:	27 85       	ldd	r18, Z+15	; 0x0f
    3196:	22 23       	and	r18, r18
    3198:	ec f3       	brlt	.-6      	; 0x3194 <nvm_eeprom_write_byte+0x1a>
	// Wait until NVM is ready
	nvm_wait_until_ready();
	nvm_eeprom_load_byte_to_buffer(address, value);
    319a:	6c 2f       	mov	r22, r28
    319c:	81 2f       	mov	r24, r17
    319e:	db df       	rcall	.-74     	; 0x3156 <nvm_eeprom_load_byte_to_buffer>

	// Set address to write to
	NVM.ADDR2 = 0x00;
    31a0:	c0 ec       	ldi	r28, 0xC0	; 192
    31a2:	d1 e0       	ldi	r29, 0x01	; 1
    31a4:	1a 82       	std	Y+2, r1	; 0x02
	NVM.ADDR1 = (address >> 8) & 0xFF;
    31a6:	f9 82       	std	Y+1, r15	; 0x01
	NVM.ADDR0 = address & 0xFF;
    31a8:	18 83       	st	Y, r17

	/*  Issue EEPROM Atomic Write (Erase&Write) command. Load command, write
	 *  the protection signature and execute command.
	 */
	NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    31aa:	85 e3       	ldi	r24, 0x35	; 53
    31ac:	8a 87       	std	Y+10, r24	; 0x0a
 * \note The correct NVM command must be set in the NVM.CMD register before
 *       calling this function.
 */
static inline void nvm_exec(void)
{
	ccp_write_io((uint8_t *)&NVM.CTRLA, NVM_CMDEX_bm);
    31ae:	61 e0       	ldi	r22, 0x01	; 1
    31b0:	8b ec       	ldi	r24, 0xCB	; 203
    31b2:	91 e0       	ldi	r25, 0x01	; 1
    31b4:	11 d0       	rcall	.+34     	; 0x31d8 <ccp_write_io>
	nvm_exec();
	NVM.CMD = old_cmd;
    31b6:	0a 87       	std	Y+10, r16	; 0x0a
}
    31b8:	df 91       	pop	r29
    31ba:	cf 91       	pop	r28
    31bc:	1f 91       	pop	r17
    31be:	0f 91       	pop	r16
    31c0:	ff 90       	pop	r15
    31c2:	08 95       	ret

000031c4 <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    31c4:	40 91 ca 01 	lds	r20, 0x01CA
	mov ZL, r22               ; Load byte index into low byte of Z.
    31c8:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    31ca:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    31cc:	80 93 ca 01 	sts	0x01CA, r24
	lpm r24, Z                ; Perform an LPM to read out byte
    31d0:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    31d2:	40 93 ca 01 	sts	0x01CA, r20
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    31d6:	08 95       	ret

000031d8 <ccp_write_io>:

	PUBLIC_FUNCTION(ccp_write_io)

#if defined(__GNUC__)

	out     RAMPZ, r1               // Reset bits 23:16 of Z
    31d8:	1b be       	out	0x3b, r1	; 59
	movw    r30, r24                // Load addr into Z
    31da:	fc 01       	movw	r30, r24
	ldi     r18, CCP_IOREG          // Load magic CCP value
    31dc:	28 ed       	ldi	r18, 0xD8	; 216
	out     CCP, r18                // Start CCP handshake
    31de:	24 bf       	out	0x34, r18	; 52
	st      Z, r22                  // Write value to I/O register
    31e0:	60 83       	st	Z, r22
	ret                             // Return to caller
    31e2:	08 95       	ret

000031e4 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    31e4:	cf 93       	push	r28
    31e6:	df 93       	push	r29
    31e8:	fc 01       	movw	r30, r24
    31ea:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    31ec:	20 e0       	ldi	r18, 0x00	; 0
    31ee:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    31f0:	c6 2f       	mov	r28, r22
    31f2:	d0 e0       	ldi	r29, 0x00	; 0
    31f4:	de 01       	movw	r26, r28
    31f6:	02 2e       	mov	r0, r18
    31f8:	02 c0       	rjmp	.+4      	; 0x31fe <ioport_configure_port_pin+0x1a>
    31fa:	b5 95       	asr	r27
    31fc:	a7 95       	ror	r26
    31fe:	0a 94       	dec	r0
    3200:	e2 f7       	brpl	.-8      	; 0x31fa <ioport_configure_port_pin+0x16>
    3202:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3204:	50 83       	st	Z, r21
    3206:	2f 5f       	subi	r18, 0xFF	; 255
    3208:	3f 4f       	sbci	r19, 0xFF	; 255
    320a:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    320c:	28 30       	cpi	r18, 0x08	; 8
    320e:	31 05       	cpc	r19, r1
    3210:	89 f7       	brne	.-30     	; 0x31f4 <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    3212:	40 ff       	sbrs	r20, 0
    3214:	0a c0       	rjmp	.+20     	; 0x322a <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
    3216:	41 ff       	sbrs	r20, 1
    3218:	03 c0       	rjmp	.+6      	; 0x3220 <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    321a:	fc 01       	movw	r30, r24
    321c:	65 83       	std	Z+5, r22	; 0x05
    321e:	02 c0       	rjmp	.+4      	; 0x3224 <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    3220:	fc 01       	movw	r30, r24
    3222:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    3224:	fc 01       	movw	r30, r24
    3226:	61 83       	std	Z+1, r22	; 0x01
    3228:	02 c0       	rjmp	.+4      	; 0x322e <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    322a:	fc 01       	movw	r30, r24
    322c:	62 83       	std	Z+2, r22	; 0x02
	}
}
    322e:	df 91       	pop	r29
    3230:	cf 91       	pop	r28
    3232:	08 95       	ret

00003234 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    3234:	43 e0       	ldi	r20, 0x03	; 3
    3236:	50 e0       	ldi	r21, 0x00	; 0
    3238:	61 e0       	ldi	r22, 0x01	; 1
    323a:	80 ee       	ldi	r24, 0xE0	; 224
    323c:	97 e0       	ldi	r25, 0x07	; 7
    323e:	d2 df       	rcall	.-92     	; 0x31e4 <ioport_configure_port_pin>
    3240:	43 e0       	ldi	r20, 0x03	; 3
    3242:	50 e0       	ldi	r21, 0x00	; 0
    3244:	62 e0       	ldi	r22, 0x02	; 2
    3246:	80 ee       	ldi	r24, 0xE0	; 224
    3248:	97 e0       	ldi	r25, 0x07	; 7
    324a:	cc df       	rcall	.-104    	; 0x31e4 <ioport_configure_port_pin>
    324c:	43 e0       	ldi	r20, 0x03	; 3
    324e:	50 e0       	ldi	r21, 0x00	; 0
    3250:	60 e1       	ldi	r22, 0x10	; 16
    3252:	80 e6       	ldi	r24, 0x60	; 96
    3254:	96 e0       	ldi	r25, 0x06	; 6
    3256:	c6 df       	rcall	.-116    	; 0x31e4 <ioport_configure_port_pin>
    3258:	41 e0       	ldi	r20, 0x01	; 1
    325a:	50 e4       	ldi	r21, 0x40	; 64
    325c:	60 e2       	ldi	r22, 0x20	; 32
    325e:	80 e6       	ldi	r24, 0x60	; 96
    3260:	96 e0       	ldi	r25, 0x06	; 6
    3262:	c0 df       	rcall	.-128    	; 0x31e4 <ioport_configure_port_pin>
    3264:	40 e0       	ldi	r20, 0x00	; 0
    3266:	5b e1       	ldi	r21, 0x1B	; 27
    3268:	60 e2       	ldi	r22, 0x20	; 32
    326a:	80 e8       	ldi	r24, 0x80	; 128
    326c:	96 e0       	ldi	r25, 0x06	; 6
    326e:	ba df       	rcall	.-140    	; 0x31e4 <ioport_configure_port_pin>
    3270:	40 e0       	ldi	r20, 0x00	; 0
    3272:	5b e1       	ldi	r21, 0x1B	; 27
    3274:	62 e0       	ldi	r22, 0x02	; 2
    3276:	80 ea       	ldi	r24, 0xA0	; 160
    3278:	96 e0       	ldi	r25, 0x06	; 6
    327a:	b4 df       	rcall	.-152    	; 0x31e4 <ioport_configure_port_pin>
    327c:	40 e0       	ldi	r20, 0x00	; 0
    327e:	5b e1       	ldi	r21, 0x1B	; 27
    3280:	64 e0       	ldi	r22, 0x04	; 4
    3282:	80 ea       	ldi	r24, 0xA0	; 160
    3284:	96 e0       	ldi	r25, 0x06	; 6
    3286:	ae df       	rcall	.-164    	; 0x31e4 <ioport_configure_port_pin>
    3288:	43 e0       	ldi	r20, 0x03	; 3
    328a:	50 e0       	ldi	r21, 0x00	; 0
    328c:	62 e0       	ldi	r22, 0x02	; 2
    328e:	80 e6       	ldi	r24, 0x60	; 96
    3290:	96 e0       	ldi	r25, 0x06	; 6
    3292:	a8 df       	rcall	.-176    	; 0x31e4 <ioport_configure_port_pin>
    3294:	43 e0       	ldi	r20, 0x03	; 3
    3296:	50 e0       	ldi	r21, 0x00	; 0
    3298:	68 e0       	ldi	r22, 0x08	; 8
    329a:	80 e6       	ldi	r24, 0x60	; 96
    329c:	96 e0       	ldi	r25, 0x06	; 6
    329e:	a2 df       	rcall	.-188    	; 0x31e4 <ioport_configure_port_pin>
    32a0:	43 e0       	ldi	r20, 0x03	; 3
    32a2:	50 e0       	ldi	r21, 0x00	; 0
    32a4:	68 e0       	ldi	r22, 0x08	; 8
    32a6:	80 ea       	ldi	r24, 0xA0	; 160
    32a8:	96 e0       	ldi	r25, 0x06	; 6
    32aa:	9c df       	rcall	.-200    	; 0x31e4 <ioport_configure_port_pin>
    32ac:	43 e0       	ldi	r20, 0x03	; 3
    32ae:	50 e0       	ldi	r21, 0x00	; 0
    32b0:	61 e0       	ldi	r22, 0x01	; 1
    32b2:	80 e6       	ldi	r24, 0x60	; 96
    32b4:	96 e0       	ldi	r25, 0x06	; 6
    32b6:	96 df       	rcall	.-212    	; 0x31e4 <ioport_configure_port_pin>
    32b8:	43 e0       	ldi	r20, 0x03	; 3
    32ba:	50 e0       	ldi	r21, 0x00	; 0
    32bc:	68 e0       	ldi	r22, 0x08	; 8
    32be:	80 e0       	ldi	r24, 0x00	; 0
    32c0:	96 e0       	ldi	r25, 0x06	; 6
    32c2:	90 df       	rcall	.-224    	; 0x31e4 <ioport_configure_port_pin>
    32c4:	41 e0       	ldi	r20, 0x01	; 1
    32c6:	50 e0       	ldi	r21, 0x00	; 0
    32c8:	60 e1       	ldi	r22, 0x10	; 16
    32ca:	80 e8       	ldi	r24, 0x80	; 128
    32cc:	96 e0       	ldi	r25, 0x06	; 6
    32ce:	8a cf       	rjmp	.-236    	; 0x31e4 <ioport_configure_port_pin>
    32d0:	08 95       	ret

000032d2 <checkTap>:
	}
	waterUsage = nvm_eeprom_read_byte(index);
}

void setMaxWater(int max) {
	maxWater = max;
    32d2:	c0 ee       	ldi	r28, 0xE0	; 224
    32d4:	d7 e0       	ldi	r29, 0x07	; 7
    32d6:	ee 24       	eor	r14, r14
    32d8:	e3 94       	inc	r14
    32da:	68 94       	set
    32dc:	ff 24       	eor	r15, r15
    32de:	f1 f8       	bld	r15, 1
    32e0:	00 e6       	ldi	r16, 0x60	; 96
    32e2:	16 e0       	ldi	r17, 0x06	; 6
    32e4:	68 94       	set
    32e6:	cc 24       	eor	r12, r12
    32e8:	c4 f8       	bld	r12, 4
    32ea:	68 94       	set
    32ec:	dd 24       	eor	r13, r13
    32ee:	d5 f8       	bld	r13, 5
    32f0:	80 91 52 24 	lds	r24, 0x2452
    32f4:	90 91 53 24 	lds	r25, 0x2453
    32f8:	89 2b       	or	r24, r25
    32fa:	11 f4       	brne	.+4      	; 0x3300 <checkTap+0x2e>
    32fc:	ed 82       	std	Y+5, r14	; 0x05
    32fe:	01 c0       	rjmp	.+2      	; 0x3302 <checkTap+0x30>
    3300:	ee 82       	std	Y+6, r14	; 0x06
    3302:	80 91 50 24 	lds	r24, 0x2450
    3306:	90 91 51 24 	lds	r25, 0x2451
    330a:	89 2b       	or	r24, r25
    330c:	11 f4       	brne	.+4      	; 0x3312 <checkTap+0x40>
    330e:	fd 82       	std	Y+5, r15	; 0x05
    3310:	01 c0       	rjmp	.+2      	; 0x3314 <checkTap+0x42>
    3312:	fe 82       	std	Y+6, r15	; 0x06
    3314:	80 91 4e 24 	lds	r24, 0x244E
    3318:	90 91 4f 24 	lds	r25, 0x244F
    331c:	89 2b       	or	r24, r25
    331e:	19 f4       	brne	.+6      	; 0x3326 <checkTap+0x54>
    3320:	f8 01       	movw	r30, r16
    3322:	c5 82       	std	Z+5, r12	; 0x05
    3324:	02 c0       	rjmp	.+4      	; 0x332a <checkTap+0x58>
    3326:	f8 01       	movw	r30, r16
    3328:	c6 82       	std	Z+6, r12	; 0x06
    332a:	80 91 4c 24 	lds	r24, 0x244C
    332e:	90 91 4d 24 	lds	r25, 0x244D
    3332:	89 2b       	or	r24, r25
    3334:	19 f4       	brne	.+6      	; 0x333c <checkTap+0x6a>
    3336:	f8 01       	movw	r30, r16
    3338:	d5 82       	std	Z+5, r13	; 0x05
    333a:	02 c0       	rjmp	.+4      	; 0x3340 <checkTap+0x6e>
    333c:	f8 01       	movw	r30, r16
    333e:	d6 82       	std	Z+6, r13	; 0x06
    3340:	80 91 4a 24 	lds	r24, 0x244A
    3344:	90 91 4b 24 	lds	r25, 0x244B
    3348:	89 2b       	or	r24, r25
    334a:	19 f4       	brne	.+6      	; 0x3352 <checkTap+0x80>
    334c:	ee 82       	std	Y+6, r14	; 0x06
    334e:	fe 82       	std	Y+6, r15	; 0x06
    3350:	02 c0       	rjmp	.+4      	; 0x3356 <checkTap+0x84>
    3352:	ed 82       	std	Y+5, r14	; 0x05
    3354:	fd 82       	std	Y+5, r15	; 0x05
    3356:	81 e0       	ldi	r24, 0x01	; 1
    3358:	90 e0       	ldi	r25, 0x00	; 0
    335a:	3c de       	rcall	.-904    	; 0x2fd4 <vTaskDelay>
    335c:	c9 cf       	rjmp	.-110    	; 0x32f0 <checkTap+0x1e>

0000335e <setWaterDebit>:
    335e:	c0 e0       	ldi	r28, 0x00	; 0
    3360:	d2 e0       	ldi	r29, 0x02	; 2
    3362:	11 e0       	ldi	r17, 0x01	; 1
    3364:	ce 01       	movw	r24, r28
    3366:	0e 94 26 0c 	call	0x184c	; 0x184c <adc_enable>
    336a:	9f b7       	in	r25, 0x3f	; 63
    336c:	f8 94       	cli
    336e:	88 81       	ld	r24, Y
    3370:	84 60       	ori	r24, 0x04	; 4
    3372:	88 83       	st	Y, r24
    3374:	9f bf       	out	0x3f, r25	; 63
    3376:	9e 81       	ldd	r25, Y+6	; 0x06
    3378:	90 ff       	sbrs	r25, 0
    337a:	fd cf       	rjmp	.-6      	; 0x3376 <setWaterDebit+0x18>
    337c:	1e 83       	std	Y+6, r17	; 0x06
    337e:	2c a1       	ldd	r18, Y+36	; 0x24
    3380:	3d a1       	ldd	r19, Y+37	; 0x25
    3382:	36 95       	lsr	r19
    3384:	27 95       	ror	r18
    3386:	36 95       	lsr	r19
    3388:	27 95       	ror	r18
    338a:	36 95       	lsr	r19
    338c:	27 95       	ror	r18
    338e:	a5 ec       	ldi	r26, 0xC5	; 197
    3390:	b0 e2       	ldi	r27, 0x20	; 32
    3392:	99 d4       	rcall	.+2354   	; 0x3cc6 <__umulhisi3>
    3394:	92 95       	swap	r25
    3396:	82 95       	swap	r24
    3398:	8f 70       	andi	r24, 0x0F	; 15
    339a:	89 27       	eor	r24, r25
    339c:	9f 70       	andi	r25, 0x0F	; 15
    339e:	89 27       	eor	r24, r25
    33a0:	80 93 42 24 	sts	0x2442, r24
    33a4:	90 93 43 24 	sts	0x2443, r25
    33a8:	84 ef       	ldi	r24, 0xF4	; 244
    33aa:	91 e0       	ldi	r25, 0x01	; 1
    33ac:	13 de       	rcall	.-986    	; 0x2fd4 <vTaskDelay>
    33ae:	da cf       	rjmp	.-76     	; 0x3364 <setWaterDebit+0x6>

000033b0 <checkLight>:
    33b0:	c0 e0       	ldi	r28, 0x00	; 0
    33b2:	d2 e0       	ldi	r29, 0x02	; 2
    33b4:	9f b7       	in	r25, 0x3f	; 63
    33b6:	f8 94       	cli
    33b8:	88 81       	ld	r24, Y
    33ba:	84 60       	ori	r24, 0x04	; 4
    33bc:	88 83       	st	Y, r24
    33be:	9f bf       	out	0x3f, r25	; 63
    33c0:	0e 94 4c 08 	call	0x1098	; 0x1098 <lightsensor_data_is_ready>
    33c4:	88 23       	and	r24, r24
    33c6:	31 f0       	breq	.+12     	; 0x33d4 <checkLight+0x24>
    33c8:	0e 94 a5 08 	call	0x114a	; 0x114a <lightsensor_get_raw_value>
    33cc:	80 93 48 24 	sts	0x2448, r24
    33d0:	90 93 49 24 	sts	0x2449, r25
    33d4:	8a e0       	ldi	r24, 0x0A	; 10
    33d6:	90 e0       	ldi	r25, 0x00	; 0
    33d8:	fd dd       	rcall	.-1030   	; 0x2fd4 <vTaskDelay>
    33da:	ec cf       	rjmp	.-40     	; 0x33b4 <checkLight+0x4>

000033dc <adc_init>:
    33dc:	cf 93       	push	r28
    33de:	df 93       	push	r29
    33e0:	cd b7       	in	r28, 0x3d	; 61
    33e2:	de b7       	in	r29, 0x3e	; 62
    33e4:	2b 97       	sbiw	r28, 0x0b	; 11
    33e6:	cd bf       	out	0x3d, r28	; 61
    33e8:	de bf       	out	0x3e, r29	; 62
    33ea:	be 01       	movw	r22, r28
    33ec:	6f 5f       	subi	r22, 0xFF	; 255
    33ee:	7f 4f       	sbci	r23, 0xFF	; 255
    33f0:	80 e0       	ldi	r24, 0x00	; 0
    33f2:	92 e0       	ldi	r25, 0x02	; 2
    33f4:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <adc_read_configuration>
    33f8:	ae 01       	movw	r20, r28
    33fa:	48 5f       	subi	r20, 0xF8	; 248
    33fc:	5f 4f       	sbci	r21, 0xFF	; 255
    33fe:	61 e0       	ldi	r22, 0x01	; 1
    3400:	80 e0       	ldi	r24, 0x00	; 0
    3402:	92 e0       	ldi	r25, 0x02	; 2
    3404:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <adcch_read_configuration>
    3408:	9a 81       	ldd	r25, Y+2	; 0x02
    340a:	8b 81       	ldd	r24, Y+3	; 0x03
    340c:	8f 78       	andi	r24, 0x8F	; 143
    340e:	80 61       	ori	r24, 0x10	; 16
    3410:	8b 83       	std	Y+3, r24	; 0x03
    3412:	89 2f       	mov	r24, r25
    3414:	81 7e       	andi	r24, 0xE1	; 225
    3416:	8a 83       	std	Y+2, r24	; 0x02
    3418:	1c 82       	std	Y+4, r1	; 0x04
    341a:	86 e0       	ldi	r24, 0x06	; 6
    341c:	8d 83       	std	Y+5, r24	; 0x05
    341e:	81 e0       	ldi	r24, 0x01	; 1
    3420:	88 87       	std	Y+8, r24	; 0x08
    3422:	19 86       	std	Y+9, r1	; 0x09
    3424:	be 01       	movw	r22, r28
    3426:	6f 5f       	subi	r22, 0xFF	; 255
    3428:	7f 4f       	sbci	r23, 0xFF	; 255
    342a:	80 e0       	ldi	r24, 0x00	; 0
    342c:	92 e0       	ldi	r25, 0x02	; 2
    342e:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <adc_write_configuration>
    3432:	ae 01       	movw	r20, r28
    3434:	48 5f       	subi	r20, 0xF8	; 248
    3436:	5f 4f       	sbci	r21, 0xFF	; 255
    3438:	61 e0       	ldi	r22, 0x01	; 1
    343a:	80 e0       	ldi	r24, 0x00	; 0
    343c:	92 e0       	ldi	r25, 0x02	; 2
    343e:	0e 94 44 0e 	call	0x1c88	; 0x1c88 <adcch_write_configuration>
    3442:	2b 96       	adiw	r28, 0x0b	; 11
    3444:	cd bf       	out	0x3d, r28	; 61
    3446:	de bf       	out	0x3e, r29	; 62
    3448:	df 91       	pop	r29
    344a:	cf 91       	pop	r28
    344c:	08 95       	ret

0000344e <setUpSerial>:
    344e:	10 92 a7 08 	sts	0x08A7, r1
    3452:	8c e0       	ldi	r24, 0x0C	; 12
    3454:	80 93 a6 08 	sts	0x08A6, r24
    3458:	10 92 a3 08 	sts	0x08A3, r1
    345c:	83 e0       	ldi	r24, 0x03	; 3
    345e:	80 93 a5 08 	sts	0x08A5, r24
    3462:	88 e1       	ldi	r24, 0x18	; 24
    3464:	80 93 a4 08 	sts	0x08A4, r24
    3468:	08 95       	ret

0000346a <sendChar>:
    346a:	e1 ea       	ldi	r30, 0xA1	; 161
    346c:	f8 e0       	ldi	r31, 0x08	; 8
    346e:	90 81       	ld	r25, Z
    3470:	95 ff       	sbrs	r25, 5
    3472:	fd cf       	rjmp	.-6      	; 0x346e <sendChar+0x4>
    3474:	80 93 a0 08 	sts	0x08A0, r24
    3478:	08 95       	ret

0000347a <receiveChar>:
    347a:	e1 ea       	ldi	r30, 0xA1	; 161
    347c:	f8 e0       	ldi	r31, 0x08	; 8
    347e:	80 81       	ld	r24, Z
    3480:	88 23       	and	r24, r24
    3482:	ec f7       	brge	.-6      	; 0x347e <receiveChar+0x4>
    3484:	80 91 a0 08 	lds	r24, 0x08A0
    3488:	08 95       	ret

0000348a <getWaterUsageFromEEPROM>:
    348a:	cf 93       	push	r28
    348c:	df 93       	push	r29
    348e:	ce e0       	ldi	r28, 0x0E	; 14
    3490:	d0 e0       	ldi	r29, 0x00	; 0
    3492:	ce 01       	movw	r24, r28
    3494:	3e de       	rcall	.-900    	; 0x3112 <nvm_eeprom_read_byte>
    3496:	28 2f       	mov	r18, r24
    3498:	30 e0       	ldi	r19, 0x00	; 0
    349a:	2f 3f       	cpi	r18, 0xFF	; 255
    349c:	31 05       	cpc	r19, r1
    349e:	14 f0       	brlt	.+4      	; 0x34a4 <getWaterUsageFromEEPROM+0x1a>
    34a0:	21 96       	adiw	r28, 0x01	; 1
    34a2:	f7 cf       	rjmp	.-18     	; 0x3492 <getWaterUsageFromEEPROM+0x8>
    34a4:	ce 01       	movw	r24, r28
    34a6:	35 de       	rcall	.-918    	; 0x3112 <nvm_eeprom_read_byte>
    34a8:	90 e0       	ldi	r25, 0x00	; 0
    34aa:	80 93 46 24 	sts	0x2446, r24
    34ae:	90 93 47 24 	sts	0x2447, r25
    34b2:	df 91       	pop	r29
    34b4:	cf 91       	pop	r28
    34b6:	08 95       	ret

000034b8 <setRainTankVolume>:
}

void setRainTankVolume(int vol) {
    34b8:	bf 92       	push	r11
    34ba:	cf 92       	push	r12
    34bc:	df 92       	push	r13
    34be:	ef 92       	push	r14
    34c0:	ff 92       	push	r15
    34c2:	0f 93       	push	r16
    34c4:	1f 93       	push	r17
    34c6:	cf 93       	push	r28
    34c8:	df 93       	push	r29
	rainTankVolume = vol;
    34ca:	80 93 40 24 	sts	0x2440, r24
    34ce:	90 93 41 24 	sts	0x2441, r25

	int i = vol/255;
    34d2:	6f ef       	ldi	r22, 0xFF	; 255
    34d4:	70 e0       	ldi	r23, 0x00	; 0
    34d6:	c2 d3       	rcall	.+1924   	; 0x3c5c <__divmodhi4>
    34d8:	6b 01       	movw	r12, r22
    34da:	b8 2e       	mov	r11, r24
    34dc:	8b 01       	movw	r16, r22
	int remainder = vol%255;
    34de:	e8 2e       	mov	r14, r24
    34e0:	f9 2e       	mov	r15, r25
	int a;
	for(a = 1; a <= i; a++){
    34e2:	16 16       	cp	r1, r22
    34e4:	17 06       	cpc	r1, r23
    34e6:	4c f4       	brge	.+18     	; 0x34fa <setRainTankVolume+0x42>
    34e8:	c1 e0       	ldi	r28, 0x01	; 1
    34ea:	d0 e0       	ldi	r29, 0x00	; 0
		nvm_eeprom_write_byte(a, 255);
    34ec:	6f ef       	ldi	r22, 0xFF	; 255
    34ee:	ce 01       	movw	r24, r28
    34f0:	44 de       	rcall	.-888    	; 0x317a <nvm_eeprom_write_byte>
	rainTankVolume = vol;

	int i = vol/255;
	int remainder = vol%255;
	int a;
	for(a = 1; a <= i; a++){
    34f2:	21 96       	adiw	r28, 0x01	; 1
    34f4:	0c 17       	cp	r16, r28
    34f6:	1d 07       	cpc	r17, r29
    34f8:	cc f7       	brge	.-14     	; 0x34ec <setRainTankVolume+0x34>
		nvm_eeprom_write_byte(a, 255);
	}
	
	if(remainder!=0) {
    34fa:	ef 28       	or	r14, r15
    34fc:	21 f0       	breq	.+8      	; 0x3506 <setRainTankVolume+0x4e>
		nvm_eeprom_write_byte(i+1, remainder);
    34fe:	6b 2d       	mov	r22, r11
    3500:	c6 01       	movw	r24, r12
    3502:	01 96       	adiw	r24, 0x01	; 1
    3504:	3a de       	rcall	.-908    	; 0x317a <nvm_eeprom_write_byte>
	}
	
}
    3506:	df 91       	pop	r29
    3508:	cf 91       	pop	r28
    350a:	1f 91       	pop	r17
    350c:	0f 91       	pop	r16
    350e:	ff 90       	pop	r15
    3510:	ef 90       	pop	r14
    3512:	df 90       	pop	r13
    3514:	cf 90       	pop	r12
    3516:	bf 90       	pop	r11
    3518:	08 95       	ret

0000351a <watering>:
static void watering(void *vpParameters) {
	while(1) {
		if(isAutoWatering==1 && lightIntensity>=150  && lightIntensity<=200) {
			
			int wateringVol = 500;
			isWateringTapOpened = 1;	//triggering openCloseTap()
    351a:	01 e0       	ldi	r16, 0x01	; 1
    351c:	10 e0       	ldi	r17, 0x00	; 0
    351e:	0f 2e       	mov	r0, r31
    3520:	f5 ef       	ldi	r31, 0xF5	; 245
    3522:	ef 2e       	mov	r14, r31
    3524:	f0 2d       	mov	r31, r0
    3526:	ff 24       	eor	r15, r15
    3528:	f3 94       	inc	r15
	}
}

static void watering(void *vpParameters) {
	while(1) {
		if(isAutoWatering==1 && lightIntensity>=150  && lightIntensity<=200) {
    352a:	80 91 3e 24 	lds	r24, 0x243E
    352e:	90 91 3f 24 	lds	r25, 0x243F
    3532:	81 30       	cpi	r24, 0x01	; 1
    3534:	91 05       	cpc	r25, r1
    3536:	11 f5       	brne	.+68     	; 0x357c <watering+0x62>
    3538:	80 91 48 24 	lds	r24, 0x2448
    353c:	90 91 49 24 	lds	r25, 0x2449
    3540:	86 59       	subi	r24, 0x96	; 150
    3542:	91 09       	sbc	r25, r1
    3544:	c3 97       	sbiw	r24, 0x33	; 51
    3546:	88 f7       	brcc	.-30     	; 0x352a <watering+0x10>
			
			int wateringVol = 500;
			isWateringTapOpened = 1;	//triggering openCloseTap()
    3548:	00 93 4a 24 	sts	0x244A, r16
    354c:	10 93 4b 24 	sts	0x244B, r17
    3550:	ce 2d       	mov	r28, r14
    3552:	df 2d       	mov	r29, r15
			
			while(wateringVol>=0) {
				wateringVol--;
				vTaskDelay(5);
    3554:	85 e0       	ldi	r24, 0x05	; 5
    3556:	90 e0       	ldi	r25, 0x00	; 0
    3558:	3d dd       	rcall	.-1414   	; 0x2fd4 <vTaskDelay>
    355a:	21 97       	sbiw	r28, 0x01	; 1
		if(isAutoWatering==1 && lightIntensity>=150  && lightIntensity<=200) {
			
			int wateringVol = 500;
			isWateringTapOpened = 1;	//triggering openCloseTap()
			
			while(wateringVol>=0) {
    355c:	d9 f7       	brne	.-10     	; 0x3554 <watering+0x3a>
				wateringVol--;
				vTaskDelay(5);
			}
			
			rainTankVolume -= wateringVol;
    355e:	80 91 40 24 	lds	r24, 0x2440
    3562:	90 91 41 24 	lds	r25, 0x2441
    3566:	01 96       	adiw	r24, 0x01	; 1
    3568:	80 93 40 24 	sts	0x2440, r24
    356c:	90 93 41 24 	sts	0x2441, r25
			setRainTankVolume(rainTankVolume);
    3570:	a3 df       	rcall	.-186    	; 0x34b8 <setRainTankVolume>
			isWateringTapOpened=0;
    3572:	10 92 4a 24 	sts	0x244A, r1
    3576:	10 92 4b 24 	sts	0x244B, r1
	}
}

static void watering(void *vpParameters) {
	while(1) {
		if(isAutoWatering==1 && lightIntensity>=150  && lightIntensity<=200) {
    357a:	d7 cf       	rjmp	.-82     	; 0x352a <watering+0x10>
			
			rainTankVolume -= wateringVol;
			setRainTankVolume(rainTankVolume);
			isWateringTapOpened=0;
			
			} else if(isAutoWatering==0 && isWateringTapOpened==1) {
    357c:	89 2b       	or	r24, r25
    357e:	a9 f6       	brne	.-86     	; 0x352a <watering+0x10>
    3580:	80 91 4a 24 	lds	r24, 0x244A
    3584:	90 91 4b 24 	lds	r25, 0x244B
    3588:	01 97       	sbiw	r24, 0x01	; 1
    358a:	79 f6       	brne	.-98     	; 0x352a <watering+0x10>
			
			while(rainTankVolume>=0 && isWateringTapOpened==1) {
    358c:	80 91 40 24 	lds	r24, 0x2440
    3590:	90 91 41 24 	lds	r25, 0x2441
    3594:	99 23       	and	r25, r25
    3596:	ac f0       	brlt	.+42     	; 0x35c2 <watering+0xa8>
				rainTankVolume--;
    3598:	01 97       	sbiw	r24, 0x01	; 1
    359a:	80 93 40 24 	sts	0x2440, r24
    359e:	90 93 41 24 	sts	0x2441, r25
				vTaskDelay(5);
    35a2:	85 e0       	ldi	r24, 0x05	; 5
    35a4:	90 e0       	ldi	r25, 0x00	; 0
    35a6:	16 dd       	rcall	.-1492   	; 0x2fd4 <vTaskDelay>
			setRainTankVolume(rainTankVolume);
			isWateringTapOpened=0;
			
			} else if(isAutoWatering==0 && isWateringTapOpened==1) {
			
			while(rainTankVolume>=0 && isWateringTapOpened==1) {
    35a8:	80 91 40 24 	lds	r24, 0x2440
    35ac:	90 91 41 24 	lds	r25, 0x2441
    35b0:	99 23       	and	r25, r25
    35b2:	3c f0       	brlt	.+14     	; 0x35c2 <watering+0xa8>
    35b4:	20 91 4a 24 	lds	r18, 0x244A
    35b8:	30 91 4b 24 	lds	r19, 0x244B
    35bc:	21 30       	cpi	r18, 0x01	; 1
    35be:	31 05       	cpc	r19, r1
    35c0:	59 f3       	breq	.-42     	; 0x3598 <watering+0x7e>
				rainTankVolume--;
				vTaskDelay(5);
			}
			
			setRainTankVolume(rainTankVolume);
    35c2:	7a df       	rcall	.-268    	; 0x34b8 <setRainTankVolume>
    35c4:	b2 cf       	rjmp	.-156    	; 0x352a <watering+0x10>

000035c6 <getDelayBasedOnDebit>:
		
	}
}

void getDelayBasedOnDebit(void) {
	if(debit==0) delay = 250;
    35c6:	80 91 42 24 	lds	r24, 0x2442
    35ca:	90 91 43 24 	lds	r25, 0x2443
    35ce:	00 97       	sbiw	r24, 0x00	; 0
    35d0:	39 f4       	brne	.+14     	; 0x35e0 <getDelayBasedOnDebit+0x1a>
    35d2:	8a ef       	ldi	r24, 0xFA	; 250
    35d4:	90 e0       	ldi	r25, 0x00	; 0
    35d6:	80 93 3c 24 	sts	0x243C, r24
    35da:	90 93 3d 24 	sts	0x243D, r25
    35de:	08 95       	ret
	else if(debit==1) delay = 200;
    35e0:	81 30       	cpi	r24, 0x01	; 1
    35e2:	91 05       	cpc	r25, r1
    35e4:	39 f4       	brne	.+14     	; 0x35f4 <getDelayBasedOnDebit+0x2e>
    35e6:	88 ec       	ldi	r24, 0xC8	; 200
    35e8:	90 e0       	ldi	r25, 0x00	; 0
    35ea:	80 93 3c 24 	sts	0x243C, r24
    35ee:	90 93 3d 24 	sts	0x243D, r25
    35f2:	08 95       	ret
	else if(debit==2) delay = 150;
    35f4:	82 30       	cpi	r24, 0x02	; 2
    35f6:	91 05       	cpc	r25, r1
    35f8:	39 f4       	brne	.+14     	; 0x3608 <getDelayBasedOnDebit+0x42>
    35fa:	86 e9       	ldi	r24, 0x96	; 150
    35fc:	90 e0       	ldi	r25, 0x00	; 0
    35fe:	80 93 3c 24 	sts	0x243C, r24
    3602:	90 93 3d 24 	sts	0x243D, r25
    3606:	08 95       	ret
	else if(debit==3) delay = 100;
    3608:	83 30       	cpi	r24, 0x03	; 3
    360a:	91 05       	cpc	r25, r1
    360c:	39 f4       	brne	.+14     	; 0x361c <getDelayBasedOnDebit+0x56>
    360e:	84 e6       	ldi	r24, 0x64	; 100
    3610:	90 e0       	ldi	r25, 0x00	; 0
    3612:	80 93 3c 24 	sts	0x243C, r24
    3616:	90 93 3d 24 	sts	0x243D, r25
    361a:	08 95       	ret
	else if(debit==4) delay = 50;
    361c:	04 97       	sbiw	r24, 0x04	; 4
    361e:	31 f4       	brne	.+12     	; 0x362c <getDelayBasedOnDebit+0x66>
    3620:	82 e3       	ldi	r24, 0x32	; 50
    3622:	90 e0       	ldi	r25, 0x00	; 0
    3624:	80 93 3c 24 	sts	0x243C, r24
    3628:	90 93 3d 24 	sts	0x243D, r25
    362c:	08 95       	ret

0000362e <countWaterUsage>:
	
}

static void countWaterUsage(void *vpParameters) {
	while(1) {
		if(isTap1Opened==1 || isTap2Opened==1 || isTap3Opened==1 || isTap4Opened==1) {
    362e:	80 91 52 24 	lds	r24, 0x2452
    3632:	90 91 53 24 	lds	r25, 0x2453
    3636:	01 97       	sbiw	r24, 0x01	; 1
    3638:	b9 f0       	breq	.+46     	; 0x3668 <countWaterUsage+0x3a>
    363a:	80 91 50 24 	lds	r24, 0x2450
    363e:	90 91 51 24 	lds	r25, 0x2451
    3642:	01 97       	sbiw	r24, 0x01	; 1
    3644:	b1 f0       	breq	.+44     	; 0x3672 <countWaterUsage+0x44>
    3646:	80 91 4e 24 	lds	r24, 0x244E
    364a:	90 91 4f 24 	lds	r25, 0x244F
    364e:	01 97       	sbiw	r24, 0x01	; 1
    3650:	a9 f0       	breq	.+42     	; 0x367c <countWaterUsage+0x4e>
    3652:	80 91 4c 24 	lds	r24, 0x244C
    3656:	90 91 4d 24 	lds	r25, 0x244D
    365a:	01 97       	sbiw	r24, 0x01	; 1
    365c:	f1 f4       	brne	.+60     	; 0x369a <countWaterUsage+0x6c>
    365e:	00 e0       	ldi	r16, 0x00	; 0
    3660:	10 e0       	ldi	r17, 0x00	; 0
    3662:	ce e0       	ldi	r28, 0x0E	; 14
    3664:	d0 e0       	ldi	r29, 0x00	; 0
    3666:	0e c0       	rjmp	.+28     	; 0x3684 <countWaterUsage+0x56>
    3668:	00 e0       	ldi	r16, 0x00	; 0
    366a:	10 e0       	ldi	r17, 0x00	; 0
    366c:	ce e0       	ldi	r28, 0x0E	; 14
    366e:	d0 e0       	ldi	r29, 0x00	; 0
    3670:	09 c0       	rjmp	.+18     	; 0x3684 <countWaterUsage+0x56>
    3672:	00 e0       	ldi	r16, 0x00	; 0
    3674:	10 e0       	ldi	r17, 0x00	; 0
    3676:	ce e0       	ldi	r28, 0x0E	; 14
    3678:	d0 e0       	ldi	r29, 0x00	; 0
    367a:	04 c0       	rjmp	.+8      	; 0x3684 <countWaterUsage+0x56>
    367c:	00 e0       	ldi	r16, 0x00	; 0
    367e:	10 e0       	ldi	r17, 0x00	; 0
    3680:	ce e0       	ldi	r28, 0x0E	; 14
    3682:	d0 e0       	ldi	r29, 0x00	; 0
			int Subtotal=0;
			int total=0;
			int index=0;
			bool habis = false;
			while(!habis){
				Subtotal = nvm_eeprom_read_byte(i);
    3684:	ce 01       	movw	r24, r28
    3686:	45 dd       	rcall	.-1398   	; 0x3112 <nvm_eeprom_read_byte>
    3688:	68 2f       	mov	r22, r24
    368a:	70 e0       	ldi	r23, 0x00	; 0
				if(Subtotal>=255){
    368c:	6f 3f       	cpi	r22, 0xFF	; 255
    368e:	71 05       	cpc	r23, r1
    3690:	5c f0       	brlt	.+22     	; 0x36a8 <countWaterUsage+0x7a>
					i++;
    3692:	21 96       	adiw	r28, 0x01	; 1
				}
				else{
					habis=true;
				}
				total+=Subtotal;
    3694:	06 0f       	add	r16, r22
    3696:	17 1f       	adc	r17, r23
    3698:	f5 cf       	rjmp	.-22     	; 0x3684 <countWaterUsage+0x56>
				index = i;
			}
			waterUsage = total;
			nvm_eeprom_write_byte(index, total);
		}
		getDelayBasedOnDebit();
    369a:	95 df       	rcall	.-214    	; 0x35c6 <getDelayBasedOnDebit>
		vTaskDelay(delay);
    369c:	80 91 3c 24 	lds	r24, 0x243C
    36a0:	90 91 3d 24 	lds	r25, 0x243D
    36a4:	97 dc       	rcall	.-1746   	; 0x2fd4 <vTaskDelay>
	}
    36a6:	c3 cf       	rjmp	.-122    	; 0x362e <countWaterUsage>
					i++;
				}
				else{
					habis=true;
				}
				total+=Subtotal;
    36a8:	60 0f       	add	r22, r16
    36aa:	71 1f       	adc	r23, r17
				Subtotal=0;
				index = i;
			}
			waterUsage = total;
    36ac:	60 93 46 24 	sts	0x2446, r22
    36b0:	70 93 47 24 	sts	0x2447, r23
			nvm_eeprom_write_byte(index, total);
    36b4:	ce 01       	movw	r24, r28
    36b6:	61 dd       	rcall	.-1342   	; 0x317a <nvm_eeprom_write_byte>
    36b8:	f0 cf       	rjmp	.-32     	; 0x369a <countWaterUsage+0x6c>

000036ba <closeTap>:
		vTaskDelay(10);
	}
}

void closeTap(void){
	PORTC.DIR |= PIN0_bm;
    36ba:	e0 e4       	ldi	r30, 0x40	; 64
    36bc:	f6 e0       	ldi	r31, 0x06	; 6
    36be:	80 81       	ld	r24, Z
    36c0:	81 60       	ori	r24, 0x01	; 1
    36c2:	80 83       	st	Z, r24
	
	TCC0.CTRLA = (PIN2_bm) | (PIN0_bm);
    36c4:	e0 e0       	ldi	r30, 0x00	; 0
    36c6:	f8 e0       	ldi	r31, 0x08	; 8
    36c8:	85 e0       	ldi	r24, 0x05	; 5
    36ca:	80 83       	st	Z, r24
	TCC0.CTRLB = (PIN4_bm) | (PIN2_bm) | (PIN1_bm);
    36cc:	86 e1       	ldi	r24, 0x16	; 22
    36ce:	81 83       	std	Z+1, r24	; 0x01
	
	TCC0.PER = 8000;
    36d0:	80 e4       	ldi	r24, 0x40	; 64
    36d2:	9f e1       	ldi	r25, 0x1F	; 31
    36d4:	86 a3       	std	Z+38, r24	; 0x26
    36d6:	97 a3       	std	Z+39, r25	; 0x27
	TCC0.CCA = 1;
    36d8:	81 e0       	ldi	r24, 0x01	; 1
    36da:	90 e0       	ldi	r25, 0x00	; 0
    36dc:	80 a7       	std	Z+40, r24	; 0x28
    36de:	91 a7       	std	Z+41, r25	; 0x29
    36e0:	08 95       	ret

000036e2 <openTap>:
}

void openTap(void){
	PORTC.DIR |= PIN0_bm;
    36e2:	e0 e4       	ldi	r30, 0x40	; 64
    36e4:	f6 e0       	ldi	r31, 0x06	; 6
    36e6:	80 81       	ld	r24, Z
    36e8:	81 60       	ori	r24, 0x01	; 1
    36ea:	80 83       	st	Z, r24
	
	TCC0.CTRLA = (PIN2_bm) | (PIN0_bm);
    36ec:	e0 e0       	ldi	r30, 0x00	; 0
    36ee:	f8 e0       	ldi	r31, 0x08	; 8
    36f0:	85 e0       	ldi	r24, 0x05	; 5
    36f2:	80 83       	st	Z, r24
	TCC0.CTRLB = (PIN4_bm) | (PIN2_bm) | (PIN1_bm);
    36f4:	86 e1       	ldi	r24, 0x16	; 22
    36f6:	81 83       	std	Z+1, r24	; 0x01
	
	TCC0.PER = 8000;
    36f8:	80 e4       	ldi	r24, 0x40	; 64
    36fa:	9f e1       	ldi	r25, 0x1F	; 31
    36fc:	86 a3       	std	Z+38, r24	; 0x26
    36fe:	97 a3       	std	Z+39, r25	; 0x27
	TCC0.CCA = 375;
    3700:	87 e7       	ldi	r24, 0x77	; 119
    3702:	91 e0       	ldi	r25, 0x01	; 1
    3704:	80 a7       	std	Z+40, r24	; 0x28
    3706:	91 a7       	std	Z+41, r25	; 0x29
    3708:	08 95       	ret

0000370a <openCloseTap>:
{
	 while(1){
		
		if(isTap1Opened==0) {
			openTap();
			isTap1Opened = 1;
    370a:	c1 e0       	ldi	r28, 0x01	; 1
    370c:	d0 e0       	ldi	r29, 0x00	; 0

static void openCloseTap(void *pvParameters)
{
	 while(1){
		
		if(isTap1Opened==0) {
    370e:	80 91 52 24 	lds	r24, 0x2452
    3712:	90 91 53 24 	lds	r25, 0x2453
    3716:	89 2b       	or	r24, r25
    3718:	31 f4       	brne	.+12     	; 0x3726 <openCloseTap+0x1c>
			openTap();
    371a:	e3 df       	rcall	.-58     	; 0x36e2 <openTap>
			isTap1Opened = 1;
    371c:	c0 93 52 24 	sts	0x2452, r28
    3720:	d0 93 53 24 	sts	0x2453, r29
    3724:	05 c0       	rjmp	.+10     	; 0x3730 <openCloseTap+0x26>
		} else {
			closeTap();
    3726:	c9 df       	rcall	.-110    	; 0x36ba <closeTap>
			isTap1Opened = 0;
    3728:	10 92 52 24 	sts	0x2452, r1
    372c:	10 92 53 24 	sts	0x2453, r1
		}
			
		if(isTap2Opened==0) {
    3730:	80 91 50 24 	lds	r24, 0x2450
    3734:	90 91 51 24 	lds	r25, 0x2451
    3738:	89 2b       	or	r24, r25
    373a:	31 f4       	brne	.+12     	; 0x3748 <openCloseTap+0x3e>
			openTap();
    373c:	d2 df       	rcall	.-92     	; 0x36e2 <openTap>
			isTap2Opened = 1;
    373e:	c0 93 50 24 	sts	0x2450, r28
    3742:	d0 93 51 24 	sts	0x2451, r29
    3746:	05 c0       	rjmp	.+10     	; 0x3752 <openCloseTap+0x48>
			} else {
			closeTap();
    3748:	b8 df       	rcall	.-144    	; 0x36ba <closeTap>
			isTap2Opened = 0;
    374a:	10 92 50 24 	sts	0x2450, r1
    374e:	10 92 51 24 	sts	0x2451, r1
		}
			
		if(isTap3Opened==0) {
    3752:	80 91 4e 24 	lds	r24, 0x244E
    3756:	90 91 4f 24 	lds	r25, 0x244F
    375a:	89 2b       	or	r24, r25
    375c:	31 f4       	brne	.+12     	; 0x376a <openCloseTap+0x60>
			openTap();
    375e:	c1 df       	rcall	.-126    	; 0x36e2 <openTap>
			isTap3Opened = 1;
    3760:	c0 93 4e 24 	sts	0x244E, r28
    3764:	d0 93 4f 24 	sts	0x244F, r29
    3768:	05 c0       	rjmp	.+10     	; 0x3774 <openCloseTap+0x6a>
		} else {
			closeTap();
    376a:	a7 df       	rcall	.-178    	; 0x36ba <closeTap>
			isTap3Opened = 0;
    376c:	10 92 4e 24 	sts	0x244E, r1
    3770:	10 92 4f 24 	sts	0x244F, r1
		}
			
		if(isTap4Opened==0) {
    3774:	80 91 4c 24 	lds	r24, 0x244C
    3778:	90 91 4d 24 	lds	r25, 0x244D
    377c:	89 2b       	or	r24, r25
    377e:	31 f4       	brne	.+12     	; 0x378c <openCloseTap+0x82>
			openTap();
    3780:	b0 df       	rcall	.-160    	; 0x36e2 <openTap>
			isTap4Opened = 1;
    3782:	c0 93 4c 24 	sts	0x244C, r28
    3786:	d0 93 4d 24 	sts	0x244D, r29
    378a:	05 c0       	rjmp	.+10     	; 0x3796 <openCloseTap+0x8c>
		} else {
			closeTap();
    378c:	96 df       	rcall	.-212    	; 0x36ba <closeTap>
			isTap4Opened = 0;
    378e:	10 92 4c 24 	sts	0x244C, r1
    3792:	10 92 4d 24 	sts	0x244D, r1
		}
		
		if(isWateringTapOpened==0) {
    3796:	80 91 4a 24 	lds	r24, 0x244A
    379a:	90 91 4b 24 	lds	r25, 0x244B
    379e:	89 2b       	or	r24, r25
    37a0:	31 f4       	brne	.+12     	; 0x37ae <openCloseTap+0xa4>
			openTap();
    37a2:	9f df       	rcall	.-194    	; 0x36e2 <openTap>
			isWateringTapOpened = 1;
    37a4:	c0 93 4a 24 	sts	0x244A, r28
    37a8:	d0 93 4b 24 	sts	0x244B, r29
    37ac:	05 c0       	rjmp	.+10     	; 0x37b8 <openCloseTap+0xae>
		} else {
			closeTap();
    37ae:	85 df       	rcall	.-246    	; 0x36ba <closeTap>
			isWateringTapOpened = 0;
    37b0:	10 92 4a 24 	sts	0x244A, r1
    37b4:	10 92 4b 24 	sts	0x244B, r1
		}
		
		vTaskDelay(1);
    37b8:	ce 01       	movw	r24, r28
    37ba:	0c dc       	rcall	.-2024   	; 0x2fd4 <vTaskDelay>
	 }
    37bc:	a8 cf       	rjmp	.-176    	; 0x370e <openCloseTap+0x4>

000037be <waterAlertOn>:
	TCC0.PER = 8000;
	TCC0.CCA = 375;
}

void waterAlertOn(void) {
	PORTE_DIR=0b00000001;
    37be:	81 e0       	ldi	r24, 0x01	; 1
    37c0:	80 93 80 06 	sts	0x0680, r24
	PORTE_OUT=0b00000001;
    37c4:	80 93 84 06 	sts	0x0684, r24
    37c8:	08 95       	ret

000037ca <waterAlertOff>:
}

void waterAlertOff(void) {
	PORTE_DIR=0b00000001;
    37ca:	81 e0       	ldi	r24, 0x01	; 1
    37cc:	80 93 80 06 	sts	0x0680, r24
	PORTE_OUT=0b00000000;
    37d0:	10 92 84 06 	sts	0x0684, r1
    37d4:	08 95       	ret

000037d6 <waterAlertTask>:
    37d6:	00 e8       	ldi	r16, 0x80	; 128
    37d8:	16 e0       	ldi	r17, 0x06	; 6
    37da:	c0 e1       	ldi	r28, 0x10	; 16
    37dc:	f8 01       	movw	r30, r16
    37de:	c5 83       	std	Z+5, r28	; 0x05
}

static void waterAlertTask(void *pvParameters) {
	while(1) {
		gpio_set_pin_high(NHD_C12832A1Z_BACKLIGHT);
		if(waterUsage > maxWater && (isTap1Opened==1 || isTap2Opened==1 || isTap3Opened==1 || isTap4Opened==1)) {
    37e0:	20 91 46 24 	lds	r18, 0x2446
    37e4:	30 91 47 24 	lds	r19, 0x2447
    37e8:	80 91 44 24 	lds	r24, 0x2444
    37ec:	90 91 45 24 	lds	r25, 0x2445
    37f0:	82 17       	cp	r24, r18
    37f2:	93 07       	cpc	r25, r19
    37f4:	ec f4       	brge	.+58     	; 0x3830 <waterAlertTask+0x5a>
    37f6:	80 91 52 24 	lds	r24, 0x2452
    37fa:	90 91 53 24 	lds	r25, 0x2453
    37fe:	01 97       	sbiw	r24, 0x01	; 1
    3800:	91 f0       	breq	.+36     	; 0x3826 <waterAlertTask+0x50>
    3802:	80 91 50 24 	lds	r24, 0x2450
    3806:	90 91 51 24 	lds	r25, 0x2451
    380a:	01 97       	sbiw	r24, 0x01	; 1
    380c:	61 f0       	breq	.+24     	; 0x3826 <waterAlertTask+0x50>
    380e:	80 91 4e 24 	lds	r24, 0x244E
    3812:	90 91 4f 24 	lds	r25, 0x244F
    3816:	01 97       	sbiw	r24, 0x01	; 1
    3818:	31 f0       	breq	.+12     	; 0x3826 <waterAlertTask+0x50>
    381a:	80 91 4c 24 	lds	r24, 0x244C
    381e:	90 91 4d 24 	lds	r25, 0x244D
    3822:	01 97       	sbiw	r24, 0x01	; 1
    3824:	29 f4       	brne	.+10     	; 0x3830 <waterAlertTask+0x5a>
			waterAlertOn();
    3826:	cb df       	rcall	.-106    	; 0x37be <waterAlertOn>
			vTaskDelay(50);
    3828:	82 e3       	ldi	r24, 0x32	; 50
    382a:	90 e0       	ldi	r25, 0x00	; 0
    382c:	d3 db       	rcall	.-2138   	; 0x2fd4 <vTaskDelay>
			waterAlertOff();
    382e:	cd df       	rcall	.-102    	; 0x37ca <waterAlertOff>
		}
		vTaskDelay(10);
    3830:	8a e0       	ldi	r24, 0x0A	; 10
    3832:	90 e0       	ldi	r25, 0x00	; 0
    3834:	cf db       	rcall	.-2146   	; 0x2fd4 <vTaskDelay>
	}
    3836:	d2 cf       	rjmp	.-92     	; 0x37dc <waterAlertTask+0x6>

00003838 <clearLCD>:
	PORTE_DIR=0b00000001;
	PORTE_OUT=0b00000000;
}

void clearLCD(void){
	gfx_mono_draw_string("                    ",0,0,&sysfont);
    3838:	27 e0       	ldi	r18, 0x07	; 7
    383a:	30 e2       	ldi	r19, 0x20	; 32
    383c:	40 e0       	ldi	r20, 0x00	; 0
    383e:	60 e0       	ldi	r22, 0x00	; 0
    3840:	85 e1       	ldi	r24, 0x15	; 21
    3842:	90 e2       	ldi	r25, 0x20	; 32
    3844:	0c 94 f3 12 	jmp	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    3848:	08 95       	ret

0000384a <vReceiver>:
    384a:	80 e1       	ldi	r24, 0x10	; 16
    384c:	80 93 85 06 	sts	0x0685, r24
			} else if(cmd=='g') {
			
			clearLCD();
			gfx_mono_draw_string("Open Watering Tap",0,0,&sysfont);
			if (isAutoWatering==0) {
				isWateringTapOpened = 1;
    3850:	c1 e0       	ldi	r28, 0x01	; 1
    3852:	d0 e0       	ldi	r29, 0x00	; 0

static void vReceiver(void *pvParameters){
	gpio_set_pin_high(NHD_C12832A1Z_BACKLIGHT);
	while (1){
		
		char cmd = receiveChar();
    3854:	12 de       	rcall	.-988    	; 0x347a <receiveChar>
		
		if(cmd=='a'){
    3856:	81 36       	cpi	r24, 0x61	; 97
    3858:	f1 f4       	brne	.+60     	; 0x3896 <vReceiver+0x4c>
			if (isTap1Opened==0)
    385a:	80 91 52 24 	lds	r24, 0x2452
    385e:	90 91 53 24 	lds	r25, 0x2453
    3862:	89 2b       	or	r24, r25
    3864:	71 f4       	brne	.+28     	; 0x3882 <vReceiver+0x38>
			{
				clearLCD();
    3866:	e8 df       	rcall	.-48     	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Open Tap 1",0,0,&sysfont);
    3868:	27 e0       	ldi	r18, 0x07	; 7
    386a:	30 e2       	ldi	r19, 0x20	; 32
    386c:	40 e0       	ldi	r20, 0x00	; 0
    386e:	60 e0       	ldi	r22, 0x00	; 0
    3870:	8a e2       	ldi	r24, 0x2A	; 42
    3872:	90 e2       	ldi	r25, 0x20	; 32
    3874:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
				isTap1Opened = 1;
    3878:	c0 93 52 24 	sts	0x2452, r28
    387c:	d0 93 53 24 	sts	0x2453, r29
    3880:	5d c1       	rjmp	.+698    	; 0x3b3c <vReceiver+0x2f2>
			}
			else
			{
				clearLCD();
    3882:	da df       	rcall	.-76     	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Tap 1 had opened",0,0,&sysfont);
    3884:	27 e0       	ldi	r18, 0x07	; 7
    3886:	30 e2       	ldi	r19, 0x20	; 32
    3888:	40 e0       	ldi	r20, 0x00	; 0
    388a:	60 e0       	ldi	r22, 0x00	; 0
    388c:	85 e3       	ldi	r24, 0x35	; 53
    388e:	90 e2       	ldi	r25, 0x20	; 32
    3890:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    3894:	53 c1       	rjmp	.+678    	; 0x3b3c <vReceiver+0x2f2>
			}
			} else if(cmd=='1'){
    3896:	81 33       	cpi	r24, 0x31	; 49
    3898:	f1 f4       	brne	.+60     	; 0x38d6 <vReceiver+0x8c>
			if (isTap1Opened==1)
    389a:	80 91 52 24 	lds	r24, 0x2452
    389e:	90 91 53 24 	lds	r25, 0x2453
    38a2:	01 97       	sbiw	r24, 0x01	; 1
    38a4:	71 f4       	brne	.+28     	; 0x38c2 <vReceiver+0x78>
			{
				clearLCD();
    38a6:	c8 df       	rcall	.-112    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Close Tap 1",0,0,&sysfont);
    38a8:	27 e0       	ldi	r18, 0x07	; 7
    38aa:	30 e2       	ldi	r19, 0x20	; 32
    38ac:	40 e0       	ldi	r20, 0x00	; 0
    38ae:	60 e0       	ldi	r22, 0x00	; 0
    38b0:	86 e4       	ldi	r24, 0x46	; 70
    38b2:	90 e2       	ldi	r25, 0x20	; 32
    38b4:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
				isTap1Opened = 0;
    38b8:	10 92 52 24 	sts	0x2452, r1
    38bc:	10 92 53 24 	sts	0x2453, r1
    38c0:	3d c1       	rjmp	.+634    	; 0x3b3c <vReceiver+0x2f2>
			}
			else
			{
				clearLCD();
    38c2:	ba df       	rcall	.-140    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Tap 1 had closed",0,0,&sysfont);
    38c4:	27 e0       	ldi	r18, 0x07	; 7
    38c6:	30 e2       	ldi	r19, 0x20	; 32
    38c8:	40 e0       	ldi	r20, 0x00	; 0
    38ca:	60 e0       	ldi	r22, 0x00	; 0
    38cc:	82 e5       	ldi	r24, 0x52	; 82
    38ce:	90 e2       	ldi	r25, 0x20	; 32
    38d0:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    38d4:	33 c1       	rjmp	.+614    	; 0x3b3c <vReceiver+0x2f2>
			}
			} else if(cmd=='b'){
    38d6:	82 36       	cpi	r24, 0x62	; 98
    38d8:	f1 f4       	brne	.+60     	; 0x3916 <vReceiver+0xcc>
			if (isTap2Opened==0)
    38da:	80 91 50 24 	lds	r24, 0x2450
    38de:	90 91 51 24 	lds	r25, 0x2451
    38e2:	89 2b       	or	r24, r25
    38e4:	71 f4       	brne	.+28     	; 0x3902 <vReceiver+0xb8>
			{
				clearLCD();
    38e6:	a8 df       	rcall	.-176    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Open Tap 2",0,0,&sysfont);
    38e8:	27 e0       	ldi	r18, 0x07	; 7
    38ea:	30 e2       	ldi	r19, 0x20	; 32
    38ec:	40 e0       	ldi	r20, 0x00	; 0
    38ee:	60 e0       	ldi	r22, 0x00	; 0
    38f0:	83 e6       	ldi	r24, 0x63	; 99
    38f2:	90 e2       	ldi	r25, 0x20	; 32
    38f4:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
				isTap2Opened = 1;
    38f8:	c0 93 50 24 	sts	0x2450, r28
    38fc:	d0 93 51 24 	sts	0x2451, r29
    3900:	1d c1       	rjmp	.+570    	; 0x3b3c <vReceiver+0x2f2>
			}
			else
			{
				clearLCD();
    3902:	9a df       	rcall	.-204    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Tap 2 had opened",0,0,&sysfont);
    3904:	27 e0       	ldi	r18, 0x07	; 7
    3906:	30 e2       	ldi	r19, 0x20	; 32
    3908:	40 e0       	ldi	r20, 0x00	; 0
    390a:	60 e0       	ldi	r22, 0x00	; 0
    390c:	8e e6       	ldi	r24, 0x6E	; 110
    390e:	90 e2       	ldi	r25, 0x20	; 32
    3910:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    3914:	13 c1       	rjmp	.+550    	; 0x3b3c <vReceiver+0x2f2>
			}
			} else if(cmd=='2'){
    3916:	82 33       	cpi	r24, 0x32	; 50
    3918:	f1 f4       	brne	.+60     	; 0x3956 <vReceiver+0x10c>
			if (isTap2Opened==1)
    391a:	80 91 50 24 	lds	r24, 0x2450
    391e:	90 91 51 24 	lds	r25, 0x2451
    3922:	01 97       	sbiw	r24, 0x01	; 1
    3924:	71 f4       	brne	.+28     	; 0x3942 <vReceiver+0xf8>
			{
				clearLCD();
    3926:	88 df       	rcall	.-240    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Close Tap 2",0,0,&sysfont);
    3928:	27 e0       	ldi	r18, 0x07	; 7
    392a:	30 e2       	ldi	r19, 0x20	; 32
    392c:	40 e0       	ldi	r20, 0x00	; 0
    392e:	60 e0       	ldi	r22, 0x00	; 0
    3930:	8f e7       	ldi	r24, 0x7F	; 127
    3932:	90 e2       	ldi	r25, 0x20	; 32
    3934:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
				isTap2Opened = 0;
    3938:	10 92 50 24 	sts	0x2450, r1
    393c:	10 92 51 24 	sts	0x2451, r1
    3940:	fd c0       	rjmp	.+506    	; 0x3b3c <vReceiver+0x2f2>
			}
			else
			{
				clearLCD();
    3942:	7a df       	rcall	.-268    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Tap 2 had closed",0,0,&sysfont);
    3944:	27 e0       	ldi	r18, 0x07	; 7
    3946:	30 e2       	ldi	r19, 0x20	; 32
    3948:	40 e0       	ldi	r20, 0x00	; 0
    394a:	60 e0       	ldi	r22, 0x00	; 0
    394c:	8b e8       	ldi	r24, 0x8B	; 139
    394e:	90 e2       	ldi	r25, 0x20	; 32
    3950:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    3954:	f3 c0       	rjmp	.+486    	; 0x3b3c <vReceiver+0x2f2>
			}
			} else if(cmd=='c'){
    3956:	83 36       	cpi	r24, 0x63	; 99
    3958:	f1 f4       	brne	.+60     	; 0x3996 <vReceiver+0x14c>
			if (isTap3Opened==0)
    395a:	80 91 4e 24 	lds	r24, 0x244E
    395e:	90 91 4f 24 	lds	r25, 0x244F
    3962:	89 2b       	or	r24, r25
    3964:	71 f4       	brne	.+28     	; 0x3982 <vReceiver+0x138>
			{
				clearLCD();
    3966:	68 df       	rcall	.-304    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Open Tap 3",0,0,&sysfont);
    3968:	27 e0       	ldi	r18, 0x07	; 7
    396a:	30 e2       	ldi	r19, 0x20	; 32
    396c:	40 e0       	ldi	r20, 0x00	; 0
    396e:	60 e0       	ldi	r22, 0x00	; 0
    3970:	8c e9       	ldi	r24, 0x9C	; 156
    3972:	90 e2       	ldi	r25, 0x20	; 32
    3974:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
				isTap3Opened = 1;
    3978:	c0 93 4e 24 	sts	0x244E, r28
    397c:	d0 93 4f 24 	sts	0x244F, r29
    3980:	dd c0       	rjmp	.+442    	; 0x3b3c <vReceiver+0x2f2>
			}
			else
			{
				clearLCD();
    3982:	5a df       	rcall	.-332    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Tap 3 had opened",0,0,&sysfont);
    3984:	27 e0       	ldi	r18, 0x07	; 7
    3986:	30 e2       	ldi	r19, 0x20	; 32
    3988:	40 e0       	ldi	r20, 0x00	; 0
    398a:	60 e0       	ldi	r22, 0x00	; 0
    398c:	87 ea       	ldi	r24, 0xA7	; 167
    398e:	90 e2       	ldi	r25, 0x20	; 32
    3990:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    3994:	d3 c0       	rjmp	.+422    	; 0x3b3c <vReceiver+0x2f2>
			}
			} else if(cmd=='3'){
    3996:	83 33       	cpi	r24, 0x33	; 51
    3998:	f1 f4       	brne	.+60     	; 0x39d6 <vReceiver+0x18c>
			if (isTap1Opened==1)
    399a:	80 91 52 24 	lds	r24, 0x2452
    399e:	90 91 53 24 	lds	r25, 0x2453
    39a2:	01 97       	sbiw	r24, 0x01	; 1
    39a4:	71 f4       	brne	.+28     	; 0x39c2 <vReceiver+0x178>
			{
				clearLCD();
    39a6:	48 df       	rcall	.-368    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Close Tap 3",0,0,&sysfont);
    39a8:	27 e0       	ldi	r18, 0x07	; 7
    39aa:	30 e2       	ldi	r19, 0x20	; 32
    39ac:	40 e0       	ldi	r20, 0x00	; 0
    39ae:	60 e0       	ldi	r22, 0x00	; 0
    39b0:	88 eb       	ldi	r24, 0xB8	; 184
    39b2:	90 e2       	ldi	r25, 0x20	; 32
    39b4:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
				isTap3Opened = 0;
    39b8:	10 92 4e 24 	sts	0x244E, r1
    39bc:	10 92 4f 24 	sts	0x244F, r1
    39c0:	bd c0       	rjmp	.+378    	; 0x3b3c <vReceiver+0x2f2>
			}
			else
			{
				clearLCD();
    39c2:	3a df       	rcall	.-396    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Tap 3 had closed",0,0,&sysfont);
    39c4:	27 e0       	ldi	r18, 0x07	; 7
    39c6:	30 e2       	ldi	r19, 0x20	; 32
    39c8:	40 e0       	ldi	r20, 0x00	; 0
    39ca:	60 e0       	ldi	r22, 0x00	; 0
    39cc:	84 ec       	ldi	r24, 0xC4	; 196
    39ce:	90 e2       	ldi	r25, 0x20	; 32
    39d0:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    39d4:	b3 c0       	rjmp	.+358    	; 0x3b3c <vReceiver+0x2f2>
			}
			} else if(cmd=='d'){
    39d6:	84 36       	cpi	r24, 0x64	; 100
    39d8:	f1 f4       	brne	.+60     	; 0x3a16 <vReceiver+0x1cc>
			if (isTap4Opened==0)
    39da:	80 91 4c 24 	lds	r24, 0x244C
    39de:	90 91 4d 24 	lds	r25, 0x244D
    39e2:	89 2b       	or	r24, r25
    39e4:	71 f4       	brne	.+28     	; 0x3a02 <vReceiver+0x1b8>
			{
				clearLCD();
    39e6:	28 df       	rcall	.-432    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Open Tap 4",0,0,&sysfont);
    39e8:	27 e0       	ldi	r18, 0x07	; 7
    39ea:	30 e2       	ldi	r19, 0x20	; 32
    39ec:	40 e0       	ldi	r20, 0x00	; 0
    39ee:	60 e0       	ldi	r22, 0x00	; 0
    39f0:	85 ed       	ldi	r24, 0xD5	; 213
    39f2:	90 e2       	ldi	r25, 0x20	; 32
    39f4:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
				isTap4Opened = 1;
    39f8:	c0 93 4c 24 	sts	0x244C, r28
    39fc:	d0 93 4d 24 	sts	0x244D, r29
    3a00:	9d c0       	rjmp	.+314    	; 0x3b3c <vReceiver+0x2f2>
			}
			else
			{
				clearLCD();
    3a02:	1a df       	rcall	.-460    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Tap 4 had opened",0,0,&sysfont);
    3a04:	27 e0       	ldi	r18, 0x07	; 7
    3a06:	30 e2       	ldi	r19, 0x20	; 32
    3a08:	40 e0       	ldi	r20, 0x00	; 0
    3a0a:	60 e0       	ldi	r22, 0x00	; 0
    3a0c:	80 ee       	ldi	r24, 0xE0	; 224
    3a0e:	90 e2       	ldi	r25, 0x20	; 32
    3a10:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    3a14:	93 c0       	rjmp	.+294    	; 0x3b3c <vReceiver+0x2f2>
			}
			} else if(cmd=='4'){
    3a16:	84 33       	cpi	r24, 0x34	; 52
    3a18:	f1 f4       	brne	.+60     	; 0x3a56 <vReceiver+0x20c>
			if (isTap4Opened==1)
    3a1a:	80 91 4c 24 	lds	r24, 0x244C
    3a1e:	90 91 4d 24 	lds	r25, 0x244D
    3a22:	01 97       	sbiw	r24, 0x01	; 1
    3a24:	71 f4       	brne	.+28     	; 0x3a42 <vReceiver+0x1f8>
			{
				clearLCD();
    3a26:	08 df       	rcall	.-496    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Close Tap 4",0,0,&sysfont);
    3a28:	27 e0       	ldi	r18, 0x07	; 7
    3a2a:	30 e2       	ldi	r19, 0x20	; 32
    3a2c:	40 e0       	ldi	r20, 0x00	; 0
    3a2e:	60 e0       	ldi	r22, 0x00	; 0
    3a30:	81 ef       	ldi	r24, 0xF1	; 241
    3a32:	90 e2       	ldi	r25, 0x20	; 32
    3a34:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
				isTap4Opened = 0;
    3a38:	10 92 4c 24 	sts	0x244C, r1
    3a3c:	10 92 4d 24 	sts	0x244D, r1
    3a40:	7d c0       	rjmp	.+250    	; 0x3b3c <vReceiver+0x2f2>
			}
			else
			{
				clearLCD();
    3a42:	fa de       	rcall	.-524    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Tap 4 had closed",0,0,&sysfont);
    3a44:	27 e0       	ldi	r18, 0x07	; 7
    3a46:	30 e2       	ldi	r19, 0x20	; 32
    3a48:	40 e0       	ldi	r20, 0x00	; 0
    3a4a:	60 e0       	ldi	r22, 0x00	; 0
    3a4c:	8d ef       	ldi	r24, 0xFD	; 253
    3a4e:	90 e2       	ldi	r25, 0x20	; 32
    3a50:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    3a54:	73 c0       	rjmp	.+230    	; 0x3b3c <vReceiver+0x2f2>
			}
			} else if(cmd=='e') {
    3a56:	85 36       	cpi	r24, 0x65	; 101
    3a58:	51 f4       	brne	.+20     	; 0x3a6e <vReceiver+0x224>
			
			clearLCD();
    3a5a:	ee de       	rcall	.-548    	; 0x3838 <clearLCD>
			gfx_mono_draw_string("Water Discharge",0,0,&sysfont);
    3a5c:	27 e0       	ldi	r18, 0x07	; 7
    3a5e:	30 e2       	ldi	r19, 0x20	; 32
    3a60:	40 e0       	ldi	r20, 0x00	; 0
    3a62:	60 e0       	ldi	r22, 0x00	; 0
    3a64:	8e e0       	ldi	r24, 0x0E	; 14
    3a66:	91 e2       	ldi	r25, 0x21	; 33
    3a68:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    3a6c:	67 c0       	rjmp	.+206    	; 0x3b3c <vReceiver+0x2f2>
			
			} else if(cmd=='5') {
    3a6e:	85 33       	cpi	r24, 0x35	; 53
    3a70:	51 f4       	brne	.+20     	; 0x3a86 <vReceiver+0x23c>
			
			clearLCD();
    3a72:	e2 de       	rcall	.-572    	; 0x3838 <clearLCD>
			gfx_mono_draw_string("Water Discharge",0,0,&sysfont);
    3a74:	27 e0       	ldi	r18, 0x07	; 7
    3a76:	30 e2       	ldi	r19, 0x20	; 32
    3a78:	40 e0       	ldi	r20, 0x00	; 0
    3a7a:	60 e0       	ldi	r22, 0x00	; 0
    3a7c:	8e e0       	ldi	r24, 0x0E	; 14
    3a7e:	91 e2       	ldi	r25, 0x21	; 33
    3a80:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    3a84:	5b c0       	rjmp	.+182    	; 0x3b3c <vReceiver+0x2f2>
			
			} else if(cmd=='f') {
    3a86:	86 36       	cpi	r24, 0x66	; 102
    3a88:	71 f4       	brne	.+28     	; 0x3aa6 <vReceiver+0x25c>
			
			clearLCD();
    3a8a:	d6 de       	rcall	.-596    	; 0x3838 <clearLCD>
			gfx_mono_draw_string("Manual Watering",0,0,&sysfont);
    3a8c:	27 e0       	ldi	r18, 0x07	; 7
    3a8e:	30 e2       	ldi	r19, 0x20	; 32
    3a90:	40 e0       	ldi	r20, 0x00	; 0
    3a92:	60 e0       	ldi	r22, 0x00	; 0
    3a94:	8e e1       	ldi	r24, 0x1E	; 30
    3a96:	91 e2       	ldi	r25, 0x21	; 33
    3a98:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
			isAutoWatering = 0;
    3a9c:	10 92 3e 24 	sts	0x243E, r1
    3aa0:	10 92 3f 24 	sts	0x243F, r1
    3aa4:	4b c0       	rjmp	.+150    	; 0x3b3c <vReceiver+0x2f2>
			
			} else if(cmd=='6') {
    3aa6:	86 33       	cpi	r24, 0x36	; 54
    3aa8:	71 f4       	brne	.+28     	; 0x3ac6 <vReceiver+0x27c>
			
			clearLCD();
    3aaa:	c6 de       	rcall	.-628    	; 0x3838 <clearLCD>
			gfx_mono_draw_string("Auto Watering",0,0,&sysfont);
    3aac:	27 e0       	ldi	r18, 0x07	; 7
    3aae:	30 e2       	ldi	r19, 0x20	; 32
    3ab0:	40 e0       	ldi	r20, 0x00	; 0
    3ab2:	60 e0       	ldi	r22, 0x00	; 0
    3ab4:	8e e2       	ldi	r24, 0x2E	; 46
    3ab6:	91 e2       	ldi	r25, 0x21	; 33
    3ab8:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
			isAutoWatering = 1;
    3abc:	c0 93 3e 24 	sts	0x243E, r28
    3ac0:	d0 93 3f 24 	sts	0x243F, r29
    3ac4:	3b c0       	rjmp	.+118    	; 0x3b3c <vReceiver+0x2f2>
			
			} else if(cmd=='g') {
    3ac6:	87 36       	cpi	r24, 0x67	; 103
    3ac8:	f1 f4       	brne	.+60     	; 0x3b06 <vReceiver+0x2bc>
			
			clearLCD();
    3aca:	b6 de       	rcall	.-660    	; 0x3838 <clearLCD>
			gfx_mono_draw_string("Open Watering Tap",0,0,&sysfont);
    3acc:	27 e0       	ldi	r18, 0x07	; 7
    3ace:	30 e2       	ldi	r19, 0x20	; 32
    3ad0:	40 e0       	ldi	r20, 0x00	; 0
    3ad2:	60 e0       	ldi	r22, 0x00	; 0
    3ad4:	8c e3       	ldi	r24, 0x3C	; 60
    3ad6:	91 e2       	ldi	r25, 0x21	; 33
    3ad8:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
			if (isAutoWatering==0) {
    3adc:	80 91 3e 24 	lds	r24, 0x243E
    3ae0:	90 91 3f 24 	lds	r25, 0x243F
    3ae4:	89 2b       	or	r24, r25
    3ae6:	29 f4       	brne	.+10     	; 0x3af2 <vReceiver+0x2a8>
				isWateringTapOpened = 1;
    3ae8:	c0 93 4a 24 	sts	0x244A, r28
    3aec:	d0 93 4b 24 	sts	0x244B, r29
    3af0:	25 c0       	rjmp	.+74     	; 0x3b3c <vReceiver+0x2f2>
				} else {
				clearLCD();
    3af2:	a2 de       	rcall	.-700    	; 0x3838 <clearLCD>
				gfx_mono_draw_string("Auto Watering Mode ON",0,0,&sysfont);
    3af4:	27 e0       	ldi	r18, 0x07	; 7
    3af6:	30 e2       	ldi	r19, 0x20	; 32
    3af8:	40 e0       	ldi	r20, 0x00	; 0
    3afa:	60 e0       	ldi	r22, 0x00	; 0
    3afc:	8e e4       	ldi	r24, 0x4E	; 78
    3afe:	91 e2       	ldi	r25, 0x21	; 33
    3b00:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
    3b04:	1b c0       	rjmp	.+54     	; 0x3b3c <vReceiver+0x2f2>
			}
			
			} else if(cmd=='7') {
    3b06:	87 33       	cpi	r24, 0x37	; 55
    3b08:	71 f4       	brne	.+28     	; 0x3b26 <vReceiver+0x2dc>
			
			clearLCD();
    3b0a:	96 de       	rcall	.-724    	; 0x3838 <clearLCD>
			gfx_mono_draw_string("Close Watering Tap",0,0,&sysfont);
    3b0c:	27 e0       	ldi	r18, 0x07	; 7
    3b0e:	30 e2       	ldi	r19, 0x20	; 32
    3b10:	40 e0       	ldi	r20, 0x00	; 0
    3b12:	60 e0       	ldi	r22, 0x00	; 0
    3b14:	84 e6       	ldi	r24, 0x64	; 100
    3b16:	91 e2       	ldi	r25, 0x21	; 33
    3b18:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
			isWateringTapOpened = 0;
    3b1c:	10 92 4a 24 	sts	0x244A, r1
    3b20:	10 92 4b 24 	sts	0x244B, r1
    3b24:	0b c0       	rjmp	.+22     	; 0x3b3c <vReceiver+0x2f2>
			
			} else if(cmd=='p') {
    3b26:	80 37       	cpi	r24, 0x70	; 112
    3b28:	49 f4       	brne	.+18     	; 0x3b3c <vReceiver+0x2f2>
			
			sendChar('p');
    3b2a:	9f dc       	rcall	.-1730   	; 0x346a <sendChar>
			gfx_mono_draw_string("Send PING",0,0,&sysfont);
    3b2c:	27 e0       	ldi	r18, 0x07	; 7
    3b2e:	30 e2       	ldi	r19, 0x20	; 32
    3b30:	40 e0       	ldi	r20, 0x00	; 0
    3b32:	60 e0       	ldi	r22, 0x00	; 0
    3b34:	87 e7       	ldi	r24, 0x77	; 119
    3b36:	91 e2       	ldi	r25, 0x21	; 33
    3b38:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <gfx_mono_draw_string>
			
		}
		vTaskDelay(1);
    3b3c:	ce 01       	movw	r24, r28
    3b3e:	4a da       	rcall	.-2924   	; 0x2fd4 <vTaskDelay>
		
	}
    3b40:	89 ce       	rjmp	.-750    	; 0x3854 <vReceiver+0xa>

00003b42 <main>:
	gfx_mono_draw_string("                    ",0,0,&sysfont);
}


int main (void)
{
    3b42:	af 92       	push	r10
    3b44:	bf 92       	push	r11
    3b46:	cf 92       	push	r12
    3b48:	df 92       	push	r13
    3b4a:	ef 92       	push	r14
    3b4c:	ff 92       	push	r15
    3b4e:	0f 93       	push	r16
	board_init(); //konfigurasi awal board
    3b50:	71 db       	rcall	.-2334   	; 0x3234 <board_init>
	//sysclk_init(); //konfigurasi awal system clock
	adc_sensors_init();// konfigurasi adc
    3b52:	0e 94 58 08 	call	0x10b0	; 0x10b0 <adc_sensors_init>
	gfx_mono_init(); //konfigurasi awal LCD monochrom
    3b56:	0e 94 22 0b 	call	0x1644	; 0x1644 <gfx_mono_st7565r_init>
	tb_init(); //konfigurasi touch button
    3b5a:	0e 94 a4 0b 	call	0x1748	; 0x1748 <tb_init>
	cpu_irq_enable(); // konfigurasi untuk menghidupkan interrupt
    3b5e:	78 94       	sei
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    3b60:	87 e0       	ldi	r24, 0x07	; 7
    3b62:	80 93 a2 00 	sts	0x00A2, r24
	pmic_init(); //konfigurasi untuk menyalakan semua interrupt dan mengatur prioritas task
	//pwm_init();
	adc_init();
    3b66:	3a dc       	rcall	.-1932   	; 0x33dc <adc_init>
    3b68:	80 e1       	ldi	r24, 0x10	; 16
    3b6a:	80 93 85 06 	sts	0x0685, r24
	
	gpio_set_pin_high(NHD_C12832A1Z_BACKLIGHT);
	
	PORTC_OUTSET = PIN3_bm;
    3b6e:	88 e0       	ldi	r24, 0x08	; 8
    3b70:	80 93 45 06 	sts	0x0645, r24
	PORTC_DIRSET = PIN3_bm;
    3b74:	80 93 41 06 	sts	0x0641, r24
	
	PORTC_OUTCLR = PIN2_bm;
    3b78:	84 e0       	ldi	r24, 0x04	; 4
    3b7a:	80 93 46 06 	sts	0x0646, r24
	PORTC_DIRCLR = PIN2_bm;
    3b7e:	80 93 42 06 	sts	0x0642, r24
	
	setUpSerial();
    3b82:	65 dc       	rcall	.-1846   	; 0x344e <setUpSerial>
	
	getWaterUsageFromEEPROM();
    3b84:	82 dc       	rcall	.-1788   	; 0x348a <getWaterUsageFromEEPROM>
	}
	waterUsage = nvm_eeprom_read_byte(index);
}

void setMaxWater(int max) {
	maxWater = max;
    3b86:	88 e8       	ldi	r24, 0x88	; 136
    3b88:	93 e1       	ldi	r25, 0x13	; 19
    3b8a:	80 93 44 24 	sts	0x2444, r24
    3b8e:	90 93 45 24 	sts	0x2445, r25
	
	setUpSerial();
	
	getWaterUsageFromEEPROM();
	setMaxWater(5000);
	setRainTankVolume(2550);
    3b92:	86 ef       	ldi	r24, 0xF6	; 246
    3b94:	99 e0       	ldi	r25, 0x09	; 9
    3b96:	90 dc       	rcall	.-1760   	; 0x34b8 <setRainTankVolume>
	
	xTaskCreate(vReceiver, "", 200, NULL, 1, NULL);				// task to receive command
    3b98:	a1 2c       	mov	r10, r1
    3b9a:	b1 2c       	mov	r11, r1
    3b9c:	c1 2c       	mov	r12, r1
    3b9e:	d1 2c       	mov	r13, r1
    3ba0:	e1 2c       	mov	r14, r1
    3ba2:	f1 2c       	mov	r15, r1
    3ba4:	01 e0       	ldi	r16, 0x01	; 1
    3ba6:	20 e0       	ldi	r18, 0x00	; 0
    3ba8:	30 e0       	ldi	r19, 0x00	; 0
    3baa:	48 ec       	ldi	r20, 0xC8	; 200
    3bac:	50 e0       	ldi	r21, 0x00	; 0
    3bae:	69 e2       	ldi	r22, 0x29	; 41
    3bb0:	70 e2       	ldi	r23, 0x20	; 32
    3bb2:	85 e2       	ldi	r24, 0x25	; 37
    3bb4:	9c e1       	ldi	r25, 0x1C	; 28
    3bb6:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <xTaskGenericCreate>
	xTaskCreate(openCloseTap, "", 200, NULL, 1, NULL);			// task to OPEN or CLOSE tap based on isTapXOpened (X= {1, 2, 3, 4, WateringTank})
    3bba:	20 e0       	ldi	r18, 0x00	; 0
    3bbc:	30 e0       	ldi	r19, 0x00	; 0
    3bbe:	48 ec       	ldi	r20, 0xC8	; 200
    3bc0:	50 e0       	ldi	r21, 0x00	; 0
    3bc2:	69 e2       	ldi	r22, 0x29	; 41
    3bc4:	70 e2       	ldi	r23, 0x20	; 32
    3bc6:	85 e8       	ldi	r24, 0x85	; 133
    3bc8:	9b e1       	ldi	r25, 0x1B	; 27
    3bca:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <xTaskGenericCreate>
	xTaskCreate(checkTap, "", 200, NULL, 1, NULL);				// task to ON or OFF LED (indicator of tap is OPENED or CLOSED)
    3bce:	20 e0       	ldi	r18, 0x00	; 0
    3bd0:	30 e0       	ldi	r19, 0x00	; 0
    3bd2:	48 ec       	ldi	r20, 0xC8	; 200
    3bd4:	50 e0       	ldi	r21, 0x00	; 0
    3bd6:	69 e2       	ldi	r22, 0x29	; 41
    3bd8:	70 e2       	ldi	r23, 0x20	; 32
    3bda:	89 e6       	ldi	r24, 0x69	; 105
    3bdc:	99 e1       	ldi	r25, 0x19	; 25
    3bde:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <xTaskGenericCreate>
	xTaskCreate(watering, "", 200, NULL, 1, NULL);				// watering from rain tank triggered by isAutoWatering
    3be2:	20 e0       	ldi	r18, 0x00	; 0
    3be4:	30 e0       	ldi	r19, 0x00	; 0
    3be6:	48 ec       	ldi	r20, 0xC8	; 200
    3be8:	50 e0       	ldi	r21, 0x00	; 0
    3bea:	69 e2       	ldi	r22, 0x29	; 41
    3bec:	70 e2       	ldi	r23, 0x20	; 32
    3bee:	8d e8       	ldi	r24, 0x8D	; 141
    3bf0:	9a e1       	ldi	r25, 0x1A	; 26
    3bf2:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <xTaskGenericCreate>
	xTaskCreate(checkLight, "", 200, NULL, 1, NULL);			// light intensity 
    3bf6:	20 e0       	ldi	r18, 0x00	; 0
    3bf8:	30 e0       	ldi	r19, 0x00	; 0
    3bfa:	48 ec       	ldi	r20, 0xC8	; 200
    3bfc:	50 e0       	ldi	r21, 0x00	; 0
    3bfe:	69 e2       	ldi	r22, 0x29	; 41
    3c00:	70 e2       	ldi	r23, 0x20	; 32
    3c02:	88 ed       	ldi	r24, 0xD8	; 216
    3c04:	99 e1       	ldi	r25, 0x19	; 25
    3c06:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <xTaskGenericCreate>
	xTaskCreate(countWaterUsage, "", 400, NULL, 1, NULL);		// triggered when isTapXOpened=1, X = {1, 2, 3, 4}
    3c0a:	20 e0       	ldi	r18, 0x00	; 0
    3c0c:	30 e0       	ldi	r19, 0x00	; 0
    3c0e:	40 e9       	ldi	r20, 0x90	; 144
    3c10:	51 e0       	ldi	r21, 0x01	; 1
    3c12:	69 e2       	ldi	r22, 0x29	; 41
    3c14:	70 e2       	ldi	r23, 0x20	; 32
    3c16:	87 e1       	ldi	r24, 0x17	; 23
    3c18:	9b e1       	ldi	r25, 0x1B	; 27
    3c1a:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <xTaskGenericCreate>
	xTaskCreate(setWaterDebit, "", 200, NULL, 1, NULL);			// set debit from potensiometer
    3c1e:	20 e0       	ldi	r18, 0x00	; 0
    3c20:	30 e0       	ldi	r19, 0x00	; 0
    3c22:	48 ec       	ldi	r20, 0xC8	; 200
    3c24:	50 e0       	ldi	r21, 0x00	; 0
    3c26:	69 e2       	ldi	r22, 0x29	; 41
    3c28:	70 e2       	ldi	r23, 0x20	; 32
    3c2a:	8f ea       	ldi	r24, 0xAF	; 175
    3c2c:	99 e1       	ldi	r25, 0x19	; 25
    3c2e:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <xTaskGenericCreate>
	xTaskCreate(waterAlertTask, "", 400, NULL, 1, NULL);		// alert when water usage more than maxwater		
    3c32:	20 e0       	ldi	r18, 0x00	; 0
    3c34:	30 e0       	ldi	r19, 0x00	; 0
    3c36:	40 e9       	ldi	r20, 0x90	; 144
    3c38:	51 e0       	ldi	r21, 0x01	; 1
    3c3a:	69 e2       	ldi	r22, 0x29	; 41
    3c3c:	70 e2       	ldi	r23, 0x20	; 32
    3c3e:	8b ee       	ldi	r24, 0xEB	; 235
    3c40:	9b e1       	ldi	r25, 0x1B	; 27
    3c42:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <xTaskGenericCreate>
	
	vTaskStartScheduler();
    3c46:	47 d8       	rcall	.-3954   	; 0x2cd6 <vTaskStartScheduler>
    3c48:	80 e0       	ldi	r24, 0x00	; 0
    3c4a:	90 e0       	ldi	r25, 0x00	; 0
    3c4c:	0f 91       	pop	r16
    3c4e:	ff 90       	pop	r15
    3c50:	ef 90       	pop	r14
    3c52:	df 90       	pop	r13
    3c54:	cf 90       	pop	r12
    3c56:	bf 90       	pop	r11
    3c58:	af 90       	pop	r10
    3c5a:	08 95       	ret

00003c5c <__divmodhi4>:
    3c5c:	97 fb       	bst	r25, 7
    3c5e:	07 2e       	mov	r0, r23
    3c60:	16 f4       	brtc	.+4      	; 0x3c66 <__divmodhi4+0xa>
    3c62:	00 94       	com	r0
    3c64:	06 d0       	rcall	.+12     	; 0x3c72 <__divmodhi4_neg1>
    3c66:	77 fd       	sbrc	r23, 7
    3c68:	08 d0       	rcall	.+16     	; 0x3c7a <__divmodhi4_neg2>
    3c6a:	6d d0       	rcall	.+218    	; 0x3d46 <__udivmodhi4>
    3c6c:	07 fc       	sbrc	r0, 7
    3c6e:	05 d0       	rcall	.+10     	; 0x3c7a <__divmodhi4_neg2>
    3c70:	3e f4       	brtc	.+14     	; 0x3c80 <__divmodhi4_exit>

00003c72 <__divmodhi4_neg1>:
    3c72:	90 95       	com	r25
    3c74:	81 95       	neg	r24
    3c76:	9f 4f       	sbci	r25, 0xFF	; 255
    3c78:	08 95       	ret

00003c7a <__divmodhi4_neg2>:
    3c7a:	70 95       	com	r23
    3c7c:	61 95       	neg	r22
    3c7e:	7f 4f       	sbci	r23, 0xFF	; 255

00003c80 <__divmodhi4_exit>:
    3c80:	08 95       	ret

00003c82 <__udivmodsi4>:
    3c82:	a1 e2       	ldi	r26, 0x21	; 33
    3c84:	1a 2e       	mov	r1, r26
    3c86:	aa 1b       	sub	r26, r26
    3c88:	bb 1b       	sub	r27, r27
    3c8a:	fd 01       	movw	r30, r26
    3c8c:	0d c0       	rjmp	.+26     	; 0x3ca8 <__udivmodsi4_ep>

00003c8e <__udivmodsi4_loop>:
    3c8e:	aa 1f       	adc	r26, r26
    3c90:	bb 1f       	adc	r27, r27
    3c92:	ee 1f       	adc	r30, r30
    3c94:	ff 1f       	adc	r31, r31
    3c96:	a2 17       	cp	r26, r18
    3c98:	b3 07       	cpc	r27, r19
    3c9a:	e4 07       	cpc	r30, r20
    3c9c:	f5 07       	cpc	r31, r21
    3c9e:	20 f0       	brcs	.+8      	; 0x3ca8 <__udivmodsi4_ep>
    3ca0:	a2 1b       	sub	r26, r18
    3ca2:	b3 0b       	sbc	r27, r19
    3ca4:	e4 0b       	sbc	r30, r20
    3ca6:	f5 0b       	sbc	r31, r21

00003ca8 <__udivmodsi4_ep>:
    3ca8:	66 1f       	adc	r22, r22
    3caa:	77 1f       	adc	r23, r23
    3cac:	88 1f       	adc	r24, r24
    3cae:	99 1f       	adc	r25, r25
    3cb0:	1a 94       	dec	r1
    3cb2:	69 f7       	brne	.-38     	; 0x3c8e <__udivmodsi4_loop>
    3cb4:	60 95       	com	r22
    3cb6:	70 95       	com	r23
    3cb8:	80 95       	com	r24
    3cba:	90 95       	com	r25
    3cbc:	9b 01       	movw	r18, r22
    3cbe:	ac 01       	movw	r20, r24
    3cc0:	bd 01       	movw	r22, r26
    3cc2:	cf 01       	movw	r24, r30
    3cc4:	08 95       	ret

00003cc6 <__umulhisi3>:
    3cc6:	a2 9f       	mul	r26, r18
    3cc8:	b0 01       	movw	r22, r0
    3cca:	b3 9f       	mul	r27, r19
    3ccc:	c0 01       	movw	r24, r0
    3cce:	a3 9f       	mul	r26, r19
    3cd0:	70 0d       	add	r23, r0
    3cd2:	81 1d       	adc	r24, r1
    3cd4:	11 24       	eor	r1, r1
    3cd6:	91 1d       	adc	r25, r1
    3cd8:	b2 9f       	mul	r27, r18
    3cda:	70 0d       	add	r23, r0
    3cdc:	81 1d       	adc	r24, r1
    3cde:	11 24       	eor	r1, r1
    3ce0:	91 1d       	adc	r25, r1
    3ce2:	08 95       	ret

00003ce4 <__prologue_saves__>:
    3ce4:	2f 92       	push	r2
    3ce6:	3f 92       	push	r3
    3ce8:	4f 92       	push	r4
    3cea:	5f 92       	push	r5
    3cec:	6f 92       	push	r6
    3cee:	7f 92       	push	r7
    3cf0:	8f 92       	push	r8
    3cf2:	9f 92       	push	r9
    3cf4:	af 92       	push	r10
    3cf6:	bf 92       	push	r11
    3cf8:	cf 92       	push	r12
    3cfa:	df 92       	push	r13
    3cfc:	ef 92       	push	r14
    3cfe:	ff 92       	push	r15
    3d00:	0f 93       	push	r16
    3d02:	1f 93       	push	r17
    3d04:	cf 93       	push	r28
    3d06:	df 93       	push	r29
    3d08:	cd b7       	in	r28, 0x3d	; 61
    3d0a:	de b7       	in	r29, 0x3e	; 62
    3d0c:	ca 1b       	sub	r28, r26
    3d0e:	db 0b       	sbc	r29, r27
    3d10:	cd bf       	out	0x3d, r28	; 61
    3d12:	de bf       	out	0x3e, r29	; 62
    3d14:	19 94       	eijmp

00003d16 <__epilogue_restores__>:
    3d16:	2a 88       	ldd	r2, Y+18	; 0x12
    3d18:	39 88       	ldd	r3, Y+17	; 0x11
    3d1a:	48 88       	ldd	r4, Y+16	; 0x10
    3d1c:	5f 84       	ldd	r5, Y+15	; 0x0f
    3d1e:	6e 84       	ldd	r6, Y+14	; 0x0e
    3d20:	7d 84       	ldd	r7, Y+13	; 0x0d
    3d22:	8c 84       	ldd	r8, Y+12	; 0x0c
    3d24:	9b 84       	ldd	r9, Y+11	; 0x0b
    3d26:	aa 84       	ldd	r10, Y+10	; 0x0a
    3d28:	b9 84       	ldd	r11, Y+9	; 0x09
    3d2a:	c8 84       	ldd	r12, Y+8	; 0x08
    3d2c:	df 80       	ldd	r13, Y+7	; 0x07
    3d2e:	ee 80       	ldd	r14, Y+6	; 0x06
    3d30:	fd 80       	ldd	r15, Y+5	; 0x05
    3d32:	0c 81       	ldd	r16, Y+4	; 0x04
    3d34:	1b 81       	ldd	r17, Y+3	; 0x03
    3d36:	aa 81       	ldd	r26, Y+2	; 0x02
    3d38:	b9 81       	ldd	r27, Y+1	; 0x01
    3d3a:	ce 0f       	add	r28, r30
    3d3c:	d1 1d       	adc	r29, r1
    3d3e:	cd bf       	out	0x3d, r28	; 61
    3d40:	de bf       	out	0x3e, r29	; 62
    3d42:	ed 01       	movw	r28, r26
    3d44:	08 95       	ret

00003d46 <__udivmodhi4>:
    3d46:	aa 1b       	sub	r26, r26
    3d48:	bb 1b       	sub	r27, r27
    3d4a:	51 e1       	ldi	r21, 0x11	; 17
    3d4c:	07 c0       	rjmp	.+14     	; 0x3d5c <__udivmodhi4_ep>

00003d4e <__udivmodhi4_loop>:
    3d4e:	aa 1f       	adc	r26, r26
    3d50:	bb 1f       	adc	r27, r27
    3d52:	a6 17       	cp	r26, r22
    3d54:	b7 07       	cpc	r27, r23
    3d56:	10 f0       	brcs	.+4      	; 0x3d5c <__udivmodhi4_ep>
    3d58:	a6 1b       	sub	r26, r22
    3d5a:	b7 0b       	sbc	r27, r23

00003d5c <__udivmodhi4_ep>:
    3d5c:	88 1f       	adc	r24, r24
    3d5e:	99 1f       	adc	r25, r25
    3d60:	5a 95       	dec	r21
    3d62:	a9 f7       	brne	.-22     	; 0x3d4e <__udivmodhi4_loop>
    3d64:	80 95       	com	r24
    3d66:	90 95       	com	r25
    3d68:	bc 01       	movw	r22, r24
    3d6a:	cd 01       	movw	r24, r26
    3d6c:	08 95       	ret

00003d6e <malloc>:
    3d6e:	cf 93       	push	r28
    3d70:	df 93       	push	r29
    3d72:	82 30       	cpi	r24, 0x02	; 2
    3d74:	91 05       	cpc	r25, r1
    3d76:	10 f4       	brcc	.+4      	; 0x3d7c <malloc+0xe>
    3d78:	82 e0       	ldi	r24, 0x02	; 2
    3d7a:	90 e0       	ldi	r25, 0x00	; 0
    3d7c:	e0 91 60 24 	lds	r30, 0x2460
    3d80:	f0 91 61 24 	lds	r31, 0x2461
    3d84:	20 e0       	ldi	r18, 0x00	; 0
    3d86:	30 e0       	ldi	r19, 0x00	; 0
    3d88:	c0 e0       	ldi	r28, 0x00	; 0
    3d8a:	d0 e0       	ldi	r29, 0x00	; 0
    3d8c:	30 97       	sbiw	r30, 0x00	; 0
    3d8e:	11 f1       	breq	.+68     	; 0x3dd4 <malloc+0x66>
    3d90:	40 81       	ld	r20, Z
    3d92:	51 81       	ldd	r21, Z+1	; 0x01
    3d94:	48 17       	cp	r20, r24
    3d96:	59 07       	cpc	r21, r25
    3d98:	c0 f0       	brcs	.+48     	; 0x3dca <malloc+0x5c>
    3d9a:	48 17       	cp	r20, r24
    3d9c:	59 07       	cpc	r21, r25
    3d9e:	61 f4       	brne	.+24     	; 0x3db8 <malloc+0x4a>
    3da0:	82 81       	ldd	r24, Z+2	; 0x02
    3da2:	93 81       	ldd	r25, Z+3	; 0x03
    3da4:	20 97       	sbiw	r28, 0x00	; 0
    3da6:	19 f0       	breq	.+6      	; 0x3dae <malloc+0x40>
    3da8:	8a 83       	std	Y+2, r24	; 0x02
    3daa:	9b 83       	std	Y+3, r25	; 0x03
    3dac:	2b c0       	rjmp	.+86     	; 0x3e04 <malloc+0x96>
    3dae:	80 93 60 24 	sts	0x2460, r24
    3db2:	90 93 61 24 	sts	0x2461, r25
    3db6:	26 c0       	rjmp	.+76     	; 0x3e04 <malloc+0x96>
    3db8:	21 15       	cp	r18, r1
    3dba:	31 05       	cpc	r19, r1
    3dbc:	19 f0       	breq	.+6      	; 0x3dc4 <malloc+0x56>
    3dbe:	42 17       	cp	r20, r18
    3dc0:	53 07       	cpc	r21, r19
    3dc2:	18 f4       	brcc	.+6      	; 0x3dca <malloc+0x5c>
    3dc4:	9a 01       	movw	r18, r20
    3dc6:	be 01       	movw	r22, r28
    3dc8:	df 01       	movw	r26, r30
    3dca:	ef 01       	movw	r28, r30
    3dcc:	02 80       	ldd	r0, Z+2	; 0x02
    3dce:	f3 81       	ldd	r31, Z+3	; 0x03
    3dd0:	e0 2d       	mov	r30, r0
    3dd2:	dc cf       	rjmp	.-72     	; 0x3d8c <malloc+0x1e>
    3dd4:	21 15       	cp	r18, r1
    3dd6:	31 05       	cpc	r19, r1
    3dd8:	09 f1       	breq	.+66     	; 0x3e1c <malloc+0xae>
    3dda:	28 1b       	sub	r18, r24
    3ddc:	39 0b       	sbc	r19, r25
    3dde:	24 30       	cpi	r18, 0x04	; 4
    3de0:	31 05       	cpc	r19, r1
    3de2:	90 f4       	brcc	.+36     	; 0x3e08 <malloc+0x9a>
    3de4:	12 96       	adiw	r26, 0x02	; 2
    3de6:	8d 91       	ld	r24, X+
    3de8:	9c 91       	ld	r25, X
    3dea:	13 97       	sbiw	r26, 0x03	; 3
    3dec:	61 15       	cp	r22, r1
    3dee:	71 05       	cpc	r23, r1
    3df0:	21 f0       	breq	.+8      	; 0x3dfa <malloc+0x8c>
    3df2:	fb 01       	movw	r30, r22
    3df4:	82 83       	std	Z+2, r24	; 0x02
    3df6:	93 83       	std	Z+3, r25	; 0x03
    3df8:	04 c0       	rjmp	.+8      	; 0x3e02 <malloc+0x94>
    3dfa:	80 93 60 24 	sts	0x2460, r24
    3dfe:	90 93 61 24 	sts	0x2461, r25
    3e02:	fd 01       	movw	r30, r26
    3e04:	32 96       	adiw	r30, 0x02	; 2
    3e06:	44 c0       	rjmp	.+136    	; 0x3e90 <malloc+0x122>
    3e08:	fd 01       	movw	r30, r26
    3e0a:	e2 0f       	add	r30, r18
    3e0c:	f3 1f       	adc	r31, r19
    3e0e:	81 93       	st	Z+, r24
    3e10:	91 93       	st	Z+, r25
    3e12:	22 50       	subi	r18, 0x02	; 2
    3e14:	31 09       	sbc	r19, r1
    3e16:	2d 93       	st	X+, r18
    3e18:	3c 93       	st	X, r19
    3e1a:	3a c0       	rjmp	.+116    	; 0x3e90 <malloc+0x122>
    3e1c:	20 91 5e 24 	lds	r18, 0x245E
    3e20:	30 91 5f 24 	lds	r19, 0x245F
    3e24:	23 2b       	or	r18, r19
    3e26:	41 f4       	brne	.+16     	; 0x3e38 <malloc+0xca>
    3e28:	20 91 03 20 	lds	r18, 0x2003
    3e2c:	30 91 04 20 	lds	r19, 0x2004
    3e30:	20 93 5e 24 	sts	0x245E, r18
    3e34:	30 93 5f 24 	sts	0x245F, r19
    3e38:	20 91 01 20 	lds	r18, 0x2001
    3e3c:	30 91 02 20 	lds	r19, 0x2002
    3e40:	21 15       	cp	r18, r1
    3e42:	31 05       	cpc	r19, r1
    3e44:	41 f4       	brne	.+16     	; 0x3e56 <malloc+0xe8>
    3e46:	2d b7       	in	r18, 0x3d	; 61
    3e48:	3e b7       	in	r19, 0x3e	; 62
    3e4a:	40 91 05 20 	lds	r20, 0x2005
    3e4e:	50 91 06 20 	lds	r21, 0x2006
    3e52:	24 1b       	sub	r18, r20
    3e54:	35 0b       	sbc	r19, r21
    3e56:	e0 91 5e 24 	lds	r30, 0x245E
    3e5a:	f0 91 5f 24 	lds	r31, 0x245F
    3e5e:	e2 17       	cp	r30, r18
    3e60:	f3 07       	cpc	r31, r19
    3e62:	a0 f4       	brcc	.+40     	; 0x3e8c <malloc+0x11e>
    3e64:	2e 1b       	sub	r18, r30
    3e66:	3f 0b       	sbc	r19, r31
    3e68:	28 17       	cp	r18, r24
    3e6a:	39 07       	cpc	r19, r25
    3e6c:	78 f0       	brcs	.+30     	; 0x3e8c <malloc+0x11e>
    3e6e:	ac 01       	movw	r20, r24
    3e70:	4e 5f       	subi	r20, 0xFE	; 254
    3e72:	5f 4f       	sbci	r21, 0xFF	; 255
    3e74:	24 17       	cp	r18, r20
    3e76:	35 07       	cpc	r19, r21
    3e78:	48 f0       	brcs	.+18     	; 0x3e8c <malloc+0x11e>
    3e7a:	4e 0f       	add	r20, r30
    3e7c:	5f 1f       	adc	r21, r31
    3e7e:	40 93 5e 24 	sts	0x245E, r20
    3e82:	50 93 5f 24 	sts	0x245F, r21
    3e86:	81 93       	st	Z+, r24
    3e88:	91 93       	st	Z+, r25
    3e8a:	02 c0       	rjmp	.+4      	; 0x3e90 <malloc+0x122>
    3e8c:	e0 e0       	ldi	r30, 0x00	; 0
    3e8e:	f0 e0       	ldi	r31, 0x00	; 0
    3e90:	cf 01       	movw	r24, r30
    3e92:	df 91       	pop	r29
    3e94:	cf 91       	pop	r28
    3e96:	08 95       	ret

00003e98 <free>:
    3e98:	0f 93       	push	r16
    3e9a:	1f 93       	push	r17
    3e9c:	cf 93       	push	r28
    3e9e:	df 93       	push	r29
    3ea0:	00 97       	sbiw	r24, 0x00	; 0
    3ea2:	09 f4       	brne	.+2      	; 0x3ea6 <free+0xe>
    3ea4:	8c c0       	rjmp	.+280    	; 0x3fbe <free+0x126>
    3ea6:	fc 01       	movw	r30, r24
    3ea8:	32 97       	sbiw	r30, 0x02	; 2
    3eaa:	12 82       	std	Z+2, r1	; 0x02
    3eac:	13 82       	std	Z+3, r1	; 0x03
    3eae:	00 91 60 24 	lds	r16, 0x2460
    3eb2:	10 91 61 24 	lds	r17, 0x2461
    3eb6:	01 15       	cp	r16, r1
    3eb8:	11 05       	cpc	r17, r1
    3eba:	81 f4       	brne	.+32     	; 0x3edc <free+0x44>
    3ebc:	20 81       	ld	r18, Z
    3ebe:	31 81       	ldd	r19, Z+1	; 0x01
    3ec0:	82 0f       	add	r24, r18
    3ec2:	93 1f       	adc	r25, r19
    3ec4:	20 91 5e 24 	lds	r18, 0x245E
    3ec8:	30 91 5f 24 	lds	r19, 0x245F
    3ecc:	28 17       	cp	r18, r24
    3ece:	39 07       	cpc	r19, r25
    3ed0:	79 f5       	brne	.+94     	; 0x3f30 <free+0x98>
    3ed2:	e0 93 5e 24 	sts	0x245E, r30
    3ed6:	f0 93 5f 24 	sts	0x245F, r31
    3eda:	71 c0       	rjmp	.+226    	; 0x3fbe <free+0x126>
    3edc:	d8 01       	movw	r26, r16
    3ede:	40 e0       	ldi	r20, 0x00	; 0
    3ee0:	50 e0       	ldi	r21, 0x00	; 0
    3ee2:	ae 17       	cp	r26, r30
    3ee4:	bf 07       	cpc	r27, r31
    3ee6:	50 f4       	brcc	.+20     	; 0x3efc <free+0x64>
    3ee8:	12 96       	adiw	r26, 0x02	; 2
    3eea:	2d 91       	ld	r18, X+
    3eec:	3c 91       	ld	r19, X
    3eee:	13 97       	sbiw	r26, 0x03	; 3
    3ef0:	ad 01       	movw	r20, r26
    3ef2:	21 15       	cp	r18, r1
    3ef4:	31 05       	cpc	r19, r1
    3ef6:	09 f1       	breq	.+66     	; 0x3f3a <free+0xa2>
    3ef8:	d9 01       	movw	r26, r18
    3efa:	f3 cf       	rjmp	.-26     	; 0x3ee2 <free+0x4a>
    3efc:	9d 01       	movw	r18, r26
    3efe:	da 01       	movw	r26, r20
    3f00:	22 83       	std	Z+2, r18	; 0x02
    3f02:	33 83       	std	Z+3, r19	; 0x03
    3f04:	60 81       	ld	r22, Z
    3f06:	71 81       	ldd	r23, Z+1	; 0x01
    3f08:	86 0f       	add	r24, r22
    3f0a:	97 1f       	adc	r25, r23
    3f0c:	82 17       	cp	r24, r18
    3f0e:	93 07       	cpc	r25, r19
    3f10:	69 f4       	brne	.+26     	; 0x3f2c <free+0x94>
    3f12:	ec 01       	movw	r28, r24
    3f14:	28 81       	ld	r18, Y
    3f16:	39 81       	ldd	r19, Y+1	; 0x01
    3f18:	26 0f       	add	r18, r22
    3f1a:	37 1f       	adc	r19, r23
    3f1c:	2e 5f       	subi	r18, 0xFE	; 254
    3f1e:	3f 4f       	sbci	r19, 0xFF	; 255
    3f20:	20 83       	st	Z, r18
    3f22:	31 83       	std	Z+1, r19	; 0x01
    3f24:	8a 81       	ldd	r24, Y+2	; 0x02
    3f26:	9b 81       	ldd	r25, Y+3	; 0x03
    3f28:	82 83       	std	Z+2, r24	; 0x02
    3f2a:	93 83       	std	Z+3, r25	; 0x03
    3f2c:	45 2b       	or	r20, r21
    3f2e:	29 f4       	brne	.+10     	; 0x3f3a <free+0xa2>
    3f30:	e0 93 60 24 	sts	0x2460, r30
    3f34:	f0 93 61 24 	sts	0x2461, r31
    3f38:	42 c0       	rjmp	.+132    	; 0x3fbe <free+0x126>
    3f3a:	12 96       	adiw	r26, 0x02	; 2
    3f3c:	ed 93       	st	X+, r30
    3f3e:	fc 93       	st	X, r31
    3f40:	13 97       	sbiw	r26, 0x03	; 3
    3f42:	ed 01       	movw	r28, r26
    3f44:	49 91       	ld	r20, Y+
    3f46:	59 91       	ld	r21, Y+
    3f48:	9e 01       	movw	r18, r28
    3f4a:	24 0f       	add	r18, r20
    3f4c:	35 1f       	adc	r19, r21
    3f4e:	e2 17       	cp	r30, r18
    3f50:	f3 07       	cpc	r31, r19
    3f52:	71 f4       	brne	.+28     	; 0x3f70 <free+0xd8>
    3f54:	80 81       	ld	r24, Z
    3f56:	91 81       	ldd	r25, Z+1	; 0x01
    3f58:	84 0f       	add	r24, r20
    3f5a:	95 1f       	adc	r25, r21
    3f5c:	02 96       	adiw	r24, 0x02	; 2
    3f5e:	8d 93       	st	X+, r24
    3f60:	9c 93       	st	X, r25
    3f62:	11 97       	sbiw	r26, 0x01	; 1
    3f64:	82 81       	ldd	r24, Z+2	; 0x02
    3f66:	93 81       	ldd	r25, Z+3	; 0x03
    3f68:	12 96       	adiw	r26, 0x02	; 2
    3f6a:	8d 93       	st	X+, r24
    3f6c:	9c 93       	st	X, r25
    3f6e:	13 97       	sbiw	r26, 0x03	; 3
    3f70:	e0 e0       	ldi	r30, 0x00	; 0
    3f72:	f0 e0       	ldi	r31, 0x00	; 0
    3f74:	d8 01       	movw	r26, r16
    3f76:	12 96       	adiw	r26, 0x02	; 2
    3f78:	8d 91       	ld	r24, X+
    3f7a:	9c 91       	ld	r25, X
    3f7c:	13 97       	sbiw	r26, 0x03	; 3
    3f7e:	00 97       	sbiw	r24, 0x00	; 0
    3f80:	19 f0       	breq	.+6      	; 0x3f88 <free+0xf0>
    3f82:	f8 01       	movw	r30, r16
    3f84:	8c 01       	movw	r16, r24
    3f86:	f6 cf       	rjmp	.-20     	; 0x3f74 <free+0xdc>
    3f88:	8d 91       	ld	r24, X+
    3f8a:	9c 91       	ld	r25, X
    3f8c:	98 01       	movw	r18, r16
    3f8e:	2e 5f       	subi	r18, 0xFE	; 254
    3f90:	3f 4f       	sbci	r19, 0xFF	; 255
    3f92:	82 0f       	add	r24, r18
    3f94:	93 1f       	adc	r25, r19
    3f96:	20 91 5e 24 	lds	r18, 0x245E
    3f9a:	30 91 5f 24 	lds	r19, 0x245F
    3f9e:	28 17       	cp	r18, r24
    3fa0:	39 07       	cpc	r19, r25
    3fa2:	69 f4       	brne	.+26     	; 0x3fbe <free+0x126>
    3fa4:	30 97       	sbiw	r30, 0x00	; 0
    3fa6:	29 f4       	brne	.+10     	; 0x3fb2 <free+0x11a>
    3fa8:	10 92 60 24 	sts	0x2460, r1
    3fac:	10 92 61 24 	sts	0x2461, r1
    3fb0:	02 c0       	rjmp	.+4      	; 0x3fb6 <free+0x11e>
    3fb2:	12 82       	std	Z+2, r1	; 0x02
    3fb4:	13 82       	std	Z+3, r1	; 0x03
    3fb6:	00 93 5e 24 	sts	0x245E, r16
    3fba:	10 93 5f 24 	sts	0x245F, r17
    3fbe:	df 91       	pop	r29
    3fc0:	cf 91       	pop	r28
    3fc2:	1f 91       	pop	r17
    3fc4:	0f 91       	pop	r16
    3fc6:	08 95       	ret

00003fc8 <_exit>:
    3fc8:	f8 94       	cli

00003fca <__stop_program>:
    3fca:	ff cf       	rjmp	.-2      	; 0x3fca <__stop_program>
