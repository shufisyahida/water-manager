
TestPratikum2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000048a2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000032  00802000  000048a2  00004936  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003b7  00802032  00802032  00004968  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00004968  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  000049c4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007a8  00000000  00000000  00004a08  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001372b  00000000  00000000  000051b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000037cb  00000000  00000000  000188db  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000cc0f  00000000  00000000  0001c0a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001834  00000000  00000000  00028cb8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000345bd  00000000  00000000  0002a4ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008d21  00000000  00000000  0005eaa9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000920  00000000  00000000  000677d0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000d4c7  00000000  00000000  000680f0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	46 c2       	rjmp	.+1164   	; 0x48e <__ctors_end>
       2:	00 00       	nop
       4:	65 c2       	rjmp	.+1226   	; 0x4d0 <__bad_interrupt>
       6:	00 00       	nop
       8:	63 c2       	rjmp	.+1222   	; 0x4d0 <__bad_interrupt>
       a:	00 00       	nop
       c:	61 c2       	rjmp	.+1218   	; 0x4d0 <__bad_interrupt>
       e:	00 00       	nop
      10:	5f c2       	rjmp	.+1214   	; 0x4d0 <__bad_interrupt>
      12:	00 00       	nop
      14:	5d c2       	rjmp	.+1210   	; 0x4d0 <__bad_interrupt>
      16:	00 00       	nop
      18:	5b c2       	rjmp	.+1206   	; 0x4d0 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	59 c2       	rjmp	.+1202   	; 0x4d0 <__bad_interrupt>
      1e:	00 00       	nop
      20:	57 c2       	rjmp	.+1198   	; 0x4d0 <__bad_interrupt>
      22:	00 00       	nop
      24:	55 c2       	rjmp	.+1194   	; 0x4d0 <__bad_interrupt>
      26:	00 00       	nop
      28:	53 c2       	rjmp	.+1190   	; 0x4d0 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	51 c2       	rjmp	.+1186   	; 0x4d0 <__bad_interrupt>
      2e:	00 00       	nop
      30:	4f c2       	rjmp	.+1182   	; 0x4d0 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 89 0f 	jmp	0x1f12	; 0x1f12 <__vector_13>
      38:	0c 94 f6 14 	jmp	0x29ec	; 0x29ec <__vector_14>
      3c:	49 c2       	rjmp	.+1170   	; 0x4d0 <__bad_interrupt>
      3e:	00 00       	nop
      40:	47 c2       	rjmp	.+1166   	; 0x4d0 <__bad_interrupt>
      42:	00 00       	nop
      44:	45 c2       	rjmp	.+1162   	; 0x4d0 <__bad_interrupt>
      46:	00 00       	nop
      48:	43 c2       	rjmp	.+1158   	; 0x4d0 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	41 c2       	rjmp	.+1154   	; 0x4d0 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3f c2       	rjmp	.+1150   	; 0x4d0 <__bad_interrupt>
      52:	00 00       	nop
      54:	3d c2       	rjmp	.+1146   	; 0x4d0 <__bad_interrupt>
      56:	00 00       	nop
      58:	3b c2       	rjmp	.+1142   	; 0x4d0 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	39 c2       	rjmp	.+1138   	; 0x4d0 <__bad_interrupt>
      5e:	00 00       	nop
      60:	37 c2       	rjmp	.+1134   	; 0x4d0 <__bad_interrupt>
      62:	00 00       	nop
      64:	35 c2       	rjmp	.+1130   	; 0x4d0 <__bad_interrupt>
      66:	00 00       	nop
      68:	33 c2       	rjmp	.+1126   	; 0x4d0 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	31 c2       	rjmp	.+1122   	; 0x4d0 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2f c2       	rjmp	.+1118   	; 0x4d0 <__bad_interrupt>
      72:	00 00       	nop
      74:	2d c2       	rjmp	.+1114   	; 0x4d0 <__bad_interrupt>
      76:	00 00       	nop
      78:	2b c2       	rjmp	.+1110   	; 0x4d0 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	29 c2       	rjmp	.+1106   	; 0x4d0 <__bad_interrupt>
      7e:	00 00       	nop
      80:	27 c2       	rjmp	.+1102   	; 0x4d0 <__bad_interrupt>
      82:	00 00       	nop
      84:	25 c2       	rjmp	.+1098   	; 0x4d0 <__bad_interrupt>
      86:	00 00       	nop
      88:	23 c2       	rjmp	.+1094   	; 0x4d0 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	21 c2       	rjmp	.+1090   	; 0x4d0 <__bad_interrupt>
      8e:	00 00       	nop
      90:	1f c2       	rjmp	.+1086   	; 0x4d0 <__bad_interrupt>
      92:	00 00       	nop
      94:	1d c2       	rjmp	.+1082   	; 0x4d0 <__bad_interrupt>
      96:	00 00       	nop
      98:	1b c2       	rjmp	.+1078   	; 0x4d0 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 41 0d 	jmp	0x1a82	; 0x1a82 <__vector_39>
      a0:	0c 94 73 0d 	jmp	0x1ae6	; 0x1ae6 <__vector_40>
      a4:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <__vector_41>
      a8:	0c 94 d7 0d 	jmp	0x1bae	; 0x1bae <__vector_42>
      ac:	11 c2       	rjmp	.+1058   	; 0x4d0 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	0f c2       	rjmp	.+1054   	; 0x4d0 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	0d c2       	rjmp	.+1050   	; 0x4d0 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	0c 94 b0 0f 	jmp	0x1f60	; 0x1f60 <__vector_46>
      bc:	09 c2       	rjmp	.+1042   	; 0x4d0 <__bad_interrupt>
      be:	00 00       	nop
      c0:	07 c2       	rjmp	.+1038   	; 0x4d0 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	05 c2       	rjmp	.+1034   	; 0x4d0 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	03 c2       	rjmp	.+1030   	; 0x4d0 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	01 c2       	rjmp	.+1026   	; 0x4d0 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	ff c1       	rjmp	.+1022   	; 0x4d0 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	fd c1       	rjmp	.+1018   	; 0x4d0 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	fb c1       	rjmp	.+1014   	; 0x4d0 <__bad_interrupt>
      da:	00 00       	nop
      dc:	f9 c1       	rjmp	.+1010   	; 0x4d0 <__bad_interrupt>
      de:	00 00       	nop
      e0:	f7 c1       	rjmp	.+1006   	; 0x4d0 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	f5 c1       	rjmp	.+1002   	; 0x4d0 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	f3 c1       	rjmp	.+998    	; 0x4d0 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	f1 c1       	rjmp	.+994    	; 0x4d0 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	ef c1       	rjmp	.+990    	; 0x4d0 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	ed c1       	rjmp	.+986    	; 0x4d0 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	eb c1       	rjmp	.+982    	; 0x4d0 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	e9 c1       	rjmp	.+978    	; 0x4d0 <__bad_interrupt>
      fe:	00 00       	nop
     100:	e7 c1       	rjmp	.+974    	; 0x4d0 <__bad_interrupt>
     102:	00 00       	nop
     104:	e5 c1       	rjmp	.+970    	; 0x4d0 <__bad_interrupt>
     106:	00 00       	nop
     108:	e3 c1       	rjmp	.+966    	; 0x4d0 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	e1 c1       	rjmp	.+962    	; 0x4d0 <__bad_interrupt>
     10e:	00 00       	nop
     110:	df c1       	rjmp	.+958    	; 0x4d0 <__bad_interrupt>
     112:	00 00       	nop
     114:	dd c1       	rjmp	.+954    	; 0x4d0 <__bad_interrupt>
     116:	00 00       	nop
     118:	db c1       	rjmp	.+950    	; 0x4d0 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	0c 94 79 0c 	jmp	0x18f2	; 0x18f2 <__vector_71>
     120:	0c 94 ab 0c 	jmp	0x1956	; 0x1956 <__vector_72>
     124:	0c 94 dd 0c 	jmp	0x19ba	; 0x19ba <__vector_73>
     128:	0c 94 0f 0d 	jmp	0x1a1e	; 0x1a1e <__vector_74>
     12c:	d1 c1       	rjmp	.+930    	; 0x4d0 <__bad_interrupt>
     12e:	00 00       	nop
     130:	cf c1       	rjmp	.+926    	; 0x4d0 <__bad_interrupt>
     132:	00 00       	nop
     134:	cd c1       	rjmp	.+922    	; 0x4d0 <__bad_interrupt>
     136:	00 00       	nop
     138:	cb c1       	rjmp	.+918    	; 0x4d0 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	c9 c1       	rjmp	.+914    	; 0x4d0 <__bad_interrupt>
     13e:	00 00       	nop
     140:	c7 c1       	rjmp	.+910    	; 0x4d0 <__bad_interrupt>
     142:	00 00       	nop
     144:	c5 c1       	rjmp	.+906    	; 0x4d0 <__bad_interrupt>
     146:	00 00       	nop
     148:	c3 c1       	rjmp	.+902    	; 0x4d0 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	c1 c1       	rjmp	.+898    	; 0x4d0 <__bad_interrupt>
     14e:	00 00       	nop
     150:	bf c1       	rjmp	.+894    	; 0x4d0 <__bad_interrupt>
     152:	00 00       	nop
     154:	bd c1       	rjmp	.+890    	; 0x4d0 <__bad_interrupt>
     156:	00 00       	nop
     158:	bb c1       	rjmp	.+886    	; 0x4d0 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	b9 c1       	rjmp	.+882    	; 0x4d0 <__bad_interrupt>
     15e:	00 00       	nop
     160:	b7 c1       	rjmp	.+878    	; 0x4d0 <__bad_interrupt>
     162:	00 00       	nop
     164:	b5 c1       	rjmp	.+874    	; 0x4d0 <__bad_interrupt>
     166:	00 00       	nop
     168:	b3 c1       	rjmp	.+870    	; 0x4d0 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	b1 c1       	rjmp	.+866    	; 0x4d0 <__bad_interrupt>
     16e:	00 00       	nop
     170:	af c1       	rjmp	.+862    	; 0x4d0 <__bad_interrupt>
     172:	00 00       	nop
     174:	ad c1       	rjmp	.+858    	; 0x4d0 <__bad_interrupt>
     176:	00 00       	nop
     178:	ab c1       	rjmp	.+854    	; 0x4d0 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	a9 c1       	rjmp	.+850    	; 0x4d0 <__bad_interrupt>
     17e:	00 00       	nop
     180:	a7 c1       	rjmp	.+846    	; 0x4d0 <__bad_interrupt>
     182:	00 00       	nop
     184:	a5 c1       	rjmp	.+842    	; 0x4d0 <__bad_interrupt>
     186:	00 00       	nop
     188:	a3 c1       	rjmp	.+838    	; 0x4d0 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	a1 c1       	rjmp	.+834    	; 0x4d0 <__bad_interrupt>
     18e:	00 00       	nop
     190:	9f c1       	rjmp	.+830    	; 0x4d0 <__bad_interrupt>
     192:	00 00       	nop
     194:	9d c1       	rjmp	.+826    	; 0x4d0 <__bad_interrupt>
     196:	00 00       	nop
     198:	9b c1       	rjmp	.+822    	; 0x4d0 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	99 c1       	rjmp	.+818    	; 0x4d0 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	97 c1       	rjmp	.+814    	; 0x4d0 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	95 c1       	rjmp	.+810    	; 0x4d0 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	93 c1       	rjmp	.+806    	; 0x4d0 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	91 c1       	rjmp	.+802    	; 0x4d0 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	8f c1       	rjmp	.+798    	; 0x4d0 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	8d c1       	rjmp	.+794    	; 0x4d0 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	8b c1       	rjmp	.+790    	; 0x4d0 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	89 c1       	rjmp	.+786    	; 0x4d0 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	87 c1       	rjmp	.+782    	; 0x4d0 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	85 c1       	rjmp	.+778    	; 0x4d0 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	83 c1       	rjmp	.+774    	; 0x4d0 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	81 c1       	rjmp	.+770    	; 0x4d0 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	7f c1       	rjmp	.+766    	; 0x4d0 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	7d c1       	rjmp	.+762    	; 0x4d0 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	7b c1       	rjmp	.+758    	; 0x4d0 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	79 c1       	rjmp	.+754    	; 0x4d0 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	77 c1       	rjmp	.+750    	; 0x4d0 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	75 c1       	rjmp	.+746    	; 0x4d0 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	73 c1       	rjmp	.+742    	; 0x4d0 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	71 c1       	rjmp	.+738    	; 0x4d0 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	6f c1       	rjmp	.+734    	; 0x4d0 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	6d c1       	rjmp	.+730    	; 0x4d0 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	6b c1       	rjmp	.+726    	; 0x4d0 <__bad_interrupt>
	...

000001fc <__trampolines_end>:
     1fc:	00 00       	nop
     1fe:	00 00       	nop
     200:	00 00       	nop
     202:	00 20       	and	r0, r0
     204:	20 20       	and	r2, r0
     206:	20 20       	and	r2, r0
     208:	00 20       	and	r0, r0
     20a:	50 50       	subi	r21, 0x00	; 0
     20c:	50 00       	.word	0x0050	; ????
     20e:	00 00       	nop
     210:	00 50       	subi	r16, 0x00	; 0
     212:	50 f8       	bld	r5, 0
     214:	50 f8       	bld	r5, 0
     216:	50 50       	subi	r21, 0x00	; 0
     218:	20 78       	andi	r18, 0x80	; 128
     21a:	a0 70       	andi	r26, 0x00	; 0
     21c:	28 f0       	brcs	.+10     	; 0x228 <__trampolines_end+0x2c>
     21e:	20 c0       	rjmp	.+64     	; 0x260 <__trampolines_end+0x64>
     220:	c8 10       	cpse	r12, r8
     222:	20 40       	sbci	r18, 0x00	; 0
     224:	98 18       	sub	r9, r8
     226:	60 90 a0 40 	lds	r6, 0x40A0
     22a:	a8 90       	.word	0x90a8	; ????
     22c:	68 60       	ori	r22, 0x08	; 8
     22e:	20 40       	sbci	r18, 0x00	; 0
     230:	00 00       	nop
     232:	00 00       	nop
     234:	10 20       	and	r1, r0
     236:	40 40       	sbci	r20, 0x00	; 0
     238:	40 20       	and	r4, r0
     23a:	10 40       	sbci	r17, 0x00	; 0
     23c:	20 10       	cpse	r2, r0
     23e:	10 10       	cpse	r1, r0
     240:	20 40       	sbci	r18, 0x00	; 0
     242:	00 50       	subi	r16, 0x00	; 0
     244:	20 f8       	bld	r2, 0
     246:	20 50       	subi	r18, 0x00	; 0
     248:	00 00       	nop
     24a:	20 20       	and	r2, r0
     24c:	f8 20       	and	r15, r8
     24e:	20 00       	.word	0x0020	; ????
     250:	00 00       	nop
     252:	00 00       	nop
     254:	60 20       	and	r6, r0
     256:	40 00       	.word	0x0040	; ????
     258:	00 00       	nop
     25a:	f8 00       	.word	0x00f8	; ????
     25c:	00 00       	nop
     25e:	00 00       	nop
     260:	00 00       	nop
     262:	00 60       	ori	r16, 0x00	; 0
     264:	60 00       	.word	0x0060	; ????
     266:	08 10       	cpse	r0, r8
     268:	20 40       	sbci	r18, 0x00	; 0
     26a:	80 00       	.word	0x0080	; ????
     26c:	70 88       	ldd	r7, Z+16	; 0x10
     26e:	98 a8       	ldd	r9, Y+48	; 0x30
     270:	c8 88       	ldd	r12, Y+16	; 0x10
     272:	70 20       	and	r7, r0
     274:	60 20       	and	r6, r0
     276:	20 20       	and	r2, r0
     278:	20 70       	andi	r18, 0x00	; 0
     27a:	70 88       	ldd	r7, Z+16	; 0x10
     27c:	08 10       	cpse	r0, r8
     27e:	20 40       	sbci	r18, 0x00	; 0
     280:	f8 f8       	.word	0xf8f8	; ????
     282:	10 20       	and	r1, r0
     284:	10 08       	sbc	r1, r0
     286:	88 70       	andi	r24, 0x08	; 8
     288:	10 30       	cpi	r17, 0x00	; 0
     28a:	50 90 f8 10 	lds	r5, 0x10F8
     28e:	10 f8       	bld	r1, 0
     290:	80 f0       	brcs	.+32     	; 0x2b2 <__trampolines_end+0xb6>
     292:	08 08       	sbc	r0, r8
     294:	88 70       	andi	r24, 0x08	; 8
     296:	30 40       	sbci	r19, 0x00	; 0
     298:	80 f0       	brcs	.+32     	; 0x2ba <__trampolines_end+0xbe>
     29a:	88 88       	ldd	r8, Y+16	; 0x10
     29c:	70 f8       	bld	r7, 0
     29e:	08 10       	cpse	r0, r8
     2a0:	20 40       	sbci	r18, 0x00	; 0
     2a2:	40 40       	sbci	r20, 0x00	; 0
     2a4:	70 88       	ldd	r7, Z+16	; 0x10
     2a6:	88 70       	andi	r24, 0x08	; 8
     2a8:	88 88       	ldd	r8, Y+16	; 0x10
     2aa:	70 70       	andi	r23, 0x00	; 0
     2ac:	88 88       	ldd	r8, Y+16	; 0x10
     2ae:	78 08       	sbc	r7, r8
     2b0:	10 60       	ori	r17, 0x00	; 0
     2b2:	00 60       	ori	r16, 0x00	; 0
     2b4:	60 00       	.word	0x0060	; ????
     2b6:	60 60       	ori	r22, 0x00	; 0
     2b8:	00 00       	nop
     2ba:	60 60       	ori	r22, 0x00	; 0
     2bc:	00 60       	ori	r16, 0x00	; 0
     2be:	20 40       	sbci	r18, 0x00	; 0
     2c0:	08 10       	cpse	r0, r8
     2c2:	20 40       	sbci	r18, 0x00	; 0
     2c4:	20 10       	cpse	r2, r0
     2c6:	08 00       	.word	0x0008	; ????
     2c8:	00 f8       	bld	r0, 0
     2ca:	00 f8       	bld	r0, 0
     2cc:	00 00       	nop
     2ce:	80 40       	sbci	r24, 0x00	; 0
     2d0:	20 10       	cpse	r2, r0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	80 70       	andi	r24, 0x00	; 0
     2d6:	88 08       	sbc	r8, r8
     2d8:	10 20       	and	r1, r0
     2da:	00 20       	and	r0, r0
     2dc:	70 88       	ldd	r7, Z+16	; 0x10
     2de:	08 68       	ori	r16, 0x88	; 136
     2e0:	a8 a8       	ldd	r10, Y+48	; 0x30
     2e2:	70 70       	andi	r23, 0x00	; 0
     2e4:	88 88       	ldd	r8, Y+16	; 0x10
     2e6:	88 f8       	.word	0xf888	; ????
     2e8:	88 88       	ldd	r8, Y+16	; 0x10
     2ea:	f0 88       	ldd	r15, Z+16	; 0x10
     2ec:	88 f0       	brcs	.+34     	; 0x310 <__trampolines_end+0x114>
     2ee:	88 88       	ldd	r8, Y+16	; 0x10
     2f0:	f0 70       	andi	r31, 0x00	; 0
     2f2:	88 80       	ld	r8, Y
     2f4:	80 80       	ld	r8, Z
     2f6:	88 70       	andi	r24, 0x08	; 8
     2f8:	e0 90 88 88 	lds	r14, 0x8888
     2fc:	88 90       	.word	0x9088	; ????
     2fe:	e0 f8       	bld	r14, 0
     300:	80 80       	ld	r8, Z
     302:	f0 80       	ld	r15, Z
     304:	80 f8       	bld	r8, 0
     306:	f8 80       	ld	r15, Y
     308:	80 e0       	ldi	r24, 0x00	; 0
     30a:	80 80       	ld	r8, Z
     30c:	80 70       	andi	r24, 0x00	; 0
     30e:	88 80       	ld	r8, Y
     310:	80 98       	cbi	0x10, 0	; 16
     312:	88 70       	andi	r24, 0x08	; 8
     314:	88 88       	ldd	r8, Y+16	; 0x10
     316:	88 f8       	.word	0xf888	; ????
     318:	88 88       	ldd	r8, Y+16	; 0x10
     31a:	88 70       	andi	r24, 0x08	; 8
     31c:	20 20       	and	r2, r0
     31e:	20 20       	and	r2, r0
     320:	20 70       	andi	r18, 0x00	; 0
     322:	38 10       	cpse	r3, r8
     324:	10 10       	cpse	r1, r0
     326:	10 90 60 88 	lds	r1, 0x8860
     32a:	90 a0       	ldd	r9, Z+32	; 0x20
     32c:	c0 a0       	ldd	r12, Z+32	; 0x20
     32e:	90 88       	ldd	r9, Z+16	; 0x10
     330:	80 80       	ld	r8, Z
     332:	80 80       	ld	r8, Z
     334:	80 80       	ld	r8, Z
     336:	f8 88       	ldd	r15, Y+16	; 0x10
     338:	d8 a8       	ldd	r13, Y+48	; 0x30
     33a:	88 88       	ldd	r8, Y+16	; 0x10
     33c:	88 88       	ldd	r8, Y+16	; 0x10
     33e:	88 88       	ldd	r8, Y+16	; 0x10
     340:	c8 a8       	ldd	r12, Y+48	; 0x30
     342:	98 88       	ldd	r9, Y+16	; 0x10
     344:	88 70       	andi	r24, 0x08	; 8
     346:	88 88       	ldd	r8, Y+16	; 0x10
     348:	88 88       	ldd	r8, Y+16	; 0x10
     34a:	88 70       	andi	r24, 0x08	; 8
     34c:	f0 88       	ldd	r15, Z+16	; 0x10
     34e:	88 f0       	brcs	.+34     	; 0x372 <__trampolines_end+0x176>
     350:	80 80       	ld	r8, Z
     352:	80 70       	andi	r24, 0x00	; 0
     354:	88 88       	ldd	r8, Y+16	; 0x10
     356:	88 a8       	ldd	r8, Y+48	; 0x30
     358:	90 68       	ori	r25, 0x80	; 128
     35a:	f0 88       	ldd	r15, Z+16	; 0x10
     35c:	88 f0       	brcs	.+34     	; 0x380 <__trampolines_end+0x184>
     35e:	a0 90 88 78 	lds	r10, 0x7888
     362:	80 80       	ld	r8, Z
     364:	70 08       	sbc	r7, r0
     366:	08 f0       	brcs	.+2      	; 0x36a <__trampolines_end+0x16e>
     368:	f8 20       	and	r15, r8
     36a:	20 20       	and	r2, r0
     36c:	20 20       	and	r2, r0
     36e:	20 88       	ldd	r2, Z+16	; 0x10
     370:	88 88       	ldd	r8, Y+16	; 0x10
     372:	88 88       	ldd	r8, Y+16	; 0x10
     374:	88 70       	andi	r24, 0x08	; 8
     376:	88 88       	ldd	r8, Y+16	; 0x10
     378:	88 88       	ldd	r8, Y+16	; 0x10
     37a:	88 50       	subi	r24, 0x08	; 8
     37c:	20 88       	ldd	r2, Z+16	; 0x10
     37e:	88 88       	ldd	r8, Y+16	; 0x10
     380:	a8 a8       	ldd	r10, Y+48	; 0x30
     382:	d8 88       	ldd	r13, Y+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	50 20       	and	r5, r0
     388:	50 88       	ldd	r5, Z+16	; 0x10
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 50       	subi	r24, 0x08	; 8
     38e:	20 20       	and	r2, r0
     390:	20 20       	and	r2, r0
     392:	f8 08       	sbc	r15, r8
     394:	10 20       	and	r1, r0
     396:	40 80       	ld	r4, Z
     398:	f8 38       	cpi	r31, 0x88	; 136
     39a:	20 20       	and	r2, r0
     39c:	20 20       	and	r2, r0
     39e:	20 38       	cpi	r18, 0x80	; 128
     3a0:	00 80       	ld	r0, Z
     3a2:	40 20       	and	r4, r0
     3a4:	10 08       	sbc	r1, r0
     3a6:	00 e0       	ldi	r16, 0x00	; 0
     3a8:	20 20       	and	r2, r0
     3aa:	20 20       	and	r2, r0
     3ac:	20 e0       	ldi	r18, 0x00	; 0
     3ae:	20 50       	subi	r18, 0x00	; 0
     3b0:	88 00       	.word	0x0088	; ????
	...
     3ba:	00 f8       	bld	r0, 0
     3bc:	40 20       	and	r4, r0
     3be:	10 00       	.word	0x0010	; ????
     3c0:	00 00       	nop
     3c2:	00 00       	nop
     3c4:	00 70       	andi	r16, 0x00	; 0
     3c6:	08 78       	andi	r16, 0x88	; 136
     3c8:	88 78       	andi	r24, 0x88	; 136
     3ca:	80 80       	ld	r8, Z
     3cc:	b0 c8       	rjmp	.-3744   	; 0xfffff52e <__eeprom_end+0xff7ef52e>
     3ce:	88 88       	ldd	r8, Y+16	; 0x10
     3d0:	f0 00       	.word	0x00f0	; ????
     3d2:	00 70       	andi	r16, 0x00	; 0
     3d4:	80 80       	ld	r8, Z
     3d6:	88 70       	andi	r24, 0x08	; 8
     3d8:	08 08       	sbc	r0, r8
     3da:	68 98       	cbi	0x0d, 0	; 13
     3dc:	88 88       	ldd	r8, Y+16	; 0x10
     3de:	78 00       	.word	0x0078	; ????
     3e0:	00 70       	andi	r16, 0x00	; 0
     3e2:	88 f8       	.word	0xf888	; ????
     3e4:	80 70       	andi	r24, 0x00	; 0
     3e6:	30 48       	sbci	r19, 0x80	; 128
     3e8:	40 e0       	ldi	r20, 0x00	; 0
     3ea:	40 40       	sbci	r20, 0x00	; 0
     3ec:	40 00       	.word	0x0040	; ????
     3ee:	00 78       	andi	r16, 0x80	; 128
     3f0:	88 78       	andi	r24, 0x88	; 136
     3f2:	08 30       	cpi	r16, 0x08	; 8
     3f4:	80 80       	ld	r8, Z
     3f6:	b0 c8       	rjmp	.-3744   	; 0xfffff558 <__eeprom_end+0xff7ef558>
     3f8:	88 88       	ldd	r8, Y+16	; 0x10
     3fa:	88 20       	and	r8, r8
     3fc:	00 60       	ori	r16, 0x00	; 0
     3fe:	20 20       	and	r2, r0
     400:	20 70       	andi	r18, 0x00	; 0
     402:	10 00       	.word	0x0010	; ????
     404:	30 10       	cpse	r3, r0
     406:	10 90 60 40 	lds	r1, 0x4060
     40a:	40 48       	sbci	r20, 0x80	; 128
     40c:	50 60       	ori	r21, 0x00	; 0
     40e:	50 48       	sbci	r21, 0x80	; 128
     410:	60 20       	and	r6, r0
     412:	20 20       	and	r2, r0
     414:	20 20       	and	r2, r0
     416:	70 00       	.word	0x0070	; ????
     418:	00 d0       	rcall	.+0      	; 0x41a <__trampolines_end+0x21e>
     41a:	a8 a8       	ldd	r10, Y+48	; 0x30
     41c:	88 88       	ldd	r8, Y+16	; 0x10
     41e:	00 00       	nop
     420:	b0 c8       	rjmp	.-3744   	; 0xfffff582 <__eeprom_end+0xff7ef582>
     422:	88 88       	ldd	r8, Y+16	; 0x10
     424:	88 00       	.word	0x0088	; ????
     426:	00 70       	andi	r16, 0x00	; 0
     428:	88 88       	ldd	r8, Y+16	; 0x10
     42a:	88 70       	andi	r24, 0x08	; 8
     42c:	00 00       	nop
     42e:	f0 88       	ldd	r15, Z+16	; 0x10
     430:	f0 80       	ld	r15, Z
     432:	80 00       	.word	0x0080	; ????
     434:	00 68       	ori	r16, 0x80	; 128
     436:	98 78       	andi	r25, 0x88	; 136
     438:	08 08       	sbc	r0, r8
     43a:	00 00       	nop
     43c:	b0 c8       	rjmp	.-3744   	; 0xfffff59e <__eeprom_end+0xff7ef59e>
     43e:	80 80       	ld	r8, Z
     440:	80 00       	.word	0x0080	; ????
     442:	00 70       	andi	r16, 0x00	; 0
     444:	80 70       	andi	r24, 0x00	; 0
     446:	08 f0       	brcs	.+2      	; 0x44a <__trampolines_end+0x24e>
     448:	40 40       	sbci	r20, 0x00	; 0
     44a:	e0 40       	sbci	r30, 0x00	; 0
     44c:	40 48       	sbci	r20, 0x80	; 128
     44e:	30 00       	.word	0x0030	; ????
     450:	00 88       	ldd	r0, Z+16	; 0x10
     452:	88 88       	ldd	r8, Y+16	; 0x10
     454:	98 68       	ori	r25, 0x88	; 136
     456:	00 00       	nop
     458:	88 88       	ldd	r8, Y+16	; 0x10
     45a:	88 50       	subi	r24, 0x08	; 8
     45c:	20 00       	.word	0x0020	; ????
     45e:	00 88       	ldd	r0, Z+16	; 0x10
     460:	88 a8       	ldd	r8, Y+48	; 0x30
     462:	a8 50       	subi	r26, 0x08	; 8
     464:	00 00       	nop
     466:	88 50       	subi	r24, 0x08	; 8
     468:	20 50       	subi	r18, 0x00	; 0
     46a:	88 00       	.word	0x0088	; ????
     46c:	00 88       	ldd	r0, Z+16	; 0x10
     46e:	88 78       	andi	r24, 0x88	; 136
     470:	08 70       	andi	r16, 0x08	; 8
     472:	00 00       	nop
     474:	f8 10       	cpse	r15, r8
     476:	20 40       	sbci	r18, 0x00	; 0
     478:	f8 10       	cpse	r15, r8
     47a:	20 20       	and	r2, r0
     47c:	40 20       	and	r4, r0
     47e:	20 10       	cpse	r2, r0
     480:	20 20       	and	r2, r0
     482:	20 20       	and	r2, r0
     484:	20 20       	and	r2, r0
     486:	20 40       	sbci	r18, 0x00	; 0
     488:	20 20       	and	r2, r0
     48a:	10 20       	and	r1, r0
     48c:	20 40       	sbci	r18, 0x00	; 0

0000048e <__ctors_end>:
     48e:	11 24       	eor	r1, r1
     490:	1f be       	out	0x3f, r1	; 63
     492:	cf ef       	ldi	r28, 0xFF	; 255
     494:	cd bf       	out	0x3d, r28	; 61
     496:	df e5       	ldi	r29, 0x5F	; 95
     498:	de bf       	out	0x3e, r29	; 62
     49a:	00 e0       	ldi	r16, 0x00	; 0
     49c:	0c bf       	out	0x3c, r16	; 60

0000049e <__do_copy_data>:
     49e:	10 e2       	ldi	r17, 0x20	; 32
     4a0:	a0 e0       	ldi	r26, 0x00	; 0
     4a2:	b0 e2       	ldi	r27, 0x20	; 32
     4a4:	e2 ea       	ldi	r30, 0xA2	; 162
     4a6:	f8 e4       	ldi	r31, 0x48	; 72
     4a8:	00 e0       	ldi	r16, 0x00	; 0
     4aa:	0b bf       	out	0x3b, r16	; 59
     4ac:	02 c0       	rjmp	.+4      	; 0x4b2 <__do_copy_data+0x14>
     4ae:	07 90       	elpm	r0, Z+
     4b0:	0d 92       	st	X+, r0
     4b2:	a2 33       	cpi	r26, 0x32	; 50
     4b4:	b1 07       	cpc	r27, r17
     4b6:	d9 f7       	brne	.-10     	; 0x4ae <__do_copy_data+0x10>

000004b8 <__do_clear_bss>:
     4b8:	23 e2       	ldi	r18, 0x23	; 35
     4ba:	a2 e3       	ldi	r26, 0x32	; 50
     4bc:	b0 e2       	ldi	r27, 0x20	; 32
     4be:	01 c0       	rjmp	.+2      	; 0x4c2 <.do_clear_bss_start>

000004c0 <.do_clear_bss_loop>:
     4c0:	1d 92       	st	X+, r1

000004c2 <.do_clear_bss_start>:
     4c2:	a9 3e       	cpi	r26, 0xE9	; 233
     4c4:	b2 07       	cpc	r27, r18
     4c6:	e1 f7       	brne	.-8      	; 0x4c0 <.do_clear_bss_loop>
     4c8:	0e 94 65 1d 	call	0x3aca	; 0x3aca <main>
     4cc:	0c 94 4f 24 	jmp	0x489e	; 0x489e <_exit>

000004d0 <__bad_interrupt>:
     4d0:	97 cd       	rjmp	.-1234   	; 0x0 <__vectors>

000004d2 <_1101010101_>:

#if ((_STATIC_PORT_PIN_CONF_ == 1) && (QTOUCH_SNS_PORT_COUNT >= 1))

GLOBAL_FUNCTION _1101010101_
_1101010101_:
    sts	CONCAT( PORT, SNS1, _DIRCLR ), p_1
     4d2:	80 93 a2 06 	sts	0x06A2, r24
    sts	CONCAT( PORT, SNSK1, _DIRCLR ), p_2
     4d6:	60 93 a2 06 	sts	0x06A2, r22
    sts	CONCAT( PORT, SNS1, _OUTSET), p_1
     4da:	80 93 a5 06 	sts	0x06A5, r24
    sts	CONCAT( PORT, SNSK1, _OUTCLR), p_2    
     4de:	60 93 a6 06 	sts	0x06A6, r22
    sts	CONCAT( PORT, SNSK1, _DIRSET), p_2   
     4e2:	60 93 a1 06 	sts	0x06A1, r22
    ret
     4e6:	08 95       	ret

000004e8 <_1101010111_>:


GLOBAL_FUNCTION _1101010111_
_1101010111_:
    push r19
     4e8:	3f 93       	push	r19
    sts	CONCAT( PORT, SNSK1, _DIRCLR), p_2
     4ea:	60 93 a2 06 	sts	0x06A2, r22
    sts	CONCAT( PORT, SNS1, _DIRSET), p_1
     4ee:	80 93 a1 06 	sts	0x06A1, r24
    _10100011_
    _01101001_
    _00011001_
    _00011001_
#endif
    sts	CONCAT( PORT, SNS1, _DIRCLR ), p_1
     4f2:	80 93 a2 06 	sts	0x06A2, r24
    sts	CONCAT( PORT, SNSK1, _DIRSET ), p_2 
     4f6:	60 93 a1 06 	sts	0x06A1, r22
    pop  r19
     4fa:	3f 91       	pop	r19
    lds	r_v, CONCAT(PORT, SNS1, _IN )
     4fc:	80 91 a8 06 	lds	r24, 0x06A8
    and	r_v, p_3
     500:	84 23       	and	r24, r20
    ret
     502:	08 95       	ret

00000504 <_1101010110_>:

GLOBAL_FUNCTION _1101010110_
_1101010110_:
    sts	CONCAT( PORT, SNS1, _OUTCLR), p_1
     504:	80 93 a6 06 	sts	0x06A6, r24
    sts	CONCAT( PORT, SNS1, _DIRSET), p_1
     508:	80 93 a1 06 	sts	0x06A1, r24
    ret
     50c:	08 95       	ret

0000050e <burst_1_1_10_0_1>:
     50e:	a1 e0       	ldi	r26, 0x01	; 1
     510:	b0 e0       	ldi	r27, 0x00	; 0
     512:	ed e8       	ldi	r30, 0x8D	; 141
     514:	f2 e0       	ldi	r31, 0x02	; 2
     516:	0c 94 e6 1f 	jmp	0x3fcc	; 0x3fcc <__prologue_saves__+0xc>
     51a:	e8 2f       	mov	r30, r24
     51c:	0f b7       	in	r16, 0x3f	; 63
     51e:	00 78       	andi	r16, 0x80	; 128
     520:	19 82       	std	Y+1, r1	; 0x01
     522:	80 91 33 20 	lds	r24, 0x2033
     526:	81 30       	cpi	r24, 0x01	; 1
     528:	19 f0       	breq	.+6      	; 0x530 <burst_1_1_10_0_1+0x22>
     52a:	81 e0       	ldi	r24, 0x01	; 1
     52c:	80 93 33 20 	sts	0x2033, r24
     530:	ce 2e       	mov	r12, r30
     532:	dd 24       	eor	r13, r13
     534:	f6 01       	movw	r30, r12
     536:	eb 58       	subi	r30, 0x8B	; 139
     538:	ff 4d       	sbci	r31, 0xDF	; 223
     53a:	b0 80       	ld	r11, Z
     53c:	f6 01       	movw	r30, r12
     53e:	e7 58       	subi	r30, 0x87	; 135
     540:	ff 4d       	sbci	r31, 0xDF	; 223
     542:	a0 80       	ld	r10, Z
     544:	f8 94       	cli
     546:	bb 20       	and	r11, r11
     548:	09 f4       	brne	.+2      	; 0x54c <burst_1_1_10_0_1+0x3e>
     54a:	aa c0       	rjmp	.+340    	; 0x6a0 <burst_1_1_10_0_1+0x192>
     54c:	8b 2d       	mov	r24, r11
     54e:	da df       	rcall	.-76     	; 0x504 <_1101010110_>
     550:	8b 2d       	mov	r24, r11
     552:	6a 2d       	mov	r22, r10
     554:	be df       	rcall	.-132    	; 0x4d2 <_1101010101_>
     556:	1b 2d       	mov	r17, r11
     558:	ee 24       	eor	r14, r14
     55a:	ff 24       	eor	r15, r15
     55c:	60 e0       	ldi	r22, 0x00	; 0
     55e:	81 2c       	mov	r8, r1
     560:	30 e2       	ldi	r19, 0x20	; 32
     562:	93 2e       	mov	r9, r19
     564:	f5 fe       	sbrs	r15, 5
     566:	07 c0       	rjmp	.+14     	; 0x576 <burst_1_1_10_0_1+0x68>
     568:	90 91 76 20 	lds	r25, 0x2076
     56c:	80 91 75 20 	lds	r24, 0x2075
     570:	98 2b       	or	r25, r24
     572:	19 f5       	brne	.+70     	; 0x5ba <burst_1_1_10_0_1+0xac>
     574:	35 c0       	rjmp	.+106    	; 0x5e0 <burst_1_1_10_0_1+0xd2>
     576:	8f b7       	in	r24, 0x3f	; 63
     578:	80 2b       	or	r24, r16
     57a:	8f bf       	out	0x3f, r24	; 63
     57c:	00 00       	nop
     57e:	f8 94       	cli
     580:	8b 2d       	mov	r24, r11
     582:	6a 2d       	mov	r22, r10
     584:	41 2f       	mov	r20, r17
     586:	b0 df       	rcall	.-160    	; 0x4e8 <_1101010111_>
     588:	68 2f       	mov	r22, r24
     58a:	08 94       	sec
     58c:	e1 1c       	adc	r14, r1
     58e:	f1 1c       	adc	r15, r1
     590:	80 91 00 20 	lds	r24, 0x2000
     594:	8f 5f       	subi	r24, 0xFF	; 255
     596:	80 93 00 20 	sts	0x2000, r24
     59a:	82 30       	cpi	r24, 0x02	; 2
     59c:	30 f0       	brcs	.+12     	; 0x5aa <burst_1_1_10_0_1+0x9c>
     59e:	82 30       	cpi	r24, 0x02	; 2
     5a0:	21 f0       	breq	.+8      	; 0x5aa <burst_1_1_10_0_1+0x9c>
     5a2:	83 30       	cpi	r24, 0x03	; 3
     5a4:	11 f0       	breq	.+4      	; 0x5aa <burst_1_1_10_0_1+0x9c>
     5a6:	10 92 00 20 	sts	0x2000, r1
     5aa:	66 23       	and	r22, r22
     5ac:	d9 f2       	breq	.-74     	; 0x564 <burst_1_1_10_0_1+0x56>
     5ae:	20 91 76 20 	lds	r18, 0x2076
     5b2:	80 91 75 20 	lds	r24, 0x2075
     5b6:	28 2b       	or	r18, r24
     5b8:	15 c0       	rjmp	.+42     	; 0x5e4 <burst_1_1_10_0_1+0xd6>
     5ba:	41 2f       	mov	r20, r17
     5bc:	80 e0       	ldi	r24, 0x00	; 0
     5be:	40 ff       	sbrs	r20, 0
     5c0:	09 c0       	rjmp	.+18     	; 0x5d4 <burst_1_1_10_0_1+0xc6>
     5c2:	e8 2f       	mov	r30, r24
     5c4:	f0 e0       	ldi	r31, 0x00	; 0
     5c6:	ee 0f       	add	r30, r30
     5c8:	ff 1f       	adc	r31, r31
     5ca:	e2 5c       	subi	r30, 0xC2	; 194
     5cc:	ff 4d       	sbci	r31, 0xDF	; 223
     5ce:	80 82       	st	Z, r8
     5d0:	91 82       	std	Z+1, r9	; 0x01
     5d2:	01 c0       	rjmp	.+2      	; 0x5d6 <burst_1_1_10_0_1+0xc8>
     5d4:	90 fd       	sbrc	r25, 0
     5d6:	8f 5f       	subi	r24, 0xFF	; 255
     5d8:	96 95       	lsr	r25
     5da:	46 95       	lsr	r20
     5dc:	99 23       	and	r25, r25
     5de:	79 f7       	brne	.-34     	; 0x5be <burst_1_1_10_0_1+0xb0>
     5e0:	10 e0       	ldi	r17, 0x00	; 0
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	8f b7       	in	r24, 0x3f	; 63
     5e6:	80 2b       	or	r24, r16
     5e8:	8f bf       	out	0x3f, r24	; 63
     5ea:	10 92 34 20 	sts	0x2034, r1
     5ee:	22 23       	and	r18, r18
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <burst_1_1_10_0_1+0xe6>
     5f2:	3f c0       	rjmp	.+126    	; 0x672 <burst_1_1_10_0_1+0x164>
     5f4:	11 23       	and	r17, r17
     5f6:	09 f4       	brne	.+2      	; 0x5fa <burst_1_1_10_0_1+0xec>
     5f8:	3c c0       	rjmp	.+120    	; 0x672 <burst_1_1_10_0_1+0x164>
     5fa:	30 91 7a 20 	lds	r19, 0x207A
     5fe:	80 91 79 20 	lds	r24, 0x2079
     602:	38 2b       	or	r19, r24
     604:	56 2f       	mov	r21, r22
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	80 e0       	ldi	r24, 0x00	; 0
     60a:	70 e0       	ldi	r23, 0x00	; 0
     60c:	40 e0       	ldi	r20, 0x00	; 0
     60e:	23 c0       	rjmp	.+70     	; 0x656 <burst_1_1_10_0_1+0x148>
     610:	50 fd       	sbrc	r21, 0
     612:	17 c0       	rjmp	.+46     	; 0x642 <burst_1_1_10_0_1+0x134>
     614:	19 c0       	rjmp	.+50     	; 0x648 <burst_1_1_10_0_1+0x13a>
     616:	30 ff       	sbrs	r19, 0
     618:	13 c0       	rjmp	.+38     	; 0x640 <burst_1_1_10_0_1+0x132>
     61a:	98 17       	cp	r25, r24
     61c:	81 f4       	brne	.+32     	; 0x63e <burst_1_1_10_0_1+0x130>
     61e:	e4 2f       	mov	r30, r20
     620:	f0 e0       	ldi	r31, 0x00	; 0
     622:	ee 0f       	add	r30, r30
     624:	ff 1f       	adc	r31, r31
     626:	e2 5c       	subi	r30, 0xC2	; 194
     628:	ff 4d       	sbci	r31, 0xDF	; 223
     62a:	e0 82       	st	Z, r14
     62c:	f1 82       	std	Z+1, r15	; 0x01
     62e:	85 2f       	mov	r24, r21
     630:	8e 7f       	andi	r24, 0xFE	; 254
     632:	19 f4       	brne	.+6      	; 0x63a <burst_1_1_10_0_1+0x12c>
     634:	89 2f       	mov	r24, r25
     636:	71 e0       	ldi	r23, 0x01	; 1
     638:	08 c0       	rjmp	.+16     	; 0x64a <burst_1_1_10_0_1+0x13c>
     63a:	89 2f       	mov	r24, r25
     63c:	06 c0       	rjmp	.+12     	; 0x64a <burst_1_1_10_0_1+0x13c>
     63e:	8f 5f       	subi	r24, 0xFF	; 255
     640:	36 95       	lsr	r19
     642:	33 23       	and	r19, r19
     644:	41 f7       	brne	.-48     	; 0x616 <burst_1_1_10_0_1+0x108>
     646:	01 c0       	rjmp	.+2      	; 0x64a <burst_1_1_10_0_1+0x13c>
     648:	20 fd       	sbrc	r18, 0
     64a:	9f 5f       	subi	r25, 0xFF	; 255
     64c:	20 fd       	sbrc	r18, 0
     64e:	4f 5f       	subi	r20, 0xFF	; 255
     650:	56 95       	lsr	r21
     652:	26 95       	lsr	r18
     654:	11 f0       	breq	.+4      	; 0x65a <burst_1_1_10_0_1+0x14c>
     656:	55 23       	and	r21, r21
     658:	d9 f6       	brne	.-74     	; 0x610 <burst_1_1_10_0_1+0x102>
     65a:	40 93 34 20 	sts	0x2034, r20
     65e:	60 95       	com	r22
     660:	16 23       	and	r17, r22
     662:	71 30       	cpi	r23, 0x01	; 1
     664:	21 f4       	brne	.+8      	; 0x66e <burst_1_1_10_0_1+0x160>
     666:	11 23       	and	r17, r17
     668:	11 f4       	brne	.+4      	; 0x66e <burst_1_1_10_0_1+0x160>
     66a:	ee 24       	eor	r14, r14
     66c:	ff 24       	eor	r15, r15
     66e:	60 e0       	ldi	r22, 0x00	; 0
     670:	13 c0       	rjmp	.+38     	; 0x698 <burst_1_1_10_0_1+0x18a>
     672:	80 91 76 20 	lds	r24, 0x2076
     676:	90 91 75 20 	lds	r25, 0x2075
     67a:	89 2b       	or	r24, r25
     67c:	89 83       	std	Y+1, r24	; 0x01
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	06 c0       	rjmp	.+12     	; 0x68e <burst_1_1_10_0_1+0x180>
     682:	89 81       	ldd	r24, Y+1	; 0x01
     684:	80 fd       	sbrc	r24, 0
     686:	9f 5f       	subi	r25, 0xFF	; 255
     688:	89 81       	ldd	r24, Y+1	; 0x01
     68a:	86 95       	lsr	r24
     68c:	89 83       	std	Y+1, r24	; 0x01
     68e:	89 81       	ldd	r24, Y+1	; 0x01
     690:	88 23       	and	r24, r24
     692:	b9 f7       	brne	.-18     	; 0x682 <burst_1_1_10_0_1+0x174>
     694:	90 93 34 20 	sts	0x2034, r25
     698:	f8 94       	cli
     69a:	11 23       	and	r17, r17
     69c:	09 f0       	breq	.+2      	; 0x6a0 <burst_1_1_10_0_1+0x192>
     69e:	62 cf       	rjmp	.-316    	; 0x564 <burst_1_1_10_0_1+0x56>
     6a0:	85 e7       	ldi	r24, 0x75	; 117
     6a2:	90 e2       	ldi	r25, 0x20	; 32
     6a4:	c8 0e       	add	r12, r24
     6a6:	d9 1e       	adc	r13, r25
     6a8:	f6 01       	movw	r30, r12
     6aa:	80 81       	ld	r24, Z
     6ac:	2b df       	rcall	.-426    	; 0x504 <_1101010110_>
     6ae:	10 92 32 20 	sts	0x2032, r1
     6b2:	8f b7       	in	r24, 0x3f	; 63
     6b4:	08 2b       	or	r16, r24
     6b6:	0f bf       	out	0x3f, r16	; 63
     6b8:	21 96       	adiw	r28, 0x01	; 1
     6ba:	ec e0       	ldi	r30, 0x0C	; 12
     6bc:	0c 94 ff 1f 	jmp	0x3ffe	; 0x3ffe <__epilogue_restores__+0xc>

000006c0 <qt_get_library_sig>:
     6c0:	fc 01       	movw	r30, r24
     6c2:	80 e2       	ldi	r24, 0x20	; 32
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	80 83       	st	Z, r24
     6c8:	91 83       	std	Z+1, r25	; 0x01
     6ca:	12 82       	std	Z+2, r1	; 0x02
     6cc:	13 82       	std	Z+3, r1	; 0x03
     6ce:	80 e4       	ldi	r24, 0x40	; 64
     6d0:	94 e0       	ldi	r25, 0x04	; 4
     6d2:	84 83       	std	Z+4, r24	; 0x04
     6d4:	95 83       	std	Z+5, r25	; 0x05
     6d6:	08 95       	ret

000006d8 <qt_enable_key>:
     6d8:	90 91 6f 20 	lds	r25, 0x206F
     6dc:	a9 2f       	mov	r26, r25
     6de:	b0 e0       	ldi	r27, 0x00	; 0
     6e0:	fd 01       	movw	r30, r26
     6e2:	ee 0f       	add	r30, r30
     6e4:	ff 1f       	adc	r31, r31
     6e6:	ea 0f       	add	r30, r26
     6e8:	fb 1f       	adc	r31, r27
     6ea:	ee 0f       	add	r30, r30
     6ec:	ff 1f       	adc	r31, r31
     6ee:	e9 5a       	subi	r30, 0xA9	; 169
     6f0:	ff 4d       	sbci	r31, 0xDF	; 223
     6f2:	43 83       	std	Z+3, r20	; 0x03
     6f4:	67 70       	andi	r22, 0x07	; 7
     6f6:	85 83       	std	Z+5, r24	; 0x05
     6f8:	23 70       	andi	r18, 0x03	; 3
     6fa:	66 0f       	add	r22, r22
     6fc:	66 0f       	add	r22, r22
     6fe:	66 0f       	add	r22, r22
     700:	26 2b       	or	r18, r22
     702:	24 83       	std	Z+4, r18	; 0x04
     704:	9f 5f       	subi	r25, 0xFF	; 255
     706:	90 93 6f 20 	sts	0x206F, r25
     70a:	08 95       	ret

0000070c <qt_get_sensor_delta>:
     70c:	1f 93       	push	r17
     70e:	cf 93       	push	r28
     710:	df 93       	push	r29
     712:	28 2f       	mov	r18, r24
     714:	c8 2f       	mov	r28, r24
     716:	d0 e0       	ldi	r29, 0x00	; 0
     718:	fe 01       	movw	r30, r28
     71a:	ee 0f       	add	r30, r30
     71c:	ff 1f       	adc	r31, r31
     71e:	ec 0f       	add	r30, r28
     720:	fd 1f       	adc	r31, r29
     722:	ee 0f       	add	r30, r30
     724:	ff 1f       	adc	r31, r31
     726:	e9 5a       	subi	r30, 0xA9	; 169
     728:	ff 4d       	sbci	r31, 0xDF	; 223
     72a:	35 81       	ldd	r19, Z+5	; 0x05
     72c:	83 81       	ldd	r24, Z+3	; 0x03
     72e:	90 e0       	ldi	r25, 0x00	; 0
     730:	00 90 37 20 	lds	r0, 0x2037
     734:	02 c0       	rjmp	.+4      	; 0x73a <qt_get_sensor_delta+0x2e>
     736:	95 95       	asr	r25
     738:	87 95       	ror	r24
     73a:	0a 94       	dec	r0
     73c:	e2 f7       	brpl	.-8      	; 0x736 <qt_get_sensor_delta+0x2a>
     73e:	18 2f       	mov	r17, r24
     740:	84 30       	cpi	r24, 0x04	; 4
     742:	08 f4       	brcc	.+2      	; 0x746 <qt_get_sensor_delta+0x3a>
     744:	14 e0       	ldi	r17, 0x04	; 4
     746:	80 91 6f 20 	lds	r24, 0x206F
     74a:	28 17       	cp	r18, r24
     74c:	18 f0       	brcs	.+6      	; 0x754 <qt_get_sensor_delta+0x48>
     74e:	20 e0       	ldi	r18, 0x00	; 0
     750:	30 e0       	ldi	r19, 0x00	; 0
     752:	2d c0       	rjmp	.+90     	; 0x7ae <qt_get_sensor_delta+0xa2>
     754:	83 2f       	mov	r24, r19
     756:	1d d1       	rcall	.+570    	; 0x992 <get_channel_delta>
     758:	9c 01       	movw	r18, r24
     75a:	41 2f       	mov	r20, r17
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	16 95       	lsr	r17
     760:	16 95       	lsr	r17
     762:	81 2f       	mov	r24, r17
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	84 1b       	sub	r24, r20
     768:	95 0b       	sbc	r25, r21
     76a:	82 17       	cp	r24, r18
     76c:	93 07       	cpc	r25, r19
     76e:	64 f4       	brge	.+24     	; 0x788 <qt_get_sensor_delta+0x7c>
     770:	fe 01       	movw	r30, r28
     772:	ee 0f       	add	r30, r30
     774:	ff 1f       	adc	r31, r31
     776:	ec 0f       	add	r30, r28
     778:	fd 1f       	adc	r31, r29
     77a:	ee 0f       	add	r30, r30
     77c:	ff 1f       	adc	r31, r31
     77e:	e9 5a       	subi	r30, 0xA9	; 169
     780:	ff 4d       	sbci	r31, 0xDF	; 223
     782:	84 81       	ldd	r24, Z+4	; 0x04
     784:	8b 7f       	andi	r24, 0xFB	; 251
     786:	84 83       	std	Z+4, r24	; 0x04
     788:	88 27       	eor	r24, r24
     78a:	99 27       	eor	r25, r25
     78c:	84 1b       	sub	r24, r20
     78e:	95 0b       	sbc	r25, r21
     790:	82 17       	cp	r24, r18
     792:	93 07       	cpc	r25, r19
     794:	64 f0       	brlt	.+24     	; 0x7ae <qt_get_sensor_delta+0xa2>
     796:	fe 01       	movw	r30, r28
     798:	ee 0f       	add	r30, r30
     79a:	ff 1f       	adc	r31, r31
     79c:	ec 0f       	add	r30, r28
     79e:	fd 1f       	adc	r31, r29
     7a0:	ee 0f       	add	r30, r30
     7a2:	ff 1f       	adc	r31, r31
     7a4:	e9 5a       	subi	r30, 0xA9	; 169
     7a6:	ff 4d       	sbci	r31, 0xDF	; 223
     7a8:	84 81       	ldd	r24, Z+4	; 0x04
     7aa:	84 60       	ori	r24, 0x04	; 4
     7ac:	84 83       	std	Z+4, r24	; 0x04
     7ae:	c9 01       	movw	r24, r18
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	1f 91       	pop	r17
     7b6:	08 95       	ret

000007b8 <qt_measure_sensors>:
     7b8:	ff 92       	push	r15
     7ba:	0f 93       	push	r16
     7bc:	1f 93       	push	r17
     7be:	cf 93       	push	r28
     7c0:	df 93       	push	r29
     7c2:	10 92 4f 20 	sts	0x204F, r1
     7c6:	10 92 50 20 	sts	0x2050, r1
     7ca:	20 91 53 20 	lds	r18, 0x2053
     7ce:	30 91 54 20 	lds	r19, 0x2054
     7d2:	80 93 53 20 	sts	0x2053, r24
     7d6:	90 93 54 20 	sts	0x2054, r25
     7da:	40 91 55 20 	lds	r20, 0x2055
     7de:	50 91 56 20 	lds	r21, 0x2056
     7e2:	42 1b       	sub	r20, r18
     7e4:	53 0b       	sbc	r21, r19
     7e6:	48 0f       	add	r20, r24
     7e8:	59 1f       	adc	r21, r25
     7ea:	ff 24       	eor	r15, r15
     7ec:	03 c0       	rjmp	.+6      	; 0x7f4 <qt_measure_sensors+0x3c>
     7ee:	f3 94       	inc	r15
     7f0:	48 5c       	subi	r20, 0xC8	; 200
     7f2:	50 40       	sbci	r21, 0x00	; 0
     7f4:	48 3c       	cpi	r20, 0xC8	; 200
     7f6:	51 05       	cpc	r21, r1
     7f8:	d0 f7       	brcc	.-12     	; 0x7ee <qt_measure_sensors+0x36>
     7fa:	40 93 55 20 	sts	0x2055, r20
     7fe:	50 93 56 20 	sts	0x2056, r21
     802:	80 91 70 20 	lds	r24, 0x2070
     806:	88 23       	and	r24, r24
     808:	41 f0       	breq	.+16     	; 0x81a <qt_measure_sensors+0x62>
     80a:	8f 15       	cp	r24, r15
     80c:	18 f4       	brcc	.+6      	; 0x814 <qt_measure_sensors+0x5c>
     80e:	10 92 70 20 	sts	0x2070, r1
     812:	03 c0       	rjmp	.+6      	; 0x81a <qt_measure_sensors+0x62>
     814:	8f 19       	sub	r24, r15
     816:	80 93 70 20 	sts	0x2070, r24
     81a:	c3 d3       	rcall	.+1926   	; 0xfa2 <burst>
     81c:	e0 91 51 20 	lds	r30, 0x2051
     820:	f0 91 52 20 	lds	r31, 0x2052
     824:	30 97       	sbiw	r30, 0x00	; 0
     826:	09 f0       	breq	.+2      	; 0x82a <qt_measure_sensors+0x72>
     828:	19 95       	eicall
     82a:	10 e0       	ldi	r17, 0x00	; 0
     82c:	00 e0       	ldi	r16, 0x00	; 0
     82e:	05 c0       	rjmp	.+10     	; 0x83a <qt_measure_sensors+0x82>
     830:	81 2f       	mov	r24, r17
     832:	6f 2d       	mov	r22, r15
     834:	c3 d0       	rcall	.+390    	; 0x9bc <process_sensor>
     836:	08 2b       	or	r16, r24
     838:	1f 5f       	subi	r17, 0xFF	; 255
     83a:	60 91 6f 20 	lds	r22, 0x206F
     83e:	16 17       	cp	r17, r22
     840:	b8 f3       	brcs	.-18     	; 0x830 <qt_measure_sensors+0x78>
     842:	00 23       	and	r16, r16
     844:	49 f0       	breq	.+18     	; 0x858 <qt_measure_sensors+0xa0>
     846:	80 91 4f 20 	lds	r24, 0x204F
     84a:	90 91 50 20 	lds	r25, 0x2050
     84e:	91 60       	ori	r25, 0x01	; 1
     850:	80 93 4f 20 	sts	0x204F, r24
     854:	90 93 50 20 	sts	0x2050, r25
     858:	10 92 4e 20 	sts	0x204E, r1
     85c:	a7 e5       	ldi	r26, 0x57	; 87
     85e:	b0 e2       	ldi	r27, 0x20	; 32
     860:	30 e0       	ldi	r19, 0x00	; 0
     862:	41 e0       	ldi	r20, 0x01	; 1
     864:	50 e0       	ldi	r21, 0x00	; 0
     866:	17 c0       	rjmp	.+46     	; 0x896 <qt_measure_sensors+0xde>
     868:	8c 91       	ld	r24, X
     86a:	88 71       	andi	r24, 0x18	; 24
     86c:	91 f0       	breq	.+36     	; 0x892 <qt_measure_sensors+0xda>
     86e:	e3 2f       	mov	r30, r19
     870:	e6 95       	lsr	r30
     872:	e6 95       	lsr	r30
     874:	e6 95       	lsr	r30
     876:	f0 e0       	ldi	r31, 0x00	; 0
     878:	e2 5c       	subi	r30, 0xC2	; 194
     87a:	ff 4d       	sbci	r31, 0xDF	; 223
     87c:	83 2f       	mov	r24, r19
     87e:	87 70       	andi	r24, 0x07	; 7
     880:	ea 01       	movw	r28, r20
     882:	02 c0       	rjmp	.+4      	; 0x888 <qt_measure_sensors+0xd0>
     884:	cc 0f       	add	r28, r28
     886:	dd 1f       	adc	r29, r29
     888:	8a 95       	dec	r24
     88a:	e2 f7       	brpl	.-8      	; 0x884 <qt_measure_sensors+0xcc>
     88c:	20 89       	ldd	r18, Z+16	; 0x10
     88e:	2c 2b       	or	r18, r28
     890:	20 8b       	std	Z+16, r18	; 0x10
     892:	3f 5f       	subi	r19, 0xFF	; 255
     894:	16 96       	adiw	r26, 0x06	; 6
     896:	36 17       	cp	r19, r22
     898:	38 f3       	brcs	.-50     	; 0x868 <qt_measure_sensors+0xb0>
     89a:	80 91 4f 20 	lds	r24, 0x204F
     89e:	90 91 50 20 	lds	r25, 0x2050
     8a2:	cd b7       	in	r28, 0x3d	; 61
     8a4:	de b7       	in	r29, 0x3e	; 62
     8a6:	e5 e0       	ldi	r30, 0x05	; 5
     8a8:	0c 94 06 20 	jmp	0x400c	; 0x400c <__epilogue_restores__+0x1a>

000008ac <qt_reset_sensing>:
     8ac:	10 92 6f 20 	sts	0x206F, r1
     8b0:	84 e0       	ldi	r24, 0x04	; 4
     8b2:	80 93 38 20 	sts	0x2038, r24
     8b6:	94 e1       	ldi	r25, 0x14	; 20
     8b8:	90 93 3b 20 	sts	0x203B, r25
     8bc:	85 e0       	ldi	r24, 0x05	; 5
     8be:	80 93 3c 20 	sts	0x203C, r24
     8c2:	10 92 3a 20 	sts	0x203A, r1
     8c6:	90 93 39 20 	sts	0x2039, r25
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	80 93 37 20 	sts	0x2037, r24
     8d0:	83 e0       	ldi	r24, 0x03	; 3
     8d2:	80 93 3d 20 	sts	0x203D, r24
     8d6:	54 d3       	rcall	.+1704   	; 0xf80 <burst_reset>
     8d8:	10 92 51 20 	sts	0x2051, r1
     8dc:	10 92 52 20 	sts	0x2052, r1
     8e0:	08 95       	ret

000008e2 <qt_calibrate_sensing>:
     8e2:	1f 93       	push	r17
     8e4:	10 e0       	ldi	r17, 0x00	; 0
     8e6:	03 c0       	rjmp	.+6      	; 0x8ee <qt_calibrate_sensing+0xc>
     8e8:	81 2f       	mov	r24, r17
     8ea:	27 d0       	rcall	.+78     	; 0x93a <start_cal_sensor>
     8ec:	1f 5f       	subi	r17, 0xFF	; 255
     8ee:	80 91 6f 20 	lds	r24, 0x206F
     8f2:	18 17       	cp	r17, r24
     8f4:	c8 f3       	brcs	.-14     	; 0x8e8 <qt_calibrate_sensing+0x6>
     8f6:	1f 91       	pop	r17
     8f8:	08 95       	ret

000008fa <qt_init_sensing_with_burst>:
     8fa:	ef 92       	push	r14
     8fc:	ff 92       	push	r15
     8fe:	1f 93       	push	r17
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
     904:	ec 01       	movw	r28, r24
     906:	7b 01       	movw	r14, r22
     908:	10 e0       	ldi	r17, 0x00	; 0
     90a:	03 c0       	rjmp	.+6      	; 0x912 <qt_init_sensing_with_burst+0x18>
     90c:	81 2f       	mov	r24, r17
     90e:	15 d0       	rcall	.+42     	; 0x93a <start_cal_sensor>
     910:	1f 5f       	subi	r17, 0xFF	; 255
     912:	80 91 6f 20 	lds	r24, 0x206F
     916:	18 17       	cp	r17, r24
     918:	c8 f3       	brcs	.-14     	; 0x90c <qt_init_sensing_with_burst+0x12>
     91a:	10 92 53 20 	sts	0x2053, r1
     91e:	10 92 54 20 	sts	0x2054, r1
     922:	c0 93 35 20 	sts	0x2035, r28
     926:	d0 93 36 20 	sts	0x2036, r29
     92a:	c7 01       	movw	r24, r14
     92c:	24 d3       	rcall	.+1608   	; 0xf76 <burst_init>
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	1f 91       	pop	r17
     934:	ff 90       	pop	r15
     936:	ef 90       	pop	r14
     938:	08 95       	ret

0000093a <start_cal_sensor>:
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	e7 e5       	ldi	r30, 0x57	; 87
     93e:	f0 e2       	ldi	r31, 0x20	; 32
     940:	9c 01       	movw	r18, r24
     942:	22 0f       	add	r18, r18
     944:	33 1f       	adc	r19, r19
     946:	28 0f       	add	r18, r24
     948:	39 1f       	adc	r19, r25
     94a:	d9 01       	movw	r26, r18
     94c:	aa 0f       	add	r26, r26
     94e:	bb 1f       	adc	r27, r27
     950:	ae 0f       	add	r26, r30
     952:	bf 1f       	adc	r27, r31
     954:	15 96       	adiw	r26, 0x05	; 5
     956:	4c 91       	ld	r20, X
     958:	15 97       	sbiw	r26, 0x05	; 5
     95a:	80 91 4f 20 	lds	r24, 0x204F
     95e:	90 91 50 20 	lds	r25, 0x2050
     962:	82 60       	ori	r24, 0x02	; 2
     964:	80 93 4f 20 	sts	0x204F, r24
     968:	90 93 50 20 	sts	0x2050, r25
     96c:	2f 5f       	subi	r18, 0xFF	; 255
     96e:	3f 4f       	sbci	r19, 0xFF	; 255
     970:	22 0f       	add	r18, r18
     972:	33 1f       	adc	r19, r19
     974:	e2 0f       	add	r30, r18
     976:	f3 1f       	adc	r31, r19
     978:	10 82       	st	Z, r1
     97a:	e1 e7       	ldi	r30, 0x71	; 113
     97c:	f0 e2       	ldi	r31, 0x20	; 32
     97e:	e4 0f       	add	r30, r20
     980:	f1 1d       	adc	r31, r1
     982:	80 e8       	ldi	r24, 0x80	; 128
     984:	80 83       	st	Z, r24
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	8c 93       	st	X, r24
     98a:	8f e0       	ldi	r24, 0x0F	; 15
     98c:	11 96       	adiw	r26, 0x01	; 1
     98e:	8c 93       	st	X, r24
     990:	08 95       	ret

00000992 <get_channel_delta>:
     992:	90 e0       	ldi	r25, 0x00	; 0
     994:	fc 01       	movw	r30, r24
     996:	34 96       	adiw	r30, 0x04	; 4
     998:	ae e3       	ldi	r26, 0x3E	; 62
     99a:	b0 e2       	ldi	r27, 0x20	; 32
     99c:	ee 0f       	add	r30, r30
     99e:	ff 1f       	adc	r31, r31
     9a0:	ea 0f       	add	r30, r26
     9a2:	fb 1f       	adc	r31, r27
     9a4:	88 0f       	add	r24, r24
     9a6:	99 1f       	adc	r25, r25
     9a8:	a8 0f       	add	r26, r24
     9aa:	b9 1f       	adc	r27, r25
     9ac:	20 81       	ld	r18, Z
     9ae:	31 81       	ldd	r19, Z+1	; 0x01
     9b0:	8d 91       	ld	r24, X+
     9b2:	9c 91       	ld	r25, X
     9b4:	28 1b       	sub	r18, r24
     9b6:	39 0b       	sbc	r19, r25
     9b8:	c9 01       	movw	r24, r18
     9ba:	08 95       	ret

000009bc <process_sensor>:
     9bc:	a0 e0       	ldi	r26, 0x00	; 0
     9be:	b0 e0       	ldi	r27, 0x00	; 0
     9c0:	e4 ee       	ldi	r30, 0xE4	; 228
     9c2:	f4 e0       	ldi	r31, 0x04	; 4
     9c4:	0c 94 e4 1f 	jmp	0x3fc8	; 0x3fc8 <__prologue_saves__+0x8>
     9c8:	78 2e       	mov	r7, r24
     9ca:	f6 2e       	mov	r15, r22
     9cc:	9f de       	rcall	.-706    	; 0x70c <qt_get_sensor_delta>
     9ce:	5c 01       	movw	r10, r24
     9d0:	07 2d       	mov	r16, r7
     9d2:	10 e0       	ldi	r17, 0x00	; 0
     9d4:	f8 01       	movw	r30, r16
     9d6:	ee 0f       	add	r30, r30
     9d8:	ff 1f       	adc	r31, r31
     9da:	e0 0f       	add	r30, r16
     9dc:	f1 1f       	adc	r31, r17
     9de:	ee 0f       	add	r30, r30
     9e0:	ff 1f       	adc	r31, r31
     9e2:	e9 5a       	subi	r30, 0xA9	; 169
     9e4:	ff 4d       	sbci	r31, 0xDF	; 223
     9e6:	54 81       	ldd	r21, Z+4	; 0x04
     9e8:	43 81       	ldd	r20, Z+3	; 0x03
     9ea:	24 2f       	mov	r18, r20
     9ec:	30 e0       	ldi	r19, 0x00	; 0
     9ee:	85 2f       	mov	r24, r21
     9f0:	83 70       	andi	r24, 0x03	; 3
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	01 96       	adiw	r24, 0x01	; 1
     9f6:	02 c0       	rjmp	.+4      	; 0x9fc <process_sensor+0x40>
     9f8:	35 95       	asr	r19
     9fa:	27 95       	ror	r18
     9fc:	8a 95       	dec	r24
     9fe:	e2 f7       	brpl	.-8      	; 0x9f8 <process_sensor+0x3c>
     a00:	82 2f       	mov	r24, r18
     a02:	22 30       	cpi	r18, 0x02	; 2
     a04:	08 f4       	brcc	.+2      	; 0xa08 <process_sensor+0x4c>
     a06:	82 e0       	ldi	r24, 0x02	; 2
     a08:	24 2f       	mov	r18, r20
     a0a:	30 e0       	ldi	r19, 0x00	; 0
     a0c:	b9 01       	movw	r22, r18
     a0e:	68 1b       	sub	r22, r24
     a10:	71 09       	sbc	r23, r1
     a12:	f8 01       	movw	r30, r16
     a14:	ee 0f       	add	r30, r30
     a16:	ff 1f       	adc	r31, r31
     a18:	e0 0f       	add	r30, r16
     a1a:	f1 1f       	adc	r31, r17
     a1c:	ef 01       	movw	r28, r30
     a1e:	cc 0f       	add	r28, r28
     a20:	dd 1f       	adc	r29, r29
     a22:	c9 5a       	subi	r28, 0xA9	; 169
     a24:	df 4d       	sbci	r29, 0xDF	; 223
     a26:	88 81       	ld	r24, Y
     a28:	84 30       	cpi	r24, 0x04	; 4
     a2a:	09 f4       	brne	.+2      	; 0xa2e <process_sensor+0x72>
     a2c:	fb c0       	rjmp	.+502    	; 0xc24 <process_sensor+0x268>
     a2e:	85 30       	cpi	r24, 0x05	; 5
     a30:	30 f4       	brcc	.+12     	; 0xa3e <process_sensor+0x82>
     a32:	81 30       	cpi	r24, 0x01	; 1
     a34:	71 f0       	breq	.+28     	; 0xa52 <process_sensor+0x96>
     a36:	82 30       	cpi	r24, 0x02	; 2
     a38:	09 f0       	breq	.+2      	; 0xa3c <process_sensor+0x80>
     a3a:	96 c2       	rjmp	.+1324   	; 0xf68 <process_sensor+0x5ac>
     a3c:	6e c0       	rjmp	.+220    	; 0xb1a <process_sensor+0x15e>
     a3e:	80 31       	cpi	r24, 0x10	; 16
     a40:	09 f4       	brne	.+2      	; 0xa44 <process_sensor+0x88>
     a42:	a5 c1       	rjmp	.+842    	; 0xd8e <process_sensor+0x3d2>
     a44:	80 32       	cpi	r24, 0x20	; 32
     a46:	09 f4       	brne	.+2      	; 0xa4a <process_sensor+0x8e>
     a48:	56 c2       	rjmp	.+1196   	; 0xef6 <process_sensor+0x53a>
     a4a:	88 30       	cpi	r24, 0x08	; 8
     a4c:	09 f0       	breq	.+2      	; 0xa50 <process_sensor+0x94>
     a4e:	8c c2       	rjmp	.+1304   	; 0xf68 <process_sensor+0x5ac>
     a50:	02 c2       	rjmp	.+1028   	; 0xe56 <process_sensor+0x49a>
     a52:	40 91 4f 20 	lds	r20, 0x204F
     a56:	50 91 50 20 	lds	r21, 0x2050
     a5a:	ca 01       	movw	r24, r20
     a5c:	92 60       	ori	r25, 0x02	; 2
     a5e:	80 93 4f 20 	sts	0x204F, r24
     a62:	90 93 50 20 	sts	0x2050, r25
     a66:	8d 81       	ldd	r24, Y+5	; 0x05
     a68:	69 81       	ldd	r22, Y+1	; 0x01
     a6a:	a8 2f       	mov	r26, r24
     a6c:	b0 e0       	ldi	r27, 0x00	; 0
     a6e:	6a 30       	cpi	r22, 0x0A	; 10
     a70:	60 f0       	brcs	.+24     	; 0xa8a <process_sensor+0xce>
     a72:	aa 0f       	add	r26, r26
     a74:	bb 1f       	adc	r27, r27
     a76:	fd 01       	movw	r30, r26
     a78:	e2 5c       	subi	r30, 0xC2	; 194
     a7a:	ff 4d       	sbci	r31, 0xDF	; 223
     a7c:	80 81       	ld	r24, Z
     a7e:	91 81       	ldd	r25, Z+1	; 0x01
     a80:	aa 5b       	subi	r26, 0xBA	; 186
     a82:	bf 4d       	sbci	r27, 0xDF	; 223
     a84:	8d 93       	st	X+, r24
     a86:	9c 93       	st	X, r25
     a88:	18 c0       	rjmp	.+48     	; 0xaba <process_sensor+0xfe>
     a8a:	aa 0f       	add	r26, r26
     a8c:	bb 1f       	adc	r27, r27
     a8e:	fd 01       	movw	r30, r26
     a90:	ea 5b       	subi	r30, 0xBA	; 186
     a92:	ff 4d       	sbci	r31, 0xDF	; 223
     a94:	20 81       	ld	r18, Z
     a96:	31 81       	ldd	r19, Z+1	; 0x01
     a98:	a2 5c       	subi	r26, 0xC2	; 194
     a9a:	bf 4d       	sbci	r27, 0xDF	; 223
     a9c:	8d 91       	ld	r24, X+
     a9e:	9c 91       	ld	r25, X
     aa0:	82 17       	cp	r24, r18
     aa2:	93 07       	cpc	r25, r19
     aa4:	18 f4       	brcc	.+6      	; 0xaac <process_sensor+0xf0>
     aa6:	21 50       	subi	r18, 0x01	; 1
     aa8:	30 40       	sbci	r19, 0x00	; 0
     aaa:	05 c0       	rjmp	.+10     	; 0xab6 <process_sensor+0xfa>
     aac:	28 17       	cp	r18, r24
     aae:	39 07       	cpc	r19, r25
     ab0:	50 f4       	brcc	.+20     	; 0xac6 <process_sensor+0x10a>
     ab2:	2f 5f       	subi	r18, 0xFF	; 255
     ab4:	3f 4f       	sbci	r19, 0xFF	; 255
     ab6:	20 83       	st	Z, r18
     ab8:	31 83       	std	Z+1, r19	; 0x01
     aba:	48 60       	ori	r20, 0x08	; 8
     abc:	52 60       	ori	r21, 0x02	; 2
     abe:	40 93 4f 20 	sts	0x204F, r20
     ac2:	50 93 50 20 	sts	0x2050, r21
     ac6:	86 2f       	mov	r24, r22
     ac8:	81 50       	subi	r24, 0x01	; 1
     aca:	f8 01       	movw	r30, r16
     acc:	ee 0f       	add	r30, r30
     ace:	ff 1f       	adc	r31, r31
     ad0:	e0 0f       	add	r30, r16
     ad2:	f1 1f       	adc	r31, r17
     ad4:	ef 01       	movw	r28, r30
     ad6:	cc 0f       	add	r28, r28
     ad8:	dd 1f       	adc	r29, r29
     ada:	c9 5a       	subi	r28, 0xA9	; 169
     adc:	df 4d       	sbci	r29, 0xDF	; 223
     ade:	89 83       	std	Y+1, r24	; 0x01
     ae0:	88 23       	and	r24, r24
     ae2:	b1 f4       	brne	.+44     	; 0xb10 <process_sensor+0x154>
     ae4:	ad 81       	ldd	r26, Y+5	; 0x05
     ae6:	82 e0       	ldi	r24, 0x02	; 2
     ae8:	88 83       	st	Y, r24
     aea:	80 91 4f 20 	lds	r24, 0x204F
     aee:	90 91 50 20 	lds	r25, 0x2050
     af2:	82 60       	ori	r24, 0x02	; 2
     af4:	80 93 4f 20 	sts	0x204F, r24
     af8:	90 93 50 20 	sts	0x2050, r25
     afc:	ee 0f       	add	r30, r30
     afe:	ff 1f       	adc	r31, r31
     b00:	e7 5a       	subi	r30, 0xA7	; 167
     b02:	ff 4d       	sbci	r31, 0xDF	; 223
     b04:	10 82       	st	Z, r1
     b06:	b0 e0       	ldi	r27, 0x00	; 0
     b08:	af 58       	subi	r26, 0x8F	; 143
     b0a:	bf 4d       	sbci	r27, 0xDF	; 223
     b0c:	80 e8       	ldi	r24, 0x80	; 128
     b0e:	8c 93       	st	X, r24
     b10:	80 91 39 20 	lds	r24, 0x2039
     b14:	80 93 70 20 	sts	0x2070, r24
     b18:	25 c2       	rjmp	.+1098   	; 0xf64 <process_sensor+0x5a8>
     b1a:	52 ff       	sbrs	r21, 2
     b1c:	08 c0       	rjmp	.+16     	; 0xb2e <process_sensor+0x172>
     b1e:	ed 81       	ldd	r30, Y+5	; 0x05
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	ef 58       	subi	r30, 0x8F	; 143
     b24:	ff 4d       	sbci	r31, 0xDF	; 223
     b26:	10 82       	st	Z, r1
     b28:	80 e2       	ldi	r24, 0x20	; 32
     b2a:	88 83       	st	Y, r24
     b2c:	0c c2       	rjmp	.+1048   	; 0xf46 <process_sensor+0x58a>
     b2e:	c5 01       	movw	r24, r10
     b30:	b7 fe       	sbrs	r11, 7
     b32:	02 c0       	rjmp	.+4      	; 0xb38 <process_sensor+0x17c>
     b34:	80 e0       	ldi	r24, 0x00	; 0
     b36:	90 e0       	ldi	r25, 0x00	; 0
     b38:	82 17       	cp	r24, r18
     b3a:	93 07       	cpc	r25, r19
     b3c:	80 f0       	brcs	.+32     	; 0xb5e <process_sensor+0x1a2>
     b3e:	f8 01       	movw	r30, r16
     b40:	ee 0f       	add	r30, r30
     b42:	ff 1f       	adc	r31, r31
     b44:	e0 0f       	add	r30, r16
     b46:	f1 1f       	adc	r31, r17
     b48:	ee 0f       	add	r30, r30
     b4a:	ff 1f       	adc	r31, r31
     b4c:	df 01       	movw	r26, r30
     b4e:	a9 5a       	subi	r26, 0xA9	; 169
     b50:	bf 4d       	sbci	r27, 0xDF	; 223
     b52:	84 e0       	ldi	r24, 0x04	; 4
     b54:	8c 93       	st	X, r24
     b56:	e7 5a       	subi	r30, 0xA7	; 167
     b58:	ff 4d       	sbci	r31, 0xDF	; 223
     b5a:	10 82       	st	Z, r1
     b5c:	fa c1       	rjmp	.+1012   	; 0xf52 <process_sensor+0x596>
     b5e:	ff 20       	and	r15, r15
     b60:	09 f4       	brne	.+2      	; 0xb64 <process_sensor+0x1a8>
     b62:	02 c2       	rjmp	.+1028   	; 0xf68 <process_sensor+0x5ac>
     b64:	80 91 70 20 	lds	r24, 0x2070
     b68:	88 23       	and	r24, r24
     b6a:	09 f0       	breq	.+2      	; 0xb6e <process_sensor+0x1b2>
     b6c:	fd c1       	rjmp	.+1018   	; 0xf68 <process_sensor+0x5ac>
     b6e:	f8 01       	movw	r30, r16
     b70:	ee 0f       	add	r30, r30
     b72:	ff 1f       	adc	r31, r31
     b74:	e0 0f       	add	r30, r16
     b76:	f1 1f       	adc	r31, r17
     b78:	ee 0f       	add	r30, r30
     b7a:	ff 1f       	adc	r31, r31
     b7c:	e9 5a       	subi	r30, 0xA9	; 169
     b7e:	ff 4d       	sbci	r31, 0xDF	; 223
     b80:	85 81       	ldd	r24, Z+5	; 0x05
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	ec 01       	movw	r28, r24
     b86:	cc 0f       	add	r28, r28
     b88:	dd 1f       	adc	r29, r29
     b8a:	ca 5b       	subi	r28, 0xBA	; 186
     b8c:	df 4d       	sbci	r29, 0xDF	; 223
     b8e:	28 81       	ld	r18, Y
     b90:	39 81       	ldd	r19, Y+1	; 0x01
     b92:	fc 01       	movw	r30, r24
     b94:	ee 0f       	add	r30, r30
     b96:	ff 1f       	adc	r31, r31
     b98:	e2 5c       	subi	r30, 0xC2	; 194
     b9a:	ff 4d       	sbci	r31, 0xDF	; 223
     b9c:	01 90       	ld	r0, Z+
     b9e:	f0 81       	ld	r31, Z
     ba0:	e0 2d       	mov	r30, r0
     ba2:	2e 17       	cp	r18, r30
     ba4:	3f 07       	cpc	r19, r31
     ba6:	88 f4       	brcc	.+34     	; 0xbca <process_sensor+0x20e>
     ba8:	fc 01       	movw	r30, r24
     baa:	ef 58       	subi	r30, 0x8F	; 143
     bac:	ff 4d       	sbci	r31, 0xDF	; 223
     bae:	90 81       	ld	r25, Z
     bb0:	9f 0d       	add	r25, r15
     bb2:	90 83       	st	Z, r25
     bb4:	80 91 3c 20 	lds	r24, 0x203C
     bb8:	80 58       	subi	r24, 0x80	; 128
     bba:	98 17       	cp	r25, r24
     bbc:	08 f4       	brcc	.+2      	; 0xbc0 <process_sensor+0x204>
     bbe:	d4 c1       	rjmp	.+936    	; 0xf68 <process_sensor+0x5ac>
     bc0:	80 e8       	ldi	r24, 0x80	; 128
     bc2:	80 83       	st	Z, r24
     bc4:	2f 5f       	subi	r18, 0xFF	; 255
     bc6:	3f 4f       	sbci	r19, 0xFF	; 255
     bc8:	14 c0       	rjmp	.+40     	; 0xbf2 <process_sensor+0x236>
     bca:	dc 01       	movw	r26, r24
     bcc:	af 58       	subi	r26, 0x8F	; 143
     bce:	bf 4d       	sbci	r27, 0xDF	; 223
     bd0:	e2 17       	cp	r30, r18
     bd2:	f3 07       	cpc	r31, r19
     bd4:	d0 f4       	brcc	.+52     	; 0xc0a <process_sensor+0x24e>
     bd6:	8c 91       	ld	r24, X
     bd8:	8f 19       	sub	r24, r15
     bda:	8c 93       	st	X, r24
     bdc:	40 e8       	ldi	r20, 0x80	; 128
     bde:	90 91 3b 20 	lds	r25, 0x203B
     be2:	54 2f       	mov	r21, r20
     be4:	59 1b       	sub	r21, r25
     be6:	58 17       	cp	r21, r24
     be8:	08 f4       	brcc	.+2      	; 0xbec <process_sensor+0x230>
     bea:	be c1       	rjmp	.+892    	; 0xf68 <process_sensor+0x5ac>
     bec:	4c 93       	st	X, r20
     bee:	21 50       	subi	r18, 0x01	; 1
     bf0:	30 40       	sbci	r19, 0x00	; 0
     bf2:	28 83       	st	Y, r18
     bf4:	39 83       	std	Y+1, r19	; 0x01
     bf6:	80 91 4f 20 	lds	r24, 0x204F
     bfa:	90 91 50 20 	lds	r25, 0x2050
     bfe:	88 60       	ori	r24, 0x08	; 8
     c00:	80 93 4f 20 	sts	0x204F, r24
     c04:	90 93 50 20 	sts	0x2050, r25
     c08:	af c1       	rjmp	.+862    	; 0xf68 <process_sensor+0x5ac>
     c0a:	2c 91       	ld	r18, X
     c0c:	21 38       	cpi	r18, 0x81	; 129
     c0e:	10 f0       	brcs	.+4      	; 0xc14 <process_sensor+0x258>
     c10:	21 50       	subi	r18, 0x01	; 1
     c12:	2c 93       	st	X, r18
     c14:	fc 01       	movw	r30, r24
     c16:	ef 58       	subi	r30, 0x8F	; 143
     c18:	ff 4d       	sbci	r31, 0xDF	; 223
     c1a:	80 81       	ld	r24, Z
     c1c:	87 fd       	sbrc	r24, 7
     c1e:	a4 c1       	rjmp	.+840    	; 0xf68 <process_sensor+0x5ac>
     c20:	8f 5f       	subi	r24, 0xFF	; 255
     c22:	67 c1       	rjmp	.+718    	; 0xef2 <process_sensor+0x536>
     c24:	c5 01       	movw	r24, r10
     c26:	b7 fe       	sbrs	r11, 7
     c28:	02 c0       	rjmp	.+4      	; 0xc2e <process_sensor+0x272>
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	90 e0       	ldi	r25, 0x00	; 0
     c2e:	f8 01       	movw	r30, r16
     c30:	ee 0f       	add	r30, r30
     c32:	ff 1f       	adc	r31, r31
     c34:	82 17       	cp	r24, r18
     c36:	93 07       	cpc	r25, r19
     c38:	08 f4       	brcc	.+2      	; 0xc3c <process_sensor+0x280>
     c3a:	8f c0       	rjmp	.+286    	; 0xd5a <process_sensor+0x39e>
     c3c:	80 91 39 20 	lds	r24, 0x2039
     c40:	80 93 70 20 	sts	0x2070, r24
     c44:	9f 01       	movw	r18, r30
     c46:	20 0f       	add	r18, r16
     c48:	31 1f       	adc	r19, r17
     c4a:	22 0f       	add	r18, r18
     c4c:	33 1f       	adc	r19, r19
     c4e:	d9 01       	movw	r26, r18
     c50:	a7 5a       	subi	r26, 0xA7	; 167
     c52:	bf 4d       	sbci	r27, 0xDF	; 223
     c54:	8c 91       	ld	r24, X
     c56:	8f 5f       	subi	r24, 0xFF	; 255
     c58:	8c 93       	st	X, r24
     c5a:	f9 01       	movw	r30, r18
     c5c:	e9 5a       	subi	r30, 0xA9	; 169
     c5e:	ff 4d       	sbci	r31, 0xDF	; 223
     c60:	84 81       	ldd	r24, Z+4	; 0x04
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	88 73       	andi	r24, 0x38	; 56
     c66:	90 70       	andi	r25, 0x00	; 0
     c68:	23 e0       	ldi	r18, 0x03	; 3
     c6a:	96 95       	lsr	r25
     c6c:	87 95       	ror	r24
     c6e:	2a 95       	dec	r18
     c70:	e1 f7       	brne	.-8      	; 0xc6a <process_sensor+0x2ae>
     c72:	68 2e       	mov	r6, r24
     c74:	88 23       	and	r24, r24
     c76:	09 f4       	brne	.+2      	; 0xc7a <process_sensor+0x2be>
     c78:	3e c0       	rjmp	.+124    	; 0xcf6 <process_sensor+0x33a>
     c7a:	cc 24       	eor	r12, r12
     c7c:	dd 24       	eor	r13, r13
     c7e:	7f 01       	movw	r14, r30
     c80:	83 e0       	ldi	r24, 0x03	; 3
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	e8 0e       	add	r14, r24
     c86:	f9 1e       	adc	r15, r25
     c88:	4d 01       	movw	r8, r26
     c8a:	2f c0       	rjmp	.+94     	; 0xcea <process_sensor+0x32e>
     c8c:	d7 14       	cp	r13, r7
     c8e:	61 f1       	breq	.+88     	; 0xce8 <process_sensor+0x32c>
     c90:	8d 2d       	mov	r24, r13
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	ec 01       	movw	r28, r24
     c96:	cc 0f       	add	r28, r28
     c98:	dd 1f       	adc	r29, r29
     c9a:	c8 0f       	add	r28, r24
     c9c:	d9 1f       	adc	r29, r25
     c9e:	cc 0f       	add	r28, r28
     ca0:	dd 1f       	adc	r29, r29
     ca2:	c9 5a       	subi	r28, 0xA9	; 169
     ca4:	df 4d       	sbci	r29, 0xDF	; 223
     ca6:	8c 81       	ldd	r24, Y+4	; 0x04
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	88 73       	andi	r24, 0x38	; 56
     cac:	90 70       	andi	r25, 0x00	; 0
     cae:	73 e0       	ldi	r23, 0x03	; 3
     cb0:	96 95       	lsr	r25
     cb2:	87 95       	ror	r24
     cb4:	7a 95       	dec	r23
     cb6:	e1 f7       	brne	.-8      	; 0xcb0 <process_sensor+0x2f4>
     cb8:	68 16       	cp	r6, r24
     cba:	b1 f4       	brne	.+44     	; 0xce8 <process_sensor+0x32c>
     cbc:	8d 2d       	mov	r24, r13
     cbe:	26 dd       	rcall	.-1460   	; 0x70c <qt_get_sensor_delta>
     cc0:	2b 81       	ldd	r18, Y+3	; 0x03
     cc2:	82 1b       	sub	r24, r18
     cc4:	91 09       	sbc	r25, r1
     cc6:	f7 01       	movw	r30, r14
     cc8:	20 81       	ld	r18, Z
     cca:	a5 01       	movw	r20, r10
     ccc:	42 1b       	sub	r20, r18
     cce:	51 09       	sbc	r21, r1
     cd0:	48 17       	cp	r20, r24
     cd2:	59 07       	cpc	r21, r25
     cd4:	2c f0       	brlt	.+10     	; 0xce0 <process_sensor+0x324>
     cd6:	88 81       	ld	r24, Y
     cd8:	80 31       	cpi	r24, 0x10	; 16
     cda:	11 f0       	breq	.+4      	; 0xce0 <process_sensor+0x324>
     cdc:	88 30       	cpi	r24, 0x08	; 8
     cde:	21 f4       	brne	.+8      	; 0xce8 <process_sensor+0x32c>
     ce0:	f4 01       	movw	r30, r8
     ce2:	10 82       	st	Z, r1
     ce4:	cc 24       	eor	r12, r12
     ce6:	c3 94       	inc	r12
     ce8:	d3 94       	inc	r13
     cea:	80 91 6f 20 	lds	r24, 0x206F
     cee:	d8 16       	cp	r13, r24
     cf0:	68 f2       	brcs	.-102    	; 0xc8c <process_sensor+0x2d0>
     cf2:	cc 20       	and	r12, r12
     cf4:	79 f4       	brne	.+30     	; 0xd14 <process_sensor+0x358>
     cf6:	80 91 38 20 	lds	r24, 0x2038
     cfa:	88 23       	and	r24, r24
     cfc:	59 f0       	breq	.+22     	; 0xd14 <process_sensor+0x358>
     cfe:	80 91 4f 20 	lds	r24, 0x204F
     d02:	90 91 50 20 	lds	r25, 0x2050
     d06:	98 60       	ori	r25, 0x08	; 8
     d08:	80 93 4f 20 	sts	0x204F, r24
     d0c:	90 93 50 20 	sts	0x2050, r25
     d10:	41 e0       	ldi	r20, 0x01	; 1
     d12:	01 c0       	rjmp	.+2      	; 0xd16 <process_sensor+0x35a>
     d14:	40 e0       	ldi	r20, 0x00	; 0
     d16:	98 01       	movw	r18, r16
     d18:	22 0f       	add	r18, r18
     d1a:	33 1f       	adc	r19, r19
     d1c:	20 0f       	add	r18, r16
     d1e:	31 1f       	adc	r19, r17
     d20:	f9 01       	movw	r30, r18
     d22:	ee 0f       	add	r30, r30
     d24:	ff 1f       	adc	r31, r31
     d26:	e7 5a       	subi	r30, 0xA7	; 167
     d28:	ff 4d       	sbci	r31, 0xDF	; 223
     d2a:	90 81       	ld	r25, Z
     d2c:	80 91 38 20 	lds	r24, 0x2038
     d30:	98 17       	cp	r25, r24
     d32:	08 f4       	brcc	.+2      	; 0xd36 <process_sensor+0x37a>
     d34:	1a c1       	rjmp	.+564    	; 0xf6a <process_sensor+0x5ae>
     d36:	80 91 4f 20 	lds	r24, 0x204F
     d3a:	90 91 50 20 	lds	r25, 0x2050
     d3e:	83 60       	ori	r24, 0x03	; 3
     d40:	80 93 4f 20 	sts	0x204F, r24
     d44:	90 93 50 20 	sts	0x2050, r25
     d48:	f9 01       	movw	r30, r18
     d4a:	ee 0f       	add	r30, r30
     d4c:	ff 1f       	adc	r31, r31
     d4e:	e9 5a       	subi	r30, 0xA9	; 169
     d50:	ff 4d       	sbci	r31, 0xDF	; 223
     d52:	80 e1       	ldi	r24, 0x10	; 16
     d54:	80 83       	st	Z, r24
     d56:	11 82       	std	Z+1, r1	; 0x01
     d58:	08 c1       	rjmp	.+528    	; 0xf6a <process_sensor+0x5ae>
     d5a:	e0 0f       	add	r30, r16
     d5c:	f1 1f       	adc	r31, r17
     d5e:	ee 0f       	add	r30, r30
     d60:	ff 1f       	adc	r31, r31
     d62:	df 01       	movw	r26, r30
     d64:	a9 5a       	subi	r26, 0xA9	; 169
     d66:	bf 4d       	sbci	r27, 0xDF	; 223
     d68:	15 96       	adiw	r26, 0x05	; 5
     d6a:	2c 91       	ld	r18, X
     d6c:	15 97       	sbiw	r26, 0x05	; 5
     d6e:	82 e0       	ldi	r24, 0x02	; 2
     d70:	8c 93       	st	X, r24
     d72:	80 91 4f 20 	lds	r24, 0x204F
     d76:	90 91 50 20 	lds	r25, 0x2050
     d7a:	82 60       	ori	r24, 0x02	; 2
     d7c:	80 93 4f 20 	sts	0x204F, r24
     d80:	90 93 50 20 	sts	0x2050, r25
     d84:	e7 5a       	subi	r30, 0xA7	; 167
     d86:	ff 4d       	sbci	r31, 0xDF	; 223
     d88:	10 82       	st	Z, r1
     d8a:	e2 2f       	mov	r30, r18
     d8c:	ae c0       	rjmp	.+348    	; 0xeea <process_sensor+0x52e>
     d8e:	52 ff       	sbrs	r21, 2
     d90:	0e c0       	rjmp	.+28     	; 0xdae <process_sensor+0x3f2>
     d92:	ed 81       	ldd	r30, Y+5	; 0x05
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	ef 58       	subi	r30, 0x8F	; 143
     d98:	ff 4d       	sbci	r31, 0xDF	; 223
     d9a:	80 e8       	ldi	r24, 0x80	; 128
     d9c:	80 83       	st	Z, r24
     d9e:	80 e2       	ldi	r24, 0x20	; 32
     da0:	88 83       	st	Y, r24
     da2:	80 91 4f 20 	lds	r24, 0x204F
     da6:	90 91 50 20 	lds	r25, 0x2050
     daa:	90 61       	ori	r25, 0x10	; 16
     dac:	4a c0       	rjmp	.+148    	; 0xe42 <process_sensor+0x486>
     dae:	c5 01       	movw	r24, r10
     db0:	b7 fe       	sbrs	r11, 7
     db2:	02 c0       	rjmp	.+4      	; 0xdb8 <process_sensor+0x3fc>
     db4:	80 e0       	ldi	r24, 0x00	; 0
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	f8 01       	movw	r30, r16
     dba:	ee 0f       	add	r30, r30
     dbc:	ff 1f       	adc	r31, r31
     dbe:	40 91 4f 20 	lds	r20, 0x204F
     dc2:	50 91 50 20 	lds	r21, 0x2050
     dc6:	86 17       	cp	r24, r22
     dc8:	97 07       	cpc	r25, r23
     dca:	70 f4       	brcc	.+28     	; 0xde8 <process_sensor+0x42c>
     dcc:	e0 0f       	add	r30, r16
     dce:	f1 1f       	adc	r31, r17
     dd0:	ee 0f       	add	r30, r30
     dd2:	ff 1f       	adc	r31, r31
     dd4:	e9 5a       	subi	r30, 0xA9	; 169
     dd6:	ff 4d       	sbci	r31, 0xDF	; 223
     dd8:	88 e0       	ldi	r24, 0x08	; 8
     dda:	80 83       	st	Z, r24
     ddc:	54 60       	ori	r21, 0x04	; 4
     dde:	40 93 4f 20 	sts	0x204F, r20
     de2:	50 93 50 20 	sts	0x2050, r21
     de6:	31 c0       	rjmp	.+98     	; 0xe4a <process_sensor+0x48e>
     de8:	41 60       	ori	r20, 0x01	; 1
     dea:	40 93 4f 20 	sts	0x204F, r20
     dee:	50 93 50 20 	sts	0x2050, r21
     df2:	e0 0f       	add	r30, r16
     df4:	f1 1f       	adc	r31, r17
     df6:	ee 0f       	add	r30, r30
     df8:	ff 1f       	adc	r31, r31
     dfa:	e7 5a       	subi	r30, 0xA7	; 167
     dfc:	ff 4d       	sbci	r31, 0xDF	; 223
     dfe:	90 81       	ld	r25, Z
     e00:	80 91 38 20 	lds	r24, 0x2038
     e04:	98 17       	cp	r25, r24
     e06:	10 f4       	brcc	.+4      	; 0xe0c <process_sensor+0x450>
     e08:	9f 5f       	subi	r25, 0xFF	; 255
     e0a:	90 83       	st	Z, r25
     e0c:	90 91 3a 20 	lds	r25, 0x203A
     e10:	99 23       	and	r25, r25
     e12:	71 f0       	breq	.+28     	; 0xe30 <process_sensor+0x474>
     e14:	f8 01       	movw	r30, r16
     e16:	ee 0f       	add	r30, r30
     e18:	ff 1f       	adc	r31, r31
     e1a:	e0 0f       	add	r30, r16
     e1c:	f1 1f       	adc	r31, r17
     e1e:	ee 0f       	add	r30, r30
     e20:	ff 1f       	adc	r31, r31
     e22:	e9 5a       	subi	r30, 0xA9	; 169
     e24:	ff 4d       	sbci	r31, 0xDF	; 223
     e26:	81 81       	ldd	r24, Z+1	; 0x01
     e28:	89 17       	cp	r24, r25
     e2a:	20 f4       	brcc	.+8      	; 0xe34 <process_sensor+0x478>
     e2c:	8f 0d       	add	r24, r15
     e2e:	81 83       	std	Z+1, r24	; 0x01
     e30:	40 e0       	ldi	r20, 0x00	; 0
     e32:	0c c0       	rjmp	.+24     	; 0xe4c <process_sensor+0x490>
     e34:	87 2d       	mov	r24, r7
     e36:	81 dd       	rcall	.-1278   	; 0x93a <start_cal_sensor>
     e38:	80 91 4f 20 	lds	r24, 0x204F
     e3c:	90 91 50 20 	lds	r25, 0x2050
     e40:	92 60       	ori	r25, 0x02	; 2
     e42:	80 93 4f 20 	sts	0x204F, r24
     e46:	90 93 50 20 	sts	0x2050, r25
     e4a:	41 e0       	ldi	r20, 0x01	; 1
     e4c:	80 91 39 20 	lds	r24, 0x2039
     e50:	80 93 70 20 	sts	0x2070, r24
     e54:	8a c0       	rjmp	.+276    	; 0xf6a <process_sensor+0x5ae>
     e56:	80 91 39 20 	lds	r24, 0x2039
     e5a:	80 93 70 20 	sts	0x2070, r24
     e5e:	df 01       	movw	r26, r30
     e60:	aa 0f       	add	r26, r26
     e62:	bb 1f       	adc	r27, r27
     e64:	a7 5a       	subi	r26, 0xA7	; 167
     e66:	bf 4d       	sbci	r27, 0xDF	; 223
     e68:	8c 91       	ld	r24, X
     e6a:	88 23       	and	r24, r24
     e6c:	89 f1       	breq	.+98     	; 0xed0 <process_sensor+0x514>
     e6e:	c5 01       	movw	r24, r10
     e70:	b7 fe       	sbrs	r11, 7
     e72:	02 c0       	rjmp	.+4      	; 0xe78 <process_sensor+0x4bc>
     e74:	80 e0       	ldi	r24, 0x00	; 0
     e76:	90 e0       	ldi	r25, 0x00	; 0
     e78:	40 91 4f 20 	lds	r20, 0x204F
     e7c:	50 91 50 20 	lds	r21, 0x2050
     e80:	68 17       	cp	r22, r24
     e82:	79 07       	cpc	r23, r25
     e84:	90 f4       	brcc	.+36     	; 0xeaa <process_sensor+0x4ee>
     e86:	f8 01       	movw	r30, r16
     e88:	ee 0f       	add	r30, r30
     e8a:	ff 1f       	adc	r31, r31
     e8c:	e0 0f       	add	r30, r16
     e8e:	f1 1f       	adc	r31, r17
     e90:	ee 0f       	add	r30, r30
     e92:	ff 1f       	adc	r31, r31
     e94:	e9 5a       	subi	r30, 0xA9	; 169
     e96:	ff 4d       	sbci	r31, 0xDF	; 223
     e98:	80 e1       	ldi	r24, 0x10	; 16
     e9a:	80 83       	st	Z, r24
     e9c:	41 60       	ori	r20, 0x01	; 1
     e9e:	40 93 4f 20 	sts	0x204F, r20
     ea2:	50 93 50 20 	sts	0x2050, r21
     ea6:	40 e0       	ldi	r20, 0x00	; 0
     ea8:	06 c0       	rjmp	.+12     	; 0xeb6 <process_sensor+0x4fa>
     eaa:	54 60       	ori	r21, 0x04	; 4
     eac:	40 93 4f 20 	sts	0x204F, r20
     eb0:	50 93 50 20 	sts	0x2050, r21
     eb4:	41 e0       	ldi	r20, 0x01	; 1
     eb6:	f8 01       	movw	r30, r16
     eb8:	ee 0f       	add	r30, r30
     eba:	ff 1f       	adc	r31, r31
     ebc:	e0 0f       	add	r30, r16
     ebe:	f1 1f       	adc	r31, r17
     ec0:	ee 0f       	add	r30, r30
     ec2:	ff 1f       	adc	r31, r31
     ec4:	e7 5a       	subi	r30, 0xA7	; 167
     ec6:	ff 4d       	sbci	r31, 0xDF	; 223
     ec8:	80 81       	ld	r24, Z
     eca:	81 50       	subi	r24, 0x01	; 1
     ecc:	80 83       	st	Z, r24
     ece:	4d c0       	rjmp	.+154    	; 0xf6a <process_sensor+0x5ae>
     ed0:	ed 81       	ldd	r30, Y+5	; 0x05
     ed2:	82 e0       	ldi	r24, 0x02	; 2
     ed4:	88 83       	st	Y, r24
     ed6:	80 91 4f 20 	lds	r24, 0x204F
     eda:	90 91 50 20 	lds	r25, 0x2050
     ede:	82 60       	ori	r24, 0x02	; 2
     ee0:	80 93 4f 20 	sts	0x204F, r24
     ee4:	90 93 50 20 	sts	0x2050, r25
     ee8:	1c 92       	st	X, r1
     eea:	f0 e0       	ldi	r31, 0x00	; 0
     eec:	ef 58       	subi	r30, 0x8F	; 143
     eee:	ff 4d       	sbci	r31, 0xDF	; 223
     ef0:	80 e8       	ldi	r24, 0x80	; 128
     ef2:	80 83       	st	Z, r24
     ef4:	39 c0       	rjmp	.+114    	; 0xf68 <process_sensor+0x5ac>
     ef6:	8d 81       	ldd	r24, Y+5	; 0x05
     ef8:	a8 2f       	mov	r26, r24
     efa:	b0 e0       	ldi	r27, 0x00	; 0
     efc:	af 58       	subi	r26, 0x8F	; 143
     efe:	bf 4d       	sbci	r27, 0xDF	; 223
     f00:	9c 91       	ld	r25, X
     f02:	9f 5f       	subi	r25, 0xFF	; 255
     f04:	9c 93       	st	X, r25
     f06:	52 fd       	sbrc	r21, 2
     f08:	18 c0       	rjmp	.+48     	; 0xf3a <process_sensor+0x57e>
     f0a:	97 ff       	sbrs	r25, 7
     f0c:	03 c0       	rjmp	.+6      	; 0xf14 <process_sensor+0x558>
     f0e:	80 e1       	ldi	r24, 0x10	; 16
     f10:	88 83       	st	Y, r24
     f12:	2a c0       	rjmp	.+84     	; 0xf68 <process_sensor+0x5ac>
     f14:	82 e0       	ldi	r24, 0x02	; 2
     f16:	88 83       	st	Y, r24
     f18:	80 91 4f 20 	lds	r24, 0x204F
     f1c:	90 91 50 20 	lds	r25, 0x2050
     f20:	82 60       	ori	r24, 0x02	; 2
     f22:	80 93 4f 20 	sts	0x204F, r24
     f26:	90 93 50 20 	sts	0x2050, r25
     f2a:	ee 0f       	add	r30, r30
     f2c:	ff 1f       	adc	r31, r31
     f2e:	e7 5a       	subi	r30, 0xA7	; 167
     f30:	ff 4d       	sbci	r31, 0xDF	; 223
     f32:	10 82       	st	Z, r1
     f34:	80 e8       	ldi	r24, 0x80	; 128
     f36:	8c 93       	st	X, r24
     f38:	17 c0       	rjmp	.+46     	; 0xf68 <process_sensor+0x5ac>
     f3a:	80 91 3d 20 	lds	r24, 0x203D
     f3e:	98 17       	cp	r25, r24
     f40:	40 f0       	brcs	.+16     	; 0xf52 <process_sensor+0x596>
     f42:	87 2d       	mov	r24, r7
     f44:	fa dc       	rcall	.-1548   	; 0x93a <start_cal_sensor>
     f46:	80 91 4f 20 	lds	r24, 0x204F
     f4a:	90 91 50 20 	lds	r25, 0x2050
     f4e:	90 61       	ori	r25, 0x10	; 16
     f50:	05 c0       	rjmp	.+10     	; 0xf5c <process_sensor+0x5a0>
     f52:	80 91 4f 20 	lds	r24, 0x204F
     f56:	90 91 50 20 	lds	r25, 0x2050
     f5a:	94 60       	ori	r25, 0x04	; 4
     f5c:	80 93 4f 20 	sts	0x204F, r24
     f60:	90 93 50 20 	sts	0x2050, r25
     f64:	41 e0       	ldi	r20, 0x01	; 1
     f66:	01 c0       	rjmp	.+2      	; 0xf6a <process_sensor+0x5ae>
     f68:	40 e0       	ldi	r20, 0x00	; 0
     f6a:	84 2f       	mov	r24, r20
     f6c:	cd b7       	in	r28, 0x3d	; 61
     f6e:	de b7       	in	r29, 0x3e	; 62
     f70:	ee e0       	ldi	r30, 0x0E	; 14
     f72:	0c 94 fd 1f 	jmp	0x3ffa	; 0x3ffa <__epilogue_restores__+0x8>

00000f76 <burst_init>:
     f76:	fc 01       	movw	r30, r24
     f78:	00 97       	sbiw	r24, 0x00	; 0
     f7a:	09 f0       	breq	.+2      	; 0xf7e <burst_init+0x8>
     f7c:	19 95       	eicall
     f7e:	08 95       	ret

00000f80 <burst_reset>:
     f80:	10 92 75 20 	sts	0x2075, r1
     f84:	10 92 76 20 	sts	0x2076, r1
     f88:	10 92 79 20 	sts	0x2079, r1
     f8c:	10 92 7a 20 	sts	0x207A, r1
     f90:	10 92 77 20 	sts	0x2077, r1
     f94:	10 92 78 20 	sts	0x2078, r1
     f98:	10 92 7b 20 	sts	0x207B, r1
     f9c:	10 92 7c 20 	sts	0x207C, r1
     fa0:	08 95       	ret

00000fa2 <burst>:
     fa2:	80 91 77 20 	lds	r24, 0x2077
     fa6:	90 91 75 20 	lds	r25, 0x2075
     faa:	89 2b       	or	r24, r25
     fac:	41 f0       	breq	.+16     	; 0xfbe <burst+0x1c>
     fae:	e0 91 35 20 	lds	r30, 0x2035
     fb2:	f0 91 36 20 	lds	r31, 0x2036
     fb6:	30 97       	sbiw	r30, 0x00	; 0
     fb8:	11 f0       	breq	.+4      	; 0xfbe <burst+0x1c>
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	19 95       	eicall
     fbe:	80 91 78 20 	lds	r24, 0x2078
     fc2:	90 91 76 20 	lds	r25, 0x2076
     fc6:	89 2b       	or	r24, r25
     fc8:	41 f0       	breq	.+16     	; 0xfda <burst+0x38>
     fca:	e0 91 35 20 	lds	r30, 0x2035
     fce:	f0 91 36 20 	lds	r31, 0x2036
     fd2:	30 97       	sbiw	r30, 0x00	; 0
     fd4:	11 f0       	breq	.+4      	; 0xfda <burst+0x38>
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	19 95       	eicall
     fda:	08 95       	ret

00000fdc <adc_handler>:
 * \retval the raw ADC value from the current ntc_sensor_sample
 */
int16_t ntc_get_raw_value(void)
{
	return ntc_sensor_sample;
}
     fdc:	61 30       	cpi	r22, 0x01	; 1
     fde:	69 f5       	brne	.+90     	; 0x103a <adc_handler+0x5e>
     fe0:	80 91 7e 20 	lds	r24, 0x207E
     fe4:	8f 5f       	subi	r24, 0xFF	; 255
     fe6:	80 93 7e 20 	sts	0x207E, r24
     fea:	81 30       	cpi	r24, 0x01	; 1
     fec:	39 f4       	brne	.+14     	; 0xffc <adc_handler+0x20>
     fee:	40 93 7f 20 	sts	0x207F, r20
     ff2:	50 93 80 20 	sts	0x2080, r21
     ff6:	10 92 83 20 	sts	0x2083, r1
     ffa:	0c c0       	rjmp	.+24     	; 0x1014 <adc_handler+0x38>
     ffc:	80 91 7f 20 	lds	r24, 0x207F
    1000:	90 91 80 20 	lds	r25, 0x2080
    1004:	48 0f       	add	r20, r24
    1006:	59 1f       	adc	r21, r25
    1008:	56 95       	lsr	r21
    100a:	47 95       	ror	r20
    100c:	40 93 7f 20 	sts	0x207F, r20
    1010:	50 93 80 20 	sts	0x2080, r21
    1014:	80 91 7e 20 	lds	r24, 0x207E
    1018:	84 30       	cpi	r24, 0x04	; 4
    101a:	31 f4       	brne	.+12     	; 0x1028 <adc_handler+0x4c>
    101c:	10 92 7e 20 	sts	0x207E, r1
    1020:	81 e0       	ldi	r24, 0x01	; 1
    1022:	80 93 83 20 	sts	0x2083, r24
    1026:	08 95       	ret
    1028:	9f b7       	in	r25, 0x3f	; 63
    102a:	f8 94       	cli
    102c:	e0 e0       	ldi	r30, 0x00	; 0
    102e:	f2 e0       	ldi	r31, 0x02	; 2
    1030:	80 81       	ld	r24, Z
    1032:	84 60       	ori	r24, 0x04	; 4
    1034:	80 83       	st	Z, r24
    1036:	9f bf       	out	0x3f, r25	; 63
    1038:	08 95       	ret
    103a:	62 30       	cpi	r22, 0x02	; 2
    103c:	61 f5       	brne	.+88     	; 0x1096 <adc_handler+0xba>
    103e:	80 91 7d 20 	lds	r24, 0x207D
    1042:	8f 5f       	subi	r24, 0xFF	; 255
    1044:	80 93 7d 20 	sts	0x207D, r24
    1048:	81 30       	cpi	r24, 0x01	; 1
    104a:	39 f4       	brne	.+14     	; 0x105a <adc_handler+0x7e>
    104c:	40 93 81 20 	sts	0x2081, r20
    1050:	50 93 82 20 	sts	0x2082, r21
    1054:	10 92 84 20 	sts	0x2084, r1
    1058:	0c c0       	rjmp	.+24     	; 0x1072 <adc_handler+0x96>
    105a:	80 91 81 20 	lds	r24, 0x2081
    105e:	90 91 82 20 	lds	r25, 0x2082
    1062:	48 0f       	add	r20, r24
    1064:	59 1f       	adc	r21, r25
    1066:	56 95       	lsr	r21
    1068:	47 95       	ror	r20
    106a:	40 93 81 20 	sts	0x2081, r20
    106e:	50 93 82 20 	sts	0x2082, r21
    1072:	80 91 7d 20 	lds	r24, 0x207D
    1076:	84 30       	cpi	r24, 0x04	; 4
    1078:	31 f4       	brne	.+12     	; 0x1086 <adc_handler+0xaa>
    107a:	10 92 7d 20 	sts	0x207D, r1
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	80 93 84 20 	sts	0x2084, r24
    1084:	08 95       	ret
    1086:	9f b7       	in	r25, 0x3f	; 63
    1088:	f8 94       	cli
    108a:	e0 e0       	ldi	r30, 0x00	; 0
    108c:	f2 e0       	ldi	r31, 0x02	; 2
    108e:	80 81       	ld	r24, Z
    1090:	88 60       	ori	r24, 0x08	; 8
    1092:	80 83       	st	Z, r24
    1094:	9f bf       	out	0x3f, r25	; 63
    1096:	08 95       	ret

00001098 <ntc_data_is_ready>:
    1098:	9f b7       	in	r25, 0x3f	; 63
    109a:	f8 94       	cli
    109c:	80 91 84 20 	lds	r24, 0x2084
    10a0:	88 23       	and	r24, r24
    10a2:	21 f0       	breq	.+8      	; 0x10ac <ntc_data_is_ready+0x14>
    10a4:	10 92 84 20 	sts	0x2084, r1
    10a8:	9f bf       	out	0x3f, r25	; 63
    10aa:	08 95       	ret
    10ac:	9f bf       	out	0x3f, r25	; 63
    10ae:	08 95       	ret

000010b0 <lightsensor_data_is_ready>:
    10b0:	9f b7       	in	r25, 0x3f	; 63
    10b2:	f8 94       	cli
    10b4:	80 91 83 20 	lds	r24, 0x2083
    10b8:	88 23       	and	r24, r24
    10ba:	21 f0       	breq	.+8      	; 0x10c4 <lightsensor_data_is_ready+0x14>
    10bc:	10 92 83 20 	sts	0x2083, r1
    10c0:	9f bf       	out	0x3f, r25	; 63
    10c2:	08 95       	ret
    10c4:	9f bf       	out	0x3f, r25	; 63
    10c6:	08 95       	ret

000010c8 <adc_sensors_init>:
    10c8:	1f 93       	push	r17
    10ca:	cf 93       	push	r28
    10cc:	df 93       	push	r29
    10ce:	cd b7       	in	r28, 0x3d	; 61
    10d0:	de b7       	in	r29, 0x3e	; 62
    10d2:	2b 97       	sbiw	r28, 0x0b	; 11
    10d4:	cd bf       	out	0x3d, r28	; 61
    10d6:	de bf       	out	0x3e, r29	; 62
    10d8:	be 01       	movw	r22, r28
    10da:	6f 5f       	subi	r22, 0xFF	; 255
    10dc:	7f 4f       	sbci	r23, 0xFF	; 255
    10de:	80 e0       	ldi	r24, 0x00	; 0
    10e0:	92 e0       	ldi	r25, 0x02	; 2
    10e2:	eb d5       	rcall	.+3030   	; 0x1cba <adc_read_configuration>
    10e4:	ae 01       	movw	r20, r28
    10e6:	48 5f       	subi	r20, 0xF8	; 248
    10e8:	5f 4f       	sbci	r21, 0xFF	; 255
    10ea:	61 e0       	ldi	r22, 0x01	; 1
    10ec:	80 e0       	ldi	r24, 0x00	; 0
    10ee:	92 e0       	ldi	r25, 0x02	; 2
    10f0:	40 d6       	rcall	.+3200   	; 0x1d72 <adcch_read_configuration>
    10f2:	8a 81       	ldd	r24, Y+2	; 0x02
    10f4:	9b 81       	ldd	r25, Y+3	; 0x03
    10f6:	9f 78       	andi	r25, 0x8F	; 143
    10f8:	90 61       	ori	r25, 0x10	; 16
    10fa:	9b 83       	std	Y+3, r25	; 0x03
    10fc:	96 e0       	ldi	r25, 0x06	; 6
    10fe:	9d 83       	std	Y+5, r25	; 0x05
    1100:	81 7e       	andi	r24, 0xE1	; 225
    1102:	80 61       	ori	r24, 0x10	; 16
    1104:	8a 83       	std	Y+2, r24	; 0x02
    1106:	1c 82       	std	Y+4, r1	; 0x04
    1108:	be 01       	movw	r22, r28
    110a:	6f 5f       	subi	r22, 0xFF	; 255
    110c:	7f 4f       	sbci	r23, 0xFF	; 255
    110e:	80 e0       	ldi	r24, 0x00	; 0
    1110:	92 e0       	ldi	r25, 0x02	; 2
    1112:	7f d5       	rcall	.+2814   	; 0x1c12 <adc_write_configuration>
    1114:	6e ee       	ldi	r22, 0xEE	; 238
    1116:	77 e0       	ldi	r23, 0x07	; 7
    1118:	80 e0       	ldi	r24, 0x00	; 0
    111a:	92 e0       	ldi	r25, 0x02	; 2
    111c:	7d d3       	rcall	.+1786   	; 0x1818 <adc_set_callback>
    111e:	11 e0       	ldi	r17, 0x01	; 1
    1120:	18 87       	std	Y+8, r17	; 0x08
    1122:	19 86       	std	Y+9, r1	; 0x09
    1124:	8a 85       	ldd	r24, Y+10	; 0x0a
    1126:	80 7f       	andi	r24, 0xF0	; 240
    1128:	81 60       	ori	r24, 0x01	; 1
    112a:	8a 87       	std	Y+10, r24	; 0x0a
    112c:	ae 01       	movw	r20, r28
    112e:	48 5f       	subi	r20, 0xF8	; 248
    1130:	5f 4f       	sbci	r21, 0xFF	; 255
    1132:	61 e0       	ldi	r22, 0x01	; 1
    1134:	80 e0       	ldi	r24, 0x00	; 0
    1136:	92 e0       	ldi	r25, 0x02	; 2
    1138:	e3 d5       	rcall	.+3014   	; 0x1d00 <adcch_write_configuration>
    113a:	18 87       	std	Y+8, r17	; 0x08
    113c:	88 e0       	ldi	r24, 0x08	; 8
    113e:	89 87       	std	Y+9, r24	; 0x09
    1140:	ae 01       	movw	r20, r28
    1142:	48 5f       	subi	r20, 0xF8	; 248
    1144:	5f 4f       	sbci	r21, 0xFF	; 255
    1146:	62 e0       	ldi	r22, 0x02	; 2
    1148:	80 e0       	ldi	r24, 0x00	; 0
    114a:	92 e0       	ldi	r25, 0x02	; 2
    114c:	d9 d5       	rcall	.+2994   	; 0x1d00 <adcch_write_configuration>
    114e:	80 e0       	ldi	r24, 0x00	; 0
    1150:	92 e0       	ldi	r25, 0x02	; 2
    1152:	b8 d3       	rcall	.+1904   	; 0x18c4 <adc_enable>
    1154:	2b 96       	adiw	r28, 0x0b	; 11
    1156:	cd bf       	out	0x3d, r28	; 61
    1158:	de bf       	out	0x3e, r29	; 62
    115a:	df 91       	pop	r29
    115c:	cf 91       	pop	r28
    115e:	1f 91       	pop	r17
    1160:	08 95       	ret

00001162 <ntc_get_temperature>:
 * \note The result is inaccurate for temperatures outside 5-45 degrees.
 *
 * \retval the temperature in Celsius
 */
int8_t ntc_get_temperature(void)
{
    1162:	cf 93       	push	r28
    1164:	df 93       	push	r29
	int8_t retval = 0;
	float ntc_sample = ntc_sensor_sample;
    1166:	c0 91 81 20 	lds	r28, 0x2081
    116a:	d0 91 82 20 	lds	r29, 0x2082
    116e:	be 01       	movw	r22, r28
    1170:	80 e0       	ldi	r24, 0x00	; 0
    1172:	90 e0       	ldi	r25, 0x00	; 0
    1174:	0e 94 ab 1e 	call	0x3d56	; 0x3d56 <__floatunsisf>
	if (ntc_sensor_sample > 697) {
		retval = (int8_t)((-0.0295 * ntc_sample) + 40.5);
	} if (ntc_sensor_sample > 420) {
    1178:	c5 3a       	cpi	r28, 0xA5	; 165
    117a:	d1 40       	sbci	r29, 0x01	; 1
    117c:	80 f0       	brcs	.+32     	; 0x119e <ntc_get_temperature+0x3c>
		retval = (int8_t)((-0.0474 * ntc_sample) + 53.3);
    117e:	21 e8       	ldi	r18, 0x81	; 129
    1180:	36 e2       	ldi	r19, 0x26	; 38
    1182:	42 e4       	ldi	r20, 0x42	; 66
    1184:	5d eb       	ldi	r21, 0xBD	; 189
    1186:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <__mulsf3>
    118a:	23 e3       	ldi	r18, 0x33	; 51
    118c:	33 e3       	ldi	r19, 0x33	; 51
    118e:	45 e5       	ldi	r20, 0x55	; 85
    1190:	52 e4       	ldi	r21, 0x42	; 66
    1192:	0e 94 16 1e 	call	0x3c2c	; 0x3c2c <__addsf3>
    1196:	0e 94 7a 1e 	call	0x3cf4	; 0x3cf4 <__fixsfsi>
    119a:	86 2f       	mov	r24, r22
    119c:	0f c0       	rjmp	.+30     	; 0x11bc <ntc_get_temperature+0x5a>
	} else {
		retval = (int8_t)((-0.0777 * ntc_sample) + 65.1);
    119e:	2d e2       	ldi	r18, 0x2D	; 45
    11a0:	31 e2       	ldi	r19, 0x21	; 33
    11a2:	4f e9       	ldi	r20, 0x9F	; 159
    11a4:	5d eb       	ldi	r21, 0xBD	; 189
    11a6:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <__mulsf3>
    11aa:	23 e3       	ldi	r18, 0x33	; 51
    11ac:	33 e3       	ldi	r19, 0x33	; 51
    11ae:	42 e8       	ldi	r20, 0x82	; 130
    11b0:	52 e4       	ldi	r21, 0x42	; 66
    11b2:	0e 94 16 1e 	call	0x3c2c	; 0x3c2c <__addsf3>
    11b6:	0e 94 7a 1e 	call	0x3cf4	; 0x3cf4 <__fixsfsi>
    11ba:	86 2f       	mov	r24, r22
	}
	return retval;
}
    11bc:	df 91       	pop	r29
    11be:	cf 91       	pop	r28
    11c0:	08 95       	ret

000011c2 <lightsensor_get_raw_value>:
 * \retval the raw ADC value from the current ntc_sensor_sample
 */
int16_t lightsensor_get_raw_value(void)
{
	return light_sensor_sample;
}
    11c2:	80 91 7f 20 	lds	r24, 0x207F
    11c6:	90 91 80 20 	lds	r25, 0x2080
    11ca:	08 95       	ret

000011cc <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
    11cc:	bf 92       	push	r11
    11ce:	cf 92       	push	r12
    11d0:	df 92       	push	r13
    11d2:	ef 92       	push	r14
    11d4:	ff 92       	push	r15
    11d6:	0f 93       	push	r16
    11d8:	1f 93       	push	r17
    11da:	cf 93       	push	r28
    11dc:	df 93       	push	r29
    11de:	1f 92       	push	r1
    11e0:	cd b7       	in	r28, 0x3d	; 61
    11e2:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    11e4:	88 e0       	ldi	r24, 0x08	; 8
    11e6:	80 93 06 06 	sts	0x0606, r24
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    11ec:	90 e0       	ldi	r25, 0x00	; 0
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	do { barrier(); } while (--n);
    11ee:	01 96       	adiw	r24, 0x01	; 1
    11f0:	85 33       	cpi	r24, 0x35	; 53
    11f2:	91 05       	cpc	r25, r1
    11f4:	e1 f7       	brne	.-8      	; 0x11ee <st7565r_init+0x22>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    11f6:	88 e0       	ldi	r24, 0x08	; 8
    11f8:	80 93 05 06 	sts	0x0605, r24
    11fc:	80 e0       	ldi	r24, 0x00	; 0
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	01 96       	adiw	r24, 0x01	; 1
    1202:	85 33       	cpi	r24, 0x35	; 53
    1204:	91 05       	cpc	r25, r1
    1206:	e1 f7       	brne	.-8      	; 0x1200 <st7565r_init+0x34>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
    1208:	0f 2e       	mov	r0, r31
    120a:	fb e2       	ldi	r31, 0x2B	; 43
    120c:	bf 2e       	mov	r11, r31
    120e:	f0 2d       	mov	r31, r0
    1210:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
    1212:	80 ea       	ldi	r24, 0xA0	; 160
    1214:	99 e0       	ldi	r25, 0x09	; 9
    1216:	0e 94 b7 11 	call	0x236e	; 0x236e <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
    121a:	c1 2c       	mov	r12, r1
    121c:	d1 2c       	mov	r13, r1
    121e:	76 01       	movw	r14, r12
    1220:	00 e4       	ldi	r16, 0x40	; 64
    1222:	12 e4       	ldi	r17, 0x42	; 66
    1224:	2f e0       	ldi	r18, 0x0F	; 15
    1226:	30 e0       	ldi	r19, 0x00	; 0
    1228:	43 e0       	ldi	r20, 0x03	; 3
    122a:	be 01       	movw	r22, r28
    122c:	6f 5f       	subi	r22, 0xFF	; 255
    122e:	7f 4f       	sbci	r23, 0xFF	; 255
    1230:	80 ea       	ldi	r24, 0xA0	; 160
    1232:	99 e0       	ldi	r25, 0x09	; 9
    1234:	0e 94 e6 11 	call	0x23cc	; 0x23cc <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    1238:	00 e6       	ldi	r16, 0x60	; 96
    123a:	16 e0       	ldi	r17, 0x06	; 6
    123c:	ff 24       	eor	r15, r15
    123e:	f3 94       	inc	r15
    1240:	f8 01       	movw	r30, r16
    1242:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1244:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1246:	be 01       	movw	r22, r28
    1248:	6f 5f       	subi	r22, 0xFF	; 255
    124a:	7f 4f       	sbci	r23, 0xFF	; 255
    124c:	80 ea       	ldi	r24, 0xA0	; 160
    124e:	99 e0       	ldi	r25, 0x09	; 9
    1250:	0e 94 00 12 	call	0x2400	; 0x2400 <usart_spi_select_device>
    1254:	f8 01       	movw	r30, r16
    1256:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1258:	e0 ea       	ldi	r30, 0xA0	; 160
    125a:	f9 e0       	ldi	r31, 0x09	; 9
    125c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    125e:	85 ff       	sbrs	r24, 5
    1260:	fd cf       	rjmp	.-6      	; 0x125c <st7565r_init+0x90>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1262:	80 ea       	ldi	r24, 0xA0	; 160
    1264:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1268:	e0 ea       	ldi	r30, 0xA0	; 160
    126a:	f9 e0       	ldi	r31, 0x09	; 9
    126c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    126e:	86 ff       	sbrs	r24, 6
    1270:	fd cf       	rjmp	.-6      	; 0x126c <st7565r_init+0xa0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1272:	e0 ea       	ldi	r30, 0xA0	; 160
    1274:	f9 e0       	ldi	r31, 0x09	; 9
    1276:	80 e4       	ldi	r24, 0x40	; 64
    1278:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    127a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    127c:	be 01       	movw	r22, r28
    127e:	6f 5f       	subi	r22, 0xFF	; 255
    1280:	7f 4f       	sbci	r23, 0xFF	; 255
    1282:	80 ea       	ldi	r24, 0xA0	; 160
    1284:	99 e0       	ldi	r25, 0x09	; 9
    1286:	0e 94 16 12 	call	0x242c	; 0x242c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    128a:	8b e2       	ldi	r24, 0x2B	; 43
    128c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    128e:	be 01       	movw	r22, r28
    1290:	6f 5f       	subi	r22, 0xFF	; 255
    1292:	7f 4f       	sbci	r23, 0xFF	; 255
    1294:	80 ea       	ldi	r24, 0xA0	; 160
    1296:	99 e0       	ldi	r25, 0x09	; 9
    1298:	0e 94 00 12 	call	0x2400	; 0x2400 <usart_spi_select_device>
    129c:	81 e0       	ldi	r24, 0x01	; 1
    129e:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    12a2:	e0 ea       	ldi	r30, 0xA0	; 160
    12a4:	f9 e0       	ldi	r31, 0x09	; 9
    12a6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    12a8:	85 ff       	sbrs	r24, 5
    12aa:	fd cf       	rjmp	.-6      	; 0x12a6 <st7565r_init+0xda>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    12ac:	86 ea       	ldi	r24, 0xA6	; 166
    12ae:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    12b2:	e0 ea       	ldi	r30, 0xA0	; 160
    12b4:	f9 e0       	ldi	r31, 0x09	; 9
    12b6:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    12b8:	86 ff       	sbrs	r24, 6
    12ba:	fd cf       	rjmp	.-6      	; 0x12b6 <st7565r_init+0xea>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    12bc:	e0 ea       	ldi	r30, 0xA0	; 160
    12be:	f9 e0       	ldi	r31, 0x09	; 9
    12c0:	80 e4       	ldi	r24, 0x40	; 64
    12c2:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    12c4:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    12c6:	be 01       	movw	r22, r28
    12c8:	6f 5f       	subi	r22, 0xFF	; 255
    12ca:	7f 4f       	sbci	r23, 0xFF	; 255
    12cc:	80 ea       	ldi	r24, 0xA0	; 160
    12ce:	99 e0       	ldi	r25, 0x09	; 9
    12d0:	0e 94 16 12 	call	0x242c	; 0x242c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    12d4:	8b e2       	ldi	r24, 0x2B	; 43
    12d6:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    12d8:	be 01       	movw	r22, r28
    12da:	6f 5f       	subi	r22, 0xFF	; 255
    12dc:	7f 4f       	sbci	r23, 0xFF	; 255
    12de:	80 ea       	ldi	r24, 0xA0	; 160
    12e0:	99 e0       	ldi	r25, 0x09	; 9
    12e2:	0e 94 00 12 	call	0x2400	; 0x2400 <usart_spi_select_device>
    12e6:	81 e0       	ldi	r24, 0x01	; 1
    12e8:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    12ec:	e0 ea       	ldi	r30, 0xA0	; 160
    12ee:	f9 e0       	ldi	r31, 0x09	; 9
    12f0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    12f2:	85 ff       	sbrs	r24, 5
    12f4:	fd cf       	rjmp	.-6      	; 0x12f0 <st7565r_init+0x124>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    12f6:	88 ec       	ldi	r24, 0xC8	; 200
    12f8:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    12fc:	e0 ea       	ldi	r30, 0xA0	; 160
    12fe:	f9 e0       	ldi	r31, 0x09	; 9
    1300:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1302:	86 ff       	sbrs	r24, 6
    1304:	fd cf       	rjmp	.-6      	; 0x1300 <st7565r_init+0x134>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1306:	e0 ea       	ldi	r30, 0xA0	; 160
    1308:	f9 e0       	ldi	r31, 0x09	; 9
    130a:	80 e4       	ldi	r24, 0x40	; 64
    130c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    130e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1310:	be 01       	movw	r22, r28
    1312:	6f 5f       	subi	r22, 0xFF	; 255
    1314:	7f 4f       	sbci	r23, 0xFF	; 255
    1316:	80 ea       	ldi	r24, 0xA0	; 160
    1318:	99 e0       	ldi	r25, 0x09	; 9
    131a:	0e 94 16 12 	call	0x242c	; 0x242c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    131e:	8b e2       	ldi	r24, 0x2B	; 43
    1320:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1322:	be 01       	movw	r22, r28
    1324:	6f 5f       	subi	r22, 0xFF	; 255
    1326:	7f 4f       	sbci	r23, 0xFF	; 255
    1328:	80 ea       	ldi	r24, 0xA0	; 160
    132a:	99 e0       	ldi	r25, 0x09	; 9
    132c:	0e 94 00 12 	call	0x2400	; 0x2400 <usart_spi_select_device>
    1330:	81 e0       	ldi	r24, 0x01	; 1
    1332:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1336:	e0 ea       	ldi	r30, 0xA0	; 160
    1338:	f9 e0       	ldi	r31, 0x09	; 9
    133a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    133c:	85 ff       	sbrs	r24, 5
    133e:	fd cf       	rjmp	.-6      	; 0x133a <st7565r_init+0x16e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1340:	82 ea       	ldi	r24, 0xA2	; 162
    1342:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1346:	e0 ea       	ldi	r30, 0xA0	; 160
    1348:	f9 e0       	ldi	r31, 0x09	; 9
    134a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    134c:	86 ff       	sbrs	r24, 6
    134e:	fd cf       	rjmp	.-6      	; 0x134a <st7565r_init+0x17e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1350:	e0 ea       	ldi	r30, 0xA0	; 160
    1352:	f9 e0       	ldi	r31, 0x09	; 9
    1354:	80 e4       	ldi	r24, 0x40	; 64
    1356:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1358:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    135a:	be 01       	movw	r22, r28
    135c:	6f 5f       	subi	r22, 0xFF	; 255
    135e:	7f 4f       	sbci	r23, 0xFF	; 255
    1360:	80 ea       	ldi	r24, 0xA0	; 160
    1362:	99 e0       	ldi	r25, 0x09	; 9
    1364:	0e 94 16 12 	call	0x242c	; 0x242c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1368:	8b e2       	ldi	r24, 0x2B	; 43
    136a:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    136c:	be 01       	movw	r22, r28
    136e:	6f 5f       	subi	r22, 0xFF	; 255
    1370:	7f 4f       	sbci	r23, 0xFF	; 255
    1372:	80 ea       	ldi	r24, 0xA0	; 160
    1374:	99 e0       	ldi	r25, 0x09	; 9
    1376:	0e 94 00 12 	call	0x2400	; 0x2400 <usart_spi_select_device>
    137a:	81 e0       	ldi	r24, 0x01	; 1
    137c:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1380:	e0 ea       	ldi	r30, 0xA0	; 160
    1382:	f9 e0       	ldi	r31, 0x09	; 9
    1384:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1386:	85 ff       	sbrs	r24, 5
    1388:	fd cf       	rjmp	.-6      	; 0x1384 <st7565r_init+0x1b8>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    138a:	8f e2       	ldi	r24, 0x2F	; 47
    138c:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1390:	e0 ea       	ldi	r30, 0xA0	; 160
    1392:	f9 e0       	ldi	r31, 0x09	; 9
    1394:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1396:	86 ff       	sbrs	r24, 6
    1398:	fd cf       	rjmp	.-6      	; 0x1394 <st7565r_init+0x1c8>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    139a:	e0 ea       	ldi	r30, 0xA0	; 160
    139c:	f9 e0       	ldi	r31, 0x09	; 9
    139e:	80 e4       	ldi	r24, 0x40	; 64
    13a0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    13a2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    13a4:	be 01       	movw	r22, r28
    13a6:	6f 5f       	subi	r22, 0xFF	; 255
    13a8:	7f 4f       	sbci	r23, 0xFF	; 255
    13aa:	80 ea       	ldi	r24, 0xA0	; 160
    13ac:	99 e0       	ldi	r25, 0x09	; 9
    13ae:	0e 94 16 12 	call	0x242c	; 0x242c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    13b2:	8b e2       	ldi	r24, 0x2B	; 43
    13b4:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    13b6:	be 01       	movw	r22, r28
    13b8:	6f 5f       	subi	r22, 0xFF	; 255
    13ba:	7f 4f       	sbci	r23, 0xFF	; 255
    13bc:	80 ea       	ldi	r24, 0xA0	; 160
    13be:	99 e0       	ldi	r25, 0x09	; 9
    13c0:	0e 94 00 12 	call	0x2400	; 0x2400 <usart_spi_select_device>
    13c4:	81 e0       	ldi	r24, 0x01	; 1
    13c6:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    13ca:	e0 ea       	ldi	r30, 0xA0	; 160
    13cc:	f9 e0       	ldi	r31, 0x09	; 9
    13ce:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    13d0:	85 ff       	sbrs	r24, 5
    13d2:	fd cf       	rjmp	.-6      	; 0x13ce <st7565r_init+0x202>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    13d4:	88 ef       	ldi	r24, 0xF8	; 248
    13d6:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    13da:	e0 ea       	ldi	r30, 0xA0	; 160
    13dc:	f9 e0       	ldi	r31, 0x09	; 9
    13de:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    13e0:	86 ff       	sbrs	r24, 6
    13e2:	fd cf       	rjmp	.-6      	; 0x13de <st7565r_init+0x212>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    13e4:	e0 ea       	ldi	r30, 0xA0	; 160
    13e6:	f9 e0       	ldi	r31, 0x09	; 9
    13e8:	80 e4       	ldi	r24, 0x40	; 64
    13ea:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    13ec:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    13ee:	be 01       	movw	r22, r28
    13f0:	6f 5f       	subi	r22, 0xFF	; 255
    13f2:	7f 4f       	sbci	r23, 0xFF	; 255
    13f4:	80 ea       	ldi	r24, 0xA0	; 160
    13f6:	99 e0       	ldi	r25, 0x09	; 9
    13f8:	0e 94 16 12 	call	0x242c	; 0x242c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    13fc:	8b e2       	ldi	r24, 0x2B	; 43
    13fe:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1400:	be 01       	movw	r22, r28
    1402:	6f 5f       	subi	r22, 0xFF	; 255
    1404:	7f 4f       	sbci	r23, 0xFF	; 255
    1406:	80 ea       	ldi	r24, 0xA0	; 160
    1408:	99 e0       	ldi	r25, 0x09	; 9
    140a:	fa d7       	rcall	.+4084   	; 0x2400 <usart_spi_select_device>
    140c:	81 e0       	ldi	r24, 0x01	; 1
    140e:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1412:	e0 ea       	ldi	r30, 0xA0	; 160
    1414:	f9 e0       	ldi	r31, 0x09	; 9
    1416:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1418:	85 ff       	sbrs	r24, 5
    141a:	fd cf       	rjmp	.-6      	; 0x1416 <st7565r_init+0x24a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    141c:	10 92 a0 09 	sts	0x09A0, r1
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1420:	e0 ea       	ldi	r30, 0xA0	; 160
    1422:	f9 e0       	ldi	r31, 0x09	; 9
    1424:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1426:	86 ff       	sbrs	r24, 6
    1428:	fd cf       	rjmp	.-6      	; 0x1424 <st7565r_init+0x258>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    142a:	e0 ea       	ldi	r30, 0xA0	; 160
    142c:	f9 e0       	ldi	r31, 0x09	; 9
    142e:	80 e4       	ldi	r24, 0x40	; 64
    1430:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1432:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1434:	be 01       	movw	r22, r28
    1436:	6f 5f       	subi	r22, 0xFF	; 255
    1438:	7f 4f       	sbci	r23, 0xFF	; 255
    143a:	80 ea       	ldi	r24, 0xA0	; 160
    143c:	99 e0       	ldi	r25, 0x09	; 9
    143e:	f6 d7       	rcall	.+4076   	; 0x242c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1440:	8b e2       	ldi	r24, 0x2B	; 43
    1442:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1444:	be 01       	movw	r22, r28
    1446:	6f 5f       	subi	r22, 0xFF	; 255
    1448:	7f 4f       	sbci	r23, 0xFF	; 255
    144a:	80 ea       	ldi	r24, 0xA0	; 160
    144c:	99 e0       	ldi	r25, 0x09	; 9
    144e:	d8 d7       	rcall	.+4016   	; 0x2400 <usart_spi_select_device>
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1456:	e0 ea       	ldi	r30, 0xA0	; 160
    1458:	f9 e0       	ldi	r31, 0x09	; 9
    145a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    145c:	85 ff       	sbrs	r24, 5
    145e:	fd cf       	rjmp	.-6      	; 0x145a <st7565r_init+0x28e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1460:	81 e2       	ldi	r24, 0x21	; 33
    1462:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1466:	e0 ea       	ldi	r30, 0xA0	; 160
    1468:	f9 e0       	ldi	r31, 0x09	; 9
    146a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    146c:	86 ff       	sbrs	r24, 6
    146e:	fd cf       	rjmp	.-6      	; 0x146a <st7565r_init+0x29e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1470:	e0 ea       	ldi	r30, 0xA0	; 160
    1472:	f9 e0       	ldi	r31, 0x09	; 9
    1474:	80 e4       	ldi	r24, 0x40	; 64
    1476:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1478:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    147a:	be 01       	movw	r22, r28
    147c:	6f 5f       	subi	r22, 0xFF	; 255
    147e:	7f 4f       	sbci	r23, 0xFF	; 255
    1480:	80 ea       	ldi	r24, 0xA0	; 160
    1482:	99 e0       	ldi	r25, 0x09	; 9
    1484:	d3 d7       	rcall	.+4006   	; 0x242c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1486:	8b e2       	ldi	r24, 0x2B	; 43
    1488:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    148a:	be 01       	movw	r22, r28
    148c:	6f 5f       	subi	r22, 0xFF	; 255
    148e:	7f 4f       	sbci	r23, 0xFF	; 255
    1490:	80 ea       	ldi	r24, 0xA0	; 160
    1492:	99 e0       	ldi	r25, 0x09	; 9
    1494:	b5 d7       	rcall	.+3946   	; 0x2400 <usart_spi_select_device>
    1496:	81 e0       	ldi	r24, 0x01	; 1
    1498:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    149c:	e0 ea       	ldi	r30, 0xA0	; 160
    149e:	f9 e0       	ldi	r31, 0x09	; 9
    14a0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    14a2:	85 ff       	sbrs	r24, 5
    14a4:	fd cf       	rjmp	.-6      	; 0x14a0 <st7565r_init+0x2d4>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    14a6:	81 e8       	ldi	r24, 0x81	; 129
    14a8:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    14ac:	e0 ea       	ldi	r30, 0xA0	; 160
    14ae:	f9 e0       	ldi	r31, 0x09	; 9
    14b0:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    14b2:	86 ff       	sbrs	r24, 6
    14b4:	fd cf       	rjmp	.-6      	; 0x14b0 <st7565r_init+0x2e4>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    14b6:	e0 ea       	ldi	r30, 0xA0	; 160
    14b8:	f9 e0       	ldi	r31, 0x09	; 9
    14ba:	80 e4       	ldi	r24, 0x40	; 64
    14bc:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    14be:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    14c0:	be 01       	movw	r22, r28
    14c2:	6f 5f       	subi	r22, 0xFF	; 255
    14c4:	7f 4f       	sbci	r23, 0xFF	; 255
    14c6:	80 ea       	ldi	r24, 0xA0	; 160
    14c8:	99 e0       	ldi	r25, 0x09	; 9
    14ca:	b0 d7       	rcall	.+3936   	; 0x242c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    14cc:	8b e2       	ldi	r24, 0x2B	; 43
    14ce:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    14d0:	be 01       	movw	r22, r28
    14d2:	6f 5f       	subi	r22, 0xFF	; 255
    14d4:	7f 4f       	sbci	r23, 0xFF	; 255
    14d6:	80 ea       	ldi	r24, 0xA0	; 160
    14d8:	99 e0       	ldi	r25, 0x09	; 9
    14da:	92 d7       	rcall	.+3876   	; 0x2400 <usart_spi_select_device>
    14dc:	81 e0       	ldi	r24, 0x01	; 1
    14de:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    14e2:	e0 ea       	ldi	r30, 0xA0	; 160
    14e4:	f9 e0       	ldi	r31, 0x09	; 9
    14e6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    14e8:	85 ff       	sbrs	r24, 5
    14ea:	fd cf       	rjmp	.-6      	; 0x14e6 <st7565r_init+0x31a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    14ec:	81 e2       	ldi	r24, 0x21	; 33
    14ee:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    14f2:	e0 ea       	ldi	r30, 0xA0	; 160
    14f4:	f9 e0       	ldi	r31, 0x09	; 9
    14f6:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    14f8:	86 ff       	sbrs	r24, 6
    14fa:	fd cf       	rjmp	.-6      	; 0x14f6 <st7565r_init+0x32a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    14fc:	e0 ea       	ldi	r30, 0xA0	; 160
    14fe:	f9 e0       	ldi	r31, 0x09	; 9
    1500:	80 e4       	ldi	r24, 0x40	; 64
    1502:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1504:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1506:	be 01       	movw	r22, r28
    1508:	6f 5f       	subi	r22, 0xFF	; 255
    150a:	7f 4f       	sbci	r23, 0xFF	; 255
    150c:	80 ea       	ldi	r24, 0xA0	; 160
    150e:	99 e0       	ldi	r25, 0x09	; 9
    1510:	8d d7       	rcall	.+3866   	; 0x242c <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1512:	8b e2       	ldi	r24, 0x2B	; 43
    1514:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1516:	be 01       	movw	r22, r28
    1518:	6f 5f       	subi	r22, 0xFF	; 255
    151a:	7f 4f       	sbci	r23, 0xFF	; 255
    151c:	80 ea       	ldi	r24, 0xA0	; 160
    151e:	99 e0       	ldi	r25, 0x09	; 9
    1520:	6f d7       	rcall	.+3806   	; 0x2400 <usart_spi_select_device>
    1522:	81 e0       	ldi	r24, 0x01	; 1
    1524:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1528:	e0 ea       	ldi	r30, 0xA0	; 160
    152a:	f9 e0       	ldi	r31, 0x09	; 9
    152c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    152e:	85 ff       	sbrs	r24, 5
    1530:	fd cf       	rjmp	.-6      	; 0x152c <st7565r_init+0x360>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1532:	8f ea       	ldi	r24, 0xAF	; 175
    1534:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1538:	e0 ea       	ldi	r30, 0xA0	; 160
    153a:	f9 e0       	ldi	r31, 0x09	; 9
    153c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    153e:	86 ff       	sbrs	r24, 6
    1540:	fd cf       	rjmp	.-6      	; 0x153c <st7565r_init+0x370>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1542:	e0 ea       	ldi	r30, 0xA0	; 160
    1544:	f9 e0       	ldi	r31, 0x09	; 9
    1546:	80 e4       	ldi	r24, 0x40	; 64
    1548:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    154a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    154c:	be 01       	movw	r22, r28
    154e:	6f 5f       	subi	r22, 0xFF	; 255
    1550:	7f 4f       	sbci	r23, 0xFF	; 255
    1552:	80 ea       	ldi	r24, 0xA0	; 160
    1554:	99 e0       	ldi	r25, 0x09	; 9
    1556:	6a d7       	rcall	.+3796   	; 0x242c <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
    1558:	0f 90       	pop	r0
    155a:	df 91       	pop	r29
    155c:	cf 91       	pop	r28
    155e:	1f 91       	pop	r17
    1560:	0f 91       	pop	r16
    1562:	ff 90       	pop	r15
    1564:	ef 90       	pop	r14
    1566:	df 90       	pop	r13
    1568:	cf 90       	pop	r12
    156a:	bf 90       	pop	r11
    156c:	08 95       	ret

0000156e <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
    156e:	ff 92       	push	r15
    1570:	0f 93       	push	r16
    1572:	1f 93       	push	r17
    1574:	cf 93       	push	r28
    1576:	df 93       	push	r29
    1578:	1f 92       	push	r1
    157a:	cd b7       	in	r28, 0x3d	; 61
    157c:	de b7       	in	r29, 0x3e	; 62
    157e:	08 2f       	mov	r16, r24
    1580:	f6 2e       	mov	r15, r22
    1582:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
    1584:	6e d7       	rcall	.+3804   	; 0x2462 <gfx_mono_framebuffer_put_byte>
 * \param address the page address
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
    1586:	0f 70       	andi	r16, 0x0F	; 15
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
    1588:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    158a:	8b e2       	ldi	r24, 0x2B	; 43
    158c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    158e:	be 01       	movw	r22, r28
    1590:	6f 5f       	subi	r22, 0xFF	; 255
    1592:	7f 4f       	sbci	r23, 0xFF	; 255
    1594:	80 ea       	ldi	r24, 0xA0	; 160
    1596:	99 e0       	ldi	r25, 0x09	; 9
    1598:	33 d7       	rcall	.+3686   	; 0x2400 <usart_spi_select_device>
    159a:	81 e0       	ldi	r24, 0x01	; 1
    159c:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    15a0:	e0 ea       	ldi	r30, 0xA0	; 160
    15a2:	f9 e0       	ldi	r31, 0x09	; 9
    15a4:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    15a6:	95 ff       	sbrs	r25, 5
    15a8:	fd cf       	rjmp	.-6      	; 0x15a4 <gfx_mono_st7565r_put_byte+0x36>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    15aa:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    15ae:	e0 ea       	ldi	r30, 0xA0	; 160
    15b0:	f9 e0       	ldi	r31, 0x09	; 9
    15b2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    15b4:	86 ff       	sbrs	r24, 6
    15b6:	fd cf       	rjmp	.-6      	; 0x15b2 <gfx_mono_st7565r_put_byte+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    15b8:	e0 ea       	ldi	r30, 0xA0	; 160
    15ba:	f9 e0       	ldi	r31, 0x09	; 9
    15bc:	80 e4       	ldi	r24, 0x40	; 64
    15be:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    15c0:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    15c2:	be 01       	movw	r22, r28
    15c4:	6f 5f       	subi	r22, 0xFF	; 255
    15c6:	7f 4f       	sbci	r23, 0xFF	; 255
    15c8:	80 ea       	ldi	r24, 0xA0	; 160
    15ca:	99 e0       	ldi	r25, 0x09	; 9
    15cc:	2f d7       	rcall	.+3678   	; 0x242c <usart_spi_deselect_device>
 * \param address the column address
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
    15ce:	0f 2d       	mov	r16, r15
    15d0:	0f 77       	andi	r16, 0x7F	; 127
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
    15d2:	02 95       	swap	r16
    15d4:	0f 70       	andi	r16, 0x0F	; 15
    15d6:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    15d8:	8b e2       	ldi	r24, 0x2B	; 43
    15da:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    15dc:	be 01       	movw	r22, r28
    15de:	6f 5f       	subi	r22, 0xFF	; 255
    15e0:	7f 4f       	sbci	r23, 0xFF	; 255
    15e2:	80 ea       	ldi	r24, 0xA0	; 160
    15e4:	99 e0       	ldi	r25, 0x09	; 9
    15e6:	0c d7       	rcall	.+3608   	; 0x2400 <usart_spi_select_device>
    15e8:	81 e0       	ldi	r24, 0x01	; 1
    15ea:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    15ee:	e0 ea       	ldi	r30, 0xA0	; 160
    15f0:	f9 e0       	ldi	r31, 0x09	; 9
    15f2:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    15f4:	85 ff       	sbrs	r24, 5
    15f6:	fd cf       	rjmp	.-6      	; 0x15f2 <gfx_mono_st7565r_put_byte+0x84>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    15f8:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    15fc:	e0 ea       	ldi	r30, 0xA0	; 160
    15fe:	f9 e0       	ldi	r31, 0x09	; 9
    1600:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    1602:	86 ff       	sbrs	r24, 6
    1604:	fd cf       	rjmp	.-6      	; 0x1600 <gfx_mono_st7565r_put_byte+0x92>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1606:	e0 ea       	ldi	r30, 0xA0	; 160
    1608:	f9 e0       	ldi	r31, 0x09	; 9
    160a:	80 e4       	ldi	r24, 0x40	; 64
    160c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    160e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1610:	be 01       	movw	r22, r28
    1612:	6f 5f       	subi	r22, 0xFF	; 255
    1614:	7f 4f       	sbci	r23, 0xFF	; 255
    1616:	80 ea       	ldi	r24, 0xA0	; 160
    1618:	99 e0       	ldi	r25, 0x09	; 9
    161a:	08 d7       	rcall	.+3600   	; 0x242c <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
    161c:	0f 2d       	mov	r16, r15
    161e:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1620:	8b e2       	ldi	r24, 0x2B	; 43
    1622:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1624:	be 01       	movw	r22, r28
    1626:	6f 5f       	subi	r22, 0xFF	; 255
    1628:	7f 4f       	sbci	r23, 0xFF	; 255
    162a:	80 ea       	ldi	r24, 0xA0	; 160
    162c:	99 e0       	ldi	r25, 0x09	; 9
    162e:	e8 d6       	rcall	.+3536   	; 0x2400 <usart_spi_select_device>
    1630:	81 e0       	ldi	r24, 0x01	; 1
    1632:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    1636:	e0 ea       	ldi	r30, 0xA0	; 160
    1638:	f9 e0       	ldi	r31, 0x09	; 9
    163a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    163c:	85 ff       	sbrs	r24, 5
    163e:	fd cf       	rjmp	.-6      	; 0x163a <gfx_mono_st7565r_put_byte+0xcc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1640:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1644:	e0 ea       	ldi	r30, 0xA0	; 160
    1646:	f9 e0       	ldi	r31, 0x09	; 9
    1648:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    164a:	86 ff       	sbrs	r24, 6
    164c:	fd cf       	rjmp	.-6      	; 0x1648 <gfx_mono_st7565r_put_byte+0xda>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    164e:	e0 ea       	ldi	r30, 0xA0	; 160
    1650:	f9 e0       	ldi	r31, 0x09	; 9
    1652:	80 e4       	ldi	r24, 0x40	; 64
    1654:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    1656:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    1658:	be 01       	movw	r22, r28
    165a:	6f 5f       	subi	r22, 0xFF	; 255
    165c:	7f 4f       	sbci	r23, 0xFF	; 255
    165e:	80 ea       	ldi	r24, 0xA0	; 160
    1660:	99 e0       	ldi	r25, 0x09	; 9
    1662:	e4 d6       	rcall	.+3528   	; 0x242c <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    1664:	8b e2       	ldi	r24, 0x2B	; 43
    1666:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    1668:	be 01       	movw	r22, r28
    166a:	6f 5f       	subi	r22, 0xFF	; 255
    166c:	7f 4f       	sbci	r23, 0xFF	; 255
    166e:	80 ea       	ldi	r24, 0xA0	; 160
    1670:	99 e0       	ldi	r25, 0x09	; 9
    1672:	c6 d6       	rcall	.+3468   	; 0x2400 <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1674:	81 e0       	ldi	r24, 0x01	; 1
    1676:	80 93 65 06 	sts	0x0665, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    167a:	e0 ea       	ldi	r30, 0xA0	; 160
    167c:	f9 e0       	ldi	r31, 0x09	; 9
    167e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    1680:	85 ff       	sbrs	r24, 5
    1682:	fd cf       	rjmp	.-6      	; 0x167e <gfx_mono_st7565r_put_byte+0x110>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    1684:	10 93 a0 09 	sts	0x09A0, r17
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    1688:	e0 ea       	ldi	r30, 0xA0	; 160
    168a:	f9 e0       	ldi	r31, 0x09	; 9
    168c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    168e:	86 ff       	sbrs	r24, 6
    1690:	fd cf       	rjmp	.-6      	; 0x168c <gfx_mono_st7565r_put_byte+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1692:	e0 ea       	ldi	r30, 0xA0	; 160
    1694:	f9 e0       	ldi	r31, 0x09	; 9
    1696:	80 e4       	ldi	r24, 0x40	; 64
    1698:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    169a:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    169c:	81 e0       	ldi	r24, 0x01	; 1
    169e:	80 93 66 06 	sts	0x0666, r24
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    16a2:	be 01       	movw	r22, r28
    16a4:	6f 5f       	subi	r22, 0xFF	; 255
    16a6:	7f 4f       	sbci	r23, 0xFF	; 255
    16a8:	80 ea       	ldi	r24, 0xA0	; 160
    16aa:	99 e0       	ldi	r25, 0x09	; 9
    16ac:	bf d6       	rcall	.+3454   	; 0x242c <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
    16ae:	0f 90       	pop	r0
    16b0:	df 91       	pop	r29
    16b2:	cf 91       	pop	r28
    16b4:	1f 91       	pop	r17
    16b6:	0f 91       	pop	r16
    16b8:	ff 90       	pop	r15
    16ba:	08 95       	ret

000016bc <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
    16bc:	0f 93       	push	r16
    16be:	1f 93       	push	r17
    16c0:	cf 93       	push	r28
    16c2:	df 93       	push	r29
    16c4:	1f 92       	push	r1
    16c6:	cd b7       	in	r28, 0x3d	; 61
    16c8:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
    16ca:	85 e8       	ldi	r24, 0x85	; 133
    16cc:	90 e2       	ldi	r25, 0x20	; 32
    16ce:	c4 d6       	rcall	.+3464   	; 0x2458 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
    16d0:	7d dd       	rcall	.-1286   	; 0x11cc <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
    16d2:	8b e2       	ldi	r24, 0x2B	; 43
    16d4:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
    16d6:	be 01       	movw	r22, r28
    16d8:	6f 5f       	subi	r22, 0xFF	; 255
    16da:	7f 4f       	sbci	r23, 0xFF	; 255
    16dc:	80 ea       	ldi	r24, 0xA0	; 160
    16de:	99 e0       	ldi	r25, 0x09	; 9
    16e0:	8f d6       	rcall	.+3358   	; 0x2400 <usart_spi_select_device>
    16e2:	81 e0       	ldi	r24, 0x01	; 1
    16e4:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
    16e8:	e0 ea       	ldi	r30, 0xA0	; 160
    16ea:	f9 e0       	ldi	r31, 0x09	; 9
    16ec:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
    16ee:	85 ff       	sbrs	r24, 5
    16f0:	fd cf       	rjmp	.-6      	; 0x16ec <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
    16f2:	80 e4       	ldi	r24, 0x40	; 64
    16f4:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
    16f8:	e0 ea       	ldi	r30, 0xA0	; 160
    16fa:	f9 e0       	ldi	r31, 0x09	; 9
    16fc:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
    16fe:	86 ff       	sbrs	r24, 6
    1700:	fd cf       	rjmp	.-6      	; 0x16fc <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
    1702:	e0 ea       	ldi	r30, 0xA0	; 160
    1704:	f9 e0       	ldi	r31, 0x09	; 9
    1706:	80 e4       	ldi	r24, 0x40	; 64
    1708:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
    170a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
    170c:	be 01       	movw	r22, r28
    170e:	6f 5f       	subi	r22, 0xFF	; 255
    1710:	7f 4f       	sbci	r23, 0xFF	; 255
    1712:	80 ea       	ldi	r24, 0xA0	; 160
    1714:	99 e0       	ldi	r25, 0x09	; 9
    1716:	8a d6       	rcall	.+3348   	; 0x242c <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    1718:	00 e0       	ldi	r16, 0x00	; 0
    171a:	0a c0       	rjmp	.+20     	; 0x1730 <gfx_mono_st7565r_init+0x74>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
    171c:	40 e0       	ldi	r20, 0x00	; 0
    171e:	61 2f       	mov	r22, r17
    1720:	80 2f       	mov	r24, r16
    1722:	25 df       	rcall	.-438    	; 0x156e <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
    1724:	1f 5f       	subi	r17, 0xFF	; 255
    1726:	10 38       	cpi	r17, 0x80	; 128
    1728:	c9 f7       	brne	.-14     	; 0x171c <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
    172a:	0f 5f       	subi	r16, 0xFF	; 255
    172c:	04 30       	cpi	r16, 0x04	; 4
    172e:	11 f0       	breq	.+4      	; 0x1734 <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
    1730:	10 e0       	ldi	r17, 0x00	; 0
    1732:	f4 cf       	rjmp	.-24     	; 0x171c <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
    1734:	0f 90       	pop	r0
    1736:	df 91       	pop	r29
    1738:	cf 91       	pop	r28
    173a:	1f 91       	pop	r17
    173c:	0f 91       	pop	r16
    173e:	08 95       	ret

00001740 <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
    1740:	ff 92       	push	r15
    1742:	0f 93       	push	r16
    1744:	1f 93       	push	r17
    1746:	cf 93       	push	r28
    1748:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
    174a:	88 23       	and	r24, r24
    174c:	8c f1       	brlt	.+98     	; 0x17b0 <gfx_mono_st7565r_draw_pixel+0x70>
    174e:	60 32       	cpi	r22, 0x20	; 32
    1750:	78 f5       	brcc	.+94     	; 0x17b0 <gfx_mono_st7565r_draw_pixel+0x70>
    1752:	d4 2f       	mov	r29, r20
    1754:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
    1756:	f6 2e       	mov	r15, r22
    1758:	f6 94       	lsr	r15
    175a:	f6 94       	lsr	r15
    175c:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
    175e:	2f 2d       	mov	r18, r15
    1760:	30 e0       	ldi	r19, 0x00	; 0
    1762:	31 95       	neg	r19
    1764:	21 95       	neg	r18
    1766:	31 09       	sbc	r19, r1
    1768:	22 0f       	add	r18, r18
    176a:	33 1f       	adc	r19, r19
    176c:	22 0f       	add	r18, r18
    176e:	33 1f       	adc	r19, r19
    1770:	22 0f       	add	r18, r18
    1772:	33 1f       	adc	r19, r19
    1774:	26 0f       	add	r18, r22
    1776:	31 1d       	adc	r19, r1
    1778:	61 e0       	ldi	r22, 0x01	; 1
    177a:	70 e0       	ldi	r23, 0x00	; 0
    177c:	8b 01       	movw	r16, r22
    177e:	02 c0       	rjmp	.+4      	; 0x1784 <gfx_mono_st7565r_draw_pixel+0x44>
    1780:	00 0f       	add	r16, r16
    1782:	11 1f       	adc	r17, r17
    1784:	2a 95       	dec	r18
    1786:	e2 f7       	brpl	.-8      	; 0x1780 <gfx_mono_st7565r_draw_pixel+0x40>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
    1788:	68 2f       	mov	r22, r24
    178a:	8f 2d       	mov	r24, r15
    178c:	78 d6       	rcall	.+3312   	; 0x247e <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
    178e:	d1 30       	cpi	r29, 0x01	; 1
    1790:	21 f0       	breq	.+8      	; 0x179a <gfx_mono_st7565r_draw_pixel+0x5a>
    1792:	28 f0       	brcs	.+10     	; 0x179e <gfx_mono_st7565r_draw_pixel+0x5e>
    1794:	d2 30       	cpi	r29, 0x02	; 2
    1796:	39 f0       	breq	.+14     	; 0x17a6 <gfx_mono_st7565r_draw_pixel+0x66>
    1798:	07 c0       	rjmp	.+14     	; 0x17a8 <gfx_mono_st7565r_draw_pixel+0x68>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
    179a:	80 2b       	or	r24, r16
		break;
    179c:	05 c0       	rjmp	.+10     	; 0x17a8 <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
    179e:	60 2f       	mov	r22, r16
    17a0:	60 95       	com	r22
    17a2:	86 23       	and	r24, r22
		break;
    17a4:	01 c0       	rjmp	.+2      	; 0x17a8 <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
    17a6:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
    17a8:	48 2f       	mov	r20, r24
    17aa:	6c 2f       	mov	r22, r28
    17ac:	8f 2d       	mov	r24, r15
    17ae:	df de       	rcall	.-578    	; 0x156e <gfx_mono_st7565r_put_byte>
}
    17b0:	df 91       	pop	r29
    17b2:	cf 91       	pop	r28
    17b4:	1f 91       	pop	r17
    17b6:	0f 91       	pop	r16
    17b8:	ff 90       	pop	r15
    17ba:	08 95       	ret

000017bc <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
    17bc:	60 c6       	rjmp	.+3264   	; 0x247e <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
    17be:	08 95       	ret

000017c0 <tb_init>:


uint16_t qt_measurement_period_msec = 25;

void tb_init(void) {
	qt_config_data.qt_di				= DEF_QT_DI;
    17c0:	e7 e3       	ldi	r30, 0x37	; 55
    17c2:	f0 e2       	ldi	r31, 0x20	; 32
    17c4:	84 e0       	ldi	r24, 0x04	; 4
    17c6:	81 83       	std	Z+1, r24	; 0x01
	qt_config_data.qt_neg_drift_rate	= DEF_QT_NEG_DRIFT_RATE;
    17c8:	84 e1       	ldi	r24, 0x14	; 20
    17ca:	84 83       	std	Z+4, r24	; 0x04
	qt_config_data.qt_pos_drift_rate	= DEF_QT_POS_DRIFT_RATE;
    17cc:	95 e0       	ldi	r25, 0x05	; 5
    17ce:	95 83       	std	Z+5, r25	; 0x05
	qt_config_data.qt_max_on_duration	= DEF_QT_MAX_ON_DURATION;
    17d0:	13 82       	std	Z+3, r1	; 0x03
	qt_config_data.qt_drift_hold_time	= DEF_QT_DRIFT_HOLD_TIME;
    17d2:	82 83       	std	Z+2, r24	; 0x02
	qt_config_data.qt_recal_threshold	= DEF_QT_RECAL_THRESHOLD;
    17d4:	81 e0       	ldi	r24, 0x01	; 1
    17d6:	80 83       	st	Z, r24
	qt_config_data.qt_pos_recal_delay	= DEF_QT_POS_RECAL_DELAY;
    17d8:	83 e0       	ldi	r24, 0x03	; 3
    17da:	86 83       	std	Z+6, r24	; 0x06
	qt_filter_callback					= 0;
    17dc:	10 92 51 20 	sts	0x2051, r1
    17e0:	10 92 52 20 	sts	0x2052, r1


	#ifdef QTOUCH_STUDIO_MASKS
		SNS_array[0][0] = 0x40;
    17e4:	e5 e7       	ldi	r30, 0x75	; 117
    17e6:	f0 e2       	ldi	r31, 0x20	; 32
    17e8:	80 e4       	ldi	r24, 0x40	; 64
    17ea:	80 83       	st	Z, r24
		SNS_array[0][1] = 0x0;
    17ec:	11 82       	std	Z+1, r1	; 0x01
		SNS_array[1][0] = 0x0;
    17ee:	12 82       	std	Z+2, r1	; 0x02
		SNS_array[1][1] = 0x0;
    17f0:	13 82       	std	Z+3, r1	; 0x03

		SNSK_array[0][0] = 0x80;
    17f2:	e9 e7       	ldi	r30, 0x79	; 121
    17f4:	f0 e2       	ldi	r31, 0x20	; 32
    17f6:	80 e8       	ldi	r24, 0x80	; 128
    17f8:	80 83       	st	Z, r24
		SNSK_array[0][1] = 0x0;
    17fa:	11 82       	std	Z+1, r1	; 0x01
		SNSK_array[1][0] = 0x0;
    17fc:	12 82       	std	Z+2, r1	; 0x02
		SNSK_array[1][1] = 0x0;
    17fe:	13 82       	std	Z+3, r1	; 0x03
	 * When using "pin configurability" this will result in channel 0
	 * because it is the first and only channel that is used.
	 * For the standard qtouch library setup we would need to use
	 * channel 3 since we are using the last two pins on the port.
	 */
	qt_enable_key(CHANNEL_0, NO_AKS_GROUP, 10, HYST_6_25);
    1800:	23 e0       	ldi	r18, 0x03	; 3
    1802:	4a e0       	ldi	r20, 0x0A	; 10
    1804:	60 e0       	ldi	r22, 0x00	; 0
    1806:	80 e0       	ldi	r24, 0x00	; 0
    1808:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <qt_enable_key>

	qt_init_sensing();
    180c:	60 e0       	ldi	r22, 0x00	; 0
    180e:	70 e0       	ldi	r23, 0x00	; 0
    1810:	87 e8       	ldi	r24, 0x87	; 135
    1812:	92 e0       	ldi	r25, 0x02	; 2
    1814:	72 c8       	rjmp	.-3868   	; 0x8fa <qt_init_sensing_with_burst>
    1816:	08 95       	ret

00001818 <adc_set_callback>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1818:	4f b7       	in	r20, 0x3f	; 63
	cpu_irq_disable();
    181a:	f8 94       	cli
	Assert(callback);

	flags = cpu_irq_save();

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    181c:	28 2f       	mov	r18, r24
    181e:	39 2f       	mov	r19, r25
    1820:	21 15       	cp	r18, r1
    1822:	82 e0       	ldi	r24, 0x02	; 2
    1824:	38 07       	cpc	r19, r24
    1826:	29 f4       	brne	.+10     	; 0x1832 <adc_set_callback+0x1a>
		adca_callback = callback;
    1828:	60 93 d9 23 	sts	0x23D9, r22
    182c:	70 93 da 23 	sts	0x23DA, r23
    1830:	07 c0       	rjmp	.+14     	; 0x1840 <adc_set_callback+0x28>
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1832:	20 34       	cpi	r18, 0x40	; 64
    1834:	32 40       	sbci	r19, 0x02	; 2
    1836:	21 f4       	brne	.+8      	; 0x1840 <adc_set_callback+0x28>
		adcb_callback = callback;
    1838:	60 93 d7 23 	sts	0x23D7, r22
    183c:	70 93 d8 23 	sts	0x23D8, r23
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1840:	4f bf       	out	0x3f, r20	; 63
    1842:	08 95       	ret

00001844 <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
    1844:	81 15       	cp	r24, r1
    1846:	22 e0       	ldi	r18, 0x02	; 2
    1848:	92 07       	cpc	r25, r18
    184a:	69 f4       	brne	.+26     	; 0x1866 <adc_enable_clock+0x22>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
    184c:	80 91 86 22 	lds	r24, 0x2286
    1850:	91 e0       	ldi	r25, 0x01	; 1
    1852:	98 0f       	add	r25, r24
    1854:	90 93 86 22 	sts	0x2286, r25
    1858:	81 11       	cpse	r24, r1
    185a:	14 c0       	rjmp	.+40     	; 0x1884 <adc_enable_clock+0x40>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    185c:	62 e0       	ldi	r22, 0x02	; 2
    185e:	81 e0       	ldi	r24, 0x01	; 1
    1860:	0c 94 ae 18 	jmp	0x315c	; 0x315c <sysclk_enable_module>
    1864:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
    1866:	80 34       	cpi	r24, 0x40	; 64
    1868:	92 40       	sbci	r25, 0x02	; 2
    186a:	61 f4       	brne	.+24     	; 0x1884 <adc_enable_clock+0x40>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
    186c:	80 91 85 22 	lds	r24, 0x2285
    1870:	91 e0       	ldi	r25, 0x01	; 1
    1872:	98 0f       	add	r25, r24
    1874:	90 93 85 22 	sts	0x2285, r25
    1878:	81 11       	cpse	r24, r1
    187a:	04 c0       	rjmp	.+8      	; 0x1884 <adc_enable_clock+0x40>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    187c:	62 e0       	ldi	r22, 0x02	; 2
    187e:	82 e0       	ldi	r24, 0x02	; 2
    1880:	0c 94 ae 18 	jmp	0x315c	; 0x315c <sysclk_enable_module>
    1884:	08 95       	ret

00001886 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
    1886:	81 15       	cp	r24, r1
    1888:	22 e0       	ldi	r18, 0x02	; 2
    188a:	92 07       	cpc	r25, r18
    188c:	61 f4       	brne	.+24     	; 0x18a6 <adc_disable_clock+0x20>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
    188e:	80 91 86 22 	lds	r24, 0x2286
    1892:	81 50       	subi	r24, 0x01	; 1
    1894:	80 93 86 22 	sts	0x2286, r24
    1898:	81 11       	cpse	r24, r1
    189a:	13 c0       	rjmp	.+38     	; 0x18c2 <adc_disable_clock+0x3c>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    189c:	62 e0       	ldi	r22, 0x02	; 2
    189e:	81 e0       	ldi	r24, 0x01	; 1
    18a0:	0c 94 ba 18 	jmp	0x3174	; 0x3174 <sysclk_disable_module>
    18a4:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
    18a6:	80 34       	cpi	r24, 0x40	; 64
    18a8:	92 40       	sbci	r25, 0x02	; 2
    18aa:	59 f4       	brne	.+22     	; 0x18c2 <adc_disable_clock+0x3c>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
    18ac:	80 91 85 22 	lds	r24, 0x2285
    18b0:	81 50       	subi	r24, 0x01	; 1
    18b2:	80 93 85 22 	sts	0x2285, r24
    18b6:	81 11       	cpse	r24, r1
    18b8:	04 c0       	rjmp	.+8      	; 0x18c2 <adc_disable_clock+0x3c>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    18ba:	62 e0       	ldi	r22, 0x02	; 2
    18bc:	82 e0       	ldi	r24, 0x02	; 2
    18be:	0c 94 ba 18 	jmp	0x3174	; 0x3174 <sysclk_disable_module>
    18c2:	08 95       	ret

000018c4 <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
    18c4:	1f 93       	push	r17
    18c6:	cf 93       	push	r28
    18c8:	df 93       	push	r29
    18ca:	ec 01       	movw	r28, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    18cc:	1f b7       	in	r17, 0x3f	; 63
	cpu_irq_disable();
    18ce:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
    18d0:	b9 df       	rcall	.-142    	; 0x1844 <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
    18d2:	88 81       	ld	r24, Y
    18d4:	81 60       	ori	r24, 0x01	; 1
    18d6:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    18d8:	1f bf       	out	0x3f, r17	; 63

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    18da:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    18dc:	f8 94       	cli
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
    18de:	e1 ed       	ldi	r30, 0xD1	; 209
    18e0:	f3 e2       	ldi	r31, 0x23	; 35
    18e2:	81 81       	ldd	r24, Z+1	; 0x01
    18e4:	8f 5f       	subi	r24, 0xFF	; 255
    18e6:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    18e8:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
    18ea:	df 91       	pop	r29
    18ec:	cf 91       	pop	r28
    18ee:	1f 91       	pop	r17
    18f0:	08 95       	ret

000018f2 <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
    18f2:	1f 92       	push	r1
    18f4:	0f 92       	push	r0
    18f6:	0f b6       	in	r0, 0x3f	; 63
    18f8:	0f 92       	push	r0
    18fa:	11 24       	eor	r1, r1
    18fc:	0b b6       	in	r0, 0x3b	; 59
    18fe:	0f 92       	push	r0
    1900:	2f 93       	push	r18
    1902:	3f 93       	push	r19
    1904:	4f 93       	push	r20
    1906:	5f 93       	push	r21
    1908:	6f 93       	push	r22
    190a:	7f 93       	push	r23
    190c:	8f 93       	push	r24
    190e:	9f 93       	push	r25
    1910:	af 93       	push	r26
    1912:	bf 93       	push	r27
    1914:	ef 93       	push	r30
    1916:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
    1918:	40 91 24 02 	lds	r20, 0x0224
    191c:	50 91 25 02 	lds	r21, 0x0225
    1920:	e0 91 d9 23 	lds	r30, 0x23D9
    1924:	f0 91 da 23 	lds	r31, 0x23DA
    1928:	61 e0       	ldi	r22, 0x01	; 1
    192a:	80 e0       	ldi	r24, 0x00	; 0
    192c:	92 e0       	ldi	r25, 0x02	; 2
    192e:	19 95       	eicall
}
    1930:	ff 91       	pop	r31
    1932:	ef 91       	pop	r30
    1934:	bf 91       	pop	r27
    1936:	af 91       	pop	r26
    1938:	9f 91       	pop	r25
    193a:	8f 91       	pop	r24
    193c:	7f 91       	pop	r23
    193e:	6f 91       	pop	r22
    1940:	5f 91       	pop	r21
    1942:	4f 91       	pop	r20
    1944:	3f 91       	pop	r19
    1946:	2f 91       	pop	r18
    1948:	0f 90       	pop	r0
    194a:	0b be       	out	0x3b, r0	; 59
    194c:	0f 90       	pop	r0
    194e:	0f be       	out	0x3f, r0	; 63
    1950:	0f 90       	pop	r0
    1952:	1f 90       	pop	r1
    1954:	18 95       	reti

00001956 <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
    1956:	1f 92       	push	r1
    1958:	0f 92       	push	r0
    195a:	0f b6       	in	r0, 0x3f	; 63
    195c:	0f 92       	push	r0
    195e:	11 24       	eor	r1, r1
    1960:	0b b6       	in	r0, 0x3b	; 59
    1962:	0f 92       	push	r0
    1964:	2f 93       	push	r18
    1966:	3f 93       	push	r19
    1968:	4f 93       	push	r20
    196a:	5f 93       	push	r21
    196c:	6f 93       	push	r22
    196e:	7f 93       	push	r23
    1970:	8f 93       	push	r24
    1972:	9f 93       	push	r25
    1974:	af 93       	push	r26
    1976:	bf 93       	push	r27
    1978:	ef 93       	push	r30
    197a:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
    197c:	40 91 2c 02 	lds	r20, 0x022C
    1980:	50 91 2d 02 	lds	r21, 0x022D
    1984:	e0 91 d9 23 	lds	r30, 0x23D9
    1988:	f0 91 da 23 	lds	r31, 0x23DA
    198c:	62 e0       	ldi	r22, 0x02	; 2
    198e:	80 e0       	ldi	r24, 0x00	; 0
    1990:	92 e0       	ldi	r25, 0x02	; 2
    1992:	19 95       	eicall
}
    1994:	ff 91       	pop	r31
    1996:	ef 91       	pop	r30
    1998:	bf 91       	pop	r27
    199a:	af 91       	pop	r26
    199c:	9f 91       	pop	r25
    199e:	8f 91       	pop	r24
    19a0:	7f 91       	pop	r23
    19a2:	6f 91       	pop	r22
    19a4:	5f 91       	pop	r21
    19a6:	4f 91       	pop	r20
    19a8:	3f 91       	pop	r19
    19aa:	2f 91       	pop	r18
    19ac:	0f 90       	pop	r0
    19ae:	0b be       	out	0x3b, r0	; 59
    19b0:	0f 90       	pop	r0
    19b2:	0f be       	out	0x3f, r0	; 63
    19b4:	0f 90       	pop	r0
    19b6:	1f 90       	pop	r1
    19b8:	18 95       	reti

000019ba <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
    19ba:	1f 92       	push	r1
    19bc:	0f 92       	push	r0
    19be:	0f b6       	in	r0, 0x3f	; 63
    19c0:	0f 92       	push	r0
    19c2:	11 24       	eor	r1, r1
    19c4:	0b b6       	in	r0, 0x3b	; 59
    19c6:	0f 92       	push	r0
    19c8:	2f 93       	push	r18
    19ca:	3f 93       	push	r19
    19cc:	4f 93       	push	r20
    19ce:	5f 93       	push	r21
    19d0:	6f 93       	push	r22
    19d2:	7f 93       	push	r23
    19d4:	8f 93       	push	r24
    19d6:	9f 93       	push	r25
    19d8:	af 93       	push	r26
    19da:	bf 93       	push	r27
    19dc:	ef 93       	push	r30
    19de:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
    19e0:	40 91 34 02 	lds	r20, 0x0234
    19e4:	50 91 35 02 	lds	r21, 0x0235
    19e8:	e0 91 d9 23 	lds	r30, 0x23D9
    19ec:	f0 91 da 23 	lds	r31, 0x23DA
    19f0:	64 e0       	ldi	r22, 0x04	; 4
    19f2:	80 e0       	ldi	r24, 0x00	; 0
    19f4:	92 e0       	ldi	r25, 0x02	; 2
    19f6:	19 95       	eicall
}
    19f8:	ff 91       	pop	r31
    19fa:	ef 91       	pop	r30
    19fc:	bf 91       	pop	r27
    19fe:	af 91       	pop	r26
    1a00:	9f 91       	pop	r25
    1a02:	8f 91       	pop	r24
    1a04:	7f 91       	pop	r23
    1a06:	6f 91       	pop	r22
    1a08:	5f 91       	pop	r21
    1a0a:	4f 91       	pop	r20
    1a0c:	3f 91       	pop	r19
    1a0e:	2f 91       	pop	r18
    1a10:	0f 90       	pop	r0
    1a12:	0b be       	out	0x3b, r0	; 59
    1a14:	0f 90       	pop	r0
    1a16:	0f be       	out	0x3f, r0	; 63
    1a18:	0f 90       	pop	r0
    1a1a:	1f 90       	pop	r1
    1a1c:	18 95       	reti

00001a1e <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    1a1e:	1f 92       	push	r1
    1a20:	0f 92       	push	r0
    1a22:	0f b6       	in	r0, 0x3f	; 63
    1a24:	0f 92       	push	r0
    1a26:	11 24       	eor	r1, r1
    1a28:	0b b6       	in	r0, 0x3b	; 59
    1a2a:	0f 92       	push	r0
    1a2c:	2f 93       	push	r18
    1a2e:	3f 93       	push	r19
    1a30:	4f 93       	push	r20
    1a32:	5f 93       	push	r21
    1a34:	6f 93       	push	r22
    1a36:	7f 93       	push	r23
    1a38:	8f 93       	push	r24
    1a3a:	9f 93       	push	r25
    1a3c:	af 93       	push	r26
    1a3e:	bf 93       	push	r27
    1a40:	ef 93       	push	r30
    1a42:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    1a44:	40 91 3c 02 	lds	r20, 0x023C
    1a48:	50 91 3d 02 	lds	r21, 0x023D
    1a4c:	e0 91 d9 23 	lds	r30, 0x23D9
    1a50:	f0 91 da 23 	lds	r31, 0x23DA
    1a54:	68 e0       	ldi	r22, 0x08	; 8
    1a56:	80 e0       	ldi	r24, 0x00	; 0
    1a58:	92 e0       	ldi	r25, 0x02	; 2
    1a5a:	19 95       	eicall
}
    1a5c:	ff 91       	pop	r31
    1a5e:	ef 91       	pop	r30
    1a60:	bf 91       	pop	r27
    1a62:	af 91       	pop	r26
    1a64:	9f 91       	pop	r25
    1a66:	8f 91       	pop	r24
    1a68:	7f 91       	pop	r23
    1a6a:	6f 91       	pop	r22
    1a6c:	5f 91       	pop	r21
    1a6e:	4f 91       	pop	r20
    1a70:	3f 91       	pop	r19
    1a72:	2f 91       	pop	r18
    1a74:	0f 90       	pop	r0
    1a76:	0b be       	out	0x3b, r0	; 59
    1a78:	0f 90       	pop	r0
    1a7a:	0f be       	out	0x3f, r0	; 63
    1a7c:	0f 90       	pop	r0
    1a7e:	1f 90       	pop	r1
    1a80:	18 95       	reti

00001a82 <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    1a82:	1f 92       	push	r1
    1a84:	0f 92       	push	r0
    1a86:	0f b6       	in	r0, 0x3f	; 63
    1a88:	0f 92       	push	r0
    1a8a:	11 24       	eor	r1, r1
    1a8c:	0b b6       	in	r0, 0x3b	; 59
    1a8e:	0f 92       	push	r0
    1a90:	2f 93       	push	r18
    1a92:	3f 93       	push	r19
    1a94:	4f 93       	push	r20
    1a96:	5f 93       	push	r21
    1a98:	6f 93       	push	r22
    1a9a:	7f 93       	push	r23
    1a9c:	8f 93       	push	r24
    1a9e:	9f 93       	push	r25
    1aa0:	af 93       	push	r26
    1aa2:	bf 93       	push	r27
    1aa4:	ef 93       	push	r30
    1aa6:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1aa8:	40 91 64 02 	lds	r20, 0x0264
    1aac:	50 91 65 02 	lds	r21, 0x0265
    1ab0:	e0 91 d7 23 	lds	r30, 0x23D7
    1ab4:	f0 91 d8 23 	lds	r31, 0x23D8
    1ab8:	61 e0       	ldi	r22, 0x01	; 1
    1aba:	80 e4       	ldi	r24, 0x40	; 64
    1abc:	92 e0       	ldi	r25, 0x02	; 2
    1abe:	19 95       	eicall
}
    1ac0:	ff 91       	pop	r31
    1ac2:	ef 91       	pop	r30
    1ac4:	bf 91       	pop	r27
    1ac6:	af 91       	pop	r26
    1ac8:	9f 91       	pop	r25
    1aca:	8f 91       	pop	r24
    1acc:	7f 91       	pop	r23
    1ace:	6f 91       	pop	r22
    1ad0:	5f 91       	pop	r21
    1ad2:	4f 91       	pop	r20
    1ad4:	3f 91       	pop	r19
    1ad6:	2f 91       	pop	r18
    1ad8:	0f 90       	pop	r0
    1ada:	0b be       	out	0x3b, r0	; 59
    1adc:	0f 90       	pop	r0
    1ade:	0f be       	out	0x3f, r0	; 63
    1ae0:	0f 90       	pop	r0
    1ae2:	1f 90       	pop	r1
    1ae4:	18 95       	reti

00001ae6 <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    1ae6:	1f 92       	push	r1
    1ae8:	0f 92       	push	r0
    1aea:	0f b6       	in	r0, 0x3f	; 63
    1aec:	0f 92       	push	r0
    1aee:	11 24       	eor	r1, r1
    1af0:	0b b6       	in	r0, 0x3b	; 59
    1af2:	0f 92       	push	r0
    1af4:	2f 93       	push	r18
    1af6:	3f 93       	push	r19
    1af8:	4f 93       	push	r20
    1afa:	5f 93       	push	r21
    1afc:	6f 93       	push	r22
    1afe:	7f 93       	push	r23
    1b00:	8f 93       	push	r24
    1b02:	9f 93       	push	r25
    1b04:	af 93       	push	r26
    1b06:	bf 93       	push	r27
    1b08:	ef 93       	push	r30
    1b0a:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    1b0c:	40 91 6c 02 	lds	r20, 0x026C
    1b10:	50 91 6d 02 	lds	r21, 0x026D
    1b14:	e0 91 d7 23 	lds	r30, 0x23D7
    1b18:	f0 91 d8 23 	lds	r31, 0x23D8
    1b1c:	62 e0       	ldi	r22, 0x02	; 2
    1b1e:	80 e4       	ldi	r24, 0x40	; 64
    1b20:	92 e0       	ldi	r25, 0x02	; 2
    1b22:	19 95       	eicall
}
    1b24:	ff 91       	pop	r31
    1b26:	ef 91       	pop	r30
    1b28:	bf 91       	pop	r27
    1b2a:	af 91       	pop	r26
    1b2c:	9f 91       	pop	r25
    1b2e:	8f 91       	pop	r24
    1b30:	7f 91       	pop	r23
    1b32:	6f 91       	pop	r22
    1b34:	5f 91       	pop	r21
    1b36:	4f 91       	pop	r20
    1b38:	3f 91       	pop	r19
    1b3a:	2f 91       	pop	r18
    1b3c:	0f 90       	pop	r0
    1b3e:	0b be       	out	0x3b, r0	; 59
    1b40:	0f 90       	pop	r0
    1b42:	0f be       	out	0x3f, r0	; 63
    1b44:	0f 90       	pop	r0
    1b46:	1f 90       	pop	r1
    1b48:	18 95       	reti

00001b4a <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    1b4a:	1f 92       	push	r1
    1b4c:	0f 92       	push	r0
    1b4e:	0f b6       	in	r0, 0x3f	; 63
    1b50:	0f 92       	push	r0
    1b52:	11 24       	eor	r1, r1
    1b54:	0b b6       	in	r0, 0x3b	; 59
    1b56:	0f 92       	push	r0
    1b58:	2f 93       	push	r18
    1b5a:	3f 93       	push	r19
    1b5c:	4f 93       	push	r20
    1b5e:	5f 93       	push	r21
    1b60:	6f 93       	push	r22
    1b62:	7f 93       	push	r23
    1b64:	8f 93       	push	r24
    1b66:	9f 93       	push	r25
    1b68:	af 93       	push	r26
    1b6a:	bf 93       	push	r27
    1b6c:	ef 93       	push	r30
    1b6e:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    1b70:	40 91 74 02 	lds	r20, 0x0274
    1b74:	50 91 75 02 	lds	r21, 0x0275
    1b78:	e0 91 d7 23 	lds	r30, 0x23D7
    1b7c:	f0 91 d8 23 	lds	r31, 0x23D8
    1b80:	64 e0       	ldi	r22, 0x04	; 4
    1b82:	80 e4       	ldi	r24, 0x40	; 64
    1b84:	92 e0       	ldi	r25, 0x02	; 2
    1b86:	19 95       	eicall
}
    1b88:	ff 91       	pop	r31
    1b8a:	ef 91       	pop	r30
    1b8c:	bf 91       	pop	r27
    1b8e:	af 91       	pop	r26
    1b90:	9f 91       	pop	r25
    1b92:	8f 91       	pop	r24
    1b94:	7f 91       	pop	r23
    1b96:	6f 91       	pop	r22
    1b98:	5f 91       	pop	r21
    1b9a:	4f 91       	pop	r20
    1b9c:	3f 91       	pop	r19
    1b9e:	2f 91       	pop	r18
    1ba0:	0f 90       	pop	r0
    1ba2:	0b be       	out	0x3b, r0	; 59
    1ba4:	0f 90       	pop	r0
    1ba6:	0f be       	out	0x3f, r0	; 63
    1ba8:	0f 90       	pop	r0
    1baa:	1f 90       	pop	r1
    1bac:	18 95       	reti

00001bae <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1bae:	1f 92       	push	r1
    1bb0:	0f 92       	push	r0
    1bb2:	0f b6       	in	r0, 0x3f	; 63
    1bb4:	0f 92       	push	r0
    1bb6:	11 24       	eor	r1, r1
    1bb8:	0b b6       	in	r0, 0x3b	; 59
    1bba:	0f 92       	push	r0
    1bbc:	2f 93       	push	r18
    1bbe:	3f 93       	push	r19
    1bc0:	4f 93       	push	r20
    1bc2:	5f 93       	push	r21
    1bc4:	6f 93       	push	r22
    1bc6:	7f 93       	push	r23
    1bc8:	8f 93       	push	r24
    1bca:	9f 93       	push	r25
    1bcc:	af 93       	push	r26
    1bce:	bf 93       	push	r27
    1bd0:	ef 93       	push	r30
    1bd2:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    1bd4:	40 91 7c 02 	lds	r20, 0x027C
    1bd8:	50 91 7d 02 	lds	r21, 0x027D
    1bdc:	e0 91 d7 23 	lds	r30, 0x23D7
    1be0:	f0 91 d8 23 	lds	r31, 0x23D8
    1be4:	68 e0       	ldi	r22, 0x08	; 8
    1be6:	80 e4       	ldi	r24, 0x40	; 64
    1be8:	92 e0       	ldi	r25, 0x02	; 2
    1bea:	19 95       	eicall
}
    1bec:	ff 91       	pop	r31
    1bee:	ef 91       	pop	r30
    1bf0:	bf 91       	pop	r27
    1bf2:	af 91       	pop	r26
    1bf4:	9f 91       	pop	r25
    1bf6:	8f 91       	pop	r24
    1bf8:	7f 91       	pop	r23
    1bfa:	6f 91       	pop	r22
    1bfc:	5f 91       	pop	r21
    1bfe:	4f 91       	pop	r20
    1c00:	3f 91       	pop	r19
    1c02:	2f 91       	pop	r18
    1c04:	0f 90       	pop	r0
    1c06:	0b be       	out	0x3b, r0	; 59
    1c08:	0f 90       	pop	r0
    1c0a:	0f be       	out	0x3f, r0	; 63
    1c0c:	0f 90       	pop	r0
    1c0e:	1f 90       	pop	r1
    1c10:	18 95       	reti

00001c12 <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    1c12:	df 92       	push	r13
    1c14:	ef 92       	push	r14
    1c16:	ff 92       	push	r15
    1c18:	0f 93       	push	r16
    1c1a:	1f 93       	push	r17
    1c1c:	cf 93       	push	r28
    1c1e:	df 93       	push	r29
    1c20:	ec 01       	movw	r28, r24
    1c22:	8b 01       	movw	r16, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    1c24:	c1 15       	cp	r28, r1
    1c26:	22 e0       	ldi	r18, 0x02	; 2
    1c28:	d2 07       	cpc	r29, r18
    1c2a:	81 f4       	brne	.+32     	; 0x1c4c <adc_write_configuration+0x3a>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    1c2c:	61 e2       	ldi	r22, 0x21	; 33
    1c2e:	70 e0       	ldi	r23, 0x00	; 0
    1c30:	82 e0       	ldi	r24, 0x02	; 2
    1c32:	0e 94 1e 19 	call	0x323c	; 0x323c <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    1c36:	e8 2e       	mov	r14, r24
    1c38:	f1 2c       	mov	r15, r1
    1c3a:	60 e2       	ldi	r22, 0x20	; 32
    1c3c:	70 e0       	ldi	r23, 0x00	; 0
    1c3e:	82 e0       	ldi	r24, 0x02	; 2
    1c40:	0e 94 1e 19 	call	0x323c	; 0x323c <nvm_read_byte>
		data <<= 8;
    1c44:	fe 2c       	mov	r15, r14
    1c46:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCACAL0);
    1c48:	e8 2a       	or	r14, r24
    1c4a:	12 c0       	rjmp	.+36     	; 0x1c70 <adc_write_configuration+0x5e>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1c4c:	80 34       	cpi	r24, 0x40	; 64
    1c4e:	92 40       	sbci	r25, 0x02	; 2
    1c50:	61 f5       	brne	.+88     	; 0x1caa <adc_write_configuration+0x98>
    1c52:	65 e2       	ldi	r22, 0x25	; 37
    1c54:	70 e0       	ldi	r23, 0x00	; 0
    1c56:	82 e0       	ldi	r24, 0x02	; 2
    1c58:	0e 94 1e 19 	call	0x323c	; 0x323c <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    1c5c:	e8 2e       	mov	r14, r24
    1c5e:	f1 2c       	mov	r15, r1
    1c60:	64 e2       	ldi	r22, 0x24	; 36
    1c62:	70 e0       	ldi	r23, 0x00	; 0
    1c64:	82 e0       	ldi	r24, 0x02	; 2
    1c66:	0e 94 1e 19 	call	0x323c	; 0x323c <nvm_read_byte>
		data <<= 8;
    1c6a:	fe 2c       	mov	r15, r14
    1c6c:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCBCAL0);
    1c6e:	e8 2a       	or	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1c70:	df b6       	in	r13, 0x3f	; 63
	cpu_irq_disable();
    1c72:	f8 94       	cli
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    1c74:	ce 01       	movw	r24, r28
    1c76:	e6 dd       	rcall	.-1076   	; 0x1844 <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
    1c78:	88 81       	ld	r24, Y

	adc->CTRLA = ADC_FLUSH_bm;
    1c7a:	92 e0       	ldi	r25, 0x02	; 2
    1c7c:	98 83       	st	Y, r25
	adc->CAL = cal;
    1c7e:	ec 86       	std	Y+12, r14	; 0x0c
    1c80:	fd 86       	std	Y+13, r15	; 0x0d
	adc->CMP = conf->cmp;
    1c82:	f8 01       	movw	r30, r16
    1c84:	25 81       	ldd	r18, Z+5	; 0x05
    1c86:	36 81       	ldd	r19, Z+6	; 0x06
    1c88:	28 8f       	std	Y+24, r18	; 0x18
    1c8a:	39 8f       	std	Y+25, r19	; 0x19
	adc->REFCTRL = conf->refctrl;
    1c8c:	92 81       	ldd	r25, Z+2	; 0x02
    1c8e:	9a 83       	std	Y+2, r25	; 0x02
	adc->PRESCALER = conf->prescaler;
    1c90:	94 81       	ldd	r25, Z+4	; 0x04
    1c92:	9c 83       	std	Y+4, r25	; 0x04
	adc->EVCTRL = conf->evctrl;
    1c94:	93 81       	ldd	r25, Z+3	; 0x03
    1c96:	9b 83       	std	Y+3, r25	; 0x03
	adc->CTRLB = conf->ctrlb;
    1c98:	91 81       	ldd	r25, Z+1	; 0x01
    1c9a:	99 83       	std	Y+1, r25	; 0x01
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
	enable = adc->CTRLA & ADC_ENABLE_bm;
    1c9c:	81 70       	andi	r24, 0x01	; 1
	adc->REFCTRL = conf->refctrl;
	adc->PRESCALER = conf->prescaler;
	adc->EVCTRL = conf->evctrl;
	adc->CTRLB = conf->ctrlb;

	adc->CTRLA = enable | conf->ctrla;
    1c9e:	90 81       	ld	r25, Z
    1ca0:	89 2b       	or	r24, r25
    1ca2:	88 83       	st	Y, r24

	adc_disable_clock(adc);
    1ca4:	ce 01       	movw	r24, r28
    1ca6:	ef dd       	rcall	.-1058   	; 0x1886 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1ca8:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    1caa:	df 91       	pop	r29
    1cac:	cf 91       	pop	r28
    1cae:	1f 91       	pop	r17
    1cb0:	0f 91       	pop	r16
    1cb2:	ff 90       	pop	r15
    1cb4:	ef 90       	pop	r14
    1cb6:	df 90       	pop	r13
    1cb8:	08 95       	ret

00001cba <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    1cba:	ff 92       	push	r15
    1cbc:	0f 93       	push	r16
    1cbe:	1f 93       	push	r17
    1cc0:	cf 93       	push	r28
    1cc2:	df 93       	push	r29
    1cc4:	ec 01       	movw	r28, r24
    1cc6:	8b 01       	movw	r16, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1cc8:	ff b6       	in	r15, 0x3f	; 63
	cpu_irq_disable();
    1cca:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    1ccc:	bb dd       	rcall	.-1162   	; 0x1844 <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    1cce:	88 81       	ld	r24, Y
    1cd0:	80 7c       	andi	r24, 0xC0	; 192
    1cd2:	f8 01       	movw	r30, r16
    1cd4:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    1cd6:	88 8d       	ldd	r24, Y+24	; 0x18
    1cd8:	99 8d       	ldd	r25, Y+25	; 0x19
    1cda:	85 83       	std	Z+5, r24	; 0x05
    1cdc:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    1cde:	8a 81       	ldd	r24, Y+2	; 0x02
    1ce0:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    1ce2:	8c 81       	ldd	r24, Y+4	; 0x04
    1ce4:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    1ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce8:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    1cea:	89 81       	ldd	r24, Y+1	; 0x01
    1cec:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    1cee:	ce 01       	movw	r24, r28
    1cf0:	ca dd       	rcall	.-1132   	; 0x1886 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1cf2:	ff be       	out	0x3f, r15	; 63

	cpu_irq_restore(flags);
}
    1cf4:	df 91       	pop	r29
    1cf6:	cf 91       	pop	r28
    1cf8:	1f 91       	pop	r17
    1cfa:	0f 91       	pop	r16
    1cfc:	ff 90       	pop	r15
    1cfe:	08 95       	ret

00001d00 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    1d00:	cf 92       	push	r12
    1d02:	df 92       	push	r13
    1d04:	ef 92       	push	r14
    1d06:	ff 92       	push	r15
    1d08:	0f 93       	push	r16
    1d0a:	1f 93       	push	r17
    1d0c:	cf 93       	push	r28
    1d0e:	df 93       	push	r29
    1d10:	7c 01       	movw	r14, r24
    1d12:	d6 2e       	mov	r13, r22
    1d14:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1d16:	86 2f       	mov	r24, r22
    1d18:	83 70       	andi	r24, 0x03	; 3
    1d1a:	29 f4       	brne	.+10     	; 0x1d26 <adcch_write_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    1d1c:	96 2f       	mov	r25, r22
    1d1e:	96 95       	lsr	r25
    1d20:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1d22:	82 e0       	ldi	r24, 0x02	; 2
    1d24:	02 c0       	rjmp	.+4      	; 0x1d2a <adcch_write_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1d26:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1d28:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1d2a:	90 ff       	sbrs	r25, 0
		index++;
    1d2c:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1d2e:	e7 01       	movw	r28, r14
    1d30:	a0 96       	adiw	r28, 0x20	; 32
    1d32:	98 e0       	ldi	r25, 0x08	; 8
    1d34:	89 9f       	mul	r24, r25
    1d36:	c0 0d       	add	r28, r0
    1d38:	d1 1d       	adc	r29, r1
    1d3a:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1d3c:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1d3e:	f8 94       	cli
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    1d40:	c7 01       	movw	r24, r14
    1d42:	80 dd       	rcall	.-1280   	; 0x1844 <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    1d44:	f8 01       	movw	r30, r16
    1d46:	80 81       	ld	r24, Z
    1d48:	88 83       	st	Y, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    1d4a:	82 81       	ldd	r24, Z+2	; 0x02
    1d4c:	8a 83       	std	Y+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    1d4e:	81 81       	ldd	r24, Z+1	; 0x01
    1d50:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1d52:	d0 fe       	sbrs	r13, 0
    1d54:	02 c0       	rjmp	.+4      	; 0x1d5a <adcch_write_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    1d56:	83 81       	ldd	r24, Z+3	; 0x03
    1d58:	8e 83       	std	Y+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    1d5a:	c7 01       	movw	r24, r14
    1d5c:	94 dd       	rcall	.-1240   	; 0x1886 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1d5e:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1d60:	df 91       	pop	r29
    1d62:	cf 91       	pop	r28
    1d64:	1f 91       	pop	r17
    1d66:	0f 91       	pop	r16
    1d68:	ff 90       	pop	r15
    1d6a:	ef 90       	pop	r14
    1d6c:	df 90       	pop	r13
    1d6e:	cf 90       	pop	r12
    1d70:	08 95       	ret

00001d72 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    1d72:	cf 92       	push	r12
    1d74:	df 92       	push	r13
    1d76:	ef 92       	push	r14
    1d78:	ff 92       	push	r15
    1d7a:	0f 93       	push	r16
    1d7c:	1f 93       	push	r17
    1d7e:	cf 93       	push	r28
    1d80:	df 93       	push	r29
    1d82:	7c 01       	movw	r14, r24
    1d84:	d6 2e       	mov	r13, r22
    1d86:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1d88:	86 2f       	mov	r24, r22
    1d8a:	83 70       	andi	r24, 0x03	; 3
    1d8c:	29 f4       	brne	.+10     	; 0x1d98 <adcch_read_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    1d8e:	96 2f       	mov	r25, r22
    1d90:	96 95       	lsr	r25
    1d92:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1d94:	82 e0       	ldi	r24, 0x02	; 2
    1d96:	02 c0       	rjmp	.+4      	; 0x1d9c <adcch_read_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1d98:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1d9a:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1d9c:	90 ff       	sbrs	r25, 0
		index++;
    1d9e:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1da0:	e7 01       	movw	r28, r14
    1da2:	a0 96       	adiw	r28, 0x20	; 32
    1da4:	98 e0       	ldi	r25, 0x08	; 8
    1da6:	89 9f       	mul	r24, r25
    1da8:	c0 0d       	add	r28, r0
    1daa:	d1 1d       	adc	r29, r1
    1dac:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1dae:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1db0:	f8 94       	cli

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1db2:	c7 01       	movw	r24, r14
    1db4:	47 dd       	rcall	.-1394   	; 0x1844 <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    1db6:	88 81       	ld	r24, Y
    1db8:	f8 01       	movw	r30, r16
    1dba:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    1dbc:	8a 81       	ldd	r24, Y+2	; 0x02
    1dbe:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    1dc0:	89 81       	ldd	r24, Y+1	; 0x01
    1dc2:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1dc4:	d0 fe       	sbrs	r13, 0
    1dc6:	02 c0       	rjmp	.+4      	; 0x1dcc <adcch_read_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    1dc8:	8e 81       	ldd	r24, Y+6	; 0x06
    1dca:	83 83       	std	Z+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    1dcc:	c7 01       	movw	r24, r14
    1dce:	5b dd       	rcall	.-1354   	; 0x1886 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1dd0:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1dd2:	df 91       	pop	r29
    1dd4:	cf 91       	pop	r28
    1dd6:	1f 91       	pop	r17
    1dd8:	0f 91       	pop	r16
    1dda:	ff 90       	pop	r15
    1ddc:	ef 90       	pop	r14
    1dde:	df 90       	pop	r13
    1de0:	cf 90       	pop	r12
    1de2:	08 95       	ret

00001de4 <twim_interrupt_handler>:
 * \brief Common TWI master interrupt service routine.
 *
 *  Check current status and calls the appropriate handler.
 */
static void twim_interrupt_handler(void)
{
    1de4:	cf 93       	push	r28
    1de6:	df 93       	push	r29
	uint8_t const master_status = transfer.bus->MASTER.STATUS;
    1de8:	e0 91 87 22 	lds	r30, 0x2287
    1dec:	f0 91 88 22 	lds	r31, 0x2288
    1df0:	84 81       	ldd	r24, Z+4	; 0x04

	if (master_status & TWI_MASTER_ARBLOST_bm) {
    1df2:	83 ff       	sbrs	r24, 3
    1df4:	08 c0       	rjmp	.+16     	; 0x1e06 <twim_interrupt_handler+0x22>

		transfer.bus->MASTER.STATUS = master_status | TWI_MASTER_ARBLOST_bm;
    1df6:	88 60       	ori	r24, 0x08	; 8
    1df8:	84 83       	std	Z+4, r24	; 0x04
		transfer.bus->MASTER.CTRLC  = TWI_MASTER_CMD_STOP_gc;
    1dfa:	83 e0       	ldi	r24, 0x03	; 3
    1dfc:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_BUSY;
    1dfe:	86 ef       	ldi	r24, 0xF6	; 246
    1e00:	80 93 91 22 	sts	0x2291, r24
    1e04:	83 c0       	rjmp	.+262    	; 0x1f0c <twim_interrupt_handler+0x128>
    1e06:	98 2f       	mov	r25, r24
    1e08:	94 71       	andi	r25, 0x14	; 20

	} else if ((master_status & TWI_MASTER_BUSERR_bm) ||
    1e0a:	31 f0       	breq	.+12     	; 0x1e18 <twim_interrupt_handler+0x34>
		(master_status & TWI_MASTER_RXACK_bm)) {

		transfer.bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1e0c:	83 e0       	ldi	r24, 0x03	; 3
    1e0e:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_IO_ERROR;
    1e10:	8f ef       	ldi	r24, 0xFF	; 255
    1e12:	80 93 91 22 	sts	0x2291, r24
    1e16:	7a c0       	rjmp	.+244    	; 0x1f0c <twim_interrupt_handler+0x128>

	} else if (master_status & TWI_MASTER_WIF_bm) {
    1e18:	86 ff       	sbrs	r24, 6
    1e1a:	43 c0       	rjmp	.+134    	; 0x1ea2 <twim_interrupt_handler+0xbe>
 *  Handles TWI transactions (master write) and responses to (N)ACK.
 */
static inline void twim_write_handler(void)
{
	TWI_t * const         bus = transfer.bus;
	twi_package_t * const pkg = transfer.pkg;
    1e1c:	c7 e8       	ldi	r28, 0x87	; 135
    1e1e:	d2 e2       	ldi	r29, 0x22	; 34
    1e20:	aa 81       	ldd	r26, Y+2	; 0x02
    1e22:	bb 81       	ldd	r27, Y+3	; 0x03

	if (transfer.addr_count < pkg->addr_length) {
    1e24:	8c 81       	ldd	r24, Y+4	; 0x04
    1e26:	9d 81       	ldd	r25, Y+5	; 0x05
    1e28:	14 96       	adiw	r26, 0x04	; 4
    1e2a:	2d 91       	ld	r18, X+
    1e2c:	3c 91       	ld	r19, X
    1e2e:	15 97       	sbiw	r26, 0x05	; 5
    1e30:	82 17       	cp	r24, r18
    1e32:	93 07       	cpc	r25, r19
    1e34:	6c f4       	brge	.+26     	; 0x1e50 <twim_interrupt_handler+0x6c>

		const uint8_t * const data = pkg->addr;
		bus->MASTER.DATA = data[transfer.addr_count++];
    1e36:	9c 01       	movw	r18, r24
    1e38:	2f 5f       	subi	r18, 0xFF	; 255
    1e3a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e3c:	20 93 8b 22 	sts	0x228B, r18
    1e40:	30 93 8c 22 	sts	0x228C, r19
    1e44:	a8 0f       	add	r26, r24
    1e46:	b9 1f       	adc	r27, r25
    1e48:	11 96       	adiw	r26, 0x01	; 1
    1e4a:	8c 91       	ld	r24, X
    1e4c:	87 83       	std	Z+7, r24	; 0x07
    1e4e:	5e c0       	rjmp	.+188    	; 0x1f0c <twim_interrupt_handler+0x128>

	} else if (transfer.data_count < pkg->length) {
    1e50:	80 91 8d 22 	lds	r24, 0x228D
    1e54:	90 91 8e 22 	lds	r25, 0x228E
    1e58:	18 96       	adiw	r26, 0x08	; 8
    1e5a:	2d 91       	ld	r18, X+
    1e5c:	3c 91       	ld	r19, X
    1e5e:	19 97       	sbiw	r26, 0x09	; 9
    1e60:	82 17       	cp	r24, r18
    1e62:	93 07       	cpc	r25, r19
    1e64:	c8 f4       	brcc	.+50     	; 0x1e98 <twim_interrupt_handler+0xb4>

		if (transfer.read) {
    1e66:	20 91 8f 22 	lds	r18, 0x228F
    1e6a:	22 23       	and	r18, r18
    1e6c:	21 f0       	breq	.+8      	; 0x1e76 <twim_interrupt_handler+0x92>

			/* Send repeated START condition (Address|R/W=1). */

			bus->MASTER.ADDR |= 0x01;
    1e6e:	86 81       	ldd	r24, Z+6	; 0x06
    1e70:	81 60       	ori	r24, 0x01	; 1
    1e72:	86 83       	std	Z+6, r24	; 0x06
    1e74:	4b c0       	rjmp	.+150    	; 0x1f0c <twim_interrupt_handler+0x128>

		} else {
			const uint8_t * const data = pkg->buffer;
    1e76:	16 96       	adiw	r26, 0x06	; 6
    1e78:	2d 91       	ld	r18, X+
    1e7a:	3c 91       	ld	r19, X
    1e7c:	17 97       	sbiw	r26, 0x07	; 7
			bus->MASTER.DATA = data[transfer.data_count++];
    1e7e:	ac 01       	movw	r20, r24
    1e80:	4f 5f       	subi	r20, 0xFF	; 255
    1e82:	5f 4f       	sbci	r21, 0xFF	; 255
    1e84:	40 93 8d 22 	sts	0x228D, r20
    1e88:	50 93 8e 22 	sts	0x228E, r21
    1e8c:	d9 01       	movw	r26, r18
    1e8e:	a8 0f       	add	r26, r24
    1e90:	b9 1f       	adc	r27, r25
    1e92:	8c 91       	ld	r24, X
    1e94:	87 83       	std	Z+7, r24	; 0x07
    1e96:	3a c0       	rjmp	.+116    	; 0x1f0c <twim_interrupt_handler+0x128>

	} else {

		/* Send STOP condition to complete the transaction. */

		bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1e98:	83 e0       	ldi	r24, 0x03	; 3
    1e9a:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = STATUS_OK;
    1e9c:	10 92 91 22 	sts	0x2291, r1
    1ea0:	35 c0       	rjmp	.+106    	; 0x1f0c <twim_interrupt_handler+0x128>

	} else if (master_status & TWI_MASTER_WIF_bm) {

		twim_write_handler();

	} else if (master_status & TWI_MASTER_RIF_bm) {
    1ea2:	88 23       	and	r24, r24
    1ea4:	84 f5       	brge	.+96     	; 0x1f06 <twim_interrupt_handler+0x122>
 *  reading bytes from the TWI slave.
 */
static inline void twim_read_handler(void)
{
	TWI_t * const         bus = transfer.bus;
	twi_package_t * const pkg = transfer.pkg;
    1ea6:	a7 e8       	ldi	r26, 0x87	; 135
    1ea8:	b2 e2       	ldi	r27, 0x22	; 34
    1eaa:	12 96       	adiw	r26, 0x02	; 2
    1eac:	cd 91       	ld	r28, X+
    1eae:	dc 91       	ld	r29, X
    1eb0:	13 97       	sbiw	r26, 0x03	; 3

	if (transfer.data_count < pkg->length) {
    1eb2:	16 96       	adiw	r26, 0x06	; 6
    1eb4:	8d 91       	ld	r24, X+
    1eb6:	9c 91       	ld	r25, X
    1eb8:	17 97       	sbiw	r26, 0x07	; 7
    1eba:	28 85       	ldd	r18, Y+8	; 0x08
    1ebc:	39 85       	ldd	r19, Y+9	; 0x09
    1ebe:	82 17       	cp	r24, r18
    1ec0:	93 07       	cpc	r25, r19
    1ec2:	d8 f4       	brcc	.+54     	; 0x1efa <twim_interrupt_handler+0x116>

		uint8_t * const data = pkg->buffer;
    1ec4:	6e 81       	ldd	r22, Y+6	; 0x06
    1ec6:	7f 81       	ldd	r23, Y+7	; 0x07
		data[transfer.data_count++] = bus->MASTER.DATA;
    1ec8:	9c 01       	movw	r18, r24
    1eca:	2f 5f       	subi	r18, 0xFF	; 255
    1ecc:	3f 4f       	sbci	r19, 0xFF	; 255
    1ece:	20 93 8d 22 	sts	0x228D, r18
    1ed2:	30 93 8e 22 	sts	0x228E, r19
    1ed6:	47 81       	ldd	r20, Z+7	; 0x07
    1ed8:	db 01       	movw	r26, r22
    1eda:	a8 0f       	add	r26, r24
    1edc:	b9 1f       	adc	r27, r25
    1ede:	4c 93       	st	X, r20

		/* If there is more to read, issue ACK and start a byte read.
		 * Otherwise, issue NACK and STOP to complete the transaction.
		 */
		if (transfer.data_count < pkg->length) {
    1ee0:	88 85       	ldd	r24, Y+8	; 0x08
    1ee2:	99 85       	ldd	r25, Y+9	; 0x09
    1ee4:	28 17       	cp	r18, r24
    1ee6:	39 07       	cpc	r19, r25
    1ee8:	18 f4       	brcc	.+6      	; 0x1ef0 <twim_interrupt_handler+0x10c>

			bus->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
    1eea:	82 e0       	ldi	r24, 0x02	; 2
    1eec:	83 83       	std	Z+3, r24	; 0x03
    1eee:	0e c0       	rjmp	.+28     	; 0x1f0c <twim_interrupt_handler+0x128>

		} else {

			bus->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    1ef0:	87 e0       	ldi	r24, 0x07	; 7
    1ef2:	83 83       	std	Z+3, r24	; 0x03
			transfer.status = STATUS_OK;
    1ef4:	10 92 91 22 	sts	0x2291, r1
    1ef8:	09 c0       	rjmp	.+18     	; 0x1f0c <twim_interrupt_handler+0x128>

	} else {

		/* Issue STOP and buffer overflow condition. */

		bus->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    1efa:	83 e0       	ldi	r24, 0x03	; 3
    1efc:	83 83       	std	Z+3, r24	; 0x03
		transfer.status = ERR_NO_MEMORY;
    1efe:	89 ef       	ldi	r24, 0xF9	; 249
    1f00:	80 93 91 22 	sts	0x2291, r24
    1f04:	03 c0       	rjmp	.+6      	; 0x1f0c <twim_interrupt_handler+0x128>

		twim_read_handler();

	} else {

		transfer.status = ERR_PROTOCOL;
    1f06:	8b ef       	ldi	r24, 0xFB	; 251
    1f08:	80 93 91 22 	sts	0x2291, r24
	}
}
    1f0c:	df 91       	pop	r29
    1f0e:	cf 91       	pop	r28
    1f10:	08 95       	ret

00001f12 <__vector_13>:
 * parameters specified in the global \c transfer structure.
 */
static void twim_interrupt_handler(void);

#ifdef TWIC
ISR(TWIC_TWIM_vect) { twim_interrupt_handler(); }
    1f12:	1f 92       	push	r1
    1f14:	0f 92       	push	r0
    1f16:	0f b6       	in	r0, 0x3f	; 63
    1f18:	0f 92       	push	r0
    1f1a:	11 24       	eor	r1, r1
    1f1c:	0b b6       	in	r0, 0x3b	; 59
    1f1e:	0f 92       	push	r0
    1f20:	2f 93       	push	r18
    1f22:	3f 93       	push	r19
    1f24:	4f 93       	push	r20
    1f26:	5f 93       	push	r21
    1f28:	6f 93       	push	r22
    1f2a:	7f 93       	push	r23
    1f2c:	8f 93       	push	r24
    1f2e:	9f 93       	push	r25
    1f30:	af 93       	push	r26
    1f32:	bf 93       	push	r27
    1f34:	ef 93       	push	r30
    1f36:	ff 93       	push	r31
    1f38:	55 df       	rcall	.-342    	; 0x1de4 <twim_interrupt_handler>
    1f3a:	ff 91       	pop	r31
    1f3c:	ef 91       	pop	r30
    1f3e:	bf 91       	pop	r27
    1f40:	af 91       	pop	r26
    1f42:	9f 91       	pop	r25
    1f44:	8f 91       	pop	r24
    1f46:	7f 91       	pop	r23
    1f48:	6f 91       	pop	r22
    1f4a:	5f 91       	pop	r21
    1f4c:	4f 91       	pop	r20
    1f4e:	3f 91       	pop	r19
    1f50:	2f 91       	pop	r18
    1f52:	0f 90       	pop	r0
    1f54:	0b be       	out	0x3b, r0	; 59
    1f56:	0f 90       	pop	r0
    1f58:	0f be       	out	0x3f, r0	; 63
    1f5a:	0f 90       	pop	r0
    1f5c:	1f 90       	pop	r1
    1f5e:	18 95       	reti

00001f60 <__vector_46>:
#endif
#ifdef TWID
ISR(TWID_TWIM_vect) { twim_interrupt_handler(); }
#endif
#ifdef TWIE
ISR(TWIE_TWIM_vect) { twim_interrupt_handler(); }
    1f60:	1f 92       	push	r1
    1f62:	0f 92       	push	r0
    1f64:	0f b6       	in	r0, 0x3f	; 63
    1f66:	0f 92       	push	r0
    1f68:	11 24       	eor	r1, r1
    1f6a:	0b b6       	in	r0, 0x3b	; 59
    1f6c:	0f 92       	push	r0
    1f6e:	2f 93       	push	r18
    1f70:	3f 93       	push	r19
    1f72:	4f 93       	push	r20
    1f74:	5f 93       	push	r21
    1f76:	6f 93       	push	r22
    1f78:	7f 93       	push	r23
    1f7a:	8f 93       	push	r24
    1f7c:	9f 93       	push	r25
    1f7e:	af 93       	push	r26
    1f80:	bf 93       	push	r27
    1f82:	ef 93       	push	r30
    1f84:	ff 93       	push	r31
    1f86:	2e df       	rcall	.-420    	; 0x1de4 <twim_interrupt_handler>
    1f88:	ff 91       	pop	r31
    1f8a:	ef 91       	pop	r30
    1f8c:	bf 91       	pop	r27
    1f8e:	af 91       	pop	r26
    1f90:	9f 91       	pop	r25
    1f92:	8f 91       	pop	r24
    1f94:	7f 91       	pop	r23
    1f96:	6f 91       	pop	r22
    1f98:	5f 91       	pop	r21
    1f9a:	4f 91       	pop	r20
    1f9c:	3f 91       	pop	r19
    1f9e:	2f 91       	pop	r18
    1fa0:	0f 90       	pop	r0
    1fa2:	0b be       	out	0x3b, r0	; 59
    1fa4:	0f 90       	pop	r0
    1fa6:	0f be       	out	0x3f, r0	; 63
    1fa8:	0f 90       	pop	r0
    1faa:	1f 90       	pop	r1
    1fac:	18 95       	reti

00001fae <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1fae:	cf 92       	push	r12
    1fb0:	df 92       	push	r13
    1fb2:	ef 92       	push	r14
    1fb4:	ff 92       	push	r15
    1fb6:	0f 93       	push	r16
    1fb8:	1f 93       	push	r17
    1fba:	cf 93       	push	r28
    1fbc:	df 93       	push	r29
    1fbe:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    1fc0:	d9 01       	movw	r26, r18
    1fc2:	c8 01       	movw	r24, r16
    1fc4:	b6 95       	lsr	r27
    1fc6:	a7 95       	ror	r26
    1fc8:	97 95       	ror	r25
    1fca:	87 95       	ror	r24
    1fcc:	48 17       	cp	r20, r24
    1fce:	59 07       	cpc	r21, r25
    1fd0:	6a 07       	cpc	r22, r26
    1fd2:	7b 07       	cpc	r23, r27
    1fd4:	78 f4       	brcc	.+30     	; 0x1ff4 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1fd6:	6a 01       	movw	r12, r20
    1fd8:	7b 01       	movw	r14, r22
    1fda:	cc 0c       	add	r12, r12
    1fdc:	dd 1c       	adc	r13, r13
    1fde:	ee 1c       	adc	r14, r14
    1fe0:	ff 1c       	adc	r15, r15
    1fe2:	c9 01       	movw	r24, r18
    1fe4:	b8 01       	movw	r22, r16
    1fe6:	a7 01       	movw	r20, r14
    1fe8:	96 01       	movw	r18, r12
    1fea:	0e 94 af 1f 	call	0x3f5e	; 0x3f5e <__udivmodsi4>
    1fee:	21 50       	subi	r18, 0x01	; 1
    1ff0:	31 09       	sbc	r19, r1
    1ff2:	02 c0       	rjmp	.+4      	; 0x1ff8 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1ff4:	20 e0       	ldi	r18, 0x00	; 0
    1ff6:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1ff8:	83 2f       	mov	r24, r19
    1ffa:	8f 70       	andi	r24, 0x0F	; 15
    1ffc:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1ffe:	2e 83       	std	Y+6, r18	; 0x06
}
    2000:	df 91       	pop	r29
    2002:	cf 91       	pop	r28
    2004:	1f 91       	pop	r17
    2006:	0f 91       	pop	r16
    2008:	ff 90       	pop	r15
    200a:	ef 90       	pop	r14
    200c:	df 90       	pop	r13
    200e:	cf 90       	pop	r12
    2010:	08 95       	ret

00002012 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    2012:	ef 92       	push	r14
    2014:	ff 92       	push	r15
    2016:	0f 93       	push	r16
    2018:	1f 93       	push	r17
    201a:	cf 93       	push	r28
    201c:	df 93       	push	r29
    201e:	ec 01       	movw	r28, r24
    2020:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    2022:	00 97       	sbiw	r24, 0x00	; 0
    2024:	09 f4       	brne	.+2      	; 0x2028 <usart_init_spi+0x16>
    2026:	8c c1       	rjmp	.+792    	; 0x2340 <usart_init_spi+0x32e>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    2028:	80 3c       	cpi	r24, 0xC0	; 192
    202a:	91 05       	cpc	r25, r1
    202c:	29 f4       	brne	.+10     	; 0x2038 <usart_init_spi+0x26>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    202e:	60 e1       	ldi	r22, 0x10	; 16
    2030:	80 e0       	ldi	r24, 0x00	; 0
    2032:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    2036:	84 c1       	rjmp	.+776    	; 0x2340 <usart_init_spi+0x32e>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    2038:	80 38       	cpi	r24, 0x80	; 128
    203a:	91 40       	sbci	r25, 0x01	; 1
    203c:	29 f4       	brne	.+10     	; 0x2048 <usart_init_spi+0x36>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    203e:	62 e0       	ldi	r22, 0x02	; 2
    2040:	80 e0       	ldi	r24, 0x00	; 0
    2042:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    2046:	7c c1       	rjmp	.+760    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    2048:	c1 15       	cp	r28, r1
    204a:	81 e0       	ldi	r24, 0x01	; 1
    204c:	d8 07       	cpc	r29, r24
    204e:	29 f4       	brne	.+10     	; 0x205a <usart_init_spi+0x48>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    2050:	61 e0       	ldi	r22, 0x01	; 1
    2052:	80 e0       	ldi	r24, 0x00	; 0
    2054:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    2058:	73 c1       	rjmp	.+742    	; 0x2340 <usart_init_spi+0x32e>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    205a:	c0 38       	cpi	r28, 0x80	; 128
    205c:	e3 e0       	ldi	r30, 0x03	; 3
    205e:	de 07       	cpc	r29, r30
    2060:	29 f4       	brne	.+10     	; 0x206c <usart_init_spi+0x5a>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    2062:	61 e0       	ldi	r22, 0x01	; 1
    2064:	81 e0       	ldi	r24, 0x01	; 1
    2066:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    206a:	6a c1       	rjmp	.+724    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    206c:	c0 39       	cpi	r28, 0x90	; 144
    206e:	f3 e0       	ldi	r31, 0x03	; 3
    2070:	df 07       	cpc	r29, r31
    2072:	29 f4       	brne	.+10     	; 0x207e <usart_init_spi+0x6c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    2074:	61 e0       	ldi	r22, 0x01	; 1
    2076:	82 e0       	ldi	r24, 0x02	; 2
    2078:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    207c:	61 c1       	rjmp	.+706    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    207e:	c1 15       	cp	r28, r1
    2080:	32 e0       	ldi	r19, 0x02	; 2
    2082:	d3 07       	cpc	r29, r19
    2084:	29 f4       	brne	.+10     	; 0x2090 <usart_init_spi+0x7e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    2086:	62 e0       	ldi	r22, 0x02	; 2
    2088:	81 e0       	ldi	r24, 0x01	; 1
    208a:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    208e:	58 c1       	rjmp	.+688    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    2090:	c0 34       	cpi	r28, 0x40	; 64
    2092:	82 e0       	ldi	r24, 0x02	; 2
    2094:	d8 07       	cpc	r29, r24
    2096:	29 f4       	brne	.+10     	; 0x20a2 <usart_init_spi+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    2098:	62 e0       	ldi	r22, 0x02	; 2
    209a:	82 e0       	ldi	r24, 0x02	; 2
    209c:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    20a0:	4f c1       	rjmp	.+670    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    20a2:	c0 32       	cpi	r28, 0x20	; 32
    20a4:	e3 e0       	ldi	r30, 0x03	; 3
    20a6:	de 07       	cpc	r29, r30
    20a8:	29 f4       	brne	.+10     	; 0x20b4 <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    20aa:	64 e0       	ldi	r22, 0x04	; 4
    20ac:	82 e0       	ldi	r24, 0x02	; 2
    20ae:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    20b2:	46 c1       	rjmp	.+652    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    20b4:	c1 15       	cp	r28, r1
    20b6:	f8 e0       	ldi	r31, 0x08	; 8
    20b8:	df 07       	cpc	r29, r31
    20ba:	29 f4       	brne	.+10     	; 0x20c6 <usart_init_spi+0xb4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    20bc:	61 e0       	ldi	r22, 0x01	; 1
    20be:	83 e0       	ldi	r24, 0x03	; 3
    20c0:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    20c4:	3d c1       	rjmp	.+634    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    20c6:	c1 15       	cp	r28, r1
    20c8:	39 e0       	ldi	r19, 0x09	; 9
    20ca:	d3 07       	cpc	r29, r19
    20cc:	29 f4       	brne	.+10     	; 0x20d8 <usart_init_spi+0xc6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    20ce:	61 e0       	ldi	r22, 0x01	; 1
    20d0:	84 e0       	ldi	r24, 0x04	; 4
    20d2:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    20d6:	34 c1       	rjmp	.+616    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    20d8:	c1 15       	cp	r28, r1
    20da:	8a e0       	ldi	r24, 0x0A	; 10
    20dc:	d8 07       	cpc	r29, r24
    20de:	29 f4       	brne	.+10     	; 0x20ea <usart_init_spi+0xd8>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    20e0:	61 e0       	ldi	r22, 0x01	; 1
    20e2:	85 e0       	ldi	r24, 0x05	; 5
    20e4:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    20e8:	2b c1       	rjmp	.+598    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    20ea:	c1 15       	cp	r28, r1
    20ec:	eb e0       	ldi	r30, 0x0B	; 11
    20ee:	de 07       	cpc	r29, r30
    20f0:	29 f4       	brne	.+10     	; 0x20fc <usart_init_spi+0xea>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    20f2:	61 e0       	ldi	r22, 0x01	; 1
    20f4:	86 e0       	ldi	r24, 0x06	; 6
    20f6:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    20fa:	22 c1       	rjmp	.+580    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    20fc:	c0 34       	cpi	r28, 0x40	; 64
    20fe:	f8 e0       	ldi	r31, 0x08	; 8
    2100:	df 07       	cpc	r29, r31
    2102:	29 f4       	brne	.+10     	; 0x210e <usart_init_spi+0xfc>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    2104:	62 e0       	ldi	r22, 0x02	; 2
    2106:	83 e0       	ldi	r24, 0x03	; 3
    2108:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    210c:	19 c1       	rjmp	.+562    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    210e:	c0 34       	cpi	r28, 0x40	; 64
    2110:	39 e0       	ldi	r19, 0x09	; 9
    2112:	d3 07       	cpc	r29, r19
    2114:	29 f4       	brne	.+10     	; 0x2120 <usart_init_spi+0x10e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    2116:	62 e0       	ldi	r22, 0x02	; 2
    2118:	84 e0       	ldi	r24, 0x04	; 4
    211a:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    211e:	10 c1       	rjmp	.+544    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    2120:	c0 34       	cpi	r28, 0x40	; 64
    2122:	8a e0       	ldi	r24, 0x0A	; 10
    2124:	d8 07       	cpc	r29, r24
    2126:	29 f4       	brne	.+10     	; 0x2132 <usart_init_spi+0x120>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    2128:	62 e0       	ldi	r22, 0x02	; 2
    212a:	85 e0       	ldi	r24, 0x05	; 5
    212c:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    2130:	07 c1       	rjmp	.+526    	; 0x2340 <usart_init_spi+0x32e>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    2132:	c0 39       	cpi	r28, 0x90	; 144
    2134:	e8 e0       	ldi	r30, 0x08	; 8
    2136:	de 07       	cpc	r29, r30
    2138:	29 f4       	brne	.+10     	; 0x2144 <usart_init_spi+0x132>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    213a:	64 e0       	ldi	r22, 0x04	; 4
    213c:	83 e0       	ldi	r24, 0x03	; 3
    213e:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    2142:	fe c0       	rjmp	.+508    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    2144:	c0 39       	cpi	r28, 0x90	; 144
    2146:	f9 e0       	ldi	r31, 0x09	; 9
    2148:	df 07       	cpc	r29, r31
    214a:	29 f4       	brne	.+10     	; 0x2156 <usart_init_spi+0x144>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    214c:	64 e0       	ldi	r22, 0x04	; 4
    214e:	84 e0       	ldi	r24, 0x04	; 4
    2150:	0e 94 ae 18 	call	0x315c	; 0x315c <sysclk_enable_module>
    2154:	f5 c0       	rjmp	.+490    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    2156:	c0 39       	cpi	r28, 0x90	; 144
    2158:	3a e0       	ldi	r19, 0x0A	; 10
    215a:	d3 07       	cpc	r29, r19
    215c:	21 f4       	brne	.+8      	; 0x2166 <usart_init_spi+0x154>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    215e:	64 e0       	ldi	r22, 0x04	; 4
    2160:	85 e0       	ldi	r24, 0x05	; 5
    2162:	fc d7       	rcall	.+4088   	; 0x315c <sysclk_enable_module>
    2164:	ed c0       	rjmp	.+474    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    2166:	c0 39       	cpi	r28, 0x90	; 144
    2168:	8b e0       	ldi	r24, 0x0B	; 11
    216a:	d8 07       	cpc	r29, r24
    216c:	21 f4       	brne	.+8      	; 0x2176 <usart_init_spi+0x164>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    216e:	64 e0       	ldi	r22, 0x04	; 4
    2170:	86 e0       	ldi	r24, 0x06	; 6
    2172:	f4 d7       	rcall	.+4072   	; 0x315c <sysclk_enable_module>
    2174:	e5 c0       	rjmp	.+458    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    2176:	c0 3c       	cpi	r28, 0xC0	; 192
    2178:	e8 e0       	ldi	r30, 0x08	; 8
    217a:	de 07       	cpc	r29, r30
    217c:	21 f4       	brne	.+8      	; 0x2186 <usart_init_spi+0x174>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    217e:	68 e0       	ldi	r22, 0x08	; 8
    2180:	83 e0       	ldi	r24, 0x03	; 3
    2182:	ec d7       	rcall	.+4056   	; 0x315c <sysclk_enable_module>
    2184:	dd c0       	rjmp	.+442    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    2186:	c0 3c       	cpi	r28, 0xC0	; 192
    2188:	f9 e0       	ldi	r31, 0x09	; 9
    218a:	df 07       	cpc	r29, r31
    218c:	21 f4       	brne	.+8      	; 0x2196 <usart_init_spi+0x184>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    218e:	68 e0       	ldi	r22, 0x08	; 8
    2190:	84 e0       	ldi	r24, 0x04	; 4
    2192:	e4 d7       	rcall	.+4040   	; 0x315c <sysclk_enable_module>
    2194:	d5 c0       	rjmp	.+426    	; 0x2340 <usart_init_spi+0x32e>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    2196:	c0 3a       	cpi	r28, 0xA0	; 160
    2198:	38 e0       	ldi	r19, 0x08	; 8
    219a:	d3 07       	cpc	r29, r19
    219c:	61 f4       	brne	.+24     	; 0x21b6 <usart_init_spi+0x1a4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    219e:	60 e1       	ldi	r22, 0x10	; 16
    21a0:	83 e0       	ldi	r24, 0x03	; 3
    21a2:	dc d7       	rcall	.+4024   	; 0x315c <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    21a4:	e0 ea       	ldi	r30, 0xA0	; 160
    21a6:	f8 e0       	ldi	r31, 0x08	; 8
    21a8:	84 81       	ldd	r24, Z+4	; 0x04
    21aa:	8f 7e       	andi	r24, 0xEF	; 239
    21ac:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    21ae:	f7 01       	movw	r30, r14
    21b0:	24 81       	ldd	r18, Z+4	; 0x04
    21b2:	22 50       	subi	r18, 0x02	; 2
    21b4:	43 c0       	rjmp	.+134    	; 0x223c <usart_init_spi+0x22a>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    21b6:	c0 3a       	cpi	r28, 0xA0	; 160
    21b8:	f9 e0       	ldi	r31, 0x09	; 9
    21ba:	df 07       	cpc	r29, r31
    21bc:	21 f4       	brne	.+8      	; 0x21c6 <usart_init_spi+0x1b4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    21be:	60 e1       	ldi	r22, 0x10	; 16
    21c0:	84 e0       	ldi	r24, 0x04	; 4
    21c2:	cc d7       	rcall	.+3992   	; 0x315c <sysclk_enable_module>
    21c4:	bd c0       	rjmp	.+378    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    21c6:	c0 3a       	cpi	r28, 0xA0	; 160
    21c8:	3a e0       	ldi	r19, 0x0A	; 10
    21ca:	d3 07       	cpc	r29, r19
    21cc:	21 f4       	brne	.+8      	; 0x21d6 <usart_init_spi+0x1c4>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    21ce:	60 e1       	ldi	r22, 0x10	; 16
    21d0:	85 e0       	ldi	r24, 0x05	; 5
    21d2:	c4 d7       	rcall	.+3976   	; 0x315c <sysclk_enable_module>
    21d4:	b5 c0       	rjmp	.+362    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    21d6:	c0 3a       	cpi	r28, 0xA0	; 160
    21d8:	8b e0       	ldi	r24, 0x0B	; 11
    21da:	d8 07       	cpc	r29, r24
    21dc:	21 f4       	brne	.+8      	; 0x21e6 <usart_init_spi+0x1d4>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    21de:	60 e1       	ldi	r22, 0x10	; 16
    21e0:	86 e0       	ldi	r24, 0x06	; 6
    21e2:	bc d7       	rcall	.+3960   	; 0x315c <sysclk_enable_module>
    21e4:	ad c0       	rjmp	.+346    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    21e6:	c0 3b       	cpi	r28, 0xB0	; 176
    21e8:	e8 e0       	ldi	r30, 0x08	; 8
    21ea:	de 07       	cpc	r29, r30
    21ec:	21 f4       	brne	.+8      	; 0x21f6 <usart_init_spi+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    21ee:	60 e2       	ldi	r22, 0x20	; 32
    21f0:	83 e0       	ldi	r24, 0x03	; 3
    21f2:	b4 d7       	rcall	.+3944   	; 0x315c <sysclk_enable_module>
    21f4:	a5 c0       	rjmp	.+330    	; 0x2340 <usart_init_spi+0x32e>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    21f6:	c0 3b       	cpi	r28, 0xB0	; 176
    21f8:	f9 e0       	ldi	r31, 0x09	; 9
    21fa:	df 07       	cpc	r29, r31
    21fc:	21 f4       	brne	.+8      	; 0x2206 <usart_init_spi+0x1f4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    21fe:	60 e2       	ldi	r22, 0x20	; 32
    2200:	84 e0       	ldi	r24, 0x04	; 4
    2202:	ac d7       	rcall	.+3928   	; 0x315c <sysclk_enable_module>
    2204:	9d c0       	rjmp	.+314    	; 0x2340 <usart_init_spi+0x32e>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    2206:	c0 38       	cpi	r28, 0x80	; 128
    2208:	34 e0       	ldi	r19, 0x04	; 4
    220a:	d3 07       	cpc	r29, r19
    220c:	21 f4       	brne	.+8      	; 0x2216 <usart_init_spi+0x204>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    220e:	60 e4       	ldi	r22, 0x40	; 64
    2210:	83 e0       	ldi	r24, 0x03	; 3
    2212:	a4 d7       	rcall	.+3912   	; 0x315c <sysclk_enable_module>
    2214:	95 c0       	rjmp	.+298    	; 0x2340 <usart_init_spi+0x32e>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    2216:	c0 3a       	cpi	r28, 0xA0	; 160
    2218:	84 e0       	ldi	r24, 0x04	; 4
    221a:	d8 07       	cpc	r29, r24
    221c:	21 f4       	brne	.+8      	; 0x2226 <usart_init_spi+0x214>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    221e:	60 e4       	ldi	r22, 0x40	; 64
    2220:	85 e0       	ldi	r24, 0x05	; 5
    2222:	9c d7       	rcall	.+3896   	; 0x315c <sysclk_enable_module>
    2224:	8d c0       	rjmp	.+282    	; 0x2340 <usart_init_spi+0x32e>
    2226:	8c 81       	ldd	r24, Y+4	; 0x04
    2228:	8f 7e       	andi	r24, 0xEF	; 239
    222a:	8c 83       	std	Y+4, r24	; 0x04
    222c:	fb 01       	movw	r30, r22
    222e:	24 81       	ldd	r18, Z+4	; 0x04
    2230:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    2232:	ce 01       	movw	r24, r28
    2234:	c0 3a       	cpi	r28, 0xA0	; 160
    2236:	f8 e0       	ldi	r31, 0x08	; 8
    2238:	df 07       	cpc	r29, r31
    223a:	31 f4       	brne	.+12     	; 0x2248 <usart_init_spi+0x236>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    223c:	80 91 4e 06 	lds	r24, 0x064E
    2240:	84 fd       	sbrc	r24, 4
    2242:	86 c0       	rjmp	.+268    	; 0x2350 <usart_init_spi+0x33e>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    2244:	11 e1       	ldi	r17, 0x11	; 17
    2246:	85 c0       	rjmp	.+266    	; 0x2352 <usart_init_spi+0x340>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    2248:	80 3b       	cpi	r24, 0xB0	; 176
    224a:	38 e0       	ldi	r19, 0x08	; 8
    224c:	93 07       	cpc	r25, r19
    224e:	79 f0       	breq	.+30     	; 0x226e <usart_init_spi+0x25c>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    2250:	80 3a       	cpi	r24, 0xA0	; 160
    2252:	e9 e0       	ldi	r30, 0x09	; 9
    2254:	9e 07       	cpc	r25, r30
    2256:	31 f4       	brne	.+12     	; 0x2264 <usart_init_spi+0x252>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    2258:	30 91 6e 06 	lds	r19, 0x066E
    225c:	34 fd       	sbrc	r19, 4
    225e:	7c c0       	rjmp	.+248    	; 0x2358 <usart_init_spi+0x346>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    2260:	19 e1       	ldi	r17, 0x19	; 25
    2262:	10 c0       	rjmp	.+32     	; 0x2284 <usart_init_spi+0x272>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    2264:	80 3b       	cpi	r24, 0xB0	; 176
    2266:	f9 e0       	ldi	r31, 0x09	; 9
    2268:	9f 07       	cpc	r25, r31
    226a:	a9 f0       	breq	.+42     	; 0x2296 <usart_init_spi+0x284>
    226c:	01 c0       	rjmp	.+2      	; 0x2270 <usart_init_spi+0x25e>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    226e:	15 e1       	ldi	r17, 0x15	; 21
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    2270:	80 3a       	cpi	r24, 0xA0	; 160
    2272:	3a e0       	ldi	r19, 0x0A	; 10
    2274:	93 07       	cpc	r25, r19
    2276:	31 f4       	brne	.+12     	; 0x2284 <usart_init_spi+0x272>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    2278:	80 91 8e 06 	lds	r24, 0x068E
    227c:	84 fd       	sbrc	r24, 4
    227e:	6e c0       	rjmp	.+220    	; 0x235c <usart_init_spi+0x34a>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    2280:	11 e2       	ldi	r17, 0x21	; 33
    2282:	0c c0       	rjmp	.+24     	; 0x229c <usart_init_spi+0x28a>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    2284:	80 3a       	cpi	r24, 0xA0	; 160
    2286:	9b 40       	sbci	r25, 0x0B	; 11
    2288:	49 f4       	brne	.+18     	; 0x229c <usart_init_spi+0x28a>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    228a:	80 91 ae 06 	lds	r24, 0x06AE
    228e:	84 fd       	sbrc	r24, 4
    2290:	04 c0       	rjmp	.+8      	; 0x229a <usart_init_spi+0x288>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    2292:	19 e2       	ldi	r17, 0x29	; 41
    2294:	03 c0       	rjmp	.+6      	; 0x229c <usart_init_spi+0x28a>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    2296:	1d e1       	ldi	r17, 0x1D	; 29
    2298:	01 c0       	rjmp	.+2      	; 0x229c <usart_init_spi+0x28a>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    229a:	1d e2       	ldi	r17, 0x2D	; 45
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    229c:	e1 2f       	mov	r30, r17
    229e:	e6 95       	lsr	r30
    22a0:	e6 95       	lsr	r30
    22a2:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    22a4:	30 e2       	ldi	r19, 0x20	; 32
    22a6:	e3 9f       	mul	r30, r19
    22a8:	f0 01       	movw	r30, r0
    22aa:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    22ac:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    22ae:	17 70       	andi	r17, 0x07	; 7
    22b0:	81 e0       	ldi	r24, 0x01	; 1
    22b2:	90 e0       	ldi	r25, 0x00	; 0
    22b4:	01 2e       	mov	r0, r17
    22b6:	02 c0       	rjmp	.+4      	; 0x22bc <usart_init_spi+0x2aa>
    22b8:	88 0f       	add	r24, r24
    22ba:	99 1f       	adc	r25, r25
    22bc:	0a 94       	dec	r0
    22be:	e2 f7       	brpl	.-8      	; 0x22b8 <usart_init_spi+0x2a6>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    22c0:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    22c2:	22 30       	cpi	r18, 0x02	; 2
    22c4:	10 f0       	brcs	.+4      	; 0x22ca <usart_init_spi+0x2b8>
    22c6:	40 e0       	ldi	r20, 0x00	; 0
    22c8:	01 c0       	rjmp	.+2      	; 0x22cc <usart_init_spi+0x2ba>
    22ca:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    22cc:	df 01       	movw	r26, r30
    22ce:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    22d0:	a1 0f       	add	r26, r17
    22d2:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    22d4:	3f b7       	in	r19, 0x3f	; 63
	cpu_irq_disable();
    22d6:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    22d8:	2c 91       	ld	r18, X
    22da:	27 70       	andi	r18, 0x07	; 7
    22dc:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    22de:	9c 91       	ld	r25, X
    22e0:	94 2b       	or	r25, r20
    22e2:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    22e4:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    22e6:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    22e8:	8d 81       	ldd	r24, Y+5	; 0x05
    22ea:	80 6c       	ori	r24, 0xC0	; 192
    22ec:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    22ee:	f7 01       	movw	r30, r14
    22f0:	84 81       	ldd	r24, Z+4	; 0x04
    22f2:	8d 7f       	andi	r24, 0xFD	; 253
    22f4:	81 30       	cpi	r24, 0x01	; 1
    22f6:	21 f4       	brne	.+8      	; 0x2300 <usart_init_spi+0x2ee>
		usart->CTRLC |= USART_UCPHA_bm;
    22f8:	8d 81       	ldd	r24, Y+5	; 0x05
    22fa:	82 60       	ori	r24, 0x02	; 2
    22fc:	8d 83       	std	Y+5, r24	; 0x05
    22fe:	03 c0       	rjmp	.+6      	; 0x2306 <usart_init_spi+0x2f4>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    2300:	8d 81       	ldd	r24, Y+5	; 0x05
    2302:	8d 7f       	andi	r24, 0xFD	; 253
    2304:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    2306:	f7 01       	movw	r30, r14
    2308:	85 81       	ldd	r24, Z+5	; 0x05
    230a:	88 23       	and	r24, r24
    230c:	21 f0       	breq	.+8      	; 0x2316 <usart_init_spi+0x304>
		(usart)->CTRLC |= USART_DORD_bm;
    230e:	8d 81       	ldd	r24, Y+5	; 0x05
    2310:	84 60       	ori	r24, 0x04	; 4
    2312:	8d 83       	std	Y+5, r24	; 0x05
    2314:	03 c0       	rjmp	.+6      	; 0x231c <usart_init_spi+0x30a>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    2316:	8d 81       	ldd	r24, Y+5	; 0x05
    2318:	8b 7f       	andi	r24, 0xFB	; 251
    231a:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    231c:	f7 01       	movw	r30, r14
    231e:	40 81       	ld	r20, Z
    2320:	51 81       	ldd	r21, Z+1	; 0x01
    2322:	62 81       	ldd	r22, Z+2	; 0x02
    2324:	73 81       	ldd	r23, Z+3	; 0x03
    2326:	00 e0       	ldi	r16, 0x00	; 0
    2328:	18 e4       	ldi	r17, 0x48	; 72
    232a:	28 ee       	ldi	r18, 0xE8	; 232
    232c:	31 e0       	ldi	r19, 0x01	; 1
    232e:	ce 01       	movw	r24, r28
    2330:	3e de       	rcall	.-900    	; 0x1fae <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    2332:	8c 81       	ldd	r24, Y+4	; 0x04
    2334:	88 60       	ori	r24, 0x08	; 8
    2336:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    2338:	8c 81       	ldd	r24, Y+4	; 0x04
    233a:	80 61       	ori	r24, 0x10	; 16
    233c:	8c 83       	std	Y+4, r24	; 0x04
    233e:	10 c0       	rjmp	.+32     	; 0x2360 <usart_init_spi+0x34e>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    2340:	8c 81       	ldd	r24, Y+4	; 0x04
    2342:	8f 7e       	andi	r24, 0xEF	; 239
    2344:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    2346:	f7 01       	movw	r30, r14
    2348:	24 81       	ldd	r18, Z+4	; 0x04
    234a:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    234c:	ce 01       	movw	r24, r28
    234e:	7c cf       	rjmp	.-264    	; 0x2248 <usart_init_spi+0x236>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    2350:	15 e1       	ldi	r17, 0x15	; 21
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    2352:	80 ea       	ldi	r24, 0xA0	; 160
    2354:	98 e0       	ldi	r25, 0x08	; 8
    2356:	86 cf       	rjmp	.-244    	; 0x2264 <usart_init_spi+0x252>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    2358:	1d e1       	ldi	r17, 0x1D	; 29
    235a:	94 cf       	rjmp	.-216    	; 0x2284 <usart_init_spi+0x272>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    235c:	15 e2       	ldi	r17, 0x25	; 37
    235e:	9e cf       	rjmp	.-196    	; 0x229c <usart_init_spi+0x28a>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    2360:	df 91       	pop	r29
    2362:	cf 91       	pop	r28
    2364:	1f 91       	pop	r17
    2366:	0f 91       	pop	r16
    2368:	ff 90       	pop	r15
    236a:	ef 90       	pop	r14
    236c:	08 95       	ret

0000236e <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
    236e:	80 3a       	cpi	r24, 0xA0	; 160
    2370:	28 e0       	ldi	r18, 0x08	; 8
    2372:	92 07       	cpc	r25, r18
    2374:	21 f4       	brne	.+8      	; 0x237e <usart_spi_init+0x10>
    2376:	60 e1       	ldi	r22, 0x10	; 16
    2378:	83 e0       	ldi	r24, 0x03	; 3
    237a:	f0 c6       	rjmp	.+3552   	; 0x315c <sysclk_enable_module>
    237c:	08 95       	ret
    237e:	80 3b       	cpi	r24, 0xB0	; 176
    2380:	28 e0       	ldi	r18, 0x08	; 8
    2382:	92 07       	cpc	r25, r18
    2384:	21 f4       	brne	.+8      	; 0x238e <usart_spi_init+0x20>
    2386:	60 e2       	ldi	r22, 0x20	; 32
    2388:	83 e0       	ldi	r24, 0x03	; 3
    238a:	e8 c6       	rjmp	.+3536   	; 0x315c <sysclk_enable_module>
    238c:	08 95       	ret
    238e:	80 3a       	cpi	r24, 0xA0	; 160
    2390:	29 e0       	ldi	r18, 0x09	; 9
    2392:	92 07       	cpc	r25, r18
    2394:	21 f4       	brne	.+8      	; 0x239e <usart_spi_init+0x30>
    2396:	60 e1       	ldi	r22, 0x10	; 16
    2398:	84 e0       	ldi	r24, 0x04	; 4
    239a:	e0 c6       	rjmp	.+3520   	; 0x315c <sysclk_enable_module>
    239c:	08 95       	ret
    239e:	80 3b       	cpi	r24, 0xB0	; 176
    23a0:	29 e0       	ldi	r18, 0x09	; 9
    23a2:	92 07       	cpc	r25, r18
    23a4:	21 f4       	brne	.+8      	; 0x23ae <usart_spi_init+0x40>
    23a6:	60 e2       	ldi	r22, 0x20	; 32
    23a8:	84 e0       	ldi	r24, 0x04	; 4
    23aa:	d8 c6       	rjmp	.+3504   	; 0x315c <sysclk_enable_module>
    23ac:	08 95       	ret
    23ae:	80 3a       	cpi	r24, 0xA0	; 160
    23b0:	2a e0       	ldi	r18, 0x0A	; 10
    23b2:	92 07       	cpc	r25, r18
    23b4:	21 f4       	brne	.+8      	; 0x23be <usart_spi_init+0x50>
    23b6:	60 e1       	ldi	r22, 0x10	; 16
    23b8:	85 e0       	ldi	r24, 0x05	; 5
    23ba:	d0 c6       	rjmp	.+3488   	; 0x315c <sysclk_enable_module>
    23bc:	08 95       	ret
    23be:	80 3a       	cpi	r24, 0xA0	; 160
    23c0:	9b 40       	sbci	r25, 0x0B	; 11
    23c2:	19 f4       	brne	.+6      	; 0x23ca <usart_spi_init+0x5c>
    23c4:	60 e1       	ldi	r22, 0x10	; 16
    23c6:	86 e0       	ldi	r24, 0x06	; 6
    23c8:	c9 c6       	rjmp	.+3474   	; 0x315c <sysclk_enable_module>
    23ca:	08 95       	ret

000023cc <usart_spi_setup_device>:
    23cc:	0f 93       	push	r16
    23ce:	1f 93       	push	r17
    23d0:	cf 93       	push	r28
    23d2:	df 93       	push	r29
    23d4:	00 d0       	rcall	.+0      	; 0x23d6 <usart_spi_setup_device+0xa>
    23d6:	00 d0       	rcall	.+0      	; 0x23d8 <usart_spi_setup_device+0xc>
    23d8:	cd b7       	in	r28, 0x3d	; 61
    23da:	de b7       	in	r29, 0x3e	; 62
    23dc:	09 83       	std	Y+1, r16	; 0x01
    23de:	1a 83       	std	Y+2, r17	; 0x02
    23e0:	2b 83       	std	Y+3, r18	; 0x03
    23e2:	3c 83       	std	Y+4, r19	; 0x04
    23e4:	4d 83       	std	Y+5, r20	; 0x05
    23e6:	1e 82       	std	Y+6, r1	; 0x06
    23e8:	be 01       	movw	r22, r28
    23ea:	6f 5f       	subi	r22, 0xFF	; 255
    23ec:	7f 4f       	sbci	r23, 0xFF	; 255
    23ee:	11 de       	rcall	.-990    	; 0x2012 <usart_init_spi>
    23f0:	26 96       	adiw	r28, 0x06	; 6
    23f2:	cd bf       	out	0x3d, r28	; 61
    23f4:	de bf       	out	0x3e, r29	; 62
    23f6:	df 91       	pop	r29
    23f8:	cf 91       	pop	r28
    23fa:	1f 91       	pop	r17
    23fc:	0f 91       	pop	r16
    23fe:	08 95       	ret

00002400 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
    2400:	fb 01       	movw	r30, r22
    2402:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    2404:	e8 2f       	mov	r30, r24
    2406:	e6 95       	lsr	r30
    2408:	e6 95       	lsr	r30
    240a:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    240c:	40 e2       	ldi	r20, 0x20	; 32
    240e:	e4 9f       	mul	r30, r20
    2410:	f0 01       	movw	r30, r0
    2412:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2414:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    2416:	87 70       	andi	r24, 0x07	; 7
    2418:	21 e0       	ldi	r18, 0x01	; 1
    241a:	30 e0       	ldi	r19, 0x00	; 0
    241c:	a9 01       	movw	r20, r18
    241e:	02 c0       	rjmp	.+4      	; 0x2424 <usart_spi_select_device+0x24>
    2420:	44 0f       	add	r20, r20
    2422:	55 1f       	adc	r21, r21
    2424:	8a 95       	dec	r24
    2426:	e2 f7       	brpl	.-8      	; 0x2420 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    2428:	46 83       	std	Z+6, r20	; 0x06
    242a:	08 95       	ret

0000242c <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
    242c:	fb 01       	movw	r30, r22
    242e:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    2430:	e8 2f       	mov	r30, r24
    2432:	e6 95       	lsr	r30
    2434:	e6 95       	lsr	r30
    2436:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    2438:	40 e2       	ldi	r20, 0x20	; 32
    243a:	e4 9f       	mul	r30, r20
    243c:	f0 01       	movw	r30, r0
    243e:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2440:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    2442:	87 70       	andi	r24, 0x07	; 7
    2444:	21 e0       	ldi	r18, 0x01	; 1
    2446:	30 e0       	ldi	r19, 0x00	; 0
    2448:	a9 01       	movw	r20, r18
    244a:	02 c0       	rjmp	.+4      	; 0x2450 <usart_spi_deselect_device+0x24>
    244c:	44 0f       	add	r20, r20
    244e:	55 1f       	adc	r21, r21
    2450:	8a 95       	dec	r24
    2452:	e2 f7       	brpl	.-8      	; 0x244c <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2454:	45 83       	std	Z+5, r20	; 0x05
    2456:	08 95       	ret

00002458 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
    2458:	80 93 92 22 	sts	0x2292, r24
    245c:	90 93 93 22 	sts	0x2293, r25
    2460:	08 95       	ret

00002462 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    2462:	20 e8       	ldi	r18, 0x80	; 128
    2464:	82 9f       	mul	r24, r18
    2466:	c0 01       	movw	r24, r0
    2468:	11 24       	eor	r1, r1
    246a:	86 0f       	add	r24, r22
    246c:	91 1d       	adc	r25, r1
    246e:	e0 91 92 22 	lds	r30, 0x2292
    2472:	f0 91 93 22 	lds	r31, 0x2293
    2476:	e8 0f       	add	r30, r24
    2478:	f9 1f       	adc	r31, r25
    247a:	40 83       	st	Z, r20
    247c:	08 95       	ret

0000247e <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
    247e:	20 e8       	ldi	r18, 0x80	; 128
    2480:	82 9f       	mul	r24, r18
    2482:	c0 01       	movw	r24, r0
    2484:	11 24       	eor	r1, r1
    2486:	86 0f       	add	r24, r22
    2488:	91 1d       	adc	r25, r1
    248a:	e0 91 92 22 	lds	r30, 0x2292
    248e:	f0 91 93 22 	lds	r31, 0x2293
    2492:	e8 0f       	add	r30, r24
    2494:	f9 1f       	adc	r31, r25
}
    2496:	80 81       	ld	r24, Z
    2498:	08 95       	ret

0000249a <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
    249a:	ff 92       	push	r15
    249c:	0f 93       	push	r16
    249e:	1f 93       	push	r17
    24a0:	cf 93       	push	r28
    24a2:	df 93       	push	r29
    24a4:	e4 2f       	mov	r30, r20
    24a6:	f0 e0       	ldi	r31, 0x00	; 0
    24a8:	e8 0f       	add	r30, r24
    24aa:	f1 1d       	adc	r31, r1
    24ac:	e1 38       	cpi	r30, 0x81	; 129
    24ae:	f1 05       	cpc	r31, r1
    24b0:	1c f0       	brlt	.+6      	; 0x24b8 <gfx_mono_generic_draw_horizontal_line+0x1e>
    24b2:	c0 e8       	ldi	r28, 0x80	; 128
    24b4:	4c 2f       	mov	r20, r28
    24b6:	48 1b       	sub	r20, r24
    24b8:	44 23       	and	r20, r20
    24ba:	09 f4       	brne	.+2      	; 0x24be <gfx_mono_generic_draw_horizontal_line+0x24>
    24bc:	53 c0       	rjmp	.+166    	; 0x2564 <gfx_mono_generic_draw_horizontal_line+0xca>
    24be:	d6 2f       	mov	r29, r22
    24c0:	d6 95       	lsr	r29
    24c2:	d6 95       	lsr	r29
    24c4:	d6 95       	lsr	r29
    24c6:	ed 2f       	mov	r30, r29
    24c8:	f0 e0       	ldi	r31, 0x00	; 0
    24ca:	f1 95       	neg	r31
    24cc:	e1 95       	neg	r30
    24ce:	f1 09       	sbc	r31, r1
    24d0:	ee 0f       	add	r30, r30
    24d2:	ff 1f       	adc	r31, r31
    24d4:	ee 0f       	add	r30, r30
    24d6:	ff 1f       	adc	r31, r31
    24d8:	ee 0f       	add	r30, r30
    24da:	ff 1f       	adc	r31, r31
    24dc:	df 01       	movw	r26, r30
    24de:	a6 0f       	add	r26, r22
    24e0:	b1 1d       	adc	r27, r1
    24e2:	bd 01       	movw	r22, r26
    24e4:	e1 e0       	ldi	r30, 0x01	; 1
    24e6:	f0 e0       	ldi	r31, 0x00	; 0
    24e8:	df 01       	movw	r26, r30
    24ea:	02 c0       	rjmp	.+4      	; 0x24f0 <gfx_mono_generic_draw_horizontal_line+0x56>
    24ec:	aa 0f       	add	r26, r26
    24ee:	bb 1f       	adc	r27, r27
    24f0:	6a 95       	dec	r22
    24f2:	e2 f7       	brpl	.-8      	; 0x24ec <gfx_mono_generic_draw_horizontal_line+0x52>
    24f4:	fa 2e       	mov	r15, r26
    24f6:	21 30       	cpi	r18, 0x01	; 1
    24f8:	21 f0       	breq	.+8      	; 0x2502 <gfx_mono_generic_draw_horizontal_line+0x68>
    24fa:	98 f0       	brcs	.+38     	; 0x2522 <gfx_mono_generic_draw_horizontal_line+0x88>
    24fc:	22 30       	cpi	r18, 0x02	; 2
    24fe:	19 f1       	breq	.+70     	; 0x2546 <gfx_mono_generic_draw_horizontal_line+0xac>
    2500:	31 c0       	rjmp	.+98     	; 0x2564 <gfx_mono_generic_draw_horizontal_line+0xca>
    2502:	c4 2f       	mov	r28, r20
    2504:	1f ef       	ldi	r17, 0xFF	; 255
    2506:	18 0f       	add	r17, r24
    2508:	01 2f       	mov	r16, r17
    250a:	0c 0f       	add	r16, r28
    250c:	60 2f       	mov	r22, r16
    250e:	8d 2f       	mov	r24, r29
    2510:	55 d9       	rcall	.-3414   	; 0x17bc <gfx_mono_st7565r_get_byte>
    2512:	48 2f       	mov	r20, r24
    2514:	4f 29       	or	r20, r15
    2516:	60 2f       	mov	r22, r16
    2518:	8d 2f       	mov	r24, r29
    251a:	29 d8       	rcall	.-4014   	; 0x156e <gfx_mono_st7565r_put_byte>
    251c:	c1 50       	subi	r28, 0x01	; 1
    251e:	a1 f7       	brne	.-24     	; 0x2508 <gfx_mono_generic_draw_horizontal_line+0x6e>
    2520:	21 c0       	rjmp	.+66     	; 0x2564 <gfx_mono_generic_draw_horizontal_line+0xca>
    2522:	c4 2f       	mov	r28, r20
    2524:	1f ef       	ldi	r17, 0xFF	; 255
    2526:	18 0f       	add	r17, r24
    2528:	fa 2e       	mov	r15, r26
    252a:	f0 94       	com	r15
    252c:	01 2f       	mov	r16, r17
    252e:	0c 0f       	add	r16, r28
    2530:	60 2f       	mov	r22, r16
    2532:	8d 2f       	mov	r24, r29
    2534:	43 d9       	rcall	.-3450   	; 0x17bc <gfx_mono_st7565r_get_byte>
    2536:	48 2f       	mov	r20, r24
    2538:	4f 21       	and	r20, r15
    253a:	60 2f       	mov	r22, r16
    253c:	8d 2f       	mov	r24, r29
    253e:	17 d8       	rcall	.-4050   	; 0x156e <gfx_mono_st7565r_put_byte>
    2540:	c1 50       	subi	r28, 0x01	; 1
    2542:	a1 f7       	brne	.-24     	; 0x252c <gfx_mono_generic_draw_horizontal_line+0x92>
    2544:	0f c0       	rjmp	.+30     	; 0x2564 <gfx_mono_generic_draw_horizontal_line+0xca>
    2546:	c4 2f       	mov	r28, r20
    2548:	1f ef       	ldi	r17, 0xFF	; 255
    254a:	18 0f       	add	r17, r24
    254c:	01 2f       	mov	r16, r17
    254e:	0c 0f       	add	r16, r28
    2550:	60 2f       	mov	r22, r16
    2552:	8d 2f       	mov	r24, r29
    2554:	33 d9       	rcall	.-3482   	; 0x17bc <gfx_mono_st7565r_get_byte>
    2556:	48 2f       	mov	r20, r24
    2558:	4f 25       	eor	r20, r15
    255a:	60 2f       	mov	r22, r16
    255c:	8d 2f       	mov	r24, r29
    255e:	07 d8       	rcall	.-4082   	; 0x156e <gfx_mono_st7565r_put_byte>
    2560:	c1 50       	subi	r28, 0x01	; 1
    2562:	a1 f7       	brne	.-24     	; 0x254c <gfx_mono_generic_draw_horizontal_line+0xb2>
    2564:	df 91       	pop	r29
    2566:	cf 91       	pop	r28
    2568:	1f 91       	pop	r17
    256a:	0f 91       	pop	r16
    256c:	ff 90       	pop	r15
    256e:	08 95       	ret

00002570 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
    2570:	ff 92       	push	r15
    2572:	0f 93       	push	r16
    2574:	1f 93       	push	r17
    2576:	cf 93       	push	r28
    2578:	df 93       	push	r29
	if (height == 0) {
    257a:	22 23       	and	r18, r18
    257c:	69 f0       	breq	.+26     	; 0x2598 <gfx_mono_generic_draw_filled_rect+0x28>
    257e:	c2 2f       	mov	r28, r18
    2580:	f4 2e       	mov	r15, r20
    2582:	18 2f       	mov	r17, r24
    2584:	df ef       	ldi	r29, 0xFF	; 255
    2586:	d6 0f       	add	r29, r22
    2588:	6d 2f       	mov	r22, r29
    258a:	6c 0f       	add	r22, r28
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
    258c:	20 2f       	mov	r18, r16
    258e:	4f 2d       	mov	r20, r15
    2590:	81 2f       	mov	r24, r17
    2592:	83 df       	rcall	.-250    	; 0x249a <gfx_mono_generic_draw_horizontal_line>
    2594:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
    2596:	c1 f7       	brne	.-16     	; 0x2588 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
    2598:	df 91       	pop	r29
    259a:	cf 91       	pop	r28
    259c:	1f 91       	pop	r17
    259e:	0f 91       	pop	r16
    25a0:	ff 90       	pop	r15
    25a2:	08 95       	ret

000025a4 <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
    25a4:	af 92       	push	r10
    25a6:	bf 92       	push	r11
    25a8:	cf 92       	push	r12
    25aa:	df 92       	push	r13
    25ac:	ef 92       	push	r14
    25ae:	ff 92       	push	r15
    25b0:	0f 93       	push	r16
    25b2:	1f 93       	push	r17
    25b4:	cf 93       	push	r28
    25b6:	df 93       	push	r29
    25b8:	c8 2f       	mov	r28, r24
    25ba:	e6 2e       	mov	r14, r22
    25bc:	b4 2e       	mov	r11, r20
    25be:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
    25c0:	00 e0       	ldi	r16, 0x00	; 0
    25c2:	f9 01       	movw	r30, r18
    25c4:	24 81       	ldd	r18, Z+4	; 0x04
    25c6:	43 81       	ldd	r20, Z+3	; 0x03
    25c8:	6b 2d       	mov	r22, r11
    25ca:	8e 2d       	mov	r24, r14
    25cc:	d1 df       	rcall	.-94     	; 0x2570 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
    25ce:	f6 01       	movw	r30, r12
    25d0:	80 81       	ld	r24, Z
    25d2:	81 11       	cpse	r24, r1
    25d4:	39 c0       	rjmp	.+114    	; 0x2648 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
    25d6:	83 81       	ldd	r24, Z+3	; 0x03
    25d8:	28 2f       	mov	r18, r24
    25da:	26 95       	lsr	r18
    25dc:	26 95       	lsr	r18
    25de:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
    25e0:	87 70       	andi	r24, 0x07	; 7
    25e2:	09 f0       	breq	.+2      	; 0x25e6 <gfx_mono_draw_char+0x42>
		char_row_size++;
    25e4:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
    25e6:	f6 01       	movw	r30, r12
    25e8:	a4 80       	ldd	r10, Z+4	; 0x04
    25ea:	2a 9d       	mul	r18, r10
    25ec:	90 01       	movw	r18, r0
    25ee:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
    25f0:	8c 2f       	mov	r24, r28
    25f2:	90 e0       	ldi	r25, 0x00	; 0
    25f4:	45 81       	ldd	r20, Z+5	; 0x05
    25f6:	84 1b       	sub	r24, r20
    25f8:	91 09       	sbc	r25, r1
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
    25fa:	28 9f       	mul	r18, r24
    25fc:	a0 01       	movw	r20, r0
    25fe:	29 9f       	mul	r18, r25
    2600:	50 0d       	add	r21, r0
    2602:	38 9f       	mul	r19, r24
    2604:	50 0d       	add	r21, r0
    2606:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
    2608:	01 81       	ldd	r16, Z+1	; 0x01
    260a:	12 81       	ldd	r17, Z+2	; 0x02
    260c:	04 0f       	add	r16, r20
    260e:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
    2610:	f6 01       	movw	r30, r12
    2612:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
    2614:	ff 20       	and	r15, r15
    2616:	a1 f0       	breq	.+40     	; 0x2640 <gfx_mono_draw_char+0x9c>
    2618:	d0 e0       	ldi	r29, 0x00	; 0
    261a:	c0 e0       	ldi	r28, 0x00	; 0
    261c:	8c 2f       	mov	r24, r28
    261e:	8e 0d       	add	r24, r14
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
    2620:	9c 2f       	mov	r25, r28
    2622:	97 70       	andi	r25, 0x07	; 7
    2624:	21 f4       	brne	.+8      	; 0x262e <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
    2626:	f8 01       	movw	r30, r16
    2628:	d4 91       	lpm	r29, Z
				glyph_data++;
    262a:	0f 5f       	subi	r16, 0xFF	; 255
    262c:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
    262e:	dd 23       	and	r29, r29
    2630:	1c f4       	brge	.+6      	; 0x2638 <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
    2632:	41 e0       	ldi	r20, 0x01	; 1
    2634:	6b 2d       	mov	r22, r11
    2636:	84 d8       	rcall	.-3832   	; 0x1740 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
    2638:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
    263a:	cf 5f       	subi	r28, 0xFF	; 255
    263c:	cf 11       	cpse	r28, r15
    263e:	ee cf       	rjmp	.-36     	; 0x261c <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
    2640:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
    2642:	aa 94       	dec	r10
	} while (rows_left > 0);
    2644:	a1 10       	cpse	r10, r1
    2646:	e4 cf       	rjmp	.-56     	; 0x2610 <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
    2648:	df 91       	pop	r29
    264a:	cf 91       	pop	r28
    264c:	1f 91       	pop	r17
    264e:	0f 91       	pop	r16
    2650:	ff 90       	pop	r15
    2652:	ef 90       	pop	r14
    2654:	df 90       	pop	r13
    2656:	cf 90       	pop	r12
    2658:	bf 90       	pop	r11
    265a:	af 90       	pop	r10
    265c:	08 95       	ret

0000265e <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
    265e:	df 92       	push	r13
    2660:	ef 92       	push	r14
    2662:	ff 92       	push	r15
    2664:	0f 93       	push	r16
    2666:	1f 93       	push	r17
    2668:	cf 93       	push	r28
    266a:	df 93       	push	r29
    266c:	04 2f       	mov	r16, r20
    266e:	79 01       	movw	r14, r18
    2670:	ec 01       	movw	r28, r24
    2672:	16 2f       	mov	r17, r22

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    2674:	d6 2e       	mov	r13, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
    2676:	89 91       	ld	r24, Y+
    2678:	8a 30       	cpi	r24, 0x0A	; 10
    267a:	31 f4       	brne	.+12     	; 0x2688 <gfx_mono_draw_string+0x2a>
    267c:	f7 01       	movw	r30, r14
    267e:	84 81       	ldd	r24, Z+4	; 0x04
    2680:	8f 5f       	subi	r24, 0xFF	; 255
			x = start_of_string_position_x;
			y += font->height + 1;
    2682:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    2684:	1d 2d       	mov	r17, r13
    2686:	09 c0       	rjmp	.+18     	; 0x269a <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
    2688:	8d 30       	cpi	r24, 0x0D	; 13
    268a:	39 f0       	breq	.+14     	; 0x269a <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
    268c:	97 01       	movw	r18, r14
    268e:	40 2f       	mov	r20, r16
    2690:	61 2f       	mov	r22, r17
    2692:	88 df       	rcall	.-240    	; 0x25a4 <gfx_mono_draw_char>
			x += font->width;
    2694:	f7 01       	movw	r30, r14
    2696:	83 81       	ldd	r24, Z+3	; 0x03
    2698:	18 0f       	add	r17, r24
		}
	} while (*(++str));
    269a:	88 81       	ld	r24, Y
    269c:	81 11       	cpse	r24, r1
    269e:	eb cf       	rjmp	.-42     	; 0x2676 <gfx_mono_draw_string+0x18>
}
    26a0:	df 91       	pop	r29
    26a2:	cf 91       	pop	r28
    26a4:	1f 91       	pop	r17
    26a6:	0f 91       	pop	r16
    26a8:	ff 90       	pop	r15
    26aa:	ef 90       	pop	r14
    26ac:	df 90       	pop	r13
    26ae:	08 95       	ret

000026b0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    26b0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    26b2:	03 96       	adiw	r24, 0x03	; 3
    26b4:	81 83       	std	Z+1, r24	; 0x01
    26b6:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    26b8:	2f ef       	ldi	r18, 0xFF	; 255
    26ba:	3f ef       	ldi	r19, 0xFF	; 255
    26bc:	23 83       	std	Z+3, r18	; 0x03
    26be:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    26c0:	85 83       	std	Z+5, r24	; 0x05
    26c2:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    26c4:	87 83       	std	Z+7, r24	; 0x07
    26c6:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    26c8:	10 82       	st	Z, r1
    26ca:	08 95       	ret

000026cc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    26cc:	fc 01       	movw	r30, r24
    26ce:	10 86       	std	Z+8, r1	; 0x08
    26d0:	11 86       	std	Z+9, r1	; 0x09
    26d2:	08 95       	ret

000026d4 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    26d4:	cf 93       	push	r28
    26d6:	df 93       	push	r29
    26d8:	9c 01       	movw	r18, r24
    26da:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    26dc:	dc 01       	movw	r26, r24
    26de:	11 96       	adiw	r26, 0x01	; 1
    26e0:	cd 91       	ld	r28, X+
    26e2:	dc 91       	ld	r29, X
    26e4:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    26e6:	c2 83       	std	Z+2, r28	; 0x02
    26e8:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    26ea:	8c 81       	ldd	r24, Y+4	; 0x04
    26ec:	9d 81       	ldd	r25, Y+5	; 0x05
    26ee:	84 83       	std	Z+4, r24	; 0x04
    26f0:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    26f2:	8c 81       	ldd	r24, Y+4	; 0x04
    26f4:	9d 81       	ldd	r25, Y+5	; 0x05
    26f6:	dc 01       	movw	r26, r24
    26f8:	12 96       	adiw	r26, 0x02	; 2
    26fa:	6d 93       	st	X+, r22
    26fc:	7c 93       	st	X, r23
    26fe:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    2700:	6c 83       	std	Y+4, r22	; 0x04
    2702:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2704:	20 87       	std	Z+8, r18	; 0x08
    2706:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    2708:	f9 01       	movw	r30, r18
    270a:	80 81       	ld	r24, Z
    270c:	8f 5f       	subi	r24, 0xFF	; 255
    270e:	80 83       	st	Z, r24
}
    2710:	df 91       	pop	r29
    2712:	cf 91       	pop	r28
    2714:	08 95       	ret

00002716 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2716:	cf 93       	push	r28
    2718:	df 93       	push	r29
    271a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    271c:	48 81       	ld	r20, Y
    271e:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2720:	4f 3f       	cpi	r20, 0xFF	; 255
    2722:	2f ef       	ldi	r18, 0xFF	; 255
    2724:	52 07       	cpc	r21, r18
    2726:	21 f4       	brne	.+8      	; 0x2730 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2728:	fc 01       	movw	r30, r24
    272a:	a7 81       	ldd	r26, Z+7	; 0x07
    272c:	b0 85       	ldd	r27, Z+8	; 0x08
    272e:	0d c0       	rjmp	.+26     	; 0x274a <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2730:	dc 01       	movw	r26, r24
    2732:	13 96       	adiw	r26, 0x03	; 3
    2734:	01 c0       	rjmp	.+2      	; 0x2738 <vListInsert+0x22>
    2736:	df 01       	movw	r26, r30
    2738:	12 96       	adiw	r26, 0x02	; 2
    273a:	ed 91       	ld	r30, X+
    273c:	fc 91       	ld	r31, X
    273e:	13 97       	sbiw	r26, 0x03	; 3
    2740:	20 81       	ld	r18, Z
    2742:	31 81       	ldd	r19, Z+1	; 0x01
    2744:	42 17       	cp	r20, r18
    2746:	53 07       	cpc	r21, r19
    2748:	b0 f7       	brcc	.-20     	; 0x2736 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    274a:	12 96       	adiw	r26, 0x02	; 2
    274c:	ed 91       	ld	r30, X+
    274e:	fc 91       	ld	r31, X
    2750:	13 97       	sbiw	r26, 0x03	; 3
    2752:	ea 83       	std	Y+2, r30	; 0x02
    2754:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2756:	c4 83       	std	Z+4, r28	; 0x04
    2758:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    275a:	ac 83       	std	Y+4, r26	; 0x04
    275c:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    275e:	12 96       	adiw	r26, 0x02	; 2
    2760:	cd 93       	st	X+, r28
    2762:	dc 93       	st	X, r29
    2764:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2766:	88 87       	std	Y+8, r24	; 0x08
    2768:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    276a:	fc 01       	movw	r30, r24
    276c:	20 81       	ld	r18, Z
    276e:	2f 5f       	subi	r18, 0xFF	; 255
    2770:	20 83       	st	Z, r18
}
    2772:	df 91       	pop	r29
    2774:	cf 91       	pop	r28
    2776:	08 95       	ret

00002778 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2778:	cf 93       	push	r28
    277a:	df 93       	push	r29
    277c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    277e:	a0 85       	ldd	r26, Z+8	; 0x08
    2780:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2782:	c2 81       	ldd	r28, Z+2	; 0x02
    2784:	d3 81       	ldd	r29, Z+3	; 0x03
    2786:	84 81       	ldd	r24, Z+4	; 0x04
    2788:	95 81       	ldd	r25, Z+5	; 0x05
    278a:	8c 83       	std	Y+4, r24	; 0x04
    278c:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    278e:	c4 81       	ldd	r28, Z+4	; 0x04
    2790:	d5 81       	ldd	r29, Z+5	; 0x05
    2792:	82 81       	ldd	r24, Z+2	; 0x02
    2794:	93 81       	ldd	r25, Z+3	; 0x03
    2796:	8a 83       	std	Y+2, r24	; 0x02
    2798:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    279a:	11 96       	adiw	r26, 0x01	; 1
    279c:	cd 91       	ld	r28, X+
    279e:	dc 91       	ld	r29, X
    27a0:	12 97       	sbiw	r26, 0x02	; 2
    27a2:	ce 17       	cp	r28, r30
    27a4:	df 07       	cpc	r29, r31
    27a6:	31 f4       	brne	.+12     	; 0x27b4 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    27a8:	8c 81       	ldd	r24, Y+4	; 0x04
    27aa:	9d 81       	ldd	r25, Y+5	; 0x05
    27ac:	11 96       	adiw	r26, 0x01	; 1
    27ae:	8d 93       	st	X+, r24
    27b0:	9c 93       	st	X, r25
    27b2:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    27b4:	10 86       	std	Z+8, r1	; 0x08
    27b6:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    27b8:	8c 91       	ld	r24, X
    27ba:	81 50       	subi	r24, 0x01	; 1
    27bc:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    27be:	df 91       	pop	r29
    27c0:	cf 91       	pop	r28
    27c2:	08 95       	ret

000027c4 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    27c4:	0f 93       	push	r16
    27c6:	1f 93       	push	r17
    27c8:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    27ca:	71 e1       	ldi	r23, 0x11	; 17
    27cc:	fc 01       	movw	r30, r24
    27ce:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    27d0:	31 97       	sbiw	r30, 0x01	; 1
    27d2:	62 e2       	ldi	r22, 0x22	; 34
    27d4:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    27d6:	31 97       	sbiw	r30, 0x01	; 1
    27d8:	23 e3       	ldi	r18, 0x33	; 51
    27da:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    27dc:	01 2e       	mov	r0, r17
    27de:	00 0c       	add	r0, r0
    27e0:	22 0b       	sbc	r18, r18
    27e2:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    27e4:	31 97       	sbiw	r30, 0x01	; 1
    27e6:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    27e8:	31 97       	sbiw	r30, 0x01	; 1
    27ea:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    27ec:	31 97       	sbiw	r30, 0x01	; 1
    27ee:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    27f0:	31 97       	sbiw	r30, 0x01	; 1
    27f2:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    27f4:	31 97       	sbiw	r30, 0x01	; 1
    27f6:	20 e8       	ldi	r18, 0x80	; 128
    27f8:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    27fa:	31 97       	sbiw	r30, 0x01	; 1
    27fc:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    27fe:	31 97       	sbiw	r30, 0x01	; 1
    2800:	22 e0       	ldi	r18, 0x02	; 2
    2802:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    2804:	31 97       	sbiw	r30, 0x01	; 1
    2806:	23 e0       	ldi	r18, 0x03	; 3
    2808:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    280a:	31 97       	sbiw	r30, 0x01	; 1
    280c:	24 e0       	ldi	r18, 0x04	; 4
    280e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    2810:	31 97       	sbiw	r30, 0x01	; 1
    2812:	25 e0       	ldi	r18, 0x05	; 5
    2814:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    2816:	31 97       	sbiw	r30, 0x01	; 1
    2818:	26 e0       	ldi	r18, 0x06	; 6
    281a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    281c:	31 97       	sbiw	r30, 0x01	; 1
    281e:	27 e0       	ldi	r18, 0x07	; 7
    2820:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    2822:	31 97       	sbiw	r30, 0x01	; 1
    2824:	28 e0       	ldi	r18, 0x08	; 8
    2826:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    2828:	31 97       	sbiw	r30, 0x01	; 1
    282a:	29 e0       	ldi	r18, 0x09	; 9
    282c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    282e:	31 97       	sbiw	r30, 0x01	; 1
    2830:	20 e1       	ldi	r18, 0x10	; 16
    2832:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    2834:	31 97       	sbiw	r30, 0x01	; 1
    2836:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    2838:	31 97       	sbiw	r30, 0x01	; 1
    283a:	22 e1       	ldi	r18, 0x12	; 18
    283c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    283e:	31 97       	sbiw	r30, 0x01	; 1
    2840:	23 e1       	ldi	r18, 0x13	; 19
    2842:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    2844:	31 97       	sbiw	r30, 0x01	; 1
    2846:	24 e1       	ldi	r18, 0x14	; 20
    2848:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    284a:	31 97       	sbiw	r30, 0x01	; 1
    284c:	25 e1       	ldi	r18, 0x15	; 21
    284e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    2850:	31 97       	sbiw	r30, 0x01	; 1
    2852:	26 e1       	ldi	r18, 0x16	; 22
    2854:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    2856:	31 97       	sbiw	r30, 0x01	; 1
    2858:	27 e1       	ldi	r18, 0x17	; 23
    285a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    285c:	31 97       	sbiw	r30, 0x01	; 1
    285e:	28 e1       	ldi	r18, 0x18	; 24
    2860:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    2862:	31 97       	sbiw	r30, 0x01	; 1
    2864:	29 e1       	ldi	r18, 0x19	; 25
    2866:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    2868:	31 97       	sbiw	r30, 0x01	; 1
    286a:	20 e2       	ldi	r18, 0x20	; 32
    286c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    286e:	31 97       	sbiw	r30, 0x01	; 1
    2870:	21 e2       	ldi	r18, 0x21	; 33
    2872:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    2874:	31 97       	sbiw	r30, 0x01	; 1
    2876:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    2878:	31 97       	sbiw	r30, 0x01	; 1
    287a:	23 e2       	ldi	r18, 0x23	; 35
    287c:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    287e:	31 97       	sbiw	r30, 0x01	; 1
    2880:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    2882:	31 97       	sbiw	r30, 0x01	; 1
    2884:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    2886:	31 97       	sbiw	r30, 0x01	; 1
    2888:	26 e2       	ldi	r18, 0x26	; 38
    288a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    288c:	31 97       	sbiw	r30, 0x01	; 1
    288e:	27 e2       	ldi	r18, 0x27	; 39
    2890:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    2892:	31 97       	sbiw	r30, 0x01	; 1
    2894:	28 e2       	ldi	r18, 0x28	; 40
    2896:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    2898:	31 97       	sbiw	r30, 0x01	; 1
    289a:	29 e2       	ldi	r18, 0x29	; 41
    289c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    289e:	31 97       	sbiw	r30, 0x01	; 1
    28a0:	20 e3       	ldi	r18, 0x30	; 48
    28a2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    28a4:	31 97       	sbiw	r30, 0x01	; 1
    28a6:	21 e3       	ldi	r18, 0x31	; 49
    28a8:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    28aa:	87 97       	sbiw	r24, 0x27	; 39
    28ac:	1f 91       	pop	r17
    28ae:	0f 91       	pop	r16
    28b0:	08 95       	ret

000028b2 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    28b2:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    28b4:	e0 e7       	ldi	r30, 0x70	; 112
    28b6:	f0 e0       	ldi	r31, 0x00	; 0
    28b8:	83 81       	ldd	r24, Z+3	; 0x03
    28ba:	8a 7f       	andi	r24, 0xFA	; 250
    28bc:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    28be:	e0 e0       	ldi	r30, 0x00	; 0
    28c0:	f8 e0       	ldi	r31, 0x08	; 8
    28c2:	80 ea       	ldi	r24, 0xA0	; 160
    28c4:	9f e0       	ldi	r25, 0x0F	; 15
    28c6:	86 a3       	std	Z+38, r24	; 0x26
    28c8:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    28ca:	91 e0       	ldi	r25, 0x01	; 1
    28cc:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    28ce:	a0 ea       	ldi	r26, 0xA0	; 160
    28d0:	b0 e0       	ldi	r27, 0x00	; 0
    28d2:	12 96       	adiw	r26, 0x02	; 2
    28d4:	8c 91       	ld	r24, X
    28d6:	12 97       	sbiw	r26, 0x02	; 2
    28d8:	81 60       	ori	r24, 0x01	; 1
    28da:	12 96       	adiw	r26, 0x02	; 2
    28dc:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    28de:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    28e0:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    28e2:	a0 91 ea 22 	lds	r26, 0x22EA
    28e6:	b0 91 eb 22 	lds	r27, 0x22EB
    28ea:	0d 90       	ld	r0, X+
    28ec:	0d be       	out	0x3d, r0	; 61
    28ee:	0d 90       	ld	r0, X+
    28f0:	0e be       	out	0x3e, r0	; 62
    28f2:	ff 91       	pop	r31
    28f4:	ef 91       	pop	r30
    28f6:	df 91       	pop	r29
    28f8:	cf 91       	pop	r28
    28fa:	bf 91       	pop	r27
    28fc:	af 91       	pop	r26
    28fe:	9f 91       	pop	r25
    2900:	8f 91       	pop	r24
    2902:	7f 91       	pop	r23
    2904:	6f 91       	pop	r22
    2906:	5f 91       	pop	r21
    2908:	4f 91       	pop	r20
    290a:	3f 91       	pop	r19
    290c:	2f 91       	pop	r18
    290e:	1f 91       	pop	r17
    2910:	0f 91       	pop	r16
    2912:	ff 90       	pop	r15
    2914:	ef 90       	pop	r14
    2916:	df 90       	pop	r13
    2918:	cf 90       	pop	r12
    291a:	bf 90       	pop	r11
    291c:	af 90       	pop	r10
    291e:	9f 90       	pop	r9
    2920:	8f 90       	pop	r8
    2922:	7f 90       	pop	r7
    2924:	6f 90       	pop	r6
    2926:	5f 90       	pop	r5
    2928:	4f 90       	pop	r4
    292a:	3f 90       	pop	r3
    292c:	2f 90       	pop	r2
    292e:	1f 90       	pop	r1
    2930:	0f 90       	pop	r0
    2932:	0f be       	out	0x3f, r0	; 63
    2934:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    2936:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    2938:	81 e0       	ldi	r24, 0x01	; 1
    293a:	08 95       	ret

0000293c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    293c:	0f 92       	push	r0
    293e:	0f b6       	in	r0, 0x3f	; 63
    2940:	f8 94       	cli
    2942:	0f 92       	push	r0
    2944:	1f 92       	push	r1
    2946:	11 24       	eor	r1, r1
    2948:	2f 92       	push	r2
    294a:	3f 92       	push	r3
    294c:	4f 92       	push	r4
    294e:	5f 92       	push	r5
    2950:	6f 92       	push	r6
    2952:	7f 92       	push	r7
    2954:	8f 92       	push	r8
    2956:	9f 92       	push	r9
    2958:	af 92       	push	r10
    295a:	bf 92       	push	r11
    295c:	cf 92       	push	r12
    295e:	df 92       	push	r13
    2960:	ef 92       	push	r14
    2962:	ff 92       	push	r15
    2964:	0f 93       	push	r16
    2966:	1f 93       	push	r17
    2968:	2f 93       	push	r18
    296a:	3f 93       	push	r19
    296c:	4f 93       	push	r20
    296e:	5f 93       	push	r21
    2970:	6f 93       	push	r22
    2972:	7f 93       	push	r23
    2974:	8f 93       	push	r24
    2976:	9f 93       	push	r25
    2978:	af 93       	push	r26
    297a:	bf 93       	push	r27
    297c:	cf 93       	push	r28
    297e:	df 93       	push	r29
    2980:	ef 93       	push	r30
    2982:	ff 93       	push	r31
    2984:	a0 91 ea 22 	lds	r26, 0x22EA
    2988:	b0 91 eb 22 	lds	r27, 0x22EB
    298c:	0d b6       	in	r0, 0x3d	; 61
    298e:	0d 92       	st	X+, r0
    2990:	0e b6       	in	r0, 0x3e	; 62
    2992:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    2994:	76 d3       	rcall	.+1772   	; 0x3082 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    2996:	a0 91 ea 22 	lds	r26, 0x22EA
    299a:	b0 91 eb 22 	lds	r27, 0x22EB
    299e:	0d 90       	ld	r0, X+
    29a0:	0d be       	out	0x3d, r0	; 61
    29a2:	0d 90       	ld	r0, X+
    29a4:	0e be       	out	0x3e, r0	; 62
    29a6:	ff 91       	pop	r31
    29a8:	ef 91       	pop	r30
    29aa:	df 91       	pop	r29
    29ac:	cf 91       	pop	r28
    29ae:	bf 91       	pop	r27
    29b0:	af 91       	pop	r26
    29b2:	9f 91       	pop	r25
    29b4:	8f 91       	pop	r24
    29b6:	7f 91       	pop	r23
    29b8:	6f 91       	pop	r22
    29ba:	5f 91       	pop	r21
    29bc:	4f 91       	pop	r20
    29be:	3f 91       	pop	r19
    29c0:	2f 91       	pop	r18
    29c2:	1f 91       	pop	r17
    29c4:	0f 91       	pop	r16
    29c6:	ff 90       	pop	r15
    29c8:	ef 90       	pop	r14
    29ca:	df 90       	pop	r13
    29cc:	cf 90       	pop	r12
    29ce:	bf 90       	pop	r11
    29d0:	af 90       	pop	r10
    29d2:	9f 90       	pop	r9
    29d4:	8f 90       	pop	r8
    29d6:	7f 90       	pop	r7
    29d8:	6f 90       	pop	r6
    29da:	5f 90       	pop	r5
    29dc:	4f 90       	pop	r4
    29de:	3f 90       	pop	r3
    29e0:	2f 90       	pop	r2
    29e2:	1f 90       	pop	r1
    29e4:	0f 90       	pop	r0
    29e6:	0f be       	out	0x3f, r0	; 63
    29e8:	0f 90       	pop	r0

    asm volatile ( "ret" );
    29ea:	08 95       	ret

000029ec <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    29ec:	0f 92       	push	r0
    29ee:	0f b6       	in	r0, 0x3f	; 63
    29f0:	f8 94       	cli
    29f2:	0f 92       	push	r0
    29f4:	1f 92       	push	r1
    29f6:	11 24       	eor	r1, r1
    29f8:	2f 92       	push	r2
    29fa:	3f 92       	push	r3
    29fc:	4f 92       	push	r4
    29fe:	5f 92       	push	r5
    2a00:	6f 92       	push	r6
    2a02:	7f 92       	push	r7
    2a04:	8f 92       	push	r8
    2a06:	9f 92       	push	r9
    2a08:	af 92       	push	r10
    2a0a:	bf 92       	push	r11
    2a0c:	cf 92       	push	r12
    2a0e:	df 92       	push	r13
    2a10:	ef 92       	push	r14
    2a12:	ff 92       	push	r15
    2a14:	0f 93       	push	r16
    2a16:	1f 93       	push	r17
    2a18:	2f 93       	push	r18
    2a1a:	3f 93       	push	r19
    2a1c:	4f 93       	push	r20
    2a1e:	5f 93       	push	r21
    2a20:	6f 93       	push	r22
    2a22:	7f 93       	push	r23
    2a24:	8f 93       	push	r24
    2a26:	9f 93       	push	r25
    2a28:	af 93       	push	r26
    2a2a:	bf 93       	push	r27
    2a2c:	cf 93       	push	r28
    2a2e:	df 93       	push	r29
    2a30:	ef 93       	push	r30
    2a32:	ff 93       	push	r31
    2a34:	a0 91 ea 22 	lds	r26, 0x22EA
    2a38:	b0 91 eb 22 	lds	r27, 0x22EB
    2a3c:	0d b6       	in	r0, 0x3d	; 61
    2a3e:	0d 92       	st	X+, r0
    2a40:	0e b6       	in	r0, 0x3e	; 62
    2a42:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    2a44:	b3 d1       	rcall	.+870    	; 0x2dac <xTaskIncrementTick>
    2a46:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    2a48:	1c d3       	rcall	.+1592   	; 0x3082 <vTaskSwitchContext>
        }
        portRESTORE_CONTEXT();
    2a4a:	a0 91 ea 22 	lds	r26, 0x22EA
    2a4e:	b0 91 eb 22 	lds	r27, 0x22EB
    2a52:	0d 90       	ld	r0, X+
    2a54:	0d be       	out	0x3d, r0	; 61
    2a56:	0d 90       	ld	r0, X+
    2a58:	0e be       	out	0x3e, r0	; 62
    2a5a:	ff 91       	pop	r31
    2a5c:	ef 91       	pop	r30
    2a5e:	df 91       	pop	r29
    2a60:	cf 91       	pop	r28
    2a62:	bf 91       	pop	r27
    2a64:	af 91       	pop	r26
    2a66:	9f 91       	pop	r25
    2a68:	8f 91       	pop	r24
    2a6a:	7f 91       	pop	r23
    2a6c:	6f 91       	pop	r22
    2a6e:	5f 91       	pop	r21
    2a70:	4f 91       	pop	r20
    2a72:	3f 91       	pop	r19
    2a74:	2f 91       	pop	r18
    2a76:	1f 91       	pop	r17
    2a78:	0f 91       	pop	r16
    2a7a:	ff 90       	pop	r15
    2a7c:	ef 90       	pop	r14
    2a7e:	df 90       	pop	r13
    2a80:	cf 90       	pop	r12
    2a82:	bf 90       	pop	r11
    2a84:	af 90       	pop	r10
    2a86:	9f 90       	pop	r9
    2a88:	8f 90       	pop	r8
    2a8a:	7f 90       	pop	r7
    2a8c:	6f 90       	pop	r6
    2a8e:	5f 90       	pop	r5
    2a90:	4f 90       	pop	r4
    2a92:	3f 90       	pop	r3
    2a94:	2f 90       	pop	r2
    2a96:	1f 90       	pop	r1
    2a98:	0f 90       	pop	r0
    2a9a:	0f be       	out	0x3f, r0	; 63
    2a9c:	0f 90       	pop	r0

        asm volatile ( "reti" );
    2a9e:	18 95       	reti

00002aa0 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2aa0:	cf 93       	push	r28
    2aa2:	df 93       	push	r29
    2aa4:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    2aa6:	7c d1       	rcall	.+760    	; 0x2da0 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    2aa8:	ce 01       	movw	r24, r28
    2aaa:	0e 94 25 20 	call	0x404a	; 0x404a <malloc>
    2aae:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2ab0:	50 d2       	rcall	.+1184   	; 0x2f52 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2ab2:	ce 01       	movw	r24, r28
    2ab4:	df 91       	pop	r29
    2ab6:	cf 91       	pop	r28
    2ab8:	08 95       	ret

00002aba <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2aba:	cf 93       	push	r28
    2abc:	df 93       	push	r29
	if( pv )
    2abe:	00 97       	sbiw	r24, 0x00	; 0
    2ac0:	31 f0       	breq	.+12     	; 0x2ace <vPortFree+0x14>
    2ac2:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    2ac4:	6d d1       	rcall	.+730    	; 0x2da0 <vTaskSuspendAll>
		{
			free( pv );
    2ac6:	ce 01       	movw	r24, r28
    2ac8:	0e 94 ba 20 	call	0x4174	; 0x4174 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    2acc:	42 d2       	rcall	.+1156   	; 0x2f52 <xTaskResumeAll>
	}
}
    2ace:	df 91       	pop	r29
    2ad0:	cf 91       	pop	r28
    2ad2:	08 95       	ret

00002ad4 <prvIdleTask>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2ad4:	cd eb       	ldi	r28, 0xBD	; 189
    2ad6:	d2 e2       	ldi	r29, 0x22	; 34
    2ad8:	88 81       	ld	r24, Y
    2ada:	82 30       	cpi	r24, 0x02	; 2
    2adc:	f0 f3       	brcs	.-4      	; 0x2ada <prvIdleTask+0x6>
    2ade:	2e df       	rcall	.-420    	; 0x293c <vPortYield>
    2ae0:	fb cf       	rjmp	.-10     	; 0x2ad8 <prvIdleTask+0x4>

00002ae2 <prvAddCurrentTaskToDelayedList>:
    2ae2:	cf 93       	push	r28
    2ae4:	df 93       	push	r29
    2ae6:	ec 01       	movw	r28, r24
    2ae8:	e0 91 ea 22 	lds	r30, 0x22EA
    2aec:	f0 91 eb 22 	lds	r31, 0x22EB
    2af0:	82 83       	std	Z+2, r24	; 0x02
    2af2:	93 83       	std	Z+3, r25	; 0x03
    2af4:	80 91 9b 22 	lds	r24, 0x229B
    2af8:	90 91 9c 22 	lds	r25, 0x229C
    2afc:	c8 17       	cp	r28, r24
    2afe:	d9 07       	cpc	r29, r25
    2b00:	60 f4       	brcc	.+24     	; 0x2b1a <prvAddCurrentTaskToDelayedList+0x38>
    2b02:	60 91 ea 22 	lds	r22, 0x22EA
    2b06:	70 91 eb 22 	lds	r23, 0x22EB
    2b0a:	80 91 a7 22 	lds	r24, 0x22A7
    2b0e:	90 91 a8 22 	lds	r25, 0x22A8
    2b12:	6e 5f       	subi	r22, 0xFE	; 254
    2b14:	7f 4f       	sbci	r23, 0xFF	; 255
    2b16:	ff dd       	rcall	.-1026   	; 0x2716 <vListInsert>
    2b18:	16 c0       	rjmp	.+44     	; 0x2b46 <prvAddCurrentTaskToDelayedList+0x64>
    2b1a:	60 91 ea 22 	lds	r22, 0x22EA
    2b1e:	70 91 eb 22 	lds	r23, 0x22EB
    2b22:	80 91 a9 22 	lds	r24, 0x22A9
    2b26:	90 91 aa 22 	lds	r25, 0x22AA
    2b2a:	6e 5f       	subi	r22, 0xFE	; 254
    2b2c:	7f 4f       	sbci	r23, 0xFF	; 255
    2b2e:	f3 dd       	rcall	.-1050   	; 0x2716 <vListInsert>
    2b30:	80 91 0e 20 	lds	r24, 0x200E
    2b34:	90 91 0f 20 	lds	r25, 0x200F
    2b38:	c8 17       	cp	r28, r24
    2b3a:	d9 07       	cpc	r29, r25
    2b3c:	20 f4       	brcc	.+8      	; 0x2b46 <prvAddCurrentTaskToDelayedList+0x64>
    2b3e:	c0 93 0e 20 	sts	0x200E, r28
    2b42:	d0 93 0f 20 	sts	0x200F, r29
    2b46:	df 91       	pop	r29
    2b48:	cf 91       	pop	r28
    2b4a:	08 95       	ret

00002b4c <xTaskGenericCreate>:
    2b4c:	4f 92       	push	r4
    2b4e:	5f 92       	push	r5
    2b50:	6f 92       	push	r6
    2b52:	7f 92       	push	r7
    2b54:	8f 92       	push	r8
    2b56:	9f 92       	push	r9
    2b58:	af 92       	push	r10
    2b5a:	bf 92       	push	r11
    2b5c:	cf 92       	push	r12
    2b5e:	df 92       	push	r13
    2b60:	ef 92       	push	r14
    2b62:	ff 92       	push	r15
    2b64:	0f 93       	push	r16
    2b66:	1f 93       	push	r17
    2b68:	cf 93       	push	r28
    2b6a:	df 93       	push	r29
    2b6c:	4c 01       	movw	r8, r24
    2b6e:	eb 01       	movw	r28, r22
    2b70:	5a 01       	movw	r10, r20
    2b72:	29 01       	movw	r4, r18
    2b74:	81 e2       	ldi	r24, 0x21	; 33
    2b76:	90 e0       	ldi	r25, 0x00	; 0
    2b78:	93 df       	rcall	.-218    	; 0x2aa0 <pvPortMalloc>
    2b7a:	3c 01       	movw	r6, r24
    2b7c:	00 97       	sbiw	r24, 0x00	; 0
    2b7e:	09 f4       	brne	.+2      	; 0x2b82 <xTaskGenericCreate+0x36>
    2b80:	d4 c0       	rjmp	.+424    	; 0x2d2a <xTaskGenericCreate+0x1de>
    2b82:	c1 14       	cp	r12, r1
    2b84:	d1 04       	cpc	r13, r1
    2b86:	09 f0       	breq	.+2      	; 0x2b8a <xTaskGenericCreate+0x3e>
    2b88:	cc c0       	rjmp	.+408    	; 0x2d22 <xTaskGenericCreate+0x1d6>
    2b8a:	c5 01       	movw	r24, r10
    2b8c:	89 df       	rcall	.-238    	; 0x2aa0 <pvPortMalloc>
    2b8e:	f3 01       	movw	r30, r6
    2b90:	87 8b       	std	Z+23, r24	; 0x17
    2b92:	90 8f       	std	Z+24, r25	; 0x18
    2b94:	89 2b       	or	r24, r25
    2b96:	19 f4       	brne	.+6      	; 0x2b9e <xTaskGenericCreate+0x52>
    2b98:	c3 01       	movw	r24, r6
    2b9a:	8f df       	rcall	.-226    	; 0x2aba <vPortFree>
    2b9c:	c6 c0       	rjmp	.+396    	; 0x2d2a <xTaskGenericCreate+0x1de>
    2b9e:	f1 e0       	ldi	r31, 0x01	; 1
    2ba0:	af 1a       	sub	r10, r31
    2ba2:	b1 08       	sbc	r11, r1
    2ba4:	f3 01       	movw	r30, r6
    2ba6:	87 89       	ldd	r24, Z+23	; 0x17
    2ba8:	90 8d       	ldd	r25, Z+24	; 0x18
    2baa:	a8 0e       	add	r10, r24
    2bac:	b9 1e       	adc	r11, r25
    2bae:	88 81       	ld	r24, Y
    2bb0:	81 8f       	std	Z+25, r24	; 0x19
    2bb2:	88 81       	ld	r24, Y
    2bb4:	88 23       	and	r24, r24
    2bb6:	81 f0       	breq	.+32     	; 0x2bd8 <xTaskGenericCreate+0x8c>
    2bb8:	d3 01       	movw	r26, r6
    2bba:	5a 96       	adiw	r26, 0x1a	; 26
    2bbc:	fe 01       	movw	r30, r28
    2bbe:	31 96       	adiw	r30, 0x01	; 1
    2bc0:	9e 01       	movw	r18, r28
    2bc2:	28 5f       	subi	r18, 0xF8	; 248
    2bc4:	3f 4f       	sbci	r19, 0xFF	; 255
    2bc6:	ef 01       	movw	r28, r30
    2bc8:	81 91       	ld	r24, Z+
    2bca:	8d 93       	st	X+, r24
    2bcc:	88 81       	ld	r24, Y
    2bce:	88 23       	and	r24, r24
    2bd0:	19 f0       	breq	.+6      	; 0x2bd8 <xTaskGenericCreate+0x8c>
    2bd2:	e2 17       	cp	r30, r18
    2bd4:	f3 07       	cpc	r31, r19
    2bd6:	b9 f7       	brne	.-18     	; 0x2bc6 <xTaskGenericCreate+0x7a>
    2bd8:	f3 01       	movw	r30, r6
    2bda:	10 a2       	std	Z+32, r1	; 0x20
    2bdc:	10 2f       	mov	r17, r16
    2bde:	05 30       	cpi	r16, 0x05	; 5
    2be0:	08 f0       	brcs	.+2      	; 0x2be4 <xTaskGenericCreate+0x98>
    2be2:	14 e0       	ldi	r17, 0x04	; 4
    2be4:	f3 01       	movw	r30, r6
    2be6:	16 8b       	std	Z+22, r17	; 0x16
    2be8:	e3 01       	movw	r28, r6
    2bea:	22 96       	adiw	r28, 0x02	; 2
    2bec:	ce 01       	movw	r24, r28
    2bee:	6e dd       	rcall	.-1316   	; 0x26cc <vListInitialiseItem>
    2bf0:	c3 01       	movw	r24, r6
    2bf2:	0c 96       	adiw	r24, 0x0c	; 12
    2bf4:	6b dd       	rcall	.-1322   	; 0x26cc <vListInitialiseItem>
    2bf6:	f3 01       	movw	r30, r6
    2bf8:	60 86       	std	Z+8, r6	; 0x08
    2bfa:	71 86       	std	Z+9, r7	; 0x09
    2bfc:	85 e0       	ldi	r24, 0x05	; 5
    2bfe:	90 e0       	ldi	r25, 0x00	; 0
    2c00:	81 1b       	sub	r24, r17
    2c02:	91 09       	sbc	r25, r1
    2c04:	84 87       	std	Z+12, r24	; 0x0c
    2c06:	95 87       	std	Z+13, r25	; 0x0d
    2c08:	62 8a       	std	Z+18, r6	; 0x12
    2c0a:	73 8a       	std	Z+19, r7	; 0x13
    2c0c:	a2 01       	movw	r20, r4
    2c0e:	b4 01       	movw	r22, r8
    2c10:	c5 01       	movw	r24, r10
    2c12:	d8 dd       	rcall	.-1104   	; 0x27c4 <pxPortInitialiseStack>
    2c14:	f3 01       	movw	r30, r6
    2c16:	80 83       	st	Z, r24
    2c18:	91 83       	std	Z+1, r25	; 0x01
    2c1a:	e1 14       	cp	r14, r1
    2c1c:	f1 04       	cpc	r15, r1
    2c1e:	19 f0       	breq	.+6      	; 0x2c26 <xTaskGenericCreate+0xda>
    2c20:	f7 01       	movw	r30, r14
    2c22:	60 82       	st	Z, r6
    2c24:	71 82       	std	Z+1, r7	; 0x01
    2c26:	0f b6       	in	r0, 0x3f	; 63
    2c28:	f8 94       	cli
    2c2a:	0f 92       	push	r0
    2c2c:	80 91 9d 22 	lds	r24, 0x229D
    2c30:	8f 5f       	subi	r24, 0xFF	; 255
    2c32:	80 93 9d 22 	sts	0x229D, r24
    2c36:	80 91 ea 22 	lds	r24, 0x22EA
    2c3a:	90 91 eb 22 	lds	r25, 0x22EB
    2c3e:	89 2b       	or	r24, r25
    2c40:	91 f5       	brne	.+100    	; 0x2ca6 <xTaskGenericCreate+0x15a>
    2c42:	60 92 ea 22 	sts	0x22EA, r6
    2c46:	70 92 eb 22 	sts	0x22EB, r7
    2c4a:	80 91 9d 22 	lds	r24, 0x229D
    2c4e:	81 30       	cpi	r24, 0x01	; 1
    2c50:	c9 f5       	brne	.+114    	; 0x2cc4 <xTaskGenericCreate+0x178>
    2c52:	0f 2e       	mov	r0, r31
    2c54:	fd eb       	ldi	r31, 0xBD	; 189
    2c56:	ef 2e       	mov	r14, r31
    2c58:	f2 e2       	ldi	r31, 0x22	; 34
    2c5a:	ff 2e       	mov	r15, r31
    2c5c:	f0 2d       	mov	r31, r0
    2c5e:	0f 2e       	mov	r0, r31
    2c60:	fa ee       	ldi	r31, 0xEA	; 234
    2c62:	cf 2e       	mov	r12, r31
    2c64:	f2 e2       	ldi	r31, 0x22	; 34
    2c66:	df 2e       	mov	r13, r31
    2c68:	f0 2d       	mov	r31, r0
    2c6a:	c7 01       	movw	r24, r14
    2c6c:	21 dd       	rcall	.-1470   	; 0x26b0 <vListInitialise>
    2c6e:	f9 e0       	ldi	r31, 0x09	; 9
    2c70:	ef 0e       	add	r14, r31
    2c72:	f1 1c       	adc	r15, r1
    2c74:	ec 14       	cp	r14, r12
    2c76:	fd 04       	cpc	r15, r13
    2c78:	c1 f7       	brne	.-16     	; 0x2c6a <xTaskGenericCreate+0x11e>
    2c7a:	84 eb       	ldi	r24, 0xB4	; 180
    2c7c:	92 e2       	ldi	r25, 0x22	; 34
    2c7e:	18 dd       	rcall	.-1488   	; 0x26b0 <vListInitialise>
    2c80:	8b ea       	ldi	r24, 0xAB	; 171
    2c82:	92 e2       	ldi	r25, 0x22	; 34
    2c84:	15 dd       	rcall	.-1494   	; 0x26b0 <vListInitialise>
    2c86:	8e e9       	ldi	r24, 0x9E	; 158
    2c88:	92 e2       	ldi	r25, 0x22	; 34
    2c8a:	12 dd       	rcall	.-1500   	; 0x26b0 <vListInitialise>
    2c8c:	84 eb       	ldi	r24, 0xB4	; 180
    2c8e:	92 e2       	ldi	r25, 0x22	; 34
    2c90:	80 93 a9 22 	sts	0x22A9, r24
    2c94:	90 93 aa 22 	sts	0x22AA, r25
    2c98:	8b ea       	ldi	r24, 0xAB	; 171
    2c9a:	92 e2       	ldi	r25, 0x22	; 34
    2c9c:	80 93 a7 22 	sts	0x22A7, r24
    2ca0:	90 93 a8 22 	sts	0x22A8, r25
    2ca4:	0f c0       	rjmp	.+30     	; 0x2cc4 <xTaskGenericCreate+0x178>
    2ca6:	80 91 99 22 	lds	r24, 0x2299
    2caa:	81 11       	cpse	r24, r1
    2cac:	0b c0       	rjmp	.+22     	; 0x2cc4 <xTaskGenericCreate+0x178>
    2cae:	e0 91 ea 22 	lds	r30, 0x22EA
    2cb2:	f0 91 eb 22 	lds	r31, 0x22EB
    2cb6:	86 89       	ldd	r24, Z+22	; 0x16
    2cb8:	08 17       	cp	r16, r24
    2cba:	20 f0       	brcs	.+8      	; 0x2cc4 <xTaskGenericCreate+0x178>
    2cbc:	60 92 ea 22 	sts	0x22EA, r6
    2cc0:	70 92 eb 22 	sts	0x22EB, r7
    2cc4:	80 91 95 22 	lds	r24, 0x2295
    2cc8:	8f 5f       	subi	r24, 0xFF	; 255
    2cca:	80 93 95 22 	sts	0x2295, r24
    2cce:	f3 01       	movw	r30, r6
    2cd0:	86 89       	ldd	r24, Z+22	; 0x16
    2cd2:	90 91 9a 22 	lds	r25, 0x229A
    2cd6:	98 17       	cp	r25, r24
    2cd8:	10 f4       	brcc	.+4      	; 0x2cde <xTaskGenericCreate+0x192>
    2cda:	80 93 9a 22 	sts	0x229A, r24
    2cde:	90 e0       	ldi	r25, 0x00	; 0
    2ce0:	9c 01       	movw	r18, r24
    2ce2:	22 0f       	add	r18, r18
    2ce4:	33 1f       	adc	r19, r19
    2ce6:	22 0f       	add	r18, r18
    2ce8:	33 1f       	adc	r19, r19
    2cea:	22 0f       	add	r18, r18
    2cec:	33 1f       	adc	r19, r19
    2cee:	82 0f       	add	r24, r18
    2cf0:	93 1f       	adc	r25, r19
    2cf2:	be 01       	movw	r22, r28
    2cf4:	83 54       	subi	r24, 0x43	; 67
    2cf6:	9d 4d       	sbci	r25, 0xDD	; 221
    2cf8:	ed dc       	rcall	.-1574   	; 0x26d4 <vListInsertEnd>
    2cfa:	0f 90       	pop	r0
    2cfc:	0f be       	out	0x3f, r0	; 63
    2cfe:	80 91 99 22 	lds	r24, 0x2299
    2d02:	88 23       	and	r24, r24
    2d04:	51 f0       	breq	.+20     	; 0x2d1a <xTaskGenericCreate+0x1ce>
    2d06:	e0 91 ea 22 	lds	r30, 0x22EA
    2d0a:	f0 91 eb 22 	lds	r31, 0x22EB
    2d0e:	86 89       	ldd	r24, Z+22	; 0x16
    2d10:	80 17       	cp	r24, r16
    2d12:	28 f4       	brcc	.+10     	; 0x2d1e <xTaskGenericCreate+0x1d2>
    2d14:	13 de       	rcall	.-986    	; 0x293c <vPortYield>
    2d16:	81 e0       	ldi	r24, 0x01	; 1
    2d18:	09 c0       	rjmp	.+18     	; 0x2d2c <xTaskGenericCreate+0x1e0>
    2d1a:	81 e0       	ldi	r24, 0x01	; 1
    2d1c:	07 c0       	rjmp	.+14     	; 0x2d2c <xTaskGenericCreate+0x1e0>
    2d1e:	81 e0       	ldi	r24, 0x01	; 1
    2d20:	05 c0       	rjmp	.+10     	; 0x2d2c <xTaskGenericCreate+0x1e0>
    2d22:	fc 01       	movw	r30, r24
    2d24:	c7 8a       	std	Z+23, r12	; 0x17
    2d26:	d0 8e       	std	Z+24, r13	; 0x18
    2d28:	3a cf       	rjmp	.-396    	; 0x2b9e <xTaskGenericCreate+0x52>
    2d2a:	8f ef       	ldi	r24, 0xFF	; 255
    2d2c:	df 91       	pop	r29
    2d2e:	cf 91       	pop	r28
    2d30:	1f 91       	pop	r17
    2d32:	0f 91       	pop	r16
    2d34:	ff 90       	pop	r15
    2d36:	ef 90       	pop	r14
    2d38:	df 90       	pop	r13
    2d3a:	cf 90       	pop	r12
    2d3c:	bf 90       	pop	r11
    2d3e:	af 90       	pop	r10
    2d40:	9f 90       	pop	r9
    2d42:	8f 90       	pop	r8
    2d44:	7f 90       	pop	r7
    2d46:	6f 90       	pop	r6
    2d48:	5f 90       	pop	r5
    2d4a:	4f 90       	pop	r4
    2d4c:	08 95       	ret

00002d4e <vTaskStartScheduler>:
    2d4e:	af 92       	push	r10
    2d50:	bf 92       	push	r11
    2d52:	cf 92       	push	r12
    2d54:	df 92       	push	r13
    2d56:	ef 92       	push	r14
    2d58:	ff 92       	push	r15
    2d5a:	0f 93       	push	r16
    2d5c:	a1 2c       	mov	r10, r1
    2d5e:	b1 2c       	mov	r11, r1
    2d60:	c1 2c       	mov	r12, r1
    2d62:	d1 2c       	mov	r13, r1
    2d64:	e1 2c       	mov	r14, r1
    2d66:	f1 2c       	mov	r15, r1
    2d68:	00 e0       	ldi	r16, 0x00	; 0
    2d6a:	20 e0       	ldi	r18, 0x00	; 0
    2d6c:	30 e0       	ldi	r19, 0x00	; 0
    2d6e:	45 e5       	ldi	r20, 0x55	; 85
    2d70:	50 e0       	ldi	r21, 0x00	; 0
    2d72:	64 e1       	ldi	r22, 0x14	; 20
    2d74:	70 e2       	ldi	r23, 0x20	; 32
    2d76:	8a e6       	ldi	r24, 0x6A	; 106
    2d78:	95 e1       	ldi	r25, 0x15	; 21
    2d7a:	e8 de       	rcall	.-560    	; 0x2b4c <xTaskGenericCreate>
    2d7c:	81 30       	cpi	r24, 0x01	; 1
    2d7e:	41 f4       	brne	.+16     	; 0x2d90 <vTaskStartScheduler+0x42>
    2d80:	f8 94       	cli
    2d82:	80 93 99 22 	sts	0x2299, r24
    2d86:	10 92 9b 22 	sts	0x229B, r1
    2d8a:	10 92 9c 22 	sts	0x229C, r1
    2d8e:	91 dd       	rcall	.-1246   	; 0x28b2 <xPortStartScheduler>
    2d90:	0f 91       	pop	r16
    2d92:	ff 90       	pop	r15
    2d94:	ef 90       	pop	r14
    2d96:	df 90       	pop	r13
    2d98:	cf 90       	pop	r12
    2d9a:	bf 90       	pop	r11
    2d9c:	af 90       	pop	r10
    2d9e:	08 95       	ret

00002da0 <vTaskSuspendAll>:
    2da0:	80 91 94 22 	lds	r24, 0x2294
    2da4:	8f 5f       	subi	r24, 0xFF	; 255
    2da6:	80 93 94 22 	sts	0x2294, r24
    2daa:	08 95       	ret

00002dac <xTaskIncrementTick>:
    2dac:	df 92       	push	r13
    2dae:	ef 92       	push	r14
    2db0:	ff 92       	push	r15
    2db2:	0f 93       	push	r16
    2db4:	1f 93       	push	r17
    2db6:	cf 93       	push	r28
    2db8:	df 93       	push	r29
    2dba:	80 91 94 22 	lds	r24, 0x2294
    2dbe:	81 11       	cpse	r24, r1
    2dc0:	b3 c0       	rjmp	.+358    	; 0x2f28 <xTaskIncrementTick+0x17c>
    2dc2:	80 91 9b 22 	lds	r24, 0x229B
    2dc6:	90 91 9c 22 	lds	r25, 0x229C
    2dca:	01 96       	adiw	r24, 0x01	; 1
    2dcc:	80 93 9b 22 	sts	0x229B, r24
    2dd0:	90 93 9c 22 	sts	0x229C, r25
    2dd4:	e0 90 9b 22 	lds	r14, 0x229B
    2dd8:	f0 90 9c 22 	lds	r15, 0x229C
    2ddc:	e1 14       	cp	r14, r1
    2dde:	f1 04       	cpc	r15, r1
    2de0:	99 f5       	brne	.+102    	; 0x2e48 <xTaskIncrementTick+0x9c>
    2de2:	80 91 a9 22 	lds	r24, 0x22A9
    2de6:	90 91 aa 22 	lds	r25, 0x22AA
    2dea:	20 91 a7 22 	lds	r18, 0x22A7
    2dee:	30 91 a8 22 	lds	r19, 0x22A8
    2df2:	20 93 a9 22 	sts	0x22A9, r18
    2df6:	30 93 aa 22 	sts	0x22AA, r19
    2dfa:	80 93 a7 22 	sts	0x22A7, r24
    2dfe:	90 93 a8 22 	sts	0x22A8, r25
    2e02:	80 91 96 22 	lds	r24, 0x2296
    2e06:	8f 5f       	subi	r24, 0xFF	; 255
    2e08:	80 93 96 22 	sts	0x2296, r24
    2e0c:	e0 91 a9 22 	lds	r30, 0x22A9
    2e10:	f0 91 aa 22 	lds	r31, 0x22AA
    2e14:	80 81       	ld	r24, Z
    2e16:	81 11       	cpse	r24, r1
    2e18:	07 c0       	rjmp	.+14     	; 0x2e28 <xTaskIncrementTick+0x7c>
    2e1a:	8f ef       	ldi	r24, 0xFF	; 255
    2e1c:	9f ef       	ldi	r25, 0xFF	; 255
    2e1e:	80 93 0e 20 	sts	0x200E, r24
    2e22:	90 93 0f 20 	sts	0x200F, r25
    2e26:	10 c0       	rjmp	.+32     	; 0x2e48 <xTaskIncrementTick+0x9c>
    2e28:	e0 91 a9 22 	lds	r30, 0x22A9
    2e2c:	f0 91 aa 22 	lds	r31, 0x22AA
    2e30:	05 80       	ldd	r0, Z+5	; 0x05
    2e32:	f6 81       	ldd	r31, Z+6	; 0x06
    2e34:	e0 2d       	mov	r30, r0
    2e36:	06 80       	ldd	r0, Z+6	; 0x06
    2e38:	f7 81       	ldd	r31, Z+7	; 0x07
    2e3a:	e0 2d       	mov	r30, r0
    2e3c:	82 81       	ldd	r24, Z+2	; 0x02
    2e3e:	93 81       	ldd	r25, Z+3	; 0x03
    2e40:	80 93 0e 20 	sts	0x200E, r24
    2e44:	90 93 0f 20 	sts	0x200F, r25
    2e48:	80 91 0e 20 	lds	r24, 0x200E
    2e4c:	90 91 0f 20 	lds	r25, 0x200F
    2e50:	e8 16       	cp	r14, r24
    2e52:	f9 06       	cpc	r15, r25
    2e54:	10 f4       	brcc	.+4      	; 0x2e5a <xTaskIncrementTick+0xae>
    2e56:	d1 2c       	mov	r13, r1
    2e58:	4f c0       	rjmp	.+158    	; 0x2ef8 <xTaskIncrementTick+0x14c>
    2e5a:	d1 2c       	mov	r13, r1
    2e5c:	e0 91 a9 22 	lds	r30, 0x22A9
    2e60:	f0 91 aa 22 	lds	r31, 0x22AA
    2e64:	90 81       	ld	r25, Z
    2e66:	91 11       	cpse	r25, r1
    2e68:	07 c0       	rjmp	.+14     	; 0x2e78 <xTaskIncrementTick+0xcc>
    2e6a:	8f ef       	ldi	r24, 0xFF	; 255
    2e6c:	9f ef       	ldi	r25, 0xFF	; 255
    2e6e:	80 93 0e 20 	sts	0x200E, r24
    2e72:	90 93 0f 20 	sts	0x200F, r25
    2e76:	40 c0       	rjmp	.+128    	; 0x2ef8 <xTaskIncrementTick+0x14c>
    2e78:	e0 91 a9 22 	lds	r30, 0x22A9
    2e7c:	f0 91 aa 22 	lds	r31, 0x22AA
    2e80:	05 80       	ldd	r0, Z+5	; 0x05
    2e82:	f6 81       	ldd	r31, Z+6	; 0x06
    2e84:	e0 2d       	mov	r30, r0
    2e86:	c6 81       	ldd	r28, Z+6	; 0x06
    2e88:	d7 81       	ldd	r29, Z+7	; 0x07
    2e8a:	2a 81       	ldd	r18, Y+2	; 0x02
    2e8c:	3b 81       	ldd	r19, Y+3	; 0x03
    2e8e:	e2 16       	cp	r14, r18
    2e90:	f3 06       	cpc	r15, r19
    2e92:	28 f4       	brcc	.+10     	; 0x2e9e <xTaskIncrementTick+0xf2>
    2e94:	20 93 0e 20 	sts	0x200E, r18
    2e98:	30 93 0f 20 	sts	0x200F, r19
    2e9c:	2d c0       	rjmp	.+90     	; 0x2ef8 <xTaskIncrementTick+0x14c>
    2e9e:	8e 01       	movw	r16, r28
    2ea0:	0e 5f       	subi	r16, 0xFE	; 254
    2ea2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ea4:	c8 01       	movw	r24, r16
    2ea6:	68 dc       	rcall	.-1840   	; 0x2778 <uxListRemove>
    2ea8:	8c 89       	ldd	r24, Y+20	; 0x14
    2eaa:	9d 89       	ldd	r25, Y+21	; 0x15
    2eac:	89 2b       	or	r24, r25
    2eae:	19 f0       	breq	.+6      	; 0x2eb6 <xTaskIncrementTick+0x10a>
    2eb0:	ce 01       	movw	r24, r28
    2eb2:	0c 96       	adiw	r24, 0x0c	; 12
    2eb4:	61 dc       	rcall	.-1854   	; 0x2778 <uxListRemove>
    2eb6:	2e 89       	ldd	r18, Y+22	; 0x16
    2eb8:	80 91 9a 22 	lds	r24, 0x229A
    2ebc:	82 17       	cp	r24, r18
    2ebe:	10 f4       	brcc	.+4      	; 0x2ec4 <xTaskIncrementTick+0x118>
    2ec0:	20 93 9a 22 	sts	0x229A, r18
    2ec4:	30 e0       	ldi	r19, 0x00	; 0
    2ec6:	c9 01       	movw	r24, r18
    2ec8:	88 0f       	add	r24, r24
    2eca:	99 1f       	adc	r25, r25
    2ecc:	88 0f       	add	r24, r24
    2ece:	99 1f       	adc	r25, r25
    2ed0:	88 0f       	add	r24, r24
    2ed2:	99 1f       	adc	r25, r25
    2ed4:	82 0f       	add	r24, r18
    2ed6:	93 1f       	adc	r25, r19
    2ed8:	b8 01       	movw	r22, r16
    2eda:	83 54       	subi	r24, 0x43	; 67
    2edc:	9d 4d       	sbci	r25, 0xDD	; 221
    2ede:	fa db       	rcall	.-2060   	; 0x26d4 <vListInsertEnd>
    2ee0:	e0 91 ea 22 	lds	r30, 0x22EA
    2ee4:	f0 91 eb 22 	lds	r31, 0x22EB
    2ee8:	9e 89       	ldd	r25, Y+22	; 0x16
    2eea:	86 89       	ldd	r24, Z+22	; 0x16
    2eec:	98 17       	cp	r25, r24
    2eee:	08 f4       	brcc	.+2      	; 0x2ef2 <xTaskIncrementTick+0x146>
    2ef0:	b5 cf       	rjmp	.-150    	; 0x2e5c <xTaskIncrementTick+0xb0>
    2ef2:	dd 24       	eor	r13, r13
    2ef4:	d3 94       	inc	r13
    2ef6:	b2 cf       	rjmp	.-156    	; 0x2e5c <xTaskIncrementTick+0xb0>
    2ef8:	e0 91 ea 22 	lds	r30, 0x22EA
    2efc:	f0 91 eb 22 	lds	r31, 0x22EB
    2f00:	86 89       	ldd	r24, Z+22	; 0x16
    2f02:	90 e0       	ldi	r25, 0x00	; 0
    2f04:	fc 01       	movw	r30, r24
    2f06:	ee 0f       	add	r30, r30
    2f08:	ff 1f       	adc	r31, r31
    2f0a:	ee 0f       	add	r30, r30
    2f0c:	ff 1f       	adc	r31, r31
    2f0e:	ee 0f       	add	r30, r30
    2f10:	ff 1f       	adc	r31, r31
    2f12:	8e 0f       	add	r24, r30
    2f14:	9f 1f       	adc	r25, r31
    2f16:	fc 01       	movw	r30, r24
    2f18:	e3 54       	subi	r30, 0x43	; 67
    2f1a:	fd 4d       	sbci	r31, 0xDD	; 221
    2f1c:	80 81       	ld	r24, Z
    2f1e:	82 30       	cpi	r24, 0x02	; 2
    2f20:	48 f0       	brcs	.+18     	; 0x2f34 <xTaskIncrementTick+0x188>
    2f22:	dd 24       	eor	r13, r13
    2f24:	d3 94       	inc	r13
    2f26:	06 c0       	rjmp	.+12     	; 0x2f34 <xTaskIncrementTick+0x188>
    2f28:	80 91 98 22 	lds	r24, 0x2298
    2f2c:	8f 5f       	subi	r24, 0xFF	; 255
    2f2e:	80 93 98 22 	sts	0x2298, r24
    2f32:	d1 2c       	mov	r13, r1
    2f34:	80 91 97 22 	lds	r24, 0x2297
    2f38:	88 23       	and	r24, r24
    2f3a:	11 f0       	breq	.+4      	; 0x2f40 <xTaskIncrementTick+0x194>
    2f3c:	dd 24       	eor	r13, r13
    2f3e:	d3 94       	inc	r13
    2f40:	8d 2d       	mov	r24, r13
    2f42:	df 91       	pop	r29
    2f44:	cf 91       	pop	r28
    2f46:	1f 91       	pop	r17
    2f48:	0f 91       	pop	r16
    2f4a:	ff 90       	pop	r15
    2f4c:	ef 90       	pop	r14
    2f4e:	df 90       	pop	r13
    2f50:	08 95       	ret

00002f52 <xTaskResumeAll>:
    2f52:	df 92       	push	r13
    2f54:	ef 92       	push	r14
    2f56:	ff 92       	push	r15
    2f58:	0f 93       	push	r16
    2f5a:	1f 93       	push	r17
    2f5c:	cf 93       	push	r28
    2f5e:	df 93       	push	r29
    2f60:	0f b6       	in	r0, 0x3f	; 63
    2f62:	f8 94       	cli
    2f64:	0f 92       	push	r0
    2f66:	80 91 94 22 	lds	r24, 0x2294
    2f6a:	81 50       	subi	r24, 0x01	; 1
    2f6c:	80 93 94 22 	sts	0x2294, r24
    2f70:	80 91 94 22 	lds	r24, 0x2294
    2f74:	81 11       	cpse	r24, r1
    2f76:	5d c0       	rjmp	.+186    	; 0x3032 <xTaskResumeAll+0xe0>
    2f78:	80 91 9d 22 	lds	r24, 0x229D
    2f7c:	81 11       	cpse	r24, r1
    2f7e:	30 c0       	rjmp	.+96     	; 0x2fe0 <xTaskResumeAll+0x8e>
    2f80:	5b c0       	rjmp	.+182    	; 0x3038 <xTaskResumeAll+0xe6>
    2f82:	d7 01       	movw	r26, r14
    2f84:	15 96       	adiw	r26, 0x05	; 5
    2f86:	ed 91       	ld	r30, X+
    2f88:	fc 91       	ld	r31, X
    2f8a:	16 97       	sbiw	r26, 0x06	; 6
    2f8c:	c6 81       	ldd	r28, Z+6	; 0x06
    2f8e:	d7 81       	ldd	r29, Z+7	; 0x07
    2f90:	ce 01       	movw	r24, r28
    2f92:	0c 96       	adiw	r24, 0x0c	; 12
    2f94:	f1 db       	rcall	.-2078   	; 0x2778 <uxListRemove>
    2f96:	8e 01       	movw	r16, r28
    2f98:	0e 5f       	subi	r16, 0xFE	; 254
    2f9a:	1f 4f       	sbci	r17, 0xFF	; 255
    2f9c:	c8 01       	movw	r24, r16
    2f9e:	ec db       	rcall	.-2088   	; 0x2778 <uxListRemove>
    2fa0:	2e 89       	ldd	r18, Y+22	; 0x16
    2fa2:	80 91 9a 22 	lds	r24, 0x229A
    2fa6:	82 17       	cp	r24, r18
    2fa8:	10 f4       	brcc	.+4      	; 0x2fae <xTaskResumeAll+0x5c>
    2faa:	20 93 9a 22 	sts	0x229A, r18
    2fae:	30 e0       	ldi	r19, 0x00	; 0
    2fb0:	c9 01       	movw	r24, r18
    2fb2:	88 0f       	add	r24, r24
    2fb4:	99 1f       	adc	r25, r25
    2fb6:	88 0f       	add	r24, r24
    2fb8:	99 1f       	adc	r25, r25
    2fba:	88 0f       	add	r24, r24
    2fbc:	99 1f       	adc	r25, r25
    2fbe:	82 0f       	add	r24, r18
    2fc0:	93 1f       	adc	r25, r19
    2fc2:	b8 01       	movw	r22, r16
    2fc4:	83 54       	subi	r24, 0x43	; 67
    2fc6:	9d 4d       	sbci	r25, 0xDD	; 221
    2fc8:	85 db       	rcall	.-2294   	; 0x26d4 <vListInsertEnd>
    2fca:	e0 91 ea 22 	lds	r30, 0x22EA
    2fce:	f0 91 eb 22 	lds	r31, 0x22EB
    2fd2:	9e 89       	ldd	r25, Y+22	; 0x16
    2fd4:	86 89       	ldd	r24, Z+22	; 0x16
    2fd6:	98 17       	cp	r25, r24
    2fd8:	58 f0       	brcs	.+22     	; 0x2ff0 <xTaskResumeAll+0x9e>
    2fda:	d0 92 97 22 	sts	0x2297, r13
    2fde:	08 c0       	rjmp	.+16     	; 0x2ff0 <xTaskResumeAll+0x9e>
    2fe0:	0f 2e       	mov	r0, r31
    2fe2:	fe e9       	ldi	r31, 0x9E	; 158
    2fe4:	ef 2e       	mov	r14, r31
    2fe6:	f2 e2       	ldi	r31, 0x22	; 34
    2fe8:	ff 2e       	mov	r15, r31
    2fea:	f0 2d       	mov	r31, r0
    2fec:	dd 24       	eor	r13, r13
    2fee:	d3 94       	inc	r13
    2ff0:	f7 01       	movw	r30, r14
    2ff2:	80 81       	ld	r24, Z
    2ff4:	81 11       	cpse	r24, r1
    2ff6:	c5 cf       	rjmp	.-118    	; 0x2f82 <xTaskResumeAll+0x30>
    2ff8:	80 91 98 22 	lds	r24, 0x2298
    2ffc:	88 23       	and	r24, r24
    2ffe:	91 f0       	breq	.+36     	; 0x3024 <xTaskResumeAll+0xd2>
    3000:	80 91 98 22 	lds	r24, 0x2298
    3004:	88 23       	and	r24, r24
    3006:	71 f0       	breq	.+28     	; 0x3024 <xTaskResumeAll+0xd2>
    3008:	c1 e0       	ldi	r28, 0x01	; 1
    300a:	d0 de       	rcall	.-608    	; 0x2dac <xTaskIncrementTick>
    300c:	81 11       	cpse	r24, r1
    300e:	c0 93 97 22 	sts	0x2297, r28
    3012:	80 91 98 22 	lds	r24, 0x2298
    3016:	81 50       	subi	r24, 0x01	; 1
    3018:	80 93 98 22 	sts	0x2298, r24
    301c:	80 91 98 22 	lds	r24, 0x2298
    3020:	81 11       	cpse	r24, r1
    3022:	f3 cf       	rjmp	.-26     	; 0x300a <xTaskResumeAll+0xb8>
    3024:	80 91 97 22 	lds	r24, 0x2297
    3028:	81 30       	cpi	r24, 0x01	; 1
    302a:	29 f4       	brne	.+10     	; 0x3036 <xTaskResumeAll+0xe4>
    302c:	87 dc       	rcall	.-1778   	; 0x293c <vPortYield>
    302e:	81 e0       	ldi	r24, 0x01	; 1
    3030:	03 c0       	rjmp	.+6      	; 0x3038 <xTaskResumeAll+0xe6>
    3032:	80 e0       	ldi	r24, 0x00	; 0
    3034:	01 c0       	rjmp	.+2      	; 0x3038 <xTaskResumeAll+0xe6>
    3036:	80 e0       	ldi	r24, 0x00	; 0
    3038:	0f 90       	pop	r0
    303a:	0f be       	out	0x3f, r0	; 63
    303c:	df 91       	pop	r29
    303e:	cf 91       	pop	r28
    3040:	1f 91       	pop	r17
    3042:	0f 91       	pop	r16
    3044:	ff 90       	pop	r15
    3046:	ef 90       	pop	r14
    3048:	df 90       	pop	r13
    304a:	08 95       	ret

0000304c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    304c:	cf 93       	push	r28
    304e:	df 93       	push	r29
    3050:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3052:	89 2b       	or	r24, r25
    3054:	91 f0       	breq	.+36     	; 0x307a <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3056:	a4 de       	rcall	.-696    	; 0x2da0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3058:	80 91 9b 22 	lds	r24, 0x229B
    305c:	90 91 9c 22 	lds	r25, 0x229C
    3060:	c8 0f       	add	r28, r24
    3062:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3064:	80 91 ea 22 	lds	r24, 0x22EA
    3068:	90 91 eb 22 	lds	r25, 0x22EB
    306c:	02 96       	adiw	r24, 0x02	; 2
    306e:	84 db       	rcall	.-2296   	; 0x2778 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3070:	ce 01       	movw	r24, r28
    3072:	37 dd       	rcall	.-1426   	; 0x2ae2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3074:	6e df       	rcall	.-292    	; 0x2f52 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3076:	81 11       	cpse	r24, r1
    3078:	01 c0       	rjmp	.+2      	; 0x307c <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    307a:	60 dc       	rcall	.-1856   	; 0x293c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    307c:	df 91       	pop	r29
    307e:	cf 91       	pop	r28
    3080:	08 95       	ret

00003082 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3082:	80 91 94 22 	lds	r24, 0x2294
    3086:	88 23       	and	r24, r24
    3088:	21 f0       	breq	.+8      	; 0x3092 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    308a:	81 e0       	ldi	r24, 0x01	; 1
    308c:	80 93 97 22 	sts	0x2297, r24
    3090:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    3092:	10 92 97 22 	sts	0x2297, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    3096:	80 91 9a 22 	lds	r24, 0x229A
    309a:	90 e0       	ldi	r25, 0x00	; 0
    309c:	fc 01       	movw	r30, r24
    309e:	ee 0f       	add	r30, r30
    30a0:	ff 1f       	adc	r31, r31
    30a2:	ee 0f       	add	r30, r30
    30a4:	ff 1f       	adc	r31, r31
    30a6:	ee 0f       	add	r30, r30
    30a8:	ff 1f       	adc	r31, r31
    30aa:	8e 0f       	add	r24, r30
    30ac:	9f 1f       	adc	r25, r31
    30ae:	fc 01       	movw	r30, r24
    30b0:	e3 54       	subi	r30, 0x43	; 67
    30b2:	fd 4d       	sbci	r31, 0xDD	; 221
    30b4:	80 81       	ld	r24, Z
    30b6:	81 11       	cpse	r24, r1
    30b8:	17 c0       	rjmp	.+46     	; 0x30e8 <vTaskSwitchContext+0x66>
    30ba:	80 91 9a 22 	lds	r24, 0x229A
    30be:	81 50       	subi	r24, 0x01	; 1
    30c0:	80 93 9a 22 	sts	0x229A, r24
    30c4:	80 91 9a 22 	lds	r24, 0x229A
    30c8:	90 e0       	ldi	r25, 0x00	; 0
    30ca:	fc 01       	movw	r30, r24
    30cc:	ee 0f       	add	r30, r30
    30ce:	ff 1f       	adc	r31, r31
    30d0:	ee 0f       	add	r30, r30
    30d2:	ff 1f       	adc	r31, r31
    30d4:	ee 0f       	add	r30, r30
    30d6:	ff 1f       	adc	r31, r31
    30d8:	8e 0f       	add	r24, r30
    30da:	9f 1f       	adc	r25, r31
    30dc:	fc 01       	movw	r30, r24
    30de:	e3 54       	subi	r30, 0x43	; 67
    30e0:	fd 4d       	sbci	r31, 0xDD	; 221
    30e2:	80 81       	ld	r24, Z
    30e4:	88 23       	and	r24, r24
    30e6:	49 f3       	breq	.-46     	; 0x30ba <vTaskSwitchContext+0x38>
    30e8:	80 91 9a 22 	lds	r24, 0x229A
    30ec:	90 e0       	ldi	r25, 0x00	; 0
    30ee:	9c 01       	movw	r18, r24
    30f0:	22 0f       	add	r18, r18
    30f2:	33 1f       	adc	r19, r19
    30f4:	22 0f       	add	r18, r18
    30f6:	33 1f       	adc	r19, r19
    30f8:	22 0f       	add	r18, r18
    30fa:	33 1f       	adc	r19, r19
    30fc:	28 0f       	add	r18, r24
    30fe:	39 1f       	adc	r19, r25
    3100:	d9 01       	movw	r26, r18
    3102:	a3 54       	subi	r26, 0x43	; 67
    3104:	bd 4d       	sbci	r27, 0xDD	; 221
    3106:	11 96       	adiw	r26, 0x01	; 1
    3108:	ed 91       	ld	r30, X+
    310a:	fc 91       	ld	r31, X
    310c:	12 97       	sbiw	r26, 0x02	; 2
    310e:	02 80       	ldd	r0, Z+2	; 0x02
    3110:	f3 81       	ldd	r31, Z+3	; 0x03
    3112:	e0 2d       	mov	r30, r0
    3114:	11 96       	adiw	r26, 0x01	; 1
    3116:	ed 93       	st	X+, r30
    3118:	fc 93       	st	X, r31
    311a:	12 97       	sbiw	r26, 0x02	; 2
    311c:	20 54       	subi	r18, 0x40	; 64
    311e:	3d 4d       	sbci	r19, 0xDD	; 221
    3120:	e2 17       	cp	r30, r18
    3122:	f3 07       	cpc	r31, r19
    3124:	29 f4       	brne	.+10     	; 0x3130 <vTaskSwitchContext+0xae>
    3126:	22 81       	ldd	r18, Z+2	; 0x02
    3128:	33 81       	ldd	r19, Z+3	; 0x03
    312a:	fd 01       	movw	r30, r26
    312c:	21 83       	std	Z+1, r18	; 0x01
    312e:	32 83       	std	Z+2, r19	; 0x02
    3130:	fc 01       	movw	r30, r24
    3132:	ee 0f       	add	r30, r30
    3134:	ff 1f       	adc	r31, r31
    3136:	ee 0f       	add	r30, r30
    3138:	ff 1f       	adc	r31, r31
    313a:	ee 0f       	add	r30, r30
    313c:	ff 1f       	adc	r31, r31
    313e:	8e 0f       	add	r24, r30
    3140:	9f 1f       	adc	r25, r31
    3142:	fc 01       	movw	r30, r24
    3144:	e3 54       	subi	r30, 0x43	; 67
    3146:	fd 4d       	sbci	r31, 0xDD	; 221
    3148:	01 80       	ldd	r0, Z+1	; 0x01
    314a:	f2 81       	ldd	r31, Z+2	; 0x02
    314c:	e0 2d       	mov	r30, r0
    314e:	86 81       	ldd	r24, Z+6	; 0x06
    3150:	97 81       	ldd	r25, Z+7	; 0x07
    3152:	80 93 ea 22 	sts	0x22EA, r24
    3156:	90 93 eb 22 	sts	0x22EB, r25
    315a:	08 95       	ret

0000315c <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    315c:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    315e:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    3160:	e8 2f       	mov	r30, r24
    3162:	f0 e0       	ldi	r31, 0x00	; 0
    3164:	e0 59       	subi	r30, 0x90	; 144
    3166:	ff 4f       	sbci	r31, 0xFF	; 255
    3168:	60 95       	com	r22
    316a:	80 81       	ld	r24, Z
    316c:	68 23       	and	r22, r24
    316e:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    3170:	9f bf       	out	0x3f, r25	; 63
    3172:	08 95       	ret

00003174 <sysclk_disable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    3174:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    3176:	f8 94       	cli

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
    3178:	e8 2f       	mov	r30, r24
    317a:	f0 e0       	ldi	r31, 0x00	; 0
    317c:	e0 59       	subi	r30, 0x90	; 144
    317e:	ff 4f       	sbci	r31, 0xFF	; 255
    3180:	80 81       	ld	r24, Z
    3182:	68 2b       	or	r22, r24
    3184:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    3186:	9f bf       	out	0x3f, r25	; 63
    3188:	08 95       	ret

0000318a <nvm_eeprom_read_byte>:
{
	nvm_wait_until_ready();
	eeprom_enable_mapping();
	memcpy( buf,(void*)(address+MAPPED_EEPROM_START), len );
	eeprom_disable_mapping();
}
    318a:	dc 01       	movw	r26, r24
    318c:	e0 ec       	ldi	r30, 0xC0	; 192
    318e:	f1 e0       	ldi	r31, 0x01	; 1
    3190:	97 85       	ldd	r25, Z+15	; 0x0f
    3192:	99 23       	and	r25, r25
    3194:	ec f3       	brlt	.-6      	; 0x3190 <nvm_eeprom_read_byte+0x6>
    3196:	ec ec       	ldi	r30, 0xCC	; 204
    3198:	f1 e0       	ldi	r31, 0x01	; 1
    319a:	80 81       	ld	r24, Z
    319c:	88 60       	ori	r24, 0x08	; 8
    319e:	80 83       	st	Z, r24
    31a0:	b0 5f       	subi	r27, 0xF0	; 240
    31a2:	8c 91       	ld	r24, X
    31a4:	90 81       	ld	r25, Z
    31a6:	97 7f       	andi	r25, 0xF7	; 247
    31a8:	90 83       	st	Z, r25
    31aa:	08 95       	ret

000031ac <nvm_eeprom_flush_buffer>:
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    31ac:	e0 ec       	ldi	r30, 0xC0	; 192
    31ae:	f1 e0       	ldi	r31, 0x01	; 1
    31b0:	87 85       	ldd	r24, Z+15	; 0x0f
    31b2:	88 23       	and	r24, r24
    31b4:	ec f3       	brlt	.-6      	; 0x31b0 <nvm_eeprom_flush_buffer+0x4>
{
	// Wait until NVM is ready
	nvm_wait_until_ready();

	// Flush EEPROM page buffer if necessary
	if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    31b6:	80 91 cf 01 	lds	r24, 0x01CF
    31ba:	81 ff       	sbrs	r24, 1
    31bc:	07 c0       	rjmp	.+14     	; 0x31cc <nvm_eeprom_flush_buffer+0x20>
		NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    31be:	86 e3       	ldi	r24, 0x36	; 54
    31c0:	80 93 ca 01 	sts	0x01CA, r24
 * \note The correct NVM command must be set in the NVM.CMD register before
 *       calling this function.
 */
static inline void nvm_exec(void)
{
	ccp_write_io((uint8_t *)&NVM.CTRLA, NVM_CMDEX_bm);
    31c4:	61 e0       	ldi	r22, 0x01	; 1
    31c6:	8b ec       	ldi	r24, 0xCB	; 203
    31c8:	91 e0       	ldi	r25, 0x01	; 1
    31ca:	42 c0       	rjmp	.+132    	; 0x3250 <ccp_write_io>
    31cc:	08 95       	ret

000031ce <nvm_eeprom_load_byte_to_buffer>:
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    31ce:	e0 ec       	ldi	r30, 0xC0	; 192
    31d0:	f1 e0       	ldi	r31, 0x01	; 1
    31d2:	97 85       	ldd	r25, Z+15	; 0x0f
    31d4:	99 23       	and	r25, r25
    31d6:	ec f3       	brlt	.-6      	; 0x31d2 <nvm_eeprom_load_byte_to_buffer+0x4>
 *        write operations still needs to be done through IO register.
 */
static inline void eeprom_enable_mapping(void)
{
#if !XMEGA_E
	NVM_CTRLB = NVM_CTRLB | NVM_EEMAPEN_bm;
    31d8:	ac ec       	ldi	r26, 0xCC	; 204
    31da:	b1 e0       	ldi	r27, 0x01	; 1
    31dc:	9c 91       	ld	r25, X
    31de:	98 60       	ori	r25, 0x08	; 8
    31e0:	9c 93       	st	X, r25
{
	// Wait until NVM is ready
	nvm_wait_until_ready();

	eeprom_enable_mapping();
	*(uint8_t*)(byte_addr + MAPPED_EEPROM_START) = value;
    31e2:	e8 2f       	mov	r30, r24
    31e4:	f0 e0       	ldi	r31, 0x00	; 0
    31e6:	f0 5f       	subi	r31, 0xF0	; 240
    31e8:	60 83       	st	Z, r22
 *  IO mapped access is now enabled.
 */
static inline void eeprom_disable_mapping(void)
{
#if !XMEGA_E
	NVM_CTRLB = NVM_CTRLB & ~NVM_EEMAPEN_bm;
    31ea:	8c 91       	ld	r24, X
    31ec:	87 7f       	andi	r24, 0xF7	; 247
    31ee:	8c 93       	st	X, r24
    31f0:	08 95       	ret

000031f2 <nvm_eeprom_write_byte>:
 *
 * \param  address    EEPROM address (max EEPROM_SIZE)
 * \param  value      Byte value to write to EEPROM.
 */
void nvm_eeprom_write_byte(eeprom_addr_t address, uint8_t value)
{
    31f2:	ff 92       	push	r15
    31f4:	0f 93       	push	r16
    31f6:	1f 93       	push	r17
    31f8:	cf 93       	push	r28
    31fa:	df 93       	push	r29
    31fc:	18 2f       	mov	r17, r24
    31fe:	f9 2e       	mov	r15, r25
    3200:	c6 2f       	mov	r28, r22

	Assert(address <= EEPROM_SIZE);
	/*  Flush buffer to make sure no unintentional data is written and load
	 *  the "Page Load" command into the command register.
	 */
	old_cmd = NVM.CMD;
    3202:	00 91 ca 01 	lds	r16, 0x01CA
	nvm_eeprom_flush_buffer();
    3206:	d2 df       	rcall	.-92     	; 0x31ac <nvm_eeprom_flush_buffer>
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3208:	e0 ec       	ldi	r30, 0xC0	; 192
    320a:	f1 e0       	ldi	r31, 0x01	; 1
    320c:	27 85       	ldd	r18, Z+15	; 0x0f
    320e:	22 23       	and	r18, r18
    3210:	ec f3       	brlt	.-6      	; 0x320c <nvm_eeprom_write_byte+0x1a>
	// Wait until NVM is ready
	nvm_wait_until_ready();
	nvm_eeprom_load_byte_to_buffer(address, value);
    3212:	6c 2f       	mov	r22, r28
    3214:	81 2f       	mov	r24, r17
    3216:	db df       	rcall	.-74     	; 0x31ce <nvm_eeprom_load_byte_to_buffer>

	// Set address to write to
	NVM.ADDR2 = 0x00;
    3218:	c0 ec       	ldi	r28, 0xC0	; 192
    321a:	d1 e0       	ldi	r29, 0x01	; 1
    321c:	1a 82       	std	Y+2, r1	; 0x02
	NVM.ADDR1 = (address >> 8) & 0xFF;
    321e:	f9 82       	std	Y+1, r15	; 0x01
	NVM.ADDR0 = address & 0xFF;
    3220:	18 83       	st	Y, r17

	/*  Issue EEPROM Atomic Write (Erase&Write) command. Load command, write
	 *  the protection signature and execute command.
	 */
	NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3222:	85 e3       	ldi	r24, 0x35	; 53
    3224:	8a 87       	std	Y+10, r24	; 0x0a
 * \note The correct NVM command must be set in the NVM.CMD register before
 *       calling this function.
 */
static inline void nvm_exec(void)
{
	ccp_write_io((uint8_t *)&NVM.CTRLA, NVM_CMDEX_bm);
    3226:	61 e0       	ldi	r22, 0x01	; 1
    3228:	8b ec       	ldi	r24, 0xCB	; 203
    322a:	91 e0       	ldi	r25, 0x01	; 1
    322c:	11 d0       	rcall	.+34     	; 0x3250 <ccp_write_io>
	nvm_exec();
	NVM.CMD = old_cmd;
    322e:	0a 87       	std	Y+10, r16	; 0x0a
}
    3230:	df 91       	pop	r29
    3232:	cf 91       	pop	r28
    3234:	1f 91       	pop	r17
    3236:	0f 91       	pop	r16
    3238:	ff 90       	pop	r15
    323a:	08 95       	ret

0000323c <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    323c:	40 91 ca 01 	lds	r20, 0x01CA
	mov ZL, r22               ; Load byte index into low byte of Z.
    3240:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    3242:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    3244:	80 93 ca 01 	sts	0x01CA, r24
	lpm r24, Z                ; Perform an LPM to read out byte
    3248:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    324a:	40 93 ca 01 	sts	0x01CA, r20
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    324e:	08 95       	ret

00003250 <ccp_write_io>:

	PUBLIC_FUNCTION(ccp_write_io)

#if defined(__GNUC__)

	out     RAMPZ, r1               // Reset bits 23:16 of Z
    3250:	1b be       	out	0x3b, r1	; 59
	movw    r30, r24                // Load addr into Z
    3252:	fc 01       	movw	r30, r24
	ldi     r18, CCP_IOREG          // Load magic CCP value
    3254:	28 ed       	ldi	r18, 0xD8	; 216
	out     CCP, r18                // Start CCP handshake
    3256:	24 bf       	out	0x34, r18	; 52
	st      Z, r22                  // Write value to I/O register
    3258:	60 83       	st	Z, r22
	ret                             // Return to caller
    325a:	08 95       	ret

0000325c <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    325c:	cf 93       	push	r28
    325e:	df 93       	push	r29
    3260:	fc 01       	movw	r30, r24
    3262:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3264:	20 e0       	ldi	r18, 0x00	; 0
    3266:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    3268:	c6 2f       	mov	r28, r22
    326a:	d0 e0       	ldi	r29, 0x00	; 0
    326c:	de 01       	movw	r26, r28
    326e:	02 2e       	mov	r0, r18
    3270:	02 c0       	rjmp	.+4      	; 0x3276 <ioport_configure_port_pin+0x1a>
    3272:	b5 95       	asr	r27
    3274:	a7 95       	ror	r26
    3276:	0a 94       	dec	r0
    3278:	e2 f7       	brpl	.-8      	; 0x3272 <ioport_configure_port_pin+0x16>
    327a:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    327c:	50 83       	st	Z, r21
    327e:	2f 5f       	subi	r18, 0xFF	; 255
    3280:	3f 4f       	sbci	r19, 0xFF	; 255
    3282:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    3284:	28 30       	cpi	r18, 0x08	; 8
    3286:	31 05       	cpc	r19, r1
    3288:	89 f7       	brne	.-30     	; 0x326c <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    328a:	40 ff       	sbrs	r20, 0
    328c:	0a c0       	rjmp	.+20     	; 0x32a2 <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
    328e:	41 ff       	sbrs	r20, 1
    3290:	03 c0       	rjmp	.+6      	; 0x3298 <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    3292:	fc 01       	movw	r30, r24
    3294:	65 83       	std	Z+5, r22	; 0x05
    3296:	02 c0       	rjmp	.+4      	; 0x329c <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    3298:	fc 01       	movw	r30, r24
    329a:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    329c:	fc 01       	movw	r30, r24
    329e:	61 83       	std	Z+1, r22	; 0x01
    32a0:	02 c0       	rjmp	.+4      	; 0x32a6 <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    32a2:	fc 01       	movw	r30, r24
    32a4:	62 83       	std	Z+2, r22	; 0x02
	}
}
    32a6:	df 91       	pop	r29
    32a8:	cf 91       	pop	r28
    32aa:	08 95       	ret

000032ac <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    32ac:	43 e0       	ldi	r20, 0x03	; 3
    32ae:	50 e0       	ldi	r21, 0x00	; 0
    32b0:	61 e0       	ldi	r22, 0x01	; 1
    32b2:	80 ee       	ldi	r24, 0xE0	; 224
    32b4:	97 e0       	ldi	r25, 0x07	; 7
    32b6:	d2 df       	rcall	.-92     	; 0x325c <ioport_configure_port_pin>
    32b8:	43 e0       	ldi	r20, 0x03	; 3
    32ba:	50 e0       	ldi	r21, 0x00	; 0
    32bc:	62 e0       	ldi	r22, 0x02	; 2
    32be:	80 ee       	ldi	r24, 0xE0	; 224
    32c0:	97 e0       	ldi	r25, 0x07	; 7
    32c2:	cc df       	rcall	.-104    	; 0x325c <ioport_configure_port_pin>
    32c4:	43 e0       	ldi	r20, 0x03	; 3
    32c6:	50 e0       	ldi	r21, 0x00	; 0
    32c8:	60 e1       	ldi	r22, 0x10	; 16
    32ca:	80 e6       	ldi	r24, 0x60	; 96
    32cc:	96 e0       	ldi	r25, 0x06	; 6
    32ce:	c6 df       	rcall	.-116    	; 0x325c <ioport_configure_port_pin>
    32d0:	41 e0       	ldi	r20, 0x01	; 1
    32d2:	50 e4       	ldi	r21, 0x40	; 64
    32d4:	60 e2       	ldi	r22, 0x20	; 32
    32d6:	80 e6       	ldi	r24, 0x60	; 96
    32d8:	96 e0       	ldi	r25, 0x06	; 6
    32da:	c0 df       	rcall	.-128    	; 0x325c <ioport_configure_port_pin>
    32dc:	40 e0       	ldi	r20, 0x00	; 0
    32de:	5b e1       	ldi	r21, 0x1B	; 27
    32e0:	60 e2       	ldi	r22, 0x20	; 32
    32e2:	80 e8       	ldi	r24, 0x80	; 128
    32e4:	96 e0       	ldi	r25, 0x06	; 6
    32e6:	ba df       	rcall	.-140    	; 0x325c <ioport_configure_port_pin>
    32e8:	40 e0       	ldi	r20, 0x00	; 0
    32ea:	5b e1       	ldi	r21, 0x1B	; 27
    32ec:	62 e0       	ldi	r22, 0x02	; 2
    32ee:	80 ea       	ldi	r24, 0xA0	; 160
    32f0:	96 e0       	ldi	r25, 0x06	; 6
    32f2:	b4 df       	rcall	.-152    	; 0x325c <ioport_configure_port_pin>
    32f4:	40 e0       	ldi	r20, 0x00	; 0
    32f6:	5b e1       	ldi	r21, 0x1B	; 27
    32f8:	64 e0       	ldi	r22, 0x04	; 4
    32fa:	80 ea       	ldi	r24, 0xA0	; 160
    32fc:	96 e0       	ldi	r25, 0x06	; 6
    32fe:	ae df       	rcall	.-164    	; 0x325c <ioport_configure_port_pin>
    3300:	43 e0       	ldi	r20, 0x03	; 3
    3302:	50 e0       	ldi	r21, 0x00	; 0
    3304:	62 e0       	ldi	r22, 0x02	; 2
    3306:	80 e6       	ldi	r24, 0x60	; 96
    3308:	96 e0       	ldi	r25, 0x06	; 6
    330a:	a8 df       	rcall	.-176    	; 0x325c <ioport_configure_port_pin>
    330c:	43 e0       	ldi	r20, 0x03	; 3
    330e:	50 e0       	ldi	r21, 0x00	; 0
    3310:	68 e0       	ldi	r22, 0x08	; 8
    3312:	80 e6       	ldi	r24, 0x60	; 96
    3314:	96 e0       	ldi	r25, 0x06	; 6
    3316:	a2 df       	rcall	.-188    	; 0x325c <ioport_configure_port_pin>
    3318:	43 e0       	ldi	r20, 0x03	; 3
    331a:	50 e0       	ldi	r21, 0x00	; 0
    331c:	68 e0       	ldi	r22, 0x08	; 8
    331e:	80 ea       	ldi	r24, 0xA0	; 160
    3320:	96 e0       	ldi	r25, 0x06	; 6
    3322:	9c df       	rcall	.-200    	; 0x325c <ioport_configure_port_pin>
    3324:	43 e0       	ldi	r20, 0x03	; 3
    3326:	50 e0       	ldi	r21, 0x00	; 0
    3328:	61 e0       	ldi	r22, 0x01	; 1
    332a:	80 e6       	ldi	r24, 0x60	; 96
    332c:	96 e0       	ldi	r25, 0x06	; 6
    332e:	96 df       	rcall	.-212    	; 0x325c <ioport_configure_port_pin>
    3330:	43 e0       	ldi	r20, 0x03	; 3
    3332:	50 e0       	ldi	r21, 0x00	; 0
    3334:	68 e0       	ldi	r22, 0x08	; 8
    3336:	80 e0       	ldi	r24, 0x00	; 0
    3338:	96 e0       	ldi	r25, 0x06	; 6
    333a:	90 df       	rcall	.-224    	; 0x325c <ioport_configure_port_pin>
    333c:	41 e0       	ldi	r20, 0x01	; 1
    333e:	50 e0       	ldi	r21, 0x00	; 0
    3340:	60 e1       	ldi	r22, 0x10	; 16
    3342:	80 e8       	ldi	r24, 0x80	; 128
    3344:	96 e0       	ldi	r25, 0x06	; 6
    3346:	8a cf       	rjmp	.-236    	; 0x325c <ioport_configure_port_pin>
    3348:	08 95       	ret

0000334a <vStatus>:
	PORTE_DIR=0b00000001;
	PORTE_OUT=0b00000000;
}

void clearLCD(void){
	gfx_mono_draw_string("                    ",0,0,&sysfont);
    334a:	09 e1       	ldi	r16, 0x19	; 25
    334c:	10 e2       	ldi	r17, 0x20	; 32
    334e:	0f 2e       	mov	r0, r31
    3350:	f9 ec       	ldi	r31, 0xC9	; 201
    3352:	ff 2e       	mov	r15, r31
    3354:	f0 2d       	mov	r31, r0
    3356:	c8 e0       	ldi	r28, 0x08	; 8
    3358:	d3 e2       	ldi	r29, 0x23	; 35
    335a:	80 91 f3 22 	lds	r24, 0x22F3
    335e:	8f 93       	push	r24
    3360:	80 91 f2 22 	lds	r24, 0x22F2
    3364:	8f 93       	push	r24
    3366:	1f 93       	push	r17
    3368:	0f 93       	push	r16
    336a:	1f 92       	push	r1
    336c:	ff 92       	push	r15
    336e:	df 93       	push	r29
    3370:	cf 93       	push	r28
    3372:	bb d7       	rcall	.+3958   	; 0x42ea <snprintf>
    3374:	27 e0       	ldi	r18, 0x07	; 7
    3376:	30 e2       	ldi	r19, 0x20	; 32
    3378:	40 e0       	ldi	r20, 0x00	; 0
    337a:	60 e0       	ldi	r22, 0x00	; 0
    337c:	ce 01       	movw	r24, r28
    337e:	6f d9       	rcall	.-3362   	; 0x265e <gfx_mono_draw_string>
    3380:	80 91 ff 22 	lds	r24, 0x22FF
    3384:	8f 93       	push	r24
    3386:	80 91 fe 22 	lds	r24, 0x22FE
    338a:	8f 93       	push	r24
    338c:	1f 93       	push	r17
    338e:	0f 93       	push	r16
    3390:	1f 92       	push	r1
    3392:	ff 92       	push	r15
    3394:	df 93       	push	r29
    3396:	cf 93       	push	r28
    3398:	a8 d7       	rcall	.+3920   	; 0x42ea <snprintf>
    339a:	27 e0       	ldi	r18, 0x07	; 7
    339c:	30 e2       	ldi	r19, 0x20	; 32
    339e:	48 e0       	ldi	r20, 0x08	; 8
    33a0:	60 e0       	ldi	r22, 0x00	; 0
    33a2:	ce 01       	movw	r24, r28
    33a4:	5c d9       	rcall	.-3400   	; 0x265e <gfx_mono_draw_string>
    33a6:	80 91 f5 22 	lds	r24, 0x22F5
    33aa:	8f 93       	push	r24
    33ac:	80 91 f4 22 	lds	r24, 0x22F4
    33b0:	8f 93       	push	r24
    33b2:	1f 93       	push	r17
    33b4:	0f 93       	push	r16
    33b6:	1f 92       	push	r1
    33b8:	ff 92       	push	r15
    33ba:	df 93       	push	r29
    33bc:	cf 93       	push	r28
    33be:	95 d7       	rcall	.+3882   	; 0x42ea <snprintf>
    33c0:	27 e0       	ldi	r18, 0x07	; 7
    33c2:	30 e2       	ldi	r19, 0x20	; 32
    33c4:	40 e1       	ldi	r20, 0x10	; 16
    33c6:	60 e0       	ldi	r22, 0x00	; 0
    33c8:	ce 01       	movw	r24, r28
    33ca:	49 d9       	rcall	.-3438   	; 0x265e <gfx_mono_draw_string>
    33cc:	80 91 fb 22 	lds	r24, 0x22FB
    33d0:	8f 93       	push	r24
    33d2:	80 91 fa 22 	lds	r24, 0x22FA
    33d6:	8f 93       	push	r24
    33d8:	1f 93       	push	r17
    33da:	0f 93       	push	r16
    33dc:	1f 92       	push	r1
    33de:	ff 92       	push	r15
    33e0:	df 93       	push	r29
    33e2:	cf 93       	push	r28
    33e4:	82 d7       	rcall	.+3844   	; 0x42ea <snprintf>
    33e6:	8d b7       	in	r24, 0x3d	; 61
    33e8:	9e b7       	in	r25, 0x3e	; 62
    33ea:	80 96       	adiw	r24, 0x20	; 32
    33ec:	8d bf       	out	0x3d, r24	; 61
    33ee:	9e bf       	out	0x3e, r25	; 62
    33f0:	27 e0       	ldi	r18, 0x07	; 7
    33f2:	30 e2       	ldi	r19, 0x20	; 32
    33f4:	48 e1       	ldi	r20, 0x18	; 24
    33f6:	60 e0       	ldi	r22, 0x00	; 0
    33f8:	ce 01       	movw	r24, r28
    33fa:	31 d9       	rcall	.-3486   	; 0x265e <gfx_mono_draw_string>
    33fc:	81 e0       	ldi	r24, 0x01	; 1
    33fe:	90 e0       	ldi	r25, 0x00	; 0
    3400:	25 de       	rcall	.-950    	; 0x304c <vTaskDelay>
    3402:	ab cf       	rjmp	.-170    	; 0x335a <vStatus+0x10>

00003404 <setWaterDebit>:
    3404:	c0 e0       	ldi	r28, 0x00	; 0
    3406:	d2 e0       	ldi	r29, 0x02	; 2
    3408:	11 e0       	ldi	r17, 0x01	; 1
    340a:	ce 01       	movw	r24, r28
    340c:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <adc_enable>
    3410:	9f b7       	in	r25, 0x3f	; 63
    3412:	f8 94       	cli
    3414:	88 81       	ld	r24, Y
    3416:	84 60       	ori	r24, 0x04	; 4
    3418:	88 83       	st	Y, r24
    341a:	9f bf       	out	0x3f, r25	; 63
    341c:	9e 81       	ldd	r25, Y+6	; 0x06
    341e:	90 ff       	sbrs	r25, 0
    3420:	fd cf       	rjmp	.-6      	; 0x341c <setWaterDebit+0x18>
    3422:	1e 83       	std	Y+6, r17	; 0x06
    3424:	2c a1       	ldd	r18, Y+36	; 0x24
    3426:	3d a1       	ldd	r19, Y+37	; 0x25
    3428:	36 95       	lsr	r19
    342a:	27 95       	ror	r18
    342c:	36 95       	lsr	r19
    342e:	27 95       	ror	r18
    3430:	36 95       	lsr	r19
    3432:	27 95       	ror	r18
    3434:	a5 ec       	ldi	r26, 0xC5	; 197
    3436:	b0 e2       	ldi	r27, 0x20	; 32
    3438:	b4 d5       	rcall	.+2920   	; 0x3fa2 <__umulhisi3>
    343a:	92 95       	swap	r25
    343c:	82 95       	swap	r24
    343e:	8f 70       	andi	r24, 0x0F	; 15
    3440:	89 27       	eor	r24, r25
    3442:	9f 70       	andi	r25, 0x0F	; 15
    3444:	89 27       	eor	r24, r25
    3446:	80 93 f6 22 	sts	0x22F6, r24
    344a:	90 93 f7 22 	sts	0x22F7, r25
    344e:	81 e0       	ldi	r24, 0x01	; 1
    3450:	90 e0       	ldi	r25, 0x00	; 0
    3452:	fc dd       	rcall	.-1032   	; 0x304c <vTaskDelay>
    3454:	da cf       	rjmp	.-76     	; 0x340a <setWaterDebit+0x6>

00003456 <vLightAndTemp>:
    3456:	c0 e0       	ldi	r28, 0x00	; 0
    3458:	d2 e0       	ldi	r29, 0x02	; 2
    345a:	08 ec       	ldi	r16, 0xC8	; 200
    345c:	10 e0       	ldi	r17, 0x00	; 0
    345e:	ee 24       	eor	r14, r14
    3460:	e3 94       	inc	r14
    3462:	f1 2c       	mov	r15, r1
    3464:	9f b7       	in	r25, 0x3f	; 63
    3466:	f8 94       	cli
    3468:	88 81       	ld	r24, Y
    346a:	88 60       	ori	r24, 0x08	; 8
    346c:	88 83       	st	Y, r24
    346e:	9f bf       	out	0x3f, r25	; 63
    3470:	0e 94 4c 08 	call	0x1098	; 0x1098 <ntc_data_is_ready>
    3474:	88 23       	and	r24, r24
    3476:	61 f0       	breq	.+24     	; 0x3490 <vLightAndTemp+0x3a>
    3478:	0e 94 b1 08 	call	0x1162	; 0x1162 <ntc_get_temperature>
    347c:	08 2e       	mov	r0, r24
    347e:	00 0c       	add	r0, r0
    3480:	99 0b       	sbc	r25, r25
    3482:	b8 01       	movw	r22, r16
    3484:	59 d5       	rcall	.+2738   	; 0x3f38 <__divmodhi4>
    3486:	cb 01       	movw	r24, r22
    3488:	4a e0       	ldi	r20, 0x0A	; 10
    348a:	6b ed       	ldi	r22, 0xDB	; 219
    348c:	73 e2       	ldi	r23, 0x23	; 35
    348e:	0a d7       	rcall	.+3604   	; 0x42a4 <__itoa_ncheck>
    3490:	9f b7       	in	r25, 0x3f	; 63
    3492:	f8 94       	cli
    3494:	88 81       	ld	r24, Y
    3496:	84 60       	ori	r24, 0x04	; 4
    3498:	88 83       	st	Y, r24
    349a:	9f bf       	out	0x3f, r25	; 63
    349c:	0e 94 58 08 	call	0x10b0	; 0x10b0 <lightsensor_data_is_ready>
    34a0:	88 23       	and	r24, r24
    34a2:	91 f0       	breq	.+36     	; 0x34c8 <vLightAndTemp+0x72>
    34a4:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <lightsensor_get_raw_value>
    34a8:	80 93 fc 22 	sts	0x22FC, r24
    34ac:	90 93 fd 22 	sts	0x22FD, r25
    34b0:	8c 34       	cpi	r24, 0x4C	; 76
    34b2:	91 05       	cpc	r25, r1
    34b4:	2c f0       	brlt	.+10     	; 0x34c0 <vLightAndTemp+0x6a>
    34b6:	e0 92 ec 22 	sts	0x22EC, r14
    34ba:	f0 92 ed 22 	sts	0x22ED, r15
    34be:	04 c0       	rjmp	.+8      	; 0x34c8 <vLightAndTemp+0x72>
    34c0:	10 92 ec 22 	sts	0x22EC, r1
    34c4:	10 92 ed 22 	sts	0x22ED, r1
    34c8:	8a e0       	ldi	r24, 0x0A	; 10
    34ca:	90 e0       	ldi	r25, 0x00	; 0
    34cc:	bf dd       	rcall	.-1154   	; 0x304c <vTaskDelay>
    34ce:	ca cf       	rjmp	.-108    	; 0x3464 <vLightAndTemp+0xe>

000034d0 <adc_init>:
    34d0:	cf 93       	push	r28
    34d2:	df 93       	push	r29
    34d4:	cd b7       	in	r28, 0x3d	; 61
    34d6:	de b7       	in	r29, 0x3e	; 62
    34d8:	2b 97       	sbiw	r28, 0x0b	; 11
    34da:	cd bf       	out	0x3d, r28	; 61
    34dc:	de bf       	out	0x3e, r29	; 62
    34de:	be 01       	movw	r22, r28
    34e0:	6f 5f       	subi	r22, 0xFF	; 255
    34e2:	7f 4f       	sbci	r23, 0xFF	; 255
    34e4:	80 e0       	ldi	r24, 0x00	; 0
    34e6:	92 e0       	ldi	r25, 0x02	; 2
    34e8:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <adc_read_configuration>
    34ec:	ae 01       	movw	r20, r28
    34ee:	48 5f       	subi	r20, 0xF8	; 248
    34f0:	5f 4f       	sbci	r21, 0xFF	; 255
    34f2:	61 e0       	ldi	r22, 0x01	; 1
    34f4:	80 e0       	ldi	r24, 0x00	; 0
    34f6:	92 e0       	ldi	r25, 0x02	; 2
    34f8:	0e 94 b9 0e 	call	0x1d72	; 0x1d72 <adcch_read_configuration>
    34fc:	9a 81       	ldd	r25, Y+2	; 0x02
    34fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3500:	8f 78       	andi	r24, 0x8F	; 143
    3502:	80 61       	ori	r24, 0x10	; 16
    3504:	8b 83       	std	Y+3, r24	; 0x03
    3506:	89 2f       	mov	r24, r25
    3508:	81 7e       	andi	r24, 0xE1	; 225
    350a:	8a 83       	std	Y+2, r24	; 0x02
    350c:	1c 82       	std	Y+4, r1	; 0x04
    350e:	86 e0       	ldi	r24, 0x06	; 6
    3510:	8d 83       	std	Y+5, r24	; 0x05
    3512:	81 e0       	ldi	r24, 0x01	; 1
    3514:	88 87       	std	Y+8, r24	; 0x08
    3516:	19 86       	std	Y+9, r1	; 0x09
    3518:	be 01       	movw	r22, r28
    351a:	6f 5f       	subi	r22, 0xFF	; 255
    351c:	7f 4f       	sbci	r23, 0xFF	; 255
    351e:	80 e0       	ldi	r24, 0x00	; 0
    3520:	92 e0       	ldi	r25, 0x02	; 2
    3522:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <adc_write_configuration>
    3526:	ae 01       	movw	r20, r28
    3528:	48 5f       	subi	r20, 0xF8	; 248
    352a:	5f 4f       	sbci	r21, 0xFF	; 255
    352c:	61 e0       	ldi	r22, 0x01	; 1
    352e:	80 e0       	ldi	r24, 0x00	; 0
    3530:	92 e0       	ldi	r25, 0x02	; 2
    3532:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <adcch_write_configuration>
    3536:	2b 96       	adiw	r28, 0x0b	; 11
    3538:	cd bf       	out	0x3d, r28	; 61
    353a:	de bf       	out	0x3e, r29	; 62
    353c:	df 91       	pop	r29
    353e:	cf 91       	pop	r28
    3540:	08 95       	ret

00003542 <setUpSerial>:
    3542:	10 92 a7 08 	sts	0x08A7, r1
    3546:	8c e0       	ldi	r24, 0x0C	; 12
    3548:	80 93 a6 08 	sts	0x08A6, r24
    354c:	10 92 a3 08 	sts	0x08A3, r1
    3550:	83 e0       	ldi	r24, 0x03	; 3
    3552:	80 93 a5 08 	sts	0x08A5, r24
    3556:	88 e1       	ldi	r24, 0x18	; 24
    3558:	80 93 a4 08 	sts	0x08A4, r24
    355c:	08 95       	ret

0000355e <sendChar>:
    355e:	e1 ea       	ldi	r30, 0xA1	; 161
    3560:	f8 e0       	ldi	r31, 0x08	; 8
    3562:	90 81       	ld	r25, Z
    3564:	95 ff       	sbrs	r25, 5
    3566:	fd cf       	rjmp	.-6      	; 0x3562 <sendChar+0x4>
    3568:	80 93 a0 08 	sts	0x08A0, r24
    356c:	08 95       	ret

0000356e <receiveChar>:
    356e:	e1 ea       	ldi	r30, 0xA1	; 161
    3570:	f8 e0       	ldi	r31, 0x08	; 8
    3572:	80 81       	ld	r24, Z
    3574:	88 23       	and	r24, r24
    3576:	ec f7       	brge	.-6      	; 0x3572 <receiveChar+0x4>
    3578:	80 91 a0 08 	lds	r24, 0x08A0
    357c:	08 95       	ret

0000357e <getWaterUsageFromEEPROM>:
    357e:	80 91 12 20 	lds	r24, 0x2012
    3582:	90 91 13 20 	lds	r25, 0x2013
    3586:	0f 96       	adiw	r24, 0x0f	; 15
    3588:	00 de       	rcall	.-1024   	; 0x318a <nvm_eeprom_read_byte>
    358a:	40 91 12 20 	lds	r20, 0x2012
    358e:	50 91 13 20 	lds	r21, 0x2013
    3592:	9f ef       	ldi	r25, 0xFF	; 255
    3594:	94 9f       	mul	r25, r20
    3596:	90 01       	movw	r18, r0
    3598:	95 9f       	mul	r25, r21
    359a:	30 0d       	add	r19, r0
    359c:	11 24       	eor	r1, r1
    359e:	28 0f       	add	r18, r24
    35a0:	31 1d       	adc	r19, r1
    35a2:	20 93 fa 22 	sts	0x22FA, r18
    35a6:	30 93 fb 22 	sts	0x22FB, r19
    35aa:	08 95       	ret

000035ac <getRainTankVolumeFromEEPROM>:
    35ac:	80 91 10 20 	lds	r24, 0x2010
    35b0:	90 91 11 20 	lds	r25, 0x2011
    35b4:	04 96       	adiw	r24, 0x04	; 4
    35b6:	e9 dd       	rcall	.-1070   	; 0x318a <nvm_eeprom_read_byte>
    35b8:	40 91 10 20 	lds	r20, 0x2010
    35bc:	50 91 11 20 	lds	r21, 0x2011
    35c0:	9f ef       	ldi	r25, 0xFF	; 255
    35c2:	94 9f       	mul	r25, r20
    35c4:	90 01       	movw	r18, r0
    35c6:	95 9f       	mul	r25, r21
    35c8:	30 0d       	add	r19, r0
    35ca:	11 24       	eor	r1, r1
    35cc:	28 0f       	add	r18, r24
    35ce:	31 1d       	adc	r19, r1
    35d0:	20 93 f4 22 	sts	0x22F4, r18
    35d4:	30 93 f5 22 	sts	0x22F5, r19
    35d8:	08 95       	ret

000035da <setRainTankVolume>:
    35da:	1f 93       	push	r17
    35dc:	cf 93       	push	r28
    35de:	df 93       	push	r29
    35e0:	80 93 f4 22 	sts	0x22F4, r24
    35e4:	90 93 f5 22 	sts	0x22F5, r25
    35e8:	6f ef       	ldi	r22, 0xFF	; 255
    35ea:	70 e0       	ldi	r23, 0x00	; 0
    35ec:	a5 d4       	rcall	.+2378   	; 0x3f38 <__divmodhi4>
    35ee:	18 2f       	mov	r17, r24
    35f0:	26 2f       	mov	r18, r22
    35f2:	37 2f       	mov	r19, r23
    35f4:	60 93 10 20 	sts	0x2010, r22
    35f8:	70 93 11 20 	sts	0x2011, r23
    35fc:	33 23       	and	r19, r19
    35fe:	84 f0       	brlt	.+32     	; 0x3620 <setRainTankVolume+0x46>
    3600:	c3 e0       	ldi	r28, 0x03	; 3
    3602:	d0 e0       	ldi	r29, 0x00	; 0
    3604:	6f ef       	ldi	r22, 0xFF	; 255
    3606:	ce 01       	movw	r24, r28
    3608:	f4 dd       	rcall	.-1048   	; 0x31f2 <nvm_eeprom_write_byte>
    360a:	21 96       	adiw	r28, 0x01	; 1
    360c:	20 91 10 20 	lds	r18, 0x2010
    3610:	30 91 11 20 	lds	r19, 0x2011
    3614:	a9 01       	movw	r20, r18
    3616:	4d 5f       	subi	r20, 0xFD	; 253
    3618:	5f 4f       	sbci	r21, 0xFF	; 255
    361a:	4c 17       	cp	r20, r28
    361c:	5d 07       	cpc	r21, r29
    361e:	94 f7       	brge	.-28     	; 0x3604 <setRainTankVolume+0x2a>
    3620:	61 2f       	mov	r22, r17
    3622:	c9 01       	movw	r24, r18
    3624:	04 96       	adiw	r24, 0x04	; 4
    3626:	e5 dd       	rcall	.-1078   	; 0x31f2 <nvm_eeprom_write_byte>
    3628:	60 91 10 20 	lds	r22, 0x2010
    362c:	82 e0       	ldi	r24, 0x02	; 2
    362e:	90 e0       	ldi	r25, 0x00	; 0
    3630:	e0 dd       	rcall	.-1088   	; 0x31f2 <nvm_eeprom_write_byte>
    3632:	df 91       	pop	r29
    3634:	cf 91       	pop	r28
    3636:	1f 91       	pop	r17
    3638:	08 95       	ret

0000363a <getDelayBasedOnDebit>:
    363a:	80 91 f6 22 	lds	r24, 0x22F6
    363e:	90 91 f7 22 	lds	r25, 0x22F7
    3642:	00 97       	sbiw	r24, 0x00	; 0
    3644:	39 f4       	brne	.+14     	; 0x3654 <getDelayBasedOnDebit+0x1a>
    3646:	88 e2       	ldi	r24, 0x28	; 40
    3648:	90 e0       	ldi	r25, 0x00	; 0
    364a:	80 93 f0 22 	sts	0x22F0, r24
    364e:	90 93 f1 22 	sts	0x22F1, r25
    3652:	08 95       	ret
    3654:	81 30       	cpi	r24, 0x01	; 1
    3656:	91 05       	cpc	r25, r1
    3658:	39 f4       	brne	.+14     	; 0x3668 <getDelayBasedOnDebit+0x2e>
    365a:	8e e1       	ldi	r24, 0x1E	; 30
    365c:	90 e0       	ldi	r25, 0x00	; 0
    365e:	80 93 f0 22 	sts	0x22F0, r24
    3662:	90 93 f1 22 	sts	0x22F1, r25
    3666:	08 95       	ret
    3668:	82 30       	cpi	r24, 0x02	; 2
    366a:	91 05       	cpc	r25, r1
    366c:	39 f4       	brne	.+14     	; 0x367c <getDelayBasedOnDebit+0x42>
    366e:	84 e1       	ldi	r24, 0x14	; 20
    3670:	90 e0       	ldi	r25, 0x00	; 0
    3672:	80 93 f0 22 	sts	0x22F0, r24
    3676:	90 93 f1 22 	sts	0x22F1, r25
    367a:	08 95       	ret
    367c:	83 30       	cpi	r24, 0x03	; 3
    367e:	91 05       	cpc	r25, r1
    3680:	39 f4       	brne	.+14     	; 0x3690 <getDelayBasedOnDebit+0x56>
    3682:	8a e0       	ldi	r24, 0x0A	; 10
    3684:	90 e0       	ldi	r25, 0x00	; 0
    3686:	80 93 f0 22 	sts	0x22F0, r24
    368a:	90 93 f1 22 	sts	0x22F1, r25
    368e:	08 95       	ret
    3690:	04 97       	sbiw	r24, 0x04	; 4
    3692:	31 f4       	brne	.+12     	; 0x36a0 <getDelayBasedOnDebit+0x66>
    3694:	81 e0       	ldi	r24, 0x01	; 1
    3696:	90 e0       	ldi	r25, 0x00	; 0
    3698:	80 93 f0 22 	sts	0x22F0, r24
    369c:	90 93 f1 22 	sts	0x22F1, r25
    36a0:	08 95       	ret

000036a2 <countWaterUsage>:
    36a2:	cc 24       	eor	r12, r12
    36a4:	ca 94       	dec	r12
    36a6:	d1 2c       	mov	r13, r1
    36a8:	0f 2e       	mov	r0, r31
    36aa:	f2 e1       	ldi	r31, 0x12	; 18
    36ac:	ef 2e       	mov	r14, r31
    36ae:	f0 e2       	ldi	r31, 0x20	; 32
    36b0:	ff 2e       	mov	r15, r31
    36b2:	f0 2d       	mov	r31, r0
    36b4:	60 91 06 23 	lds	r22, 0x2306
    36b8:	70 91 07 23 	lds	r23, 0x2307
    36bc:	20 91 04 23 	lds	r18, 0x2304
    36c0:	30 91 05 23 	lds	r19, 0x2305
    36c4:	40 91 02 23 	lds	r20, 0x2302
    36c8:	50 91 03 23 	lds	r21, 0x2303
    36cc:	80 91 00 23 	lds	r24, 0x2300
    36d0:	90 91 01 23 	lds	r25, 0x2301
    36d4:	61 30       	cpi	r22, 0x01	; 1
    36d6:	71 05       	cpc	r23, r1
    36d8:	49 f0       	breq	.+18     	; 0x36ec <countWaterUsage+0x4a>
    36da:	21 30       	cpi	r18, 0x01	; 1
    36dc:	31 05       	cpc	r19, r1
    36de:	31 f0       	breq	.+12     	; 0x36ec <countWaterUsage+0x4a>
    36e0:	41 30       	cpi	r20, 0x01	; 1
    36e2:	51 05       	cpc	r21, r1
    36e4:	19 f0       	breq	.+6      	; 0x36ec <countWaterUsage+0x4a>
    36e6:	81 30       	cpi	r24, 0x01	; 1
    36e8:	91 05       	cpc	r25, r1
    36ea:	99 f5       	brne	.+102    	; 0x3752 <countWaterUsage+0xb0>
    36ec:	26 0f       	add	r18, r22
    36ee:	37 1f       	adc	r19, r23
    36f0:	24 0f       	add	r18, r20
    36f2:	35 1f       	adc	r19, r21
    36f4:	28 0f       	add	r18, r24
    36f6:	39 1f       	adc	r19, r25
    36f8:	60 91 fa 22 	lds	r22, 0x22FA
    36fc:	70 91 fb 22 	lds	r23, 0x22FB
    3700:	c9 01       	movw	r24, r18
    3702:	86 0f       	add	r24, r22
    3704:	97 1f       	adc	r25, r23
    3706:	80 93 fa 22 	sts	0x22FA, r24
    370a:	90 93 fb 22 	sts	0x22FB, r25
    370e:	b6 01       	movw	r22, r12
    3710:	13 d4       	rcall	.+2086   	; 0x3f38 <__divmodhi4>
    3712:	b8 2e       	mov	r11, r24
    3714:	60 93 12 20 	sts	0x2012, r22
    3718:	70 93 13 20 	sts	0x2013, r23
    371c:	8b 01       	movw	r16, r22
    371e:	02 5f       	subi	r16, 0xF2	; 242
    3720:	1f 4f       	sbci	r17, 0xFF	; 255
    3722:	0e 30       	cpi	r16, 0x0E	; 14
    3724:	11 05       	cpc	r17, r1
    3726:	4c f0       	brlt	.+18     	; 0x373a <countWaterUsage+0x98>
    3728:	ce e0       	ldi	r28, 0x0E	; 14
    372a:	d0 e0       	ldi	r29, 0x00	; 0
    372c:	6f ef       	ldi	r22, 0xFF	; 255
    372e:	ce 01       	movw	r24, r28
    3730:	60 dd       	rcall	.-1344   	; 0x31f2 <nvm_eeprom_write_byte>
    3732:	21 96       	adiw	r28, 0x01	; 1
    3734:	0c 17       	cp	r16, r28
    3736:	1d 07       	cpc	r17, r29
    3738:	cc f7       	brge	.-14     	; 0x372c <countWaterUsage+0x8a>
    373a:	80 91 12 20 	lds	r24, 0x2012
    373e:	90 91 13 20 	lds	r25, 0x2013
    3742:	6b 2d       	mov	r22, r11
    3744:	0f 96       	adiw	r24, 0x0f	; 15
    3746:	55 dd       	rcall	.-1366   	; 0x31f2 <nvm_eeprom_write_byte>
    3748:	f7 01       	movw	r30, r14
    374a:	60 81       	ld	r22, Z
    374c:	81 e0       	ldi	r24, 0x01	; 1
    374e:	90 e0       	ldi	r25, 0x00	; 0
    3750:	50 dd       	rcall	.-1376   	; 0x31f2 <nvm_eeprom_write_byte>
    3752:	73 df       	rcall	.-282    	; 0x363a <getDelayBasedOnDebit>
    3754:	80 91 f0 22 	lds	r24, 0x22F0
    3758:	90 91 f1 22 	lds	r25, 0x22F1
    375c:	77 dc       	rcall	.-1810   	; 0x304c <vTaskDelay>
    375e:	aa cf       	rjmp	.-172    	; 0x36b4 <countWaterUsage+0x12>

00003760 <closeTap>:
    3760:	e0 e4       	ldi	r30, 0x40	; 64
    3762:	f6 e0       	ldi	r31, 0x06	; 6
    3764:	80 81       	ld	r24, Z
    3766:	81 60       	ori	r24, 0x01	; 1
    3768:	80 83       	st	Z, r24
    376a:	e0 e0       	ldi	r30, 0x00	; 0
    376c:	f8 e0       	ldi	r31, 0x08	; 8
    376e:	85 e0       	ldi	r24, 0x05	; 5
    3770:	80 83       	st	Z, r24
    3772:	86 e1       	ldi	r24, 0x16	; 22
    3774:	81 83       	std	Z+1, r24	; 0x01
    3776:	80 e4       	ldi	r24, 0x40	; 64
    3778:	9f e1       	ldi	r25, 0x1F	; 31
    377a:	86 a3       	std	Z+38, r24	; 0x26
    377c:	97 a3       	std	Z+39, r25	; 0x27
    377e:	87 e7       	ldi	r24, 0x77	; 119
    3780:	91 e0       	ldi	r25, 0x01	; 1
    3782:	80 a7       	std	Z+40, r24	; 0x28
    3784:	91 a7       	std	Z+41, r25	; 0x29
    3786:	08 95       	ret

00003788 <openTap>:
    3788:	e0 e4       	ldi	r30, 0x40	; 64
    378a:	f6 e0       	ldi	r31, 0x06	; 6
    378c:	80 81       	ld	r24, Z
    378e:	81 60       	ori	r24, 0x01	; 1
    3790:	80 83       	st	Z, r24
    3792:	e0 e0       	ldi	r30, 0x00	; 0
    3794:	f8 e0       	ldi	r31, 0x08	; 8
    3796:	85 e0       	ldi	r24, 0x05	; 5
    3798:	80 83       	st	Z, r24
    379a:	86 e1       	ldi	r24, 0x16	; 22
    379c:	81 83       	std	Z+1, r24	; 0x01
    379e:	80 e4       	ldi	r24, 0x40	; 64
    37a0:	9f e1       	ldi	r25, 0x1F	; 31
    37a2:	86 a3       	std	Z+38, r24	; 0x26
    37a4:	97 a3       	std	Z+39, r25	; 0x27
    37a6:	81 e0       	ldi	r24, 0x01	; 1
    37a8:	90 e0       	ldi	r25, 0x00	; 0
    37aa:	80 a7       	std	Z+40, r24	; 0x28
    37ac:	91 a7       	std	Z+41, r25	; 0x29
    37ae:	08 95       	ret

000037b0 <watering>:
    37b0:	01 e0       	ldi	r16, 0x01	; 1
    37b2:	10 e0       	ldi	r17, 0x00	; 0
    37b4:	20 91 f2 22 	lds	r18, 0x22F2
    37b8:	30 91 f3 22 	lds	r19, 0x22F3
    37bc:	21 30       	cpi	r18, 0x01	; 1
    37be:	31 05       	cpc	r19, r1
    37c0:	99 f5       	brne	.+102    	; 0x3828 <watering+0x78>
    37c2:	80 91 ec 22 	lds	r24, 0x22EC
    37c6:	90 91 ed 22 	lds	r25, 0x22ED
    37ca:	01 97       	sbiw	r24, 0x01	; 1
    37cc:	99 f7       	brne	.-26     	; 0x37b4 <watering+0x4>
    37ce:	00 93 fe 22 	sts	0x22FE, r16
    37d2:	10 93 ff 22 	sts	0x22FF, r17
    37d6:	d8 df       	rcall	.-80     	; 0x3788 <openTap>
    37d8:	80 91 f2 22 	lds	r24, 0x22F2
    37dc:	90 91 f3 22 	lds	r25, 0x22F3
    37e0:	01 97       	sbiw	r24, 0x01	; 1
    37e2:	09 f4       	brne	.+2      	; 0x37e6 <watering+0x36>
    37e4:	49 c0       	rjmp	.+146    	; 0x3878 <watering+0xc8>
    37e6:	c4 e1       	ldi	r28, 0x14	; 20
    37e8:	d0 e0       	ldi	r29, 0x00	; 0
    37ea:	0d c0       	rjmp	.+26     	; 0x3806 <watering+0x56>
    37ec:	21 97       	sbiw	r28, 0x01	; 1
    37ee:	c8 01       	movw	r24, r16
    37f0:	2d dc       	rcall	.-1958   	; 0x304c <vTaskDelay>
    37f2:	cf 3f       	cpi	r28, 0xFF	; 255
    37f4:	8f ef       	ldi	r24, 0xFF	; 255
    37f6:	d8 07       	cpc	r29, r24
    37f8:	31 f0       	breq	.+12     	; 0x3806 <watering+0x56>
    37fa:	80 91 f2 22 	lds	r24, 0x22F2
    37fe:	90 91 f3 22 	lds	r25, 0x22F3
    3802:	01 97       	sbiw	r24, 0x01	; 1
    3804:	99 f3       	breq	.-26     	; 0x37ec <watering+0x3c>
    3806:	ac df       	rcall	.-168    	; 0x3760 <closeTap>
    3808:	80 91 f4 22 	lds	r24, 0x22F4
    380c:	90 91 f5 22 	lds	r25, 0x22F5
    3810:	8c 1b       	sub	r24, r28
    3812:	9d 0b       	sbc	r25, r29
    3814:	80 93 f4 22 	sts	0x22F4, r24
    3818:	90 93 f5 22 	sts	0x22F5, r25
    381c:	de de       	rcall	.-580    	; 0x35da <setRainTankVolume>
    381e:	10 92 fe 22 	sts	0x22FE, r1
    3822:	10 92 ff 22 	sts	0x22FF, r1
    3826:	c6 cf       	rjmp	.-116    	; 0x37b4 <watering+0x4>
    3828:	23 2b       	or	r18, r19
    382a:	09 f0       	breq	.+2      	; 0x382e <watering+0x7e>
    382c:	c3 cf       	rjmp	.-122    	; 0x37b4 <watering+0x4>
    382e:	80 91 fe 22 	lds	r24, 0x22FE
    3832:	90 91 ff 22 	lds	r25, 0x22FF
    3836:	01 97       	sbiw	r24, 0x01	; 1
    3838:	09 f0       	breq	.+2      	; 0x383c <watering+0x8c>
    383a:	bc cf       	rjmp	.-136    	; 0x37b4 <watering+0x4>
    383c:	20 91 f4 22 	lds	r18, 0x22F4
    3840:	30 91 f5 22 	lds	r19, 0x22F5
    3844:	33 23       	and	r19, r19
    3846:	ac f0       	brlt	.+42     	; 0x3872 <watering+0xc2>
    3848:	21 50       	subi	r18, 0x01	; 1
    384a:	31 09       	sbc	r19, r1
    384c:	20 93 f4 22 	sts	0x22F4, r18
    3850:	30 93 f5 22 	sts	0x22F5, r19
    3854:	85 e0       	ldi	r24, 0x05	; 5
    3856:	90 e0       	ldi	r25, 0x00	; 0
    3858:	f9 db       	rcall	.-2062   	; 0x304c <vTaskDelay>
    385a:	20 91 f4 22 	lds	r18, 0x22F4
    385e:	30 91 f5 22 	lds	r19, 0x22F5
    3862:	33 23       	and	r19, r19
    3864:	34 f0       	brlt	.+12     	; 0x3872 <watering+0xc2>
    3866:	80 91 fe 22 	lds	r24, 0x22FE
    386a:	90 91 ff 22 	lds	r25, 0x22FF
    386e:	01 97       	sbiw	r24, 0x01	; 1
    3870:	59 f3       	breq	.-42     	; 0x3848 <watering+0x98>
    3872:	c9 01       	movw	r24, r18
    3874:	b2 de       	rcall	.-668    	; 0x35da <setRainTankVolume>
    3876:	9e cf       	rjmp	.-196    	; 0x37b4 <watering+0x4>
    3878:	c8 01       	movw	r24, r16
    387a:	e8 db       	rcall	.-2096   	; 0x304c <vTaskDelay>
    387c:	c3 e1       	ldi	r28, 0x13	; 19
    387e:	d0 e0       	ldi	r29, 0x00	; 0
    3880:	bc cf       	rjmp	.-136    	; 0x37fa <watering+0x4a>

00003882 <vReceiver>:
    3882:	80 e1       	ldi	r24, 0x10	; 16
    3884:	80 93 85 06 	sts	0x0685, r24
    3888:	00 ee       	ldi	r16, 0xE0	; 224
    388a:	17 e0       	ldi	r17, 0x07	; 7
    388c:	dd 24       	eor	r13, r13
    388e:	d3 94       	inc	r13
    3890:	68 94       	set
    3892:	cc 24       	eor	r12, r12
    3894:	c1 f8       	bld	r12, 1
    3896:	c1 e0       	ldi	r28, 0x01	; 1
    3898:	d0 e0       	ldi	r29, 0x00	; 0
    389a:	0f 2e       	mov	r0, r31
    389c:	f0 e6       	ldi	r31, 0x60	; 96
    389e:	ef 2e       	mov	r14, r31
    38a0:	f6 e0       	ldi	r31, 0x06	; 6
    38a2:	ff 2e       	mov	r15, r31
    38a4:	f0 2d       	mov	r31, r0
    38a6:	68 94       	set
    38a8:	aa 24       	eor	r10, r10
    38aa:	a5 f8       	bld	r10, 5
    38ac:	68 94       	set
    38ae:	bb 24       	eor	r11, r11
    38b0:	b4 f8       	bld	r11, 4
    38b2:	5d de       	rcall	.-838    	; 0x356e <receiveChar>
    38b4:	81 36       	cpi	r24, 0x61	; 97
    38b6:	79 f4       	brne	.+30     	; 0x38d6 <vReceiver+0x54>
    38b8:	80 91 06 23 	lds	r24, 0x2306
    38bc:	90 91 07 23 	lds	r25, 0x2307
    38c0:	89 2b       	or	r24, r25
    38c2:	09 f0       	breq	.+2      	; 0x38c6 <vReceiver+0x44>
    38c4:	c2 c0       	rjmp	.+388    	; 0x3a4a <vReceiver+0x1c8>
    38c6:	f8 01       	movw	r30, r16
    38c8:	d6 82       	std	Z+6, r13	; 0x06
    38ca:	5e df       	rcall	.-324    	; 0x3788 <openTap>
    38cc:	c0 93 06 23 	sts	0x2306, r28
    38d0:	d0 93 07 23 	sts	0x2307, r29
    38d4:	ba c0       	rjmp	.+372    	; 0x3a4a <vReceiver+0x1c8>
    38d6:	81 33       	cpi	r24, 0x31	; 49
    38d8:	79 f4       	brne	.+30     	; 0x38f8 <vReceiver+0x76>
    38da:	80 91 06 23 	lds	r24, 0x2306
    38de:	90 91 07 23 	lds	r25, 0x2307
    38e2:	01 97       	sbiw	r24, 0x01	; 1
    38e4:	09 f0       	breq	.+2      	; 0x38e8 <vReceiver+0x66>
    38e6:	b1 c0       	rjmp	.+354    	; 0x3a4a <vReceiver+0x1c8>
    38e8:	f8 01       	movw	r30, r16
    38ea:	d5 82       	std	Z+5, r13	; 0x05
    38ec:	39 df       	rcall	.-398    	; 0x3760 <closeTap>
    38ee:	10 92 06 23 	sts	0x2306, r1
    38f2:	10 92 07 23 	sts	0x2307, r1
    38f6:	a9 c0       	rjmp	.+338    	; 0x3a4a <vReceiver+0x1c8>
    38f8:	82 36       	cpi	r24, 0x62	; 98
    38fa:	79 f4       	brne	.+30     	; 0x391a <vReceiver+0x98>
    38fc:	80 91 04 23 	lds	r24, 0x2304
    3900:	90 91 05 23 	lds	r25, 0x2305
    3904:	89 2b       	or	r24, r25
    3906:	09 f0       	breq	.+2      	; 0x390a <vReceiver+0x88>
    3908:	a0 c0       	rjmp	.+320    	; 0x3a4a <vReceiver+0x1c8>
    390a:	f8 01       	movw	r30, r16
    390c:	c6 82       	std	Z+6, r12	; 0x06
    390e:	3c df       	rcall	.-392    	; 0x3788 <openTap>
    3910:	c0 93 04 23 	sts	0x2304, r28
    3914:	d0 93 05 23 	sts	0x2305, r29
    3918:	98 c0       	rjmp	.+304    	; 0x3a4a <vReceiver+0x1c8>
    391a:	82 33       	cpi	r24, 0x32	; 50
    391c:	79 f4       	brne	.+30     	; 0x393c <vReceiver+0xba>
    391e:	80 91 04 23 	lds	r24, 0x2304
    3922:	90 91 05 23 	lds	r25, 0x2305
    3926:	01 97       	sbiw	r24, 0x01	; 1
    3928:	09 f0       	breq	.+2      	; 0x392c <vReceiver+0xaa>
    392a:	8f c0       	rjmp	.+286    	; 0x3a4a <vReceiver+0x1c8>
    392c:	f8 01       	movw	r30, r16
    392e:	c5 82       	std	Z+5, r12	; 0x05
    3930:	17 df       	rcall	.-466    	; 0x3760 <closeTap>
    3932:	10 92 04 23 	sts	0x2304, r1
    3936:	10 92 05 23 	sts	0x2305, r1
    393a:	87 c0       	rjmp	.+270    	; 0x3a4a <vReceiver+0x1c8>
    393c:	83 36       	cpi	r24, 0x63	; 99
    393e:	79 f4       	brne	.+30     	; 0x395e <vReceiver+0xdc>
    3940:	80 91 02 23 	lds	r24, 0x2302
    3944:	90 91 03 23 	lds	r25, 0x2303
    3948:	89 2b       	or	r24, r25
    394a:	09 f0       	breq	.+2      	; 0x394e <vReceiver+0xcc>
    394c:	7e c0       	rjmp	.+252    	; 0x3a4a <vReceiver+0x1c8>
    394e:	f7 01       	movw	r30, r14
    3950:	b6 82       	std	Z+6, r11	; 0x06
    3952:	1a df       	rcall	.-460    	; 0x3788 <openTap>
    3954:	c0 93 02 23 	sts	0x2302, r28
    3958:	d0 93 03 23 	sts	0x2303, r29
    395c:	76 c0       	rjmp	.+236    	; 0x3a4a <vReceiver+0x1c8>
    395e:	83 33       	cpi	r24, 0x33	; 51
    3960:	79 f4       	brne	.+30     	; 0x3980 <vReceiver+0xfe>
    3962:	80 91 06 23 	lds	r24, 0x2306
    3966:	90 91 07 23 	lds	r25, 0x2307
    396a:	01 97       	sbiw	r24, 0x01	; 1
    396c:	09 f0       	breq	.+2      	; 0x3970 <vReceiver+0xee>
    396e:	6d c0       	rjmp	.+218    	; 0x3a4a <vReceiver+0x1c8>
    3970:	f7 01       	movw	r30, r14
    3972:	b5 82       	std	Z+5, r11	; 0x05
    3974:	f5 de       	rcall	.-534    	; 0x3760 <closeTap>
    3976:	10 92 02 23 	sts	0x2302, r1
    397a:	10 92 03 23 	sts	0x2303, r1
    397e:	65 c0       	rjmp	.+202    	; 0x3a4a <vReceiver+0x1c8>
    3980:	84 36       	cpi	r24, 0x64	; 100
    3982:	79 f4       	brne	.+30     	; 0x39a2 <vReceiver+0x120>
    3984:	80 91 00 23 	lds	r24, 0x2300
    3988:	90 91 01 23 	lds	r25, 0x2301
    398c:	89 2b       	or	r24, r25
    398e:	09 f0       	breq	.+2      	; 0x3992 <vReceiver+0x110>
    3990:	5c c0       	rjmp	.+184    	; 0x3a4a <vReceiver+0x1c8>
    3992:	f7 01       	movw	r30, r14
    3994:	a6 82       	std	Z+6, r10	; 0x06
    3996:	f8 de       	rcall	.-528    	; 0x3788 <openTap>
    3998:	c0 93 00 23 	sts	0x2300, r28
    399c:	d0 93 01 23 	sts	0x2301, r29
    39a0:	54 c0       	rjmp	.+168    	; 0x3a4a <vReceiver+0x1c8>
    39a2:	84 33       	cpi	r24, 0x34	; 52
    39a4:	79 f4       	brne	.+30     	; 0x39c4 <vReceiver+0x142>
    39a6:	80 91 00 23 	lds	r24, 0x2300
    39aa:	90 91 01 23 	lds	r25, 0x2301
    39ae:	01 97       	sbiw	r24, 0x01	; 1
    39b0:	09 f0       	breq	.+2      	; 0x39b4 <vReceiver+0x132>
    39b2:	4b c0       	rjmp	.+150    	; 0x3a4a <vReceiver+0x1c8>
    39b4:	f7 01       	movw	r30, r14
    39b6:	a5 82       	std	Z+5, r10	; 0x05
    39b8:	d3 de       	rcall	.-602    	; 0x3760 <closeTap>
    39ba:	10 92 00 23 	sts	0x2300, r1
    39be:	10 92 01 23 	sts	0x2301, r1
    39c2:	43 c0       	rjmp	.+134    	; 0x3a4a <vReceiver+0x1c8>
    39c4:	86 36       	cpi	r24, 0x66	; 102
    39c6:	29 f4       	brne	.+10     	; 0x39d2 <vReceiver+0x150>
    39c8:	c0 93 f2 22 	sts	0x22F2, r28
    39cc:	d0 93 f3 22 	sts	0x22F3, r29
    39d0:	3c c0       	rjmp	.+120    	; 0x3a4a <vReceiver+0x1c8>
    39d2:	86 33       	cpi	r24, 0x36	; 54
    39d4:	29 f4       	brne	.+10     	; 0x39e0 <vReceiver+0x15e>
    39d6:	10 92 f2 22 	sts	0x22F2, r1
    39da:	10 92 f3 22 	sts	0x22F3, r1
    39de:	35 c0       	rjmp	.+106    	; 0x3a4a <vReceiver+0x1c8>
    39e0:	87 36       	cpi	r24, 0x67	; 103
    39e2:	a9 f4       	brne	.+42     	; 0x3a0e <vReceiver+0x18c>
    39e4:	80 91 f2 22 	lds	r24, 0x22F2
    39e8:	90 91 f3 22 	lds	r25, 0x22F3
    39ec:	89 2b       	or	r24, r25
    39ee:	69 f5       	brne	.+90     	; 0x3a4a <vReceiver+0x1c8>
    39f0:	80 91 fe 22 	lds	r24, 0x22FE
    39f4:	90 91 ff 22 	lds	r25, 0x22FF
    39f8:	89 2b       	or	r24, r25
    39fa:	39 f5       	brne	.+78     	; 0x3a4a <vReceiver+0x1c8>
    39fc:	f8 01       	movw	r30, r16
    39fe:	d6 82       	std	Z+6, r13	; 0x06
    3a00:	c6 82       	std	Z+6, r12	; 0x06
    3a02:	c2 de       	rcall	.-636    	; 0x3788 <openTap>
    3a04:	c0 93 fe 22 	sts	0x22FE, r28
    3a08:	d0 93 ff 22 	sts	0x22FF, r29
    3a0c:	1e c0       	rjmp	.+60     	; 0x3a4a <vReceiver+0x1c8>
    3a0e:	87 33       	cpi	r24, 0x37	; 55
    3a10:	a9 f4       	brne	.+42     	; 0x3a3c <vReceiver+0x1ba>
    3a12:	80 91 f2 22 	lds	r24, 0x22F2
    3a16:	90 91 f3 22 	lds	r25, 0x22F3
    3a1a:	89 2b       	or	r24, r25
    3a1c:	b1 f4       	brne	.+44     	; 0x3a4a <vReceiver+0x1c8>
    3a1e:	80 91 fe 22 	lds	r24, 0x22FE
    3a22:	90 91 ff 22 	lds	r25, 0x22FF
    3a26:	01 97       	sbiw	r24, 0x01	; 1
    3a28:	81 f4       	brne	.+32     	; 0x3a4a <vReceiver+0x1c8>
    3a2a:	f8 01       	movw	r30, r16
    3a2c:	d5 82       	std	Z+5, r13	; 0x05
    3a2e:	c5 82       	std	Z+5, r12	; 0x05
    3a30:	97 de       	rcall	.-722    	; 0x3760 <closeTap>
    3a32:	10 92 fe 22 	sts	0x22FE, r1
    3a36:	10 92 ff 22 	sts	0x22FF, r1
    3a3a:	07 c0       	rjmp	.+14     	; 0x3a4a <vReceiver+0x1c8>
    3a3c:	80 37       	cpi	r24, 0x70	; 112
    3a3e:	11 f4       	brne	.+4      	; 0x3a44 <vReceiver+0x1c2>
    3a40:	8e dd       	rcall	.-1252   	; 0x355e <sendChar>
    3a42:	03 c0       	rjmp	.+6      	; 0x3a4a <vReceiver+0x1c8>
    3a44:	81 37       	cpi	r24, 0x71	; 113
    3a46:	09 f4       	brne	.+2      	; 0x3a4a <vReceiver+0x1c8>
    3a48:	8a dd       	rcall	.-1260   	; 0x355e <sendChar>
    3a4a:	ce 01       	movw	r24, r28
    3a4c:	ff da       	rcall	.-2562   	; 0x304c <vTaskDelay>
    3a4e:	31 cf       	rjmp	.-414    	; 0x38b2 <vReceiver+0x30>

00003a50 <waterAlertOn>:
    3a50:	81 e0       	ldi	r24, 0x01	; 1
    3a52:	80 93 80 06 	sts	0x0680, r24
    3a56:	80 93 84 06 	sts	0x0684, r24
    3a5a:	08 95       	ret

00003a5c <waterAlertOff>:
    3a5c:	81 e0       	ldi	r24, 0x01	; 1
    3a5e:	80 93 80 06 	sts	0x0680, r24
    3a62:	10 92 84 06 	sts	0x0684, r1
    3a66:	08 95       	ret

00003a68 <waterAlertTask>:
    3a68:	00 e8       	ldi	r16, 0x80	; 128
    3a6a:	16 e0       	ldi	r17, 0x06	; 6
    3a6c:	c0 e1       	ldi	r28, 0x10	; 16
    3a6e:	f8 01       	movw	r30, r16
    3a70:	c5 83       	std	Z+5, r28	; 0x05
    3a72:	20 91 fa 22 	lds	r18, 0x22FA
    3a76:	30 91 fb 22 	lds	r19, 0x22FB
    3a7a:	80 91 f8 22 	lds	r24, 0x22F8
    3a7e:	90 91 f9 22 	lds	r25, 0x22F9
    3a82:	82 17       	cp	r24, r18
    3a84:	93 07       	cpc	r25, r19
    3a86:	ec f4       	brge	.+58     	; 0x3ac2 <waterAlertTask+0x5a>
    3a88:	80 91 06 23 	lds	r24, 0x2306
    3a8c:	90 91 07 23 	lds	r25, 0x2307
    3a90:	01 97       	sbiw	r24, 0x01	; 1
    3a92:	91 f0       	breq	.+36     	; 0x3ab8 <waterAlertTask+0x50>
    3a94:	80 91 04 23 	lds	r24, 0x2304
    3a98:	90 91 05 23 	lds	r25, 0x2305
    3a9c:	01 97       	sbiw	r24, 0x01	; 1
    3a9e:	61 f0       	breq	.+24     	; 0x3ab8 <waterAlertTask+0x50>
    3aa0:	80 91 02 23 	lds	r24, 0x2302
    3aa4:	90 91 03 23 	lds	r25, 0x2303
    3aa8:	01 97       	sbiw	r24, 0x01	; 1
    3aaa:	31 f0       	breq	.+12     	; 0x3ab8 <waterAlertTask+0x50>
    3aac:	80 91 00 23 	lds	r24, 0x2300
    3ab0:	90 91 01 23 	lds	r25, 0x2301
    3ab4:	01 97       	sbiw	r24, 0x01	; 1
    3ab6:	29 f4       	brne	.+10     	; 0x3ac2 <waterAlertTask+0x5a>
    3ab8:	cb df       	rcall	.-106    	; 0x3a50 <waterAlertOn>
    3aba:	85 e0       	ldi	r24, 0x05	; 5
    3abc:	90 e0       	ldi	r25, 0x00	; 0
    3abe:	c6 da       	rcall	.-2676   	; 0x304c <vTaskDelay>
    3ac0:	cd df       	rcall	.-102    	; 0x3a5c <waterAlertOff>
    3ac2:	8a e0       	ldi	r24, 0x0A	; 10
    3ac4:	90 e0       	ldi	r25, 0x00	; 0
    3ac6:	c2 da       	rcall	.-2684   	; 0x304c <vTaskDelay>
    3ac8:	d2 cf       	rjmp	.-92     	; 0x3a6e <waterAlertTask+0x6>

00003aca <main>:
		vTaskDelay(1);
	}
}

int main (void)
{
    3aca:	af 92       	push	r10
    3acc:	bf 92       	push	r11
    3ace:	cf 92       	push	r12
    3ad0:	df 92       	push	r13
    3ad2:	ef 92       	push	r14
    3ad4:	ff 92       	push	r15
    3ad6:	0f 93       	push	r16
	board_init(); //konfigurasi awal board
    3ad8:	e9 db       	rcall	.-2094   	; 0x32ac <board_init>
	//sysclk_init(); //konfigurasi awal system clock
	adc_sensors_init();// konfigurasi adc
    3ada:	0e 94 64 08 	call	0x10c8	; 0x10c8 <adc_sensors_init>
	gfx_mono_init(); //konfigurasi awal LCD monochrom
    3ade:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <gfx_mono_st7565r_init>
	tb_init(); //konfigurasi touch button
    3ae2:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <tb_init>
	cpu_irq_enable(); // konfigurasi untuk menghidupkan interrupt
    3ae6:	78 94       	sei
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    3ae8:	87 e0       	ldi	r24, 0x07	; 7
    3aea:	80 93 a2 00 	sts	0x00A2, r24
	pmic_init(); //konfigurasi untuk menyalakan semua interrupt dan mengatur prioritas task
	//pwm_init();
	adc_init();
    3aee:	f0 dc       	rcall	.-1568   	; 0x34d0 <adc_init>
    3af0:	80 e1       	ldi	r24, 0x10	; 16
    3af2:	80 93 85 06 	sts	0x0685, r24
	
	gpio_set_pin_high(NHD_C12832A1Z_BACKLIGHT);
	
	PORTC_OUTSET = PIN3_bm;
    3af6:	88 e0       	ldi	r24, 0x08	; 8
    3af8:	80 93 45 06 	sts	0x0645, r24
	PORTC_DIRSET = PIN3_bm;
    3afc:	80 93 41 06 	sts	0x0641, r24
	
	PORTC_OUTCLR = PIN2_bm;
    3b00:	84 e0       	ldi	r24, 0x04	; 4
    3b02:	80 93 46 06 	sts	0x0646, r24
	PORTC_DIRCLR = PIN2_bm;
    3b06:	80 93 42 06 	sts	0x0642, r24
	
	setUpSerial();
    3b0a:	1b dd       	rcall	.-1482   	; 0x3542 <setUpSerial>
	
	eeprom_flag = nvm_eeprom_read_byte(0);
    3b0c:	80 e0       	ldi	r24, 0x00	; 0
    3b0e:	90 e0       	ldi	r25, 0x00	; 0
    3b10:	3c db       	rcall	.-2440   	; 0x318a <nvm_eeprom_read_byte>
    3b12:	90 e0       	ldi	r25, 0x00	; 0
    3b14:	80 93 ee 22 	sts	0x22EE, r24
    3b18:	90 93 ef 22 	sts	0x22EF, r25
	if(eeprom_flag==255){
    3b1c:	8f 3f       	cpi	r24, 0xFF	; 255
    3b1e:	91 05       	cpc	r25, r1
    3b20:	91 f4       	brne	.+36     	; 0x3b46 <main+0x7c>
		nvm_eeprom_write_byte(0, 0);
    3b22:	60 e0       	ldi	r22, 0x00	; 0
    3b24:	80 e0       	ldi	r24, 0x00	; 0
    3b26:	90 e0       	ldi	r25, 0x00	; 0
    3b28:	64 db       	rcall	.-2360   	; 0x31f2 <nvm_eeprom_write_byte>
		nvm_eeprom_write_byte(1, waterUsageIndex);
    3b2a:	60 91 12 20 	lds	r22, 0x2012
    3b2e:	81 e0       	ldi	r24, 0x01	; 1
    3b30:	90 e0       	ldi	r25, 0x00	; 0
    3b32:	5f db       	rcall	.-2370   	; 0x31f2 <nvm_eeprom_write_byte>
		nvm_eeprom_write_byte(2, rainTankVolumeIndex);
    3b34:	60 91 10 20 	lds	r22, 0x2010
    3b38:	82 e0       	ldi	r24, 0x02	; 2
    3b3a:	90 e0       	ldi	r25, 0x00	; 0
    3b3c:	5a db       	rcall	.-2380   	; 0x31f2 <nvm_eeprom_write_byte>
		setRainTankVolume(2550);
    3b3e:	86 ef       	ldi	r24, 0xF6	; 246
    3b40:	99 e0       	ldi	r25, 0x09	; 9
    3b42:	4b dd       	rcall	.-1386   	; 0x35da <setRainTankVolume>
    3b44:	14 c0       	rjmp	.+40     	; 0x3b6e <main+0xa4>
	} else if(eeprom_flag==0) {
    3b46:	89 2b       	or	r24, r25
    3b48:	91 f4       	brne	.+36     	; 0x3b6e <main+0xa4>
		waterUsageIndex = nvm_eeprom_read_byte(1);
    3b4a:	81 e0       	ldi	r24, 0x01	; 1
    3b4c:	90 e0       	ldi	r25, 0x00	; 0
    3b4e:	1d db       	rcall	.-2502   	; 0x318a <nvm_eeprom_read_byte>
    3b50:	90 e0       	ldi	r25, 0x00	; 0
    3b52:	80 93 12 20 	sts	0x2012, r24
    3b56:	90 93 13 20 	sts	0x2013, r25
		rainTankVolumeIndex = nvm_eeprom_read_byte(2);
    3b5a:	82 e0       	ldi	r24, 0x02	; 2
    3b5c:	90 e0       	ldi	r25, 0x00	; 0
    3b5e:	15 db       	rcall	.-2518   	; 0x318a <nvm_eeprom_read_byte>
    3b60:	90 e0       	ldi	r25, 0x00	; 0
    3b62:	80 93 10 20 	sts	0x2010, r24
    3b66:	90 93 11 20 	sts	0x2011, r25
		getWaterUsageFromEEPROM();
    3b6a:	09 dd       	rcall	.-1518   	; 0x357e <getWaterUsageFromEEPROM>
		getRainTankVolumeFromEEPROM();
    3b6c:	1f dd       	rcall	.-1474   	; 0x35ac <getRainTankVolumeFromEEPROM>
	int remain = nvm_eeprom_read_byte(rainTankVolumeIndex+4);
	rainTankVolume = (rainTankVolumeIndex)*255+remain;
}

void setMaxWater(int max) {
	maxWater = max;
    3b6e:	88 e8       	ldi	r24, 0x88	; 136
    3b70:	93 e1       	ldi	r25, 0x13	; 19
    3b72:	80 93 f8 22 	sts	0x22F8, r24
    3b76:	90 93 f9 22 	sts	0x22F9, r25
		getRainTankVolumeFromEEPROM();
	}
	
	setMaxWater(5000);
	
	xTaskCreate(vReceiver, "", 200, NULL, 1, NULL);				// task to receive command
    3b7a:	a1 2c       	mov	r10, r1
    3b7c:	b1 2c       	mov	r11, r1
    3b7e:	c1 2c       	mov	r12, r1
    3b80:	d1 2c       	mov	r13, r1
    3b82:	e1 2c       	mov	r14, r1
    3b84:	f1 2c       	mov	r15, r1
    3b86:	01 e0       	ldi	r16, 0x01	; 1
    3b88:	20 e0       	ldi	r18, 0x00	; 0
    3b8a:	30 e0       	ldi	r19, 0x00	; 0
    3b8c:	48 ec       	ldi	r20, 0xC8	; 200
    3b8e:	50 e0       	ldi	r21, 0x00	; 0
    3b90:	61 e3       	ldi	r22, 0x31	; 49
    3b92:	70 e2       	ldi	r23, 0x20	; 32
    3b94:	81 e4       	ldi	r24, 0x41	; 65
    3b96:	9c e1       	ldi	r25, 0x1C	; 28
    3b98:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <xTaskGenericCreate>
	xTaskCreate(watering, "", 200, NULL, 1, NULL);				// watering from rain tank triggered by isAutoWatering
    3b9c:	20 e0       	ldi	r18, 0x00	; 0
    3b9e:	30 e0       	ldi	r19, 0x00	; 0
    3ba0:	48 ec       	ldi	r20, 0xC8	; 200
    3ba2:	50 e0       	ldi	r21, 0x00	; 0
    3ba4:	61 e3       	ldi	r22, 0x31	; 49
    3ba6:	70 e2       	ldi	r23, 0x20	; 32
    3ba8:	88 ed       	ldi	r24, 0xD8	; 216
    3baa:	9b e1       	ldi	r25, 0x1B	; 27
    3bac:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <xTaskGenericCreate>
	xTaskCreate(vLightAndTemp, "", 200, NULL, 1, NULL);			// light intensity 
    3bb0:	20 e0       	ldi	r18, 0x00	; 0
    3bb2:	30 e0       	ldi	r19, 0x00	; 0
    3bb4:	48 ec       	ldi	r20, 0xC8	; 200
    3bb6:	50 e0       	ldi	r21, 0x00	; 0
    3bb8:	61 e3       	ldi	r22, 0x31	; 49
    3bba:	70 e2       	ldi	r23, 0x20	; 32
    3bbc:	8b e2       	ldi	r24, 0x2B	; 43
    3bbe:	9a e1       	ldi	r25, 0x1A	; 26
    3bc0:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <xTaskGenericCreate>
	xTaskCreate(countWaterUsage, "", 400, NULL, 1, NULL);		// triggered when isTapXOpened=1, X = {1, 2, 3, 4}
    3bc4:	20 e0       	ldi	r18, 0x00	; 0
    3bc6:	30 e0       	ldi	r19, 0x00	; 0
    3bc8:	40 e9       	ldi	r20, 0x90	; 144
    3bca:	51 e0       	ldi	r21, 0x01	; 1
    3bcc:	61 e3       	ldi	r22, 0x31	; 49
    3bce:	70 e2       	ldi	r23, 0x20	; 32
    3bd0:	81 e5       	ldi	r24, 0x51	; 81
    3bd2:	9b e1       	ldi	r25, 0x1B	; 27
    3bd4:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <xTaskGenericCreate>
	xTaskCreate(setWaterDebit, "", 200, NULL, 1, NULL);			// set debit from potensiometer
    3bd8:	20 e0       	ldi	r18, 0x00	; 0
    3bda:	30 e0       	ldi	r19, 0x00	; 0
    3bdc:	48 ec       	ldi	r20, 0xC8	; 200
    3bde:	50 e0       	ldi	r21, 0x00	; 0
    3be0:	61 e3       	ldi	r22, 0x31	; 49
    3be2:	70 e2       	ldi	r23, 0x20	; 32
    3be4:	82 e0       	ldi	r24, 0x02	; 2
    3be6:	9a e1       	ldi	r25, 0x1A	; 26
    3be8:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <xTaskGenericCreate>
	xTaskCreate(waterAlertTask, "", 400, NULL, 1, NULL);		// alert when water usage more than maxwater	
    3bec:	20 e0       	ldi	r18, 0x00	; 0
    3bee:	30 e0       	ldi	r19, 0x00	; 0
    3bf0:	40 e9       	ldi	r20, 0x90	; 144
    3bf2:	51 e0       	ldi	r21, 0x01	; 1
    3bf4:	61 e3       	ldi	r22, 0x31	; 49
    3bf6:	70 e2       	ldi	r23, 0x20	; 32
    3bf8:	84 e3       	ldi	r24, 0x34	; 52
    3bfa:	9d e1       	ldi	r25, 0x1D	; 29
    3bfc:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <xTaskGenericCreate>
	xTaskCreate(vStatus, "", 400, NULL, 1, NULL);	
    3c00:	20 e0       	ldi	r18, 0x00	; 0
    3c02:	30 e0       	ldi	r19, 0x00	; 0
    3c04:	40 e9       	ldi	r20, 0x90	; 144
    3c06:	51 e0       	ldi	r21, 0x01	; 1
    3c08:	61 e3       	ldi	r22, 0x31	; 49
    3c0a:	70 e2       	ldi	r23, 0x20	; 32
    3c0c:	85 ea       	ldi	r24, 0xA5	; 165
    3c0e:	99 e1       	ldi	r25, 0x19	; 25
    3c10:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <xTaskGenericCreate>
	
	vTaskStartScheduler();
    3c14:	9c d8       	rcall	.-3784   	; 0x2d4e <vTaskStartScheduler>
    3c16:	80 e0       	ldi	r24, 0x00	; 0
    3c18:	90 e0       	ldi	r25, 0x00	; 0
    3c1a:	0f 91       	pop	r16
    3c1c:	ff 90       	pop	r15
    3c1e:	ef 90       	pop	r14
    3c20:	df 90       	pop	r13
    3c22:	cf 90       	pop	r12
    3c24:	bf 90       	pop	r11
    3c26:	af 90       	pop	r10
    3c28:	08 95       	ret

00003c2a <__subsf3>:
    3c2a:	50 58       	subi	r21, 0x80	; 128

00003c2c <__addsf3>:
    3c2c:	bb 27       	eor	r27, r27
    3c2e:	aa 27       	eor	r26, r26
    3c30:	0e d0       	rcall	.+28     	; 0x3c4e <__addsf3x>
    3c32:	e5 c0       	rjmp	.+458    	; 0x3dfe <__fp_round>
    3c34:	d6 d0       	rcall	.+428    	; 0x3de2 <__fp_pscA>
    3c36:	30 f0       	brcs	.+12     	; 0x3c44 <__addsf3+0x18>
    3c38:	db d0       	rcall	.+438    	; 0x3df0 <__fp_pscB>
    3c3a:	20 f0       	brcs	.+8      	; 0x3c44 <__addsf3+0x18>
    3c3c:	31 f4       	brne	.+12     	; 0x3c4a <__addsf3+0x1e>
    3c3e:	9f 3f       	cpi	r25, 0xFF	; 255
    3c40:	11 f4       	brne	.+4      	; 0x3c46 <__addsf3+0x1a>
    3c42:	1e f4       	brtc	.+6      	; 0x3c4a <__addsf3+0x1e>
    3c44:	cb c0       	rjmp	.+406    	; 0x3ddc <__fp_nan>
    3c46:	0e f4       	brtc	.+2      	; 0x3c4a <__addsf3+0x1e>
    3c48:	e0 95       	com	r30
    3c4a:	e7 fb       	bst	r30, 7
    3c4c:	c1 c0       	rjmp	.+386    	; 0x3dd0 <__fp_inf>

00003c4e <__addsf3x>:
    3c4e:	e9 2f       	mov	r30, r25
    3c50:	e7 d0       	rcall	.+462    	; 0x3e20 <__fp_split3>
    3c52:	80 f3       	brcs	.-32     	; 0x3c34 <__addsf3+0x8>
    3c54:	ba 17       	cp	r27, r26
    3c56:	62 07       	cpc	r22, r18
    3c58:	73 07       	cpc	r23, r19
    3c5a:	84 07       	cpc	r24, r20
    3c5c:	95 07       	cpc	r25, r21
    3c5e:	18 f0       	brcs	.+6      	; 0x3c66 <__addsf3x+0x18>
    3c60:	71 f4       	brne	.+28     	; 0x3c7e <__addsf3x+0x30>
    3c62:	9e f5       	brtc	.+102    	; 0x3cca <__addsf3x+0x7c>
    3c64:	ff c0       	rjmp	.+510    	; 0x3e64 <__fp_zero>
    3c66:	0e f4       	brtc	.+2      	; 0x3c6a <__addsf3x+0x1c>
    3c68:	e0 95       	com	r30
    3c6a:	0b 2e       	mov	r0, r27
    3c6c:	ba 2f       	mov	r27, r26
    3c6e:	a0 2d       	mov	r26, r0
    3c70:	0b 01       	movw	r0, r22
    3c72:	b9 01       	movw	r22, r18
    3c74:	90 01       	movw	r18, r0
    3c76:	0c 01       	movw	r0, r24
    3c78:	ca 01       	movw	r24, r20
    3c7a:	a0 01       	movw	r20, r0
    3c7c:	11 24       	eor	r1, r1
    3c7e:	ff 27       	eor	r31, r31
    3c80:	59 1b       	sub	r21, r25
    3c82:	99 f0       	breq	.+38     	; 0x3caa <__addsf3x+0x5c>
    3c84:	59 3f       	cpi	r21, 0xF9	; 249
    3c86:	50 f4       	brcc	.+20     	; 0x3c9c <__addsf3x+0x4e>
    3c88:	50 3e       	cpi	r21, 0xE0	; 224
    3c8a:	68 f1       	brcs	.+90     	; 0x3ce6 <__addsf3x+0x98>
    3c8c:	1a 16       	cp	r1, r26
    3c8e:	f0 40       	sbci	r31, 0x00	; 0
    3c90:	a2 2f       	mov	r26, r18
    3c92:	23 2f       	mov	r18, r19
    3c94:	34 2f       	mov	r19, r20
    3c96:	44 27       	eor	r20, r20
    3c98:	58 5f       	subi	r21, 0xF8	; 248
    3c9a:	f3 cf       	rjmp	.-26     	; 0x3c82 <__addsf3x+0x34>
    3c9c:	46 95       	lsr	r20
    3c9e:	37 95       	ror	r19
    3ca0:	27 95       	ror	r18
    3ca2:	a7 95       	ror	r26
    3ca4:	f0 40       	sbci	r31, 0x00	; 0
    3ca6:	53 95       	inc	r21
    3ca8:	c9 f7       	brne	.-14     	; 0x3c9c <__addsf3x+0x4e>
    3caa:	7e f4       	brtc	.+30     	; 0x3cca <__addsf3x+0x7c>
    3cac:	1f 16       	cp	r1, r31
    3cae:	ba 0b       	sbc	r27, r26
    3cb0:	62 0b       	sbc	r22, r18
    3cb2:	73 0b       	sbc	r23, r19
    3cb4:	84 0b       	sbc	r24, r20
    3cb6:	ba f0       	brmi	.+46     	; 0x3ce6 <__addsf3x+0x98>
    3cb8:	91 50       	subi	r25, 0x01	; 1
    3cba:	a1 f0       	breq	.+40     	; 0x3ce4 <__addsf3x+0x96>
    3cbc:	ff 0f       	add	r31, r31
    3cbe:	bb 1f       	adc	r27, r27
    3cc0:	66 1f       	adc	r22, r22
    3cc2:	77 1f       	adc	r23, r23
    3cc4:	88 1f       	adc	r24, r24
    3cc6:	c2 f7       	brpl	.-16     	; 0x3cb8 <__addsf3x+0x6a>
    3cc8:	0e c0       	rjmp	.+28     	; 0x3ce6 <__addsf3x+0x98>
    3cca:	ba 0f       	add	r27, r26
    3ccc:	62 1f       	adc	r22, r18
    3cce:	73 1f       	adc	r23, r19
    3cd0:	84 1f       	adc	r24, r20
    3cd2:	48 f4       	brcc	.+18     	; 0x3ce6 <__addsf3x+0x98>
    3cd4:	87 95       	ror	r24
    3cd6:	77 95       	ror	r23
    3cd8:	67 95       	ror	r22
    3cda:	b7 95       	ror	r27
    3cdc:	f7 95       	ror	r31
    3cde:	9e 3f       	cpi	r25, 0xFE	; 254
    3ce0:	08 f0       	brcs	.+2      	; 0x3ce4 <__addsf3x+0x96>
    3ce2:	b3 cf       	rjmp	.-154    	; 0x3c4a <__addsf3+0x1e>
    3ce4:	93 95       	inc	r25
    3ce6:	88 0f       	add	r24, r24
    3ce8:	08 f0       	brcs	.+2      	; 0x3cec <__addsf3x+0x9e>
    3cea:	99 27       	eor	r25, r25
    3cec:	ee 0f       	add	r30, r30
    3cee:	97 95       	ror	r25
    3cf0:	87 95       	ror	r24
    3cf2:	08 95       	ret

00003cf4 <__fixsfsi>:
    3cf4:	04 d0       	rcall	.+8      	; 0x3cfe <__fixunssfsi>
    3cf6:	68 94       	set
    3cf8:	b1 11       	cpse	r27, r1
    3cfa:	b5 c0       	rjmp	.+362    	; 0x3e66 <__fp_szero>
    3cfc:	08 95       	ret

00003cfe <__fixunssfsi>:
    3cfe:	98 d0       	rcall	.+304    	; 0x3e30 <__fp_splitA>
    3d00:	88 f0       	brcs	.+34     	; 0x3d24 <__fixunssfsi+0x26>
    3d02:	9f 57       	subi	r25, 0x7F	; 127
    3d04:	90 f0       	brcs	.+36     	; 0x3d2a <__fixunssfsi+0x2c>
    3d06:	b9 2f       	mov	r27, r25
    3d08:	99 27       	eor	r25, r25
    3d0a:	b7 51       	subi	r27, 0x17	; 23
    3d0c:	a0 f0       	brcs	.+40     	; 0x3d36 <__fixunssfsi+0x38>
    3d0e:	d1 f0       	breq	.+52     	; 0x3d44 <__fixunssfsi+0x46>
    3d10:	66 0f       	add	r22, r22
    3d12:	77 1f       	adc	r23, r23
    3d14:	88 1f       	adc	r24, r24
    3d16:	99 1f       	adc	r25, r25
    3d18:	1a f0       	brmi	.+6      	; 0x3d20 <__fixunssfsi+0x22>
    3d1a:	ba 95       	dec	r27
    3d1c:	c9 f7       	brne	.-14     	; 0x3d10 <__fixunssfsi+0x12>
    3d1e:	12 c0       	rjmp	.+36     	; 0x3d44 <__fixunssfsi+0x46>
    3d20:	b1 30       	cpi	r27, 0x01	; 1
    3d22:	81 f0       	breq	.+32     	; 0x3d44 <__fixunssfsi+0x46>
    3d24:	9f d0       	rcall	.+318    	; 0x3e64 <__fp_zero>
    3d26:	b1 e0       	ldi	r27, 0x01	; 1
    3d28:	08 95       	ret
    3d2a:	9c c0       	rjmp	.+312    	; 0x3e64 <__fp_zero>
    3d2c:	67 2f       	mov	r22, r23
    3d2e:	78 2f       	mov	r23, r24
    3d30:	88 27       	eor	r24, r24
    3d32:	b8 5f       	subi	r27, 0xF8	; 248
    3d34:	39 f0       	breq	.+14     	; 0x3d44 <__fixunssfsi+0x46>
    3d36:	b9 3f       	cpi	r27, 0xF9	; 249
    3d38:	cc f3       	brlt	.-14     	; 0x3d2c <__fixunssfsi+0x2e>
    3d3a:	86 95       	lsr	r24
    3d3c:	77 95       	ror	r23
    3d3e:	67 95       	ror	r22
    3d40:	b3 95       	inc	r27
    3d42:	d9 f7       	brne	.-10     	; 0x3d3a <__fixunssfsi+0x3c>
    3d44:	3e f4       	brtc	.+14     	; 0x3d54 <__fixunssfsi+0x56>
    3d46:	90 95       	com	r25
    3d48:	80 95       	com	r24
    3d4a:	70 95       	com	r23
    3d4c:	61 95       	neg	r22
    3d4e:	7f 4f       	sbci	r23, 0xFF	; 255
    3d50:	8f 4f       	sbci	r24, 0xFF	; 255
    3d52:	9f 4f       	sbci	r25, 0xFF	; 255
    3d54:	08 95       	ret

00003d56 <__floatunsisf>:
    3d56:	e8 94       	clt
    3d58:	09 c0       	rjmp	.+18     	; 0x3d6c <__floatsisf+0x12>

00003d5a <__floatsisf>:
    3d5a:	97 fb       	bst	r25, 7
    3d5c:	3e f4       	brtc	.+14     	; 0x3d6c <__floatsisf+0x12>
    3d5e:	90 95       	com	r25
    3d60:	80 95       	com	r24
    3d62:	70 95       	com	r23
    3d64:	61 95       	neg	r22
    3d66:	7f 4f       	sbci	r23, 0xFF	; 255
    3d68:	8f 4f       	sbci	r24, 0xFF	; 255
    3d6a:	9f 4f       	sbci	r25, 0xFF	; 255
    3d6c:	99 23       	and	r25, r25
    3d6e:	a9 f0       	breq	.+42     	; 0x3d9a <__floatsisf+0x40>
    3d70:	f9 2f       	mov	r31, r25
    3d72:	96 e9       	ldi	r25, 0x96	; 150
    3d74:	bb 27       	eor	r27, r27
    3d76:	93 95       	inc	r25
    3d78:	f6 95       	lsr	r31
    3d7a:	87 95       	ror	r24
    3d7c:	77 95       	ror	r23
    3d7e:	67 95       	ror	r22
    3d80:	b7 95       	ror	r27
    3d82:	f1 11       	cpse	r31, r1
    3d84:	f8 cf       	rjmp	.-16     	; 0x3d76 <__floatsisf+0x1c>
    3d86:	fa f4       	brpl	.+62     	; 0x3dc6 <__floatsisf+0x6c>
    3d88:	bb 0f       	add	r27, r27
    3d8a:	11 f4       	brne	.+4      	; 0x3d90 <__floatsisf+0x36>
    3d8c:	60 ff       	sbrs	r22, 0
    3d8e:	1b c0       	rjmp	.+54     	; 0x3dc6 <__floatsisf+0x6c>
    3d90:	6f 5f       	subi	r22, 0xFF	; 255
    3d92:	7f 4f       	sbci	r23, 0xFF	; 255
    3d94:	8f 4f       	sbci	r24, 0xFF	; 255
    3d96:	9f 4f       	sbci	r25, 0xFF	; 255
    3d98:	16 c0       	rjmp	.+44     	; 0x3dc6 <__floatsisf+0x6c>
    3d9a:	88 23       	and	r24, r24
    3d9c:	11 f0       	breq	.+4      	; 0x3da2 <__floatsisf+0x48>
    3d9e:	96 e9       	ldi	r25, 0x96	; 150
    3da0:	11 c0       	rjmp	.+34     	; 0x3dc4 <__floatsisf+0x6a>
    3da2:	77 23       	and	r23, r23
    3da4:	21 f0       	breq	.+8      	; 0x3dae <__floatsisf+0x54>
    3da6:	9e e8       	ldi	r25, 0x8E	; 142
    3da8:	87 2f       	mov	r24, r23
    3daa:	76 2f       	mov	r23, r22
    3dac:	05 c0       	rjmp	.+10     	; 0x3db8 <__floatsisf+0x5e>
    3dae:	66 23       	and	r22, r22
    3db0:	71 f0       	breq	.+28     	; 0x3dce <__floatsisf+0x74>
    3db2:	96 e8       	ldi	r25, 0x86	; 134
    3db4:	86 2f       	mov	r24, r22
    3db6:	70 e0       	ldi	r23, 0x00	; 0
    3db8:	60 e0       	ldi	r22, 0x00	; 0
    3dba:	2a f0       	brmi	.+10     	; 0x3dc6 <__floatsisf+0x6c>
    3dbc:	9a 95       	dec	r25
    3dbe:	66 0f       	add	r22, r22
    3dc0:	77 1f       	adc	r23, r23
    3dc2:	88 1f       	adc	r24, r24
    3dc4:	da f7       	brpl	.-10     	; 0x3dbc <__floatsisf+0x62>
    3dc6:	88 0f       	add	r24, r24
    3dc8:	96 95       	lsr	r25
    3dca:	87 95       	ror	r24
    3dcc:	97 f9       	bld	r25, 7
    3dce:	08 95       	ret

00003dd0 <__fp_inf>:
    3dd0:	97 f9       	bld	r25, 7
    3dd2:	9f 67       	ori	r25, 0x7F	; 127
    3dd4:	80 e8       	ldi	r24, 0x80	; 128
    3dd6:	70 e0       	ldi	r23, 0x00	; 0
    3dd8:	60 e0       	ldi	r22, 0x00	; 0
    3dda:	08 95       	ret

00003ddc <__fp_nan>:
    3ddc:	9f ef       	ldi	r25, 0xFF	; 255
    3dde:	80 ec       	ldi	r24, 0xC0	; 192
    3de0:	08 95       	ret

00003de2 <__fp_pscA>:
    3de2:	00 24       	eor	r0, r0
    3de4:	0a 94       	dec	r0
    3de6:	16 16       	cp	r1, r22
    3de8:	17 06       	cpc	r1, r23
    3dea:	18 06       	cpc	r1, r24
    3dec:	09 06       	cpc	r0, r25
    3dee:	08 95       	ret

00003df0 <__fp_pscB>:
    3df0:	00 24       	eor	r0, r0
    3df2:	0a 94       	dec	r0
    3df4:	12 16       	cp	r1, r18
    3df6:	13 06       	cpc	r1, r19
    3df8:	14 06       	cpc	r1, r20
    3dfa:	05 06       	cpc	r0, r21
    3dfc:	08 95       	ret

00003dfe <__fp_round>:
    3dfe:	09 2e       	mov	r0, r25
    3e00:	03 94       	inc	r0
    3e02:	00 0c       	add	r0, r0
    3e04:	11 f4       	brne	.+4      	; 0x3e0a <__fp_round+0xc>
    3e06:	88 23       	and	r24, r24
    3e08:	52 f0       	brmi	.+20     	; 0x3e1e <__fp_round+0x20>
    3e0a:	bb 0f       	add	r27, r27
    3e0c:	40 f4       	brcc	.+16     	; 0x3e1e <__fp_round+0x20>
    3e0e:	bf 2b       	or	r27, r31
    3e10:	11 f4       	brne	.+4      	; 0x3e16 <__fp_round+0x18>
    3e12:	60 ff       	sbrs	r22, 0
    3e14:	04 c0       	rjmp	.+8      	; 0x3e1e <__fp_round+0x20>
    3e16:	6f 5f       	subi	r22, 0xFF	; 255
    3e18:	7f 4f       	sbci	r23, 0xFF	; 255
    3e1a:	8f 4f       	sbci	r24, 0xFF	; 255
    3e1c:	9f 4f       	sbci	r25, 0xFF	; 255
    3e1e:	08 95       	ret

00003e20 <__fp_split3>:
    3e20:	57 fd       	sbrc	r21, 7
    3e22:	90 58       	subi	r25, 0x80	; 128
    3e24:	44 0f       	add	r20, r20
    3e26:	55 1f       	adc	r21, r21
    3e28:	59 f0       	breq	.+22     	; 0x3e40 <__fp_splitA+0x10>
    3e2a:	5f 3f       	cpi	r21, 0xFF	; 255
    3e2c:	71 f0       	breq	.+28     	; 0x3e4a <__fp_splitA+0x1a>
    3e2e:	47 95       	ror	r20

00003e30 <__fp_splitA>:
    3e30:	88 0f       	add	r24, r24
    3e32:	97 fb       	bst	r25, 7
    3e34:	99 1f       	adc	r25, r25
    3e36:	61 f0       	breq	.+24     	; 0x3e50 <__fp_splitA+0x20>
    3e38:	9f 3f       	cpi	r25, 0xFF	; 255
    3e3a:	79 f0       	breq	.+30     	; 0x3e5a <__fp_splitA+0x2a>
    3e3c:	87 95       	ror	r24
    3e3e:	08 95       	ret
    3e40:	12 16       	cp	r1, r18
    3e42:	13 06       	cpc	r1, r19
    3e44:	14 06       	cpc	r1, r20
    3e46:	55 1f       	adc	r21, r21
    3e48:	f2 cf       	rjmp	.-28     	; 0x3e2e <__fp_split3+0xe>
    3e4a:	46 95       	lsr	r20
    3e4c:	f1 df       	rcall	.-30     	; 0x3e30 <__fp_splitA>
    3e4e:	08 c0       	rjmp	.+16     	; 0x3e60 <__fp_splitA+0x30>
    3e50:	16 16       	cp	r1, r22
    3e52:	17 06       	cpc	r1, r23
    3e54:	18 06       	cpc	r1, r24
    3e56:	99 1f       	adc	r25, r25
    3e58:	f1 cf       	rjmp	.-30     	; 0x3e3c <__fp_splitA+0xc>
    3e5a:	86 95       	lsr	r24
    3e5c:	71 05       	cpc	r23, r1
    3e5e:	61 05       	cpc	r22, r1
    3e60:	08 94       	sec
    3e62:	08 95       	ret

00003e64 <__fp_zero>:
    3e64:	e8 94       	clt

00003e66 <__fp_szero>:
    3e66:	bb 27       	eor	r27, r27
    3e68:	66 27       	eor	r22, r22
    3e6a:	77 27       	eor	r23, r23
    3e6c:	cb 01       	movw	r24, r22
    3e6e:	97 f9       	bld	r25, 7
    3e70:	08 95       	ret

00003e72 <__mulsf3>:
    3e72:	0b d0       	rcall	.+22     	; 0x3e8a <__mulsf3x>
    3e74:	c4 cf       	rjmp	.-120    	; 0x3dfe <__fp_round>
    3e76:	b5 df       	rcall	.-150    	; 0x3de2 <__fp_pscA>
    3e78:	28 f0       	brcs	.+10     	; 0x3e84 <__mulsf3+0x12>
    3e7a:	ba df       	rcall	.-140    	; 0x3df0 <__fp_pscB>
    3e7c:	18 f0       	brcs	.+6      	; 0x3e84 <__mulsf3+0x12>
    3e7e:	95 23       	and	r25, r21
    3e80:	09 f0       	breq	.+2      	; 0x3e84 <__mulsf3+0x12>
    3e82:	a6 cf       	rjmp	.-180    	; 0x3dd0 <__fp_inf>
    3e84:	ab cf       	rjmp	.-170    	; 0x3ddc <__fp_nan>
    3e86:	11 24       	eor	r1, r1
    3e88:	ee cf       	rjmp	.-36     	; 0x3e66 <__fp_szero>

00003e8a <__mulsf3x>:
    3e8a:	ca df       	rcall	.-108    	; 0x3e20 <__fp_split3>
    3e8c:	a0 f3       	brcs	.-24     	; 0x3e76 <__mulsf3+0x4>

00003e8e <__mulsf3_pse>:
    3e8e:	95 9f       	mul	r25, r21
    3e90:	d1 f3       	breq	.-12     	; 0x3e86 <__mulsf3+0x14>
    3e92:	95 0f       	add	r25, r21
    3e94:	50 e0       	ldi	r21, 0x00	; 0
    3e96:	55 1f       	adc	r21, r21
    3e98:	62 9f       	mul	r22, r18
    3e9a:	f0 01       	movw	r30, r0
    3e9c:	72 9f       	mul	r23, r18
    3e9e:	bb 27       	eor	r27, r27
    3ea0:	f0 0d       	add	r31, r0
    3ea2:	b1 1d       	adc	r27, r1
    3ea4:	63 9f       	mul	r22, r19
    3ea6:	aa 27       	eor	r26, r26
    3ea8:	f0 0d       	add	r31, r0
    3eaa:	b1 1d       	adc	r27, r1
    3eac:	aa 1f       	adc	r26, r26
    3eae:	64 9f       	mul	r22, r20
    3eb0:	66 27       	eor	r22, r22
    3eb2:	b0 0d       	add	r27, r0
    3eb4:	a1 1d       	adc	r26, r1
    3eb6:	66 1f       	adc	r22, r22
    3eb8:	82 9f       	mul	r24, r18
    3eba:	22 27       	eor	r18, r18
    3ebc:	b0 0d       	add	r27, r0
    3ebe:	a1 1d       	adc	r26, r1
    3ec0:	62 1f       	adc	r22, r18
    3ec2:	73 9f       	mul	r23, r19
    3ec4:	b0 0d       	add	r27, r0
    3ec6:	a1 1d       	adc	r26, r1
    3ec8:	62 1f       	adc	r22, r18
    3eca:	83 9f       	mul	r24, r19
    3ecc:	a0 0d       	add	r26, r0
    3ece:	61 1d       	adc	r22, r1
    3ed0:	22 1f       	adc	r18, r18
    3ed2:	74 9f       	mul	r23, r20
    3ed4:	33 27       	eor	r19, r19
    3ed6:	a0 0d       	add	r26, r0
    3ed8:	61 1d       	adc	r22, r1
    3eda:	23 1f       	adc	r18, r19
    3edc:	84 9f       	mul	r24, r20
    3ede:	60 0d       	add	r22, r0
    3ee0:	21 1d       	adc	r18, r1
    3ee2:	82 2f       	mov	r24, r18
    3ee4:	76 2f       	mov	r23, r22
    3ee6:	6a 2f       	mov	r22, r26
    3ee8:	11 24       	eor	r1, r1
    3eea:	9f 57       	subi	r25, 0x7F	; 127
    3eec:	50 40       	sbci	r21, 0x00	; 0
    3eee:	8a f0       	brmi	.+34     	; 0x3f12 <__mulsf3_pse+0x84>
    3ef0:	e1 f0       	breq	.+56     	; 0x3f2a <__mulsf3_pse+0x9c>
    3ef2:	88 23       	and	r24, r24
    3ef4:	4a f0       	brmi	.+18     	; 0x3f08 <__mulsf3_pse+0x7a>
    3ef6:	ee 0f       	add	r30, r30
    3ef8:	ff 1f       	adc	r31, r31
    3efa:	bb 1f       	adc	r27, r27
    3efc:	66 1f       	adc	r22, r22
    3efe:	77 1f       	adc	r23, r23
    3f00:	88 1f       	adc	r24, r24
    3f02:	91 50       	subi	r25, 0x01	; 1
    3f04:	50 40       	sbci	r21, 0x00	; 0
    3f06:	a9 f7       	brne	.-22     	; 0x3ef2 <__mulsf3_pse+0x64>
    3f08:	9e 3f       	cpi	r25, 0xFE	; 254
    3f0a:	51 05       	cpc	r21, r1
    3f0c:	70 f0       	brcs	.+28     	; 0x3f2a <__mulsf3_pse+0x9c>
    3f0e:	60 cf       	rjmp	.-320    	; 0x3dd0 <__fp_inf>
    3f10:	aa cf       	rjmp	.-172    	; 0x3e66 <__fp_szero>
    3f12:	5f 3f       	cpi	r21, 0xFF	; 255
    3f14:	ec f3       	brlt	.-6      	; 0x3f10 <__mulsf3_pse+0x82>
    3f16:	98 3e       	cpi	r25, 0xE8	; 232
    3f18:	dc f3       	brlt	.-10     	; 0x3f10 <__mulsf3_pse+0x82>
    3f1a:	86 95       	lsr	r24
    3f1c:	77 95       	ror	r23
    3f1e:	67 95       	ror	r22
    3f20:	b7 95       	ror	r27
    3f22:	f7 95       	ror	r31
    3f24:	e7 95       	ror	r30
    3f26:	9f 5f       	subi	r25, 0xFF	; 255
    3f28:	c1 f7       	brne	.-16     	; 0x3f1a <__mulsf3_pse+0x8c>
    3f2a:	fe 2b       	or	r31, r30
    3f2c:	88 0f       	add	r24, r24
    3f2e:	91 1d       	adc	r25, r1
    3f30:	96 95       	lsr	r25
    3f32:	87 95       	ror	r24
    3f34:	97 f9       	bld	r25, 7
    3f36:	08 95       	ret

00003f38 <__divmodhi4>:
    3f38:	97 fb       	bst	r25, 7
    3f3a:	07 2e       	mov	r0, r23
    3f3c:	16 f4       	brtc	.+4      	; 0x3f42 <__divmodhi4+0xa>
    3f3e:	00 94       	com	r0
    3f40:	06 d0       	rcall	.+12     	; 0x3f4e <__divmodhi4_neg1>
    3f42:	77 fd       	sbrc	r23, 7
    3f44:	08 d0       	rcall	.+16     	; 0x3f56 <__divmodhi4_neg2>
    3f46:	6d d0       	rcall	.+218    	; 0x4022 <__udivmodhi4>
    3f48:	07 fc       	sbrc	r0, 7
    3f4a:	05 d0       	rcall	.+10     	; 0x3f56 <__divmodhi4_neg2>
    3f4c:	3e f4       	brtc	.+14     	; 0x3f5c <__divmodhi4_exit>

00003f4e <__divmodhi4_neg1>:
    3f4e:	90 95       	com	r25
    3f50:	81 95       	neg	r24
    3f52:	9f 4f       	sbci	r25, 0xFF	; 255
    3f54:	08 95       	ret

00003f56 <__divmodhi4_neg2>:
    3f56:	70 95       	com	r23
    3f58:	61 95       	neg	r22
    3f5a:	7f 4f       	sbci	r23, 0xFF	; 255

00003f5c <__divmodhi4_exit>:
    3f5c:	08 95       	ret

00003f5e <__udivmodsi4>:
    3f5e:	a1 e2       	ldi	r26, 0x21	; 33
    3f60:	1a 2e       	mov	r1, r26
    3f62:	aa 1b       	sub	r26, r26
    3f64:	bb 1b       	sub	r27, r27
    3f66:	fd 01       	movw	r30, r26
    3f68:	0d c0       	rjmp	.+26     	; 0x3f84 <__udivmodsi4_ep>

00003f6a <__udivmodsi4_loop>:
    3f6a:	aa 1f       	adc	r26, r26
    3f6c:	bb 1f       	adc	r27, r27
    3f6e:	ee 1f       	adc	r30, r30
    3f70:	ff 1f       	adc	r31, r31
    3f72:	a2 17       	cp	r26, r18
    3f74:	b3 07       	cpc	r27, r19
    3f76:	e4 07       	cpc	r30, r20
    3f78:	f5 07       	cpc	r31, r21
    3f7a:	20 f0       	brcs	.+8      	; 0x3f84 <__udivmodsi4_ep>
    3f7c:	a2 1b       	sub	r26, r18
    3f7e:	b3 0b       	sbc	r27, r19
    3f80:	e4 0b       	sbc	r30, r20
    3f82:	f5 0b       	sbc	r31, r21

00003f84 <__udivmodsi4_ep>:
    3f84:	66 1f       	adc	r22, r22
    3f86:	77 1f       	adc	r23, r23
    3f88:	88 1f       	adc	r24, r24
    3f8a:	99 1f       	adc	r25, r25
    3f8c:	1a 94       	dec	r1
    3f8e:	69 f7       	brne	.-38     	; 0x3f6a <__udivmodsi4_loop>
    3f90:	60 95       	com	r22
    3f92:	70 95       	com	r23
    3f94:	80 95       	com	r24
    3f96:	90 95       	com	r25
    3f98:	9b 01       	movw	r18, r22
    3f9a:	ac 01       	movw	r20, r24
    3f9c:	bd 01       	movw	r22, r26
    3f9e:	cf 01       	movw	r24, r30
    3fa0:	08 95       	ret

00003fa2 <__umulhisi3>:
    3fa2:	a2 9f       	mul	r26, r18
    3fa4:	b0 01       	movw	r22, r0
    3fa6:	b3 9f       	mul	r27, r19
    3fa8:	c0 01       	movw	r24, r0
    3faa:	a3 9f       	mul	r26, r19
    3fac:	70 0d       	add	r23, r0
    3fae:	81 1d       	adc	r24, r1
    3fb0:	11 24       	eor	r1, r1
    3fb2:	91 1d       	adc	r25, r1
    3fb4:	b2 9f       	mul	r27, r18
    3fb6:	70 0d       	add	r23, r0
    3fb8:	81 1d       	adc	r24, r1
    3fba:	11 24       	eor	r1, r1
    3fbc:	91 1d       	adc	r25, r1
    3fbe:	08 95       	ret

00003fc0 <__prologue_saves__>:
    3fc0:	2f 92       	push	r2
    3fc2:	3f 92       	push	r3
    3fc4:	4f 92       	push	r4
    3fc6:	5f 92       	push	r5
    3fc8:	6f 92       	push	r6
    3fca:	7f 92       	push	r7
    3fcc:	8f 92       	push	r8
    3fce:	9f 92       	push	r9
    3fd0:	af 92       	push	r10
    3fd2:	bf 92       	push	r11
    3fd4:	cf 92       	push	r12
    3fd6:	df 92       	push	r13
    3fd8:	ef 92       	push	r14
    3fda:	ff 92       	push	r15
    3fdc:	0f 93       	push	r16
    3fde:	1f 93       	push	r17
    3fe0:	cf 93       	push	r28
    3fe2:	df 93       	push	r29
    3fe4:	cd b7       	in	r28, 0x3d	; 61
    3fe6:	de b7       	in	r29, 0x3e	; 62
    3fe8:	ca 1b       	sub	r28, r26
    3fea:	db 0b       	sbc	r29, r27
    3fec:	cd bf       	out	0x3d, r28	; 61
    3fee:	de bf       	out	0x3e, r29	; 62
    3ff0:	19 94       	eijmp

00003ff2 <__epilogue_restores__>:
    3ff2:	2a 88       	ldd	r2, Y+18	; 0x12
    3ff4:	39 88       	ldd	r3, Y+17	; 0x11
    3ff6:	48 88       	ldd	r4, Y+16	; 0x10
    3ff8:	5f 84       	ldd	r5, Y+15	; 0x0f
    3ffa:	6e 84       	ldd	r6, Y+14	; 0x0e
    3ffc:	7d 84       	ldd	r7, Y+13	; 0x0d
    3ffe:	8c 84       	ldd	r8, Y+12	; 0x0c
    4000:	9b 84       	ldd	r9, Y+11	; 0x0b
    4002:	aa 84       	ldd	r10, Y+10	; 0x0a
    4004:	b9 84       	ldd	r11, Y+9	; 0x09
    4006:	c8 84       	ldd	r12, Y+8	; 0x08
    4008:	df 80       	ldd	r13, Y+7	; 0x07
    400a:	ee 80       	ldd	r14, Y+6	; 0x06
    400c:	fd 80       	ldd	r15, Y+5	; 0x05
    400e:	0c 81       	ldd	r16, Y+4	; 0x04
    4010:	1b 81       	ldd	r17, Y+3	; 0x03
    4012:	aa 81       	ldd	r26, Y+2	; 0x02
    4014:	b9 81       	ldd	r27, Y+1	; 0x01
    4016:	ce 0f       	add	r28, r30
    4018:	d1 1d       	adc	r29, r1
    401a:	cd bf       	out	0x3d, r28	; 61
    401c:	de bf       	out	0x3e, r29	; 62
    401e:	ed 01       	movw	r28, r26
    4020:	08 95       	ret

00004022 <__udivmodhi4>:
    4022:	aa 1b       	sub	r26, r26
    4024:	bb 1b       	sub	r27, r27
    4026:	51 e1       	ldi	r21, 0x11	; 17
    4028:	07 c0       	rjmp	.+14     	; 0x4038 <__udivmodhi4_ep>

0000402a <__udivmodhi4_loop>:
    402a:	aa 1f       	adc	r26, r26
    402c:	bb 1f       	adc	r27, r27
    402e:	a6 17       	cp	r26, r22
    4030:	b7 07       	cpc	r27, r23
    4032:	10 f0       	brcs	.+4      	; 0x4038 <__udivmodhi4_ep>
    4034:	a6 1b       	sub	r26, r22
    4036:	b7 0b       	sbc	r27, r23

00004038 <__udivmodhi4_ep>:
    4038:	88 1f       	adc	r24, r24
    403a:	99 1f       	adc	r25, r25
    403c:	5a 95       	dec	r21
    403e:	a9 f7       	brne	.-22     	; 0x402a <__udivmodhi4_loop>
    4040:	80 95       	com	r24
    4042:	90 95       	com	r25
    4044:	bc 01       	movw	r22, r24
    4046:	cd 01       	movw	r24, r26
    4048:	08 95       	ret

0000404a <malloc>:
    404a:	cf 93       	push	r28
    404c:	df 93       	push	r29
    404e:	82 30       	cpi	r24, 0x02	; 2
    4050:	91 05       	cpc	r25, r1
    4052:	10 f4       	brcc	.+4      	; 0x4058 <malloc+0xe>
    4054:	82 e0       	ldi	r24, 0x02	; 2
    4056:	90 e0       	ldi	r25, 0x00	; 0
    4058:	e0 91 e7 23 	lds	r30, 0x23E7
    405c:	f0 91 e8 23 	lds	r31, 0x23E8
    4060:	20 e0       	ldi	r18, 0x00	; 0
    4062:	30 e0       	ldi	r19, 0x00	; 0
    4064:	c0 e0       	ldi	r28, 0x00	; 0
    4066:	d0 e0       	ldi	r29, 0x00	; 0
    4068:	30 97       	sbiw	r30, 0x00	; 0
    406a:	11 f1       	breq	.+68     	; 0x40b0 <malloc+0x66>
    406c:	40 81       	ld	r20, Z
    406e:	51 81       	ldd	r21, Z+1	; 0x01
    4070:	48 17       	cp	r20, r24
    4072:	59 07       	cpc	r21, r25
    4074:	c0 f0       	brcs	.+48     	; 0x40a6 <malloc+0x5c>
    4076:	48 17       	cp	r20, r24
    4078:	59 07       	cpc	r21, r25
    407a:	61 f4       	brne	.+24     	; 0x4094 <malloc+0x4a>
    407c:	82 81       	ldd	r24, Z+2	; 0x02
    407e:	93 81       	ldd	r25, Z+3	; 0x03
    4080:	20 97       	sbiw	r28, 0x00	; 0
    4082:	19 f0       	breq	.+6      	; 0x408a <malloc+0x40>
    4084:	8a 83       	std	Y+2, r24	; 0x02
    4086:	9b 83       	std	Y+3, r25	; 0x03
    4088:	2b c0       	rjmp	.+86     	; 0x40e0 <malloc+0x96>
    408a:	80 93 e7 23 	sts	0x23E7, r24
    408e:	90 93 e8 23 	sts	0x23E8, r25
    4092:	26 c0       	rjmp	.+76     	; 0x40e0 <malloc+0x96>
    4094:	21 15       	cp	r18, r1
    4096:	31 05       	cpc	r19, r1
    4098:	19 f0       	breq	.+6      	; 0x40a0 <malloc+0x56>
    409a:	42 17       	cp	r20, r18
    409c:	53 07       	cpc	r21, r19
    409e:	18 f4       	brcc	.+6      	; 0x40a6 <malloc+0x5c>
    40a0:	9a 01       	movw	r18, r20
    40a2:	be 01       	movw	r22, r28
    40a4:	df 01       	movw	r26, r30
    40a6:	ef 01       	movw	r28, r30
    40a8:	02 80       	ldd	r0, Z+2	; 0x02
    40aa:	f3 81       	ldd	r31, Z+3	; 0x03
    40ac:	e0 2d       	mov	r30, r0
    40ae:	dc cf       	rjmp	.-72     	; 0x4068 <malloc+0x1e>
    40b0:	21 15       	cp	r18, r1
    40b2:	31 05       	cpc	r19, r1
    40b4:	09 f1       	breq	.+66     	; 0x40f8 <malloc+0xae>
    40b6:	28 1b       	sub	r18, r24
    40b8:	39 0b       	sbc	r19, r25
    40ba:	24 30       	cpi	r18, 0x04	; 4
    40bc:	31 05       	cpc	r19, r1
    40be:	90 f4       	brcc	.+36     	; 0x40e4 <malloc+0x9a>
    40c0:	12 96       	adiw	r26, 0x02	; 2
    40c2:	8d 91       	ld	r24, X+
    40c4:	9c 91       	ld	r25, X
    40c6:	13 97       	sbiw	r26, 0x03	; 3
    40c8:	61 15       	cp	r22, r1
    40ca:	71 05       	cpc	r23, r1
    40cc:	21 f0       	breq	.+8      	; 0x40d6 <malloc+0x8c>
    40ce:	fb 01       	movw	r30, r22
    40d0:	82 83       	std	Z+2, r24	; 0x02
    40d2:	93 83       	std	Z+3, r25	; 0x03
    40d4:	04 c0       	rjmp	.+8      	; 0x40de <malloc+0x94>
    40d6:	80 93 e7 23 	sts	0x23E7, r24
    40da:	90 93 e8 23 	sts	0x23E8, r25
    40de:	fd 01       	movw	r30, r26
    40e0:	32 96       	adiw	r30, 0x02	; 2
    40e2:	44 c0       	rjmp	.+136    	; 0x416c <malloc+0x122>
    40e4:	fd 01       	movw	r30, r26
    40e6:	e2 0f       	add	r30, r18
    40e8:	f3 1f       	adc	r31, r19
    40ea:	81 93       	st	Z+, r24
    40ec:	91 93       	st	Z+, r25
    40ee:	22 50       	subi	r18, 0x02	; 2
    40f0:	31 09       	sbc	r19, r1
    40f2:	2d 93       	st	X+, r18
    40f4:	3c 93       	st	X, r19
    40f6:	3a c0       	rjmp	.+116    	; 0x416c <malloc+0x122>
    40f8:	20 91 e5 23 	lds	r18, 0x23E5
    40fc:	30 91 e6 23 	lds	r19, 0x23E6
    4100:	23 2b       	or	r18, r19
    4102:	41 f4       	brne	.+16     	; 0x4114 <malloc+0xca>
    4104:	20 91 03 20 	lds	r18, 0x2003
    4108:	30 91 04 20 	lds	r19, 0x2004
    410c:	20 93 e5 23 	sts	0x23E5, r18
    4110:	30 93 e6 23 	sts	0x23E6, r19
    4114:	20 91 01 20 	lds	r18, 0x2001
    4118:	30 91 02 20 	lds	r19, 0x2002
    411c:	21 15       	cp	r18, r1
    411e:	31 05       	cpc	r19, r1
    4120:	41 f4       	brne	.+16     	; 0x4132 <malloc+0xe8>
    4122:	2d b7       	in	r18, 0x3d	; 61
    4124:	3e b7       	in	r19, 0x3e	; 62
    4126:	40 91 05 20 	lds	r20, 0x2005
    412a:	50 91 06 20 	lds	r21, 0x2006
    412e:	24 1b       	sub	r18, r20
    4130:	35 0b       	sbc	r19, r21
    4132:	e0 91 e5 23 	lds	r30, 0x23E5
    4136:	f0 91 e6 23 	lds	r31, 0x23E6
    413a:	e2 17       	cp	r30, r18
    413c:	f3 07       	cpc	r31, r19
    413e:	a0 f4       	brcc	.+40     	; 0x4168 <malloc+0x11e>
    4140:	2e 1b       	sub	r18, r30
    4142:	3f 0b       	sbc	r19, r31
    4144:	28 17       	cp	r18, r24
    4146:	39 07       	cpc	r19, r25
    4148:	78 f0       	brcs	.+30     	; 0x4168 <malloc+0x11e>
    414a:	ac 01       	movw	r20, r24
    414c:	4e 5f       	subi	r20, 0xFE	; 254
    414e:	5f 4f       	sbci	r21, 0xFF	; 255
    4150:	24 17       	cp	r18, r20
    4152:	35 07       	cpc	r19, r21
    4154:	48 f0       	brcs	.+18     	; 0x4168 <malloc+0x11e>
    4156:	4e 0f       	add	r20, r30
    4158:	5f 1f       	adc	r21, r31
    415a:	40 93 e5 23 	sts	0x23E5, r20
    415e:	50 93 e6 23 	sts	0x23E6, r21
    4162:	81 93       	st	Z+, r24
    4164:	91 93       	st	Z+, r25
    4166:	02 c0       	rjmp	.+4      	; 0x416c <malloc+0x122>
    4168:	e0 e0       	ldi	r30, 0x00	; 0
    416a:	f0 e0       	ldi	r31, 0x00	; 0
    416c:	cf 01       	movw	r24, r30
    416e:	df 91       	pop	r29
    4170:	cf 91       	pop	r28
    4172:	08 95       	ret

00004174 <free>:
    4174:	0f 93       	push	r16
    4176:	1f 93       	push	r17
    4178:	cf 93       	push	r28
    417a:	df 93       	push	r29
    417c:	00 97       	sbiw	r24, 0x00	; 0
    417e:	09 f4       	brne	.+2      	; 0x4182 <free+0xe>
    4180:	8c c0       	rjmp	.+280    	; 0x429a <free+0x126>
    4182:	fc 01       	movw	r30, r24
    4184:	32 97       	sbiw	r30, 0x02	; 2
    4186:	12 82       	std	Z+2, r1	; 0x02
    4188:	13 82       	std	Z+3, r1	; 0x03
    418a:	00 91 e7 23 	lds	r16, 0x23E7
    418e:	10 91 e8 23 	lds	r17, 0x23E8
    4192:	01 15       	cp	r16, r1
    4194:	11 05       	cpc	r17, r1
    4196:	81 f4       	brne	.+32     	; 0x41b8 <free+0x44>
    4198:	20 81       	ld	r18, Z
    419a:	31 81       	ldd	r19, Z+1	; 0x01
    419c:	82 0f       	add	r24, r18
    419e:	93 1f       	adc	r25, r19
    41a0:	20 91 e5 23 	lds	r18, 0x23E5
    41a4:	30 91 e6 23 	lds	r19, 0x23E6
    41a8:	28 17       	cp	r18, r24
    41aa:	39 07       	cpc	r19, r25
    41ac:	79 f5       	brne	.+94     	; 0x420c <free+0x98>
    41ae:	e0 93 e5 23 	sts	0x23E5, r30
    41b2:	f0 93 e6 23 	sts	0x23E6, r31
    41b6:	71 c0       	rjmp	.+226    	; 0x429a <free+0x126>
    41b8:	d8 01       	movw	r26, r16
    41ba:	40 e0       	ldi	r20, 0x00	; 0
    41bc:	50 e0       	ldi	r21, 0x00	; 0
    41be:	ae 17       	cp	r26, r30
    41c0:	bf 07       	cpc	r27, r31
    41c2:	50 f4       	brcc	.+20     	; 0x41d8 <free+0x64>
    41c4:	12 96       	adiw	r26, 0x02	; 2
    41c6:	2d 91       	ld	r18, X+
    41c8:	3c 91       	ld	r19, X
    41ca:	13 97       	sbiw	r26, 0x03	; 3
    41cc:	ad 01       	movw	r20, r26
    41ce:	21 15       	cp	r18, r1
    41d0:	31 05       	cpc	r19, r1
    41d2:	09 f1       	breq	.+66     	; 0x4216 <free+0xa2>
    41d4:	d9 01       	movw	r26, r18
    41d6:	f3 cf       	rjmp	.-26     	; 0x41be <free+0x4a>
    41d8:	9d 01       	movw	r18, r26
    41da:	da 01       	movw	r26, r20
    41dc:	22 83       	std	Z+2, r18	; 0x02
    41de:	33 83       	std	Z+3, r19	; 0x03
    41e0:	60 81       	ld	r22, Z
    41e2:	71 81       	ldd	r23, Z+1	; 0x01
    41e4:	86 0f       	add	r24, r22
    41e6:	97 1f       	adc	r25, r23
    41e8:	82 17       	cp	r24, r18
    41ea:	93 07       	cpc	r25, r19
    41ec:	69 f4       	brne	.+26     	; 0x4208 <free+0x94>
    41ee:	ec 01       	movw	r28, r24
    41f0:	28 81       	ld	r18, Y
    41f2:	39 81       	ldd	r19, Y+1	; 0x01
    41f4:	26 0f       	add	r18, r22
    41f6:	37 1f       	adc	r19, r23
    41f8:	2e 5f       	subi	r18, 0xFE	; 254
    41fa:	3f 4f       	sbci	r19, 0xFF	; 255
    41fc:	20 83       	st	Z, r18
    41fe:	31 83       	std	Z+1, r19	; 0x01
    4200:	8a 81       	ldd	r24, Y+2	; 0x02
    4202:	9b 81       	ldd	r25, Y+3	; 0x03
    4204:	82 83       	std	Z+2, r24	; 0x02
    4206:	93 83       	std	Z+3, r25	; 0x03
    4208:	45 2b       	or	r20, r21
    420a:	29 f4       	brne	.+10     	; 0x4216 <free+0xa2>
    420c:	e0 93 e7 23 	sts	0x23E7, r30
    4210:	f0 93 e8 23 	sts	0x23E8, r31
    4214:	42 c0       	rjmp	.+132    	; 0x429a <free+0x126>
    4216:	12 96       	adiw	r26, 0x02	; 2
    4218:	ed 93       	st	X+, r30
    421a:	fc 93       	st	X, r31
    421c:	13 97       	sbiw	r26, 0x03	; 3
    421e:	ed 01       	movw	r28, r26
    4220:	49 91       	ld	r20, Y+
    4222:	59 91       	ld	r21, Y+
    4224:	9e 01       	movw	r18, r28
    4226:	24 0f       	add	r18, r20
    4228:	35 1f       	adc	r19, r21
    422a:	e2 17       	cp	r30, r18
    422c:	f3 07       	cpc	r31, r19
    422e:	71 f4       	brne	.+28     	; 0x424c <free+0xd8>
    4230:	80 81       	ld	r24, Z
    4232:	91 81       	ldd	r25, Z+1	; 0x01
    4234:	84 0f       	add	r24, r20
    4236:	95 1f       	adc	r25, r21
    4238:	02 96       	adiw	r24, 0x02	; 2
    423a:	8d 93       	st	X+, r24
    423c:	9c 93       	st	X, r25
    423e:	11 97       	sbiw	r26, 0x01	; 1
    4240:	82 81       	ldd	r24, Z+2	; 0x02
    4242:	93 81       	ldd	r25, Z+3	; 0x03
    4244:	12 96       	adiw	r26, 0x02	; 2
    4246:	8d 93       	st	X+, r24
    4248:	9c 93       	st	X, r25
    424a:	13 97       	sbiw	r26, 0x03	; 3
    424c:	e0 e0       	ldi	r30, 0x00	; 0
    424e:	f0 e0       	ldi	r31, 0x00	; 0
    4250:	d8 01       	movw	r26, r16
    4252:	12 96       	adiw	r26, 0x02	; 2
    4254:	8d 91       	ld	r24, X+
    4256:	9c 91       	ld	r25, X
    4258:	13 97       	sbiw	r26, 0x03	; 3
    425a:	00 97       	sbiw	r24, 0x00	; 0
    425c:	19 f0       	breq	.+6      	; 0x4264 <free+0xf0>
    425e:	f8 01       	movw	r30, r16
    4260:	8c 01       	movw	r16, r24
    4262:	f6 cf       	rjmp	.-20     	; 0x4250 <free+0xdc>
    4264:	8d 91       	ld	r24, X+
    4266:	9c 91       	ld	r25, X
    4268:	98 01       	movw	r18, r16
    426a:	2e 5f       	subi	r18, 0xFE	; 254
    426c:	3f 4f       	sbci	r19, 0xFF	; 255
    426e:	82 0f       	add	r24, r18
    4270:	93 1f       	adc	r25, r19
    4272:	20 91 e5 23 	lds	r18, 0x23E5
    4276:	30 91 e6 23 	lds	r19, 0x23E6
    427a:	28 17       	cp	r18, r24
    427c:	39 07       	cpc	r19, r25
    427e:	69 f4       	brne	.+26     	; 0x429a <free+0x126>
    4280:	30 97       	sbiw	r30, 0x00	; 0
    4282:	29 f4       	brne	.+10     	; 0x428e <free+0x11a>
    4284:	10 92 e7 23 	sts	0x23E7, r1
    4288:	10 92 e8 23 	sts	0x23E8, r1
    428c:	02 c0       	rjmp	.+4      	; 0x4292 <free+0x11e>
    428e:	12 82       	std	Z+2, r1	; 0x02
    4290:	13 82       	std	Z+3, r1	; 0x03
    4292:	00 93 e5 23 	sts	0x23E5, r16
    4296:	10 93 e6 23 	sts	0x23E6, r17
    429a:	df 91       	pop	r29
    429c:	cf 91       	pop	r28
    429e:	1f 91       	pop	r17
    42a0:	0f 91       	pop	r16
    42a2:	08 95       	ret

000042a4 <__itoa_ncheck>:
    42a4:	bb 27       	eor	r27, r27
    42a6:	4a 30       	cpi	r20, 0x0A	; 10
    42a8:	31 f4       	brne	.+12     	; 0x42b6 <__itoa_ncheck+0x12>
    42aa:	99 23       	and	r25, r25
    42ac:	22 f4       	brpl	.+8      	; 0x42b6 <__itoa_ncheck+0x12>
    42ae:	bd e2       	ldi	r27, 0x2D	; 45
    42b0:	90 95       	com	r25
    42b2:	81 95       	neg	r24
    42b4:	9f 4f       	sbci	r25, 0xFF	; 255
    42b6:	01 c0       	rjmp	.+2      	; 0x42ba <__utoa_common>

000042b8 <__utoa_ncheck>:
    42b8:	bb 27       	eor	r27, r27

000042ba <__utoa_common>:
    42ba:	fb 01       	movw	r30, r22
    42bc:	55 27       	eor	r21, r21
    42be:	aa 27       	eor	r26, r26
    42c0:	88 0f       	add	r24, r24
    42c2:	99 1f       	adc	r25, r25
    42c4:	aa 1f       	adc	r26, r26
    42c6:	a4 17       	cp	r26, r20
    42c8:	10 f0       	brcs	.+4      	; 0x42ce <__utoa_common+0x14>
    42ca:	a4 1b       	sub	r26, r20
    42cc:	83 95       	inc	r24
    42ce:	50 51       	subi	r21, 0x10	; 16
    42d0:	b9 f7       	brne	.-18     	; 0x42c0 <__utoa_common+0x6>
    42d2:	a0 5d       	subi	r26, 0xD0	; 208
    42d4:	aa 33       	cpi	r26, 0x3A	; 58
    42d6:	08 f0       	brcs	.+2      	; 0x42da <__utoa_common+0x20>
    42d8:	a9 5d       	subi	r26, 0xD9	; 217
    42da:	a1 93       	st	Z+, r26
    42dc:	00 97       	sbiw	r24, 0x00	; 0
    42de:	79 f7       	brne	.-34     	; 0x42be <__utoa_common+0x4>
    42e0:	b1 11       	cpse	r27, r1
    42e2:	b1 93       	st	Z+, r27
    42e4:	11 92       	st	Z+, r1
    42e6:	cb 01       	movw	r24, r22
    42e8:	34 c2       	rjmp	.+1128   	; 0x4752 <strrev>

000042ea <snprintf>:
    42ea:	0f 93       	push	r16
    42ec:	1f 93       	push	r17
    42ee:	cf 93       	push	r28
    42f0:	df 93       	push	r29
    42f2:	cd b7       	in	r28, 0x3d	; 61
    42f4:	de b7       	in	r29, 0x3e	; 62
    42f6:	2e 97       	sbiw	r28, 0x0e	; 14
    42f8:	cd bf       	out	0x3d, r28	; 61
    42fa:	de bf       	out	0x3e, r29	; 62
    42fc:	0e 89       	ldd	r16, Y+22	; 0x16
    42fe:	1f 89       	ldd	r17, Y+23	; 0x17
    4300:	88 8d       	ldd	r24, Y+24	; 0x18
    4302:	99 8d       	ldd	r25, Y+25	; 0x19
    4304:	26 e0       	ldi	r18, 0x06	; 6
    4306:	2c 83       	std	Y+4, r18	; 0x04
    4308:	09 83       	std	Y+1, r16	; 0x01
    430a:	1a 83       	std	Y+2, r17	; 0x02
    430c:	97 ff       	sbrs	r25, 7
    430e:	02 c0       	rjmp	.+4      	; 0x4314 <snprintf+0x2a>
    4310:	80 e0       	ldi	r24, 0x00	; 0
    4312:	90 e8       	ldi	r25, 0x80	; 128
    4314:	01 97       	sbiw	r24, 0x01	; 1
    4316:	8d 83       	std	Y+5, r24	; 0x05
    4318:	9e 83       	std	Y+6, r25	; 0x06
    431a:	ae 01       	movw	r20, r28
    431c:	44 5e       	subi	r20, 0xE4	; 228
    431e:	5f 4f       	sbci	r21, 0xFF	; 255
    4320:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4322:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4324:	ce 01       	movw	r24, r28
    4326:	01 96       	adiw	r24, 0x01	; 1
    4328:	16 d0       	rcall	.+44     	; 0x4356 <vfprintf>
    432a:	4d 81       	ldd	r20, Y+5	; 0x05
    432c:	5e 81       	ldd	r21, Y+6	; 0x06
    432e:	57 fd       	sbrc	r21, 7
    4330:	0a c0       	rjmp	.+20     	; 0x4346 <snprintf+0x5c>
    4332:	2f 81       	ldd	r18, Y+7	; 0x07
    4334:	38 85       	ldd	r19, Y+8	; 0x08
    4336:	42 17       	cp	r20, r18
    4338:	53 07       	cpc	r21, r19
    433a:	0c f4       	brge	.+2      	; 0x433e <snprintf+0x54>
    433c:	9a 01       	movw	r18, r20
    433e:	f8 01       	movw	r30, r16
    4340:	e2 0f       	add	r30, r18
    4342:	f3 1f       	adc	r31, r19
    4344:	10 82       	st	Z, r1
    4346:	2e 96       	adiw	r28, 0x0e	; 14
    4348:	cd bf       	out	0x3d, r28	; 61
    434a:	de bf       	out	0x3e, r29	; 62
    434c:	df 91       	pop	r29
    434e:	cf 91       	pop	r28
    4350:	1f 91       	pop	r17
    4352:	0f 91       	pop	r16
    4354:	08 95       	ret

00004356 <vfprintf>:
    4356:	2f 92       	push	r2
    4358:	3f 92       	push	r3
    435a:	4f 92       	push	r4
    435c:	5f 92       	push	r5
    435e:	6f 92       	push	r6
    4360:	7f 92       	push	r7
    4362:	8f 92       	push	r8
    4364:	9f 92       	push	r9
    4366:	af 92       	push	r10
    4368:	bf 92       	push	r11
    436a:	cf 92       	push	r12
    436c:	df 92       	push	r13
    436e:	ef 92       	push	r14
    4370:	ff 92       	push	r15
    4372:	0f 93       	push	r16
    4374:	1f 93       	push	r17
    4376:	cf 93       	push	r28
    4378:	df 93       	push	r29
    437a:	cd b7       	in	r28, 0x3d	; 61
    437c:	de b7       	in	r29, 0x3e	; 62
    437e:	2c 97       	sbiw	r28, 0x0c	; 12
    4380:	cd bf       	out	0x3d, r28	; 61
    4382:	de bf       	out	0x3e, r29	; 62
    4384:	7c 01       	movw	r14, r24
    4386:	6b 01       	movw	r12, r22
    4388:	8a 01       	movw	r16, r20
    438a:	fc 01       	movw	r30, r24
    438c:	16 82       	std	Z+6, r1	; 0x06
    438e:	17 82       	std	Z+7, r1	; 0x07
    4390:	83 81       	ldd	r24, Z+3	; 0x03
    4392:	81 ff       	sbrs	r24, 1
    4394:	b0 c1       	rjmp	.+864    	; 0x46f6 <vfprintf+0x3a0>
    4396:	ce 01       	movw	r24, r28
    4398:	01 96       	adiw	r24, 0x01	; 1
    439a:	4c 01       	movw	r8, r24
    439c:	f7 01       	movw	r30, r14
    439e:	93 81       	ldd	r25, Z+3	; 0x03
    43a0:	f6 01       	movw	r30, r12
    43a2:	93 fd       	sbrc	r25, 3
    43a4:	85 91       	lpm	r24, Z+
    43a6:	93 ff       	sbrs	r25, 3
    43a8:	81 91       	ld	r24, Z+
    43aa:	6f 01       	movw	r12, r30
    43ac:	88 23       	and	r24, r24
    43ae:	09 f4       	brne	.+2      	; 0x43b2 <vfprintf+0x5c>
    43b0:	9e c1       	rjmp	.+828    	; 0x46ee <vfprintf+0x398>
    43b2:	85 32       	cpi	r24, 0x25	; 37
    43b4:	39 f4       	brne	.+14     	; 0x43c4 <vfprintf+0x6e>
    43b6:	93 fd       	sbrc	r25, 3
    43b8:	85 91       	lpm	r24, Z+
    43ba:	93 ff       	sbrs	r25, 3
    43bc:	81 91       	ld	r24, Z+
    43be:	6f 01       	movw	r12, r30
    43c0:	85 32       	cpi	r24, 0x25	; 37
    43c2:	21 f4       	brne	.+8      	; 0x43cc <vfprintf+0x76>
    43c4:	b7 01       	movw	r22, r14
    43c6:	90 e0       	ldi	r25, 0x00	; 0
    43c8:	d4 d1       	rcall	.+936    	; 0x4772 <fputc>
    43ca:	e8 cf       	rjmp	.-48     	; 0x439c <vfprintf+0x46>
    43cc:	51 2c       	mov	r5, r1
    43ce:	31 2c       	mov	r3, r1
    43d0:	20 e0       	ldi	r18, 0x00	; 0
    43d2:	20 32       	cpi	r18, 0x20	; 32
    43d4:	a0 f4       	brcc	.+40     	; 0x43fe <vfprintf+0xa8>
    43d6:	8b 32       	cpi	r24, 0x2B	; 43
    43d8:	69 f0       	breq	.+26     	; 0x43f4 <vfprintf+0x9e>
    43da:	30 f4       	brcc	.+12     	; 0x43e8 <vfprintf+0x92>
    43dc:	80 32       	cpi	r24, 0x20	; 32
    43de:	59 f0       	breq	.+22     	; 0x43f6 <vfprintf+0xa0>
    43e0:	83 32       	cpi	r24, 0x23	; 35
    43e2:	69 f4       	brne	.+26     	; 0x43fe <vfprintf+0xa8>
    43e4:	20 61       	ori	r18, 0x10	; 16
    43e6:	2c c0       	rjmp	.+88     	; 0x4440 <vfprintf+0xea>
    43e8:	8d 32       	cpi	r24, 0x2D	; 45
    43ea:	39 f0       	breq	.+14     	; 0x43fa <vfprintf+0xa4>
    43ec:	80 33       	cpi	r24, 0x30	; 48
    43ee:	39 f4       	brne	.+14     	; 0x43fe <vfprintf+0xa8>
    43f0:	21 60       	ori	r18, 0x01	; 1
    43f2:	26 c0       	rjmp	.+76     	; 0x4440 <vfprintf+0xea>
    43f4:	22 60       	ori	r18, 0x02	; 2
    43f6:	24 60       	ori	r18, 0x04	; 4
    43f8:	23 c0       	rjmp	.+70     	; 0x4440 <vfprintf+0xea>
    43fa:	28 60       	ori	r18, 0x08	; 8
    43fc:	21 c0       	rjmp	.+66     	; 0x4440 <vfprintf+0xea>
    43fe:	27 fd       	sbrc	r18, 7
    4400:	27 c0       	rjmp	.+78     	; 0x4450 <vfprintf+0xfa>
    4402:	30 ed       	ldi	r19, 0xD0	; 208
    4404:	38 0f       	add	r19, r24
    4406:	3a 30       	cpi	r19, 0x0A	; 10
    4408:	78 f4       	brcc	.+30     	; 0x4428 <vfprintf+0xd2>
    440a:	26 ff       	sbrs	r18, 6
    440c:	06 c0       	rjmp	.+12     	; 0x441a <vfprintf+0xc4>
    440e:	fa e0       	ldi	r31, 0x0A	; 10
    4410:	5f 9e       	mul	r5, r31
    4412:	30 0d       	add	r19, r0
    4414:	11 24       	eor	r1, r1
    4416:	53 2e       	mov	r5, r19
    4418:	13 c0       	rjmp	.+38     	; 0x4440 <vfprintf+0xea>
    441a:	8a e0       	ldi	r24, 0x0A	; 10
    441c:	38 9e       	mul	r3, r24
    441e:	30 0d       	add	r19, r0
    4420:	11 24       	eor	r1, r1
    4422:	33 2e       	mov	r3, r19
    4424:	20 62       	ori	r18, 0x20	; 32
    4426:	0c c0       	rjmp	.+24     	; 0x4440 <vfprintf+0xea>
    4428:	8e 32       	cpi	r24, 0x2E	; 46
    442a:	21 f4       	brne	.+8      	; 0x4434 <vfprintf+0xde>
    442c:	26 fd       	sbrc	r18, 6
    442e:	5f c1       	rjmp	.+702    	; 0x46ee <vfprintf+0x398>
    4430:	20 64       	ori	r18, 0x40	; 64
    4432:	06 c0       	rjmp	.+12     	; 0x4440 <vfprintf+0xea>
    4434:	8c 36       	cpi	r24, 0x6C	; 108
    4436:	11 f4       	brne	.+4      	; 0x443c <vfprintf+0xe6>
    4438:	20 68       	ori	r18, 0x80	; 128
    443a:	02 c0       	rjmp	.+4      	; 0x4440 <vfprintf+0xea>
    443c:	88 36       	cpi	r24, 0x68	; 104
    443e:	41 f4       	brne	.+16     	; 0x4450 <vfprintf+0xfa>
    4440:	f6 01       	movw	r30, r12
    4442:	93 fd       	sbrc	r25, 3
    4444:	85 91       	lpm	r24, Z+
    4446:	93 ff       	sbrs	r25, 3
    4448:	81 91       	ld	r24, Z+
    444a:	6f 01       	movw	r12, r30
    444c:	81 11       	cpse	r24, r1
    444e:	c1 cf       	rjmp	.-126    	; 0x43d2 <vfprintf+0x7c>
    4450:	98 2f       	mov	r25, r24
    4452:	9f 7d       	andi	r25, 0xDF	; 223
    4454:	95 54       	subi	r25, 0x45	; 69
    4456:	93 30       	cpi	r25, 0x03	; 3
    4458:	28 f4       	brcc	.+10     	; 0x4464 <vfprintf+0x10e>
    445a:	0c 5f       	subi	r16, 0xFC	; 252
    445c:	1f 4f       	sbci	r17, 0xFF	; 255
    445e:	ff e3       	ldi	r31, 0x3F	; 63
    4460:	f9 83       	std	Y+1, r31	; 0x01
    4462:	0d c0       	rjmp	.+26     	; 0x447e <vfprintf+0x128>
    4464:	83 36       	cpi	r24, 0x63	; 99
    4466:	31 f0       	breq	.+12     	; 0x4474 <vfprintf+0x11e>
    4468:	83 37       	cpi	r24, 0x73	; 115
    446a:	71 f0       	breq	.+28     	; 0x4488 <vfprintf+0x132>
    446c:	83 35       	cpi	r24, 0x53	; 83
    446e:	09 f0       	breq	.+2      	; 0x4472 <vfprintf+0x11c>
    4470:	57 c0       	rjmp	.+174    	; 0x4520 <vfprintf+0x1ca>
    4472:	21 c0       	rjmp	.+66     	; 0x44b6 <vfprintf+0x160>
    4474:	f8 01       	movw	r30, r16
    4476:	80 81       	ld	r24, Z
    4478:	89 83       	std	Y+1, r24	; 0x01
    447a:	0e 5f       	subi	r16, 0xFE	; 254
    447c:	1f 4f       	sbci	r17, 0xFF	; 255
    447e:	44 24       	eor	r4, r4
    4480:	43 94       	inc	r4
    4482:	51 2c       	mov	r5, r1
    4484:	54 01       	movw	r10, r8
    4486:	14 c0       	rjmp	.+40     	; 0x44b0 <vfprintf+0x15a>
    4488:	38 01       	movw	r6, r16
    448a:	f2 e0       	ldi	r31, 0x02	; 2
    448c:	6f 0e       	add	r6, r31
    448e:	71 1c       	adc	r7, r1
    4490:	f8 01       	movw	r30, r16
    4492:	a0 80       	ld	r10, Z
    4494:	b1 80       	ldd	r11, Z+1	; 0x01
    4496:	26 ff       	sbrs	r18, 6
    4498:	03 c0       	rjmp	.+6      	; 0x44a0 <vfprintf+0x14a>
    449a:	65 2d       	mov	r22, r5
    449c:	70 e0       	ldi	r23, 0x00	; 0
    449e:	02 c0       	rjmp	.+4      	; 0x44a4 <vfprintf+0x14e>
    44a0:	6f ef       	ldi	r22, 0xFF	; 255
    44a2:	7f ef       	ldi	r23, 0xFF	; 255
    44a4:	c5 01       	movw	r24, r10
    44a6:	2c 87       	std	Y+12, r18	; 0x0c
    44a8:	49 d1       	rcall	.+658    	; 0x473c <strnlen>
    44aa:	2c 01       	movw	r4, r24
    44ac:	83 01       	movw	r16, r6
    44ae:	2c 85       	ldd	r18, Y+12	; 0x0c
    44b0:	2f 77       	andi	r18, 0x7F	; 127
    44b2:	22 2e       	mov	r2, r18
    44b4:	16 c0       	rjmp	.+44     	; 0x44e2 <vfprintf+0x18c>
    44b6:	38 01       	movw	r6, r16
    44b8:	f2 e0       	ldi	r31, 0x02	; 2
    44ba:	6f 0e       	add	r6, r31
    44bc:	71 1c       	adc	r7, r1
    44be:	f8 01       	movw	r30, r16
    44c0:	a0 80       	ld	r10, Z
    44c2:	b1 80       	ldd	r11, Z+1	; 0x01
    44c4:	26 ff       	sbrs	r18, 6
    44c6:	03 c0       	rjmp	.+6      	; 0x44ce <vfprintf+0x178>
    44c8:	65 2d       	mov	r22, r5
    44ca:	70 e0       	ldi	r23, 0x00	; 0
    44cc:	02 c0       	rjmp	.+4      	; 0x44d2 <vfprintf+0x17c>
    44ce:	6f ef       	ldi	r22, 0xFF	; 255
    44d0:	7f ef       	ldi	r23, 0xFF	; 255
    44d2:	c5 01       	movw	r24, r10
    44d4:	2c 87       	std	Y+12, r18	; 0x0c
    44d6:	27 d1       	rcall	.+590    	; 0x4726 <strnlen_P>
    44d8:	2c 01       	movw	r4, r24
    44da:	2c 85       	ldd	r18, Y+12	; 0x0c
    44dc:	20 68       	ori	r18, 0x80	; 128
    44de:	22 2e       	mov	r2, r18
    44e0:	83 01       	movw	r16, r6
    44e2:	23 fc       	sbrc	r2, 3
    44e4:	19 c0       	rjmp	.+50     	; 0x4518 <vfprintf+0x1c2>
    44e6:	83 2d       	mov	r24, r3
    44e8:	90 e0       	ldi	r25, 0x00	; 0
    44ea:	48 16       	cp	r4, r24
    44ec:	59 06       	cpc	r5, r25
    44ee:	a0 f4       	brcc	.+40     	; 0x4518 <vfprintf+0x1c2>
    44f0:	b7 01       	movw	r22, r14
    44f2:	80 e2       	ldi	r24, 0x20	; 32
    44f4:	90 e0       	ldi	r25, 0x00	; 0
    44f6:	3d d1       	rcall	.+634    	; 0x4772 <fputc>
    44f8:	3a 94       	dec	r3
    44fa:	f5 cf       	rjmp	.-22     	; 0x44e6 <vfprintf+0x190>
    44fc:	f5 01       	movw	r30, r10
    44fe:	27 fc       	sbrc	r2, 7
    4500:	85 91       	lpm	r24, Z+
    4502:	27 fe       	sbrs	r2, 7
    4504:	81 91       	ld	r24, Z+
    4506:	5f 01       	movw	r10, r30
    4508:	b7 01       	movw	r22, r14
    450a:	90 e0       	ldi	r25, 0x00	; 0
    450c:	32 d1       	rcall	.+612    	; 0x4772 <fputc>
    450e:	31 10       	cpse	r3, r1
    4510:	3a 94       	dec	r3
    4512:	f1 e0       	ldi	r31, 0x01	; 1
    4514:	4f 1a       	sub	r4, r31
    4516:	51 08       	sbc	r5, r1
    4518:	41 14       	cp	r4, r1
    451a:	51 04       	cpc	r5, r1
    451c:	79 f7       	brne	.-34     	; 0x44fc <vfprintf+0x1a6>
    451e:	de c0       	rjmp	.+444    	; 0x46dc <vfprintf+0x386>
    4520:	84 36       	cpi	r24, 0x64	; 100
    4522:	11 f0       	breq	.+4      	; 0x4528 <vfprintf+0x1d2>
    4524:	89 36       	cpi	r24, 0x69	; 105
    4526:	31 f5       	brne	.+76     	; 0x4574 <vfprintf+0x21e>
    4528:	f8 01       	movw	r30, r16
    452a:	27 ff       	sbrs	r18, 7
    452c:	07 c0       	rjmp	.+14     	; 0x453c <vfprintf+0x1e6>
    452e:	60 81       	ld	r22, Z
    4530:	71 81       	ldd	r23, Z+1	; 0x01
    4532:	82 81       	ldd	r24, Z+2	; 0x02
    4534:	93 81       	ldd	r25, Z+3	; 0x03
    4536:	0c 5f       	subi	r16, 0xFC	; 252
    4538:	1f 4f       	sbci	r17, 0xFF	; 255
    453a:	08 c0       	rjmp	.+16     	; 0x454c <vfprintf+0x1f6>
    453c:	60 81       	ld	r22, Z
    453e:	71 81       	ldd	r23, Z+1	; 0x01
    4540:	07 2e       	mov	r0, r23
    4542:	00 0c       	add	r0, r0
    4544:	88 0b       	sbc	r24, r24
    4546:	99 0b       	sbc	r25, r25
    4548:	0e 5f       	subi	r16, 0xFE	; 254
    454a:	1f 4f       	sbci	r17, 0xFF	; 255
    454c:	2f 76       	andi	r18, 0x6F	; 111
    454e:	72 2e       	mov	r7, r18
    4550:	97 ff       	sbrs	r25, 7
    4552:	09 c0       	rjmp	.+18     	; 0x4566 <vfprintf+0x210>
    4554:	90 95       	com	r25
    4556:	80 95       	com	r24
    4558:	70 95       	com	r23
    455a:	61 95       	neg	r22
    455c:	7f 4f       	sbci	r23, 0xFF	; 255
    455e:	8f 4f       	sbci	r24, 0xFF	; 255
    4560:	9f 4f       	sbci	r25, 0xFF	; 255
    4562:	20 68       	ori	r18, 0x80	; 128
    4564:	72 2e       	mov	r7, r18
    4566:	2a e0       	ldi	r18, 0x0A	; 10
    4568:	30 e0       	ldi	r19, 0x00	; 0
    456a:	a4 01       	movw	r20, r8
    456c:	3a d1       	rcall	.+628    	; 0x47e2 <__ultoa_invert>
    456e:	a8 2e       	mov	r10, r24
    4570:	a8 18       	sub	r10, r8
    4572:	43 c0       	rjmp	.+134    	; 0x45fa <vfprintf+0x2a4>
    4574:	85 37       	cpi	r24, 0x75	; 117
    4576:	29 f4       	brne	.+10     	; 0x4582 <vfprintf+0x22c>
    4578:	2f 7e       	andi	r18, 0xEF	; 239
    457a:	b2 2e       	mov	r11, r18
    457c:	2a e0       	ldi	r18, 0x0A	; 10
    457e:	30 e0       	ldi	r19, 0x00	; 0
    4580:	25 c0       	rjmp	.+74     	; 0x45cc <vfprintf+0x276>
    4582:	f2 2f       	mov	r31, r18
    4584:	f9 7f       	andi	r31, 0xF9	; 249
    4586:	bf 2e       	mov	r11, r31
    4588:	8f 36       	cpi	r24, 0x6F	; 111
    458a:	c1 f0       	breq	.+48     	; 0x45bc <vfprintf+0x266>
    458c:	18 f4       	brcc	.+6      	; 0x4594 <vfprintf+0x23e>
    458e:	88 35       	cpi	r24, 0x58	; 88
    4590:	79 f0       	breq	.+30     	; 0x45b0 <vfprintf+0x25a>
    4592:	ad c0       	rjmp	.+346    	; 0x46ee <vfprintf+0x398>
    4594:	80 37       	cpi	r24, 0x70	; 112
    4596:	19 f0       	breq	.+6      	; 0x459e <vfprintf+0x248>
    4598:	88 37       	cpi	r24, 0x78	; 120
    459a:	21 f0       	breq	.+8      	; 0x45a4 <vfprintf+0x24e>
    459c:	a8 c0       	rjmp	.+336    	; 0x46ee <vfprintf+0x398>
    459e:	2f 2f       	mov	r18, r31
    45a0:	20 61       	ori	r18, 0x10	; 16
    45a2:	b2 2e       	mov	r11, r18
    45a4:	b4 fe       	sbrs	r11, 4
    45a6:	0d c0       	rjmp	.+26     	; 0x45c2 <vfprintf+0x26c>
    45a8:	8b 2d       	mov	r24, r11
    45aa:	84 60       	ori	r24, 0x04	; 4
    45ac:	b8 2e       	mov	r11, r24
    45ae:	09 c0       	rjmp	.+18     	; 0x45c2 <vfprintf+0x26c>
    45b0:	24 ff       	sbrs	r18, 4
    45b2:	0a c0       	rjmp	.+20     	; 0x45c8 <vfprintf+0x272>
    45b4:	9f 2f       	mov	r25, r31
    45b6:	96 60       	ori	r25, 0x06	; 6
    45b8:	b9 2e       	mov	r11, r25
    45ba:	06 c0       	rjmp	.+12     	; 0x45c8 <vfprintf+0x272>
    45bc:	28 e0       	ldi	r18, 0x08	; 8
    45be:	30 e0       	ldi	r19, 0x00	; 0
    45c0:	05 c0       	rjmp	.+10     	; 0x45cc <vfprintf+0x276>
    45c2:	20 e1       	ldi	r18, 0x10	; 16
    45c4:	30 e0       	ldi	r19, 0x00	; 0
    45c6:	02 c0       	rjmp	.+4      	; 0x45cc <vfprintf+0x276>
    45c8:	20 e1       	ldi	r18, 0x10	; 16
    45ca:	32 e0       	ldi	r19, 0x02	; 2
    45cc:	f8 01       	movw	r30, r16
    45ce:	b7 fe       	sbrs	r11, 7
    45d0:	07 c0       	rjmp	.+14     	; 0x45e0 <vfprintf+0x28a>
    45d2:	60 81       	ld	r22, Z
    45d4:	71 81       	ldd	r23, Z+1	; 0x01
    45d6:	82 81       	ldd	r24, Z+2	; 0x02
    45d8:	93 81       	ldd	r25, Z+3	; 0x03
    45da:	0c 5f       	subi	r16, 0xFC	; 252
    45dc:	1f 4f       	sbci	r17, 0xFF	; 255
    45de:	06 c0       	rjmp	.+12     	; 0x45ec <vfprintf+0x296>
    45e0:	60 81       	ld	r22, Z
    45e2:	71 81       	ldd	r23, Z+1	; 0x01
    45e4:	80 e0       	ldi	r24, 0x00	; 0
    45e6:	90 e0       	ldi	r25, 0x00	; 0
    45e8:	0e 5f       	subi	r16, 0xFE	; 254
    45ea:	1f 4f       	sbci	r17, 0xFF	; 255
    45ec:	a4 01       	movw	r20, r8
    45ee:	f9 d0       	rcall	.+498    	; 0x47e2 <__ultoa_invert>
    45f0:	a8 2e       	mov	r10, r24
    45f2:	a8 18       	sub	r10, r8
    45f4:	fb 2d       	mov	r31, r11
    45f6:	ff 77       	andi	r31, 0x7F	; 127
    45f8:	7f 2e       	mov	r7, r31
    45fa:	76 fe       	sbrs	r7, 6
    45fc:	0b c0       	rjmp	.+22     	; 0x4614 <vfprintf+0x2be>
    45fe:	37 2d       	mov	r19, r7
    4600:	3e 7f       	andi	r19, 0xFE	; 254
    4602:	a5 14       	cp	r10, r5
    4604:	50 f4       	brcc	.+20     	; 0x461a <vfprintf+0x2c4>
    4606:	74 fe       	sbrs	r7, 4
    4608:	0a c0       	rjmp	.+20     	; 0x461e <vfprintf+0x2c8>
    460a:	72 fc       	sbrc	r7, 2
    460c:	08 c0       	rjmp	.+16     	; 0x461e <vfprintf+0x2c8>
    460e:	37 2d       	mov	r19, r7
    4610:	3e 7e       	andi	r19, 0xEE	; 238
    4612:	05 c0       	rjmp	.+10     	; 0x461e <vfprintf+0x2c8>
    4614:	ba 2c       	mov	r11, r10
    4616:	37 2d       	mov	r19, r7
    4618:	03 c0       	rjmp	.+6      	; 0x4620 <vfprintf+0x2ca>
    461a:	ba 2c       	mov	r11, r10
    461c:	01 c0       	rjmp	.+2      	; 0x4620 <vfprintf+0x2ca>
    461e:	b5 2c       	mov	r11, r5
    4620:	34 ff       	sbrs	r19, 4
    4622:	0d c0       	rjmp	.+26     	; 0x463e <vfprintf+0x2e8>
    4624:	fe 01       	movw	r30, r28
    4626:	ea 0d       	add	r30, r10
    4628:	f1 1d       	adc	r31, r1
    462a:	80 81       	ld	r24, Z
    462c:	80 33       	cpi	r24, 0x30	; 48
    462e:	11 f4       	brne	.+4      	; 0x4634 <vfprintf+0x2de>
    4630:	39 7e       	andi	r19, 0xE9	; 233
    4632:	09 c0       	rjmp	.+18     	; 0x4646 <vfprintf+0x2f0>
    4634:	32 ff       	sbrs	r19, 2
    4636:	06 c0       	rjmp	.+12     	; 0x4644 <vfprintf+0x2ee>
    4638:	b3 94       	inc	r11
    463a:	b3 94       	inc	r11
    463c:	04 c0       	rjmp	.+8      	; 0x4646 <vfprintf+0x2f0>
    463e:	83 2f       	mov	r24, r19
    4640:	86 78       	andi	r24, 0x86	; 134
    4642:	09 f0       	breq	.+2      	; 0x4646 <vfprintf+0x2f0>
    4644:	b3 94       	inc	r11
    4646:	33 fd       	sbrc	r19, 3
    4648:	12 c0       	rjmp	.+36     	; 0x466e <vfprintf+0x318>
    464a:	30 ff       	sbrs	r19, 0
    464c:	06 c0       	rjmp	.+12     	; 0x465a <vfprintf+0x304>
    464e:	5a 2c       	mov	r5, r10
    4650:	b3 14       	cp	r11, r3
    4652:	18 f4       	brcc	.+6      	; 0x465a <vfprintf+0x304>
    4654:	53 0c       	add	r5, r3
    4656:	5b 18       	sub	r5, r11
    4658:	b3 2c       	mov	r11, r3
    465a:	b3 14       	cp	r11, r3
    465c:	60 f4       	brcc	.+24     	; 0x4676 <vfprintf+0x320>
    465e:	b7 01       	movw	r22, r14
    4660:	80 e2       	ldi	r24, 0x20	; 32
    4662:	90 e0       	ldi	r25, 0x00	; 0
    4664:	3c 87       	std	Y+12, r19	; 0x0c
    4666:	85 d0       	rcall	.+266    	; 0x4772 <fputc>
    4668:	b3 94       	inc	r11
    466a:	3c 85       	ldd	r19, Y+12	; 0x0c
    466c:	f6 cf       	rjmp	.-20     	; 0x465a <vfprintf+0x304>
    466e:	b3 14       	cp	r11, r3
    4670:	10 f4       	brcc	.+4      	; 0x4676 <vfprintf+0x320>
    4672:	3b 18       	sub	r3, r11
    4674:	01 c0       	rjmp	.+2      	; 0x4678 <vfprintf+0x322>
    4676:	31 2c       	mov	r3, r1
    4678:	34 ff       	sbrs	r19, 4
    467a:	11 c0       	rjmp	.+34     	; 0x469e <vfprintf+0x348>
    467c:	b7 01       	movw	r22, r14
    467e:	80 e3       	ldi	r24, 0x30	; 48
    4680:	90 e0       	ldi	r25, 0x00	; 0
    4682:	3c 87       	std	Y+12, r19	; 0x0c
    4684:	76 d0       	rcall	.+236    	; 0x4772 <fputc>
    4686:	3c 85       	ldd	r19, Y+12	; 0x0c
    4688:	32 ff       	sbrs	r19, 2
    468a:	16 c0       	rjmp	.+44     	; 0x46b8 <vfprintf+0x362>
    468c:	31 fd       	sbrc	r19, 1
    468e:	03 c0       	rjmp	.+6      	; 0x4696 <vfprintf+0x340>
    4690:	88 e7       	ldi	r24, 0x78	; 120
    4692:	90 e0       	ldi	r25, 0x00	; 0
    4694:	02 c0       	rjmp	.+4      	; 0x469a <vfprintf+0x344>
    4696:	88 e5       	ldi	r24, 0x58	; 88
    4698:	90 e0       	ldi	r25, 0x00	; 0
    469a:	b7 01       	movw	r22, r14
    469c:	0c c0       	rjmp	.+24     	; 0x46b6 <vfprintf+0x360>
    469e:	83 2f       	mov	r24, r19
    46a0:	86 78       	andi	r24, 0x86	; 134
    46a2:	51 f0       	breq	.+20     	; 0x46b8 <vfprintf+0x362>
    46a4:	31 ff       	sbrs	r19, 1
    46a6:	02 c0       	rjmp	.+4      	; 0x46ac <vfprintf+0x356>
    46a8:	8b e2       	ldi	r24, 0x2B	; 43
    46aa:	01 c0       	rjmp	.+2      	; 0x46ae <vfprintf+0x358>
    46ac:	80 e2       	ldi	r24, 0x20	; 32
    46ae:	37 fd       	sbrc	r19, 7
    46b0:	8d e2       	ldi	r24, 0x2D	; 45
    46b2:	b7 01       	movw	r22, r14
    46b4:	90 e0       	ldi	r25, 0x00	; 0
    46b6:	5d d0       	rcall	.+186    	; 0x4772 <fputc>
    46b8:	a5 14       	cp	r10, r5
    46ba:	30 f4       	brcc	.+12     	; 0x46c8 <vfprintf+0x372>
    46bc:	b7 01       	movw	r22, r14
    46be:	80 e3       	ldi	r24, 0x30	; 48
    46c0:	90 e0       	ldi	r25, 0x00	; 0
    46c2:	57 d0       	rcall	.+174    	; 0x4772 <fputc>
    46c4:	5a 94       	dec	r5
    46c6:	f8 cf       	rjmp	.-16     	; 0x46b8 <vfprintf+0x362>
    46c8:	aa 94       	dec	r10
    46ca:	f4 01       	movw	r30, r8
    46cc:	ea 0d       	add	r30, r10
    46ce:	f1 1d       	adc	r31, r1
    46d0:	80 81       	ld	r24, Z
    46d2:	b7 01       	movw	r22, r14
    46d4:	90 e0       	ldi	r25, 0x00	; 0
    46d6:	4d d0       	rcall	.+154    	; 0x4772 <fputc>
    46d8:	a1 10       	cpse	r10, r1
    46da:	f6 cf       	rjmp	.-20     	; 0x46c8 <vfprintf+0x372>
    46dc:	33 20       	and	r3, r3
    46de:	09 f4       	brne	.+2      	; 0x46e2 <vfprintf+0x38c>
    46e0:	5d ce       	rjmp	.-838    	; 0x439c <vfprintf+0x46>
    46e2:	b7 01       	movw	r22, r14
    46e4:	80 e2       	ldi	r24, 0x20	; 32
    46e6:	90 e0       	ldi	r25, 0x00	; 0
    46e8:	44 d0       	rcall	.+136    	; 0x4772 <fputc>
    46ea:	3a 94       	dec	r3
    46ec:	f7 cf       	rjmp	.-18     	; 0x46dc <vfprintf+0x386>
    46ee:	f7 01       	movw	r30, r14
    46f0:	86 81       	ldd	r24, Z+6	; 0x06
    46f2:	97 81       	ldd	r25, Z+7	; 0x07
    46f4:	02 c0       	rjmp	.+4      	; 0x46fa <vfprintf+0x3a4>
    46f6:	8f ef       	ldi	r24, 0xFF	; 255
    46f8:	9f ef       	ldi	r25, 0xFF	; 255
    46fa:	2c 96       	adiw	r28, 0x0c	; 12
    46fc:	cd bf       	out	0x3d, r28	; 61
    46fe:	de bf       	out	0x3e, r29	; 62
    4700:	df 91       	pop	r29
    4702:	cf 91       	pop	r28
    4704:	1f 91       	pop	r17
    4706:	0f 91       	pop	r16
    4708:	ff 90       	pop	r15
    470a:	ef 90       	pop	r14
    470c:	df 90       	pop	r13
    470e:	cf 90       	pop	r12
    4710:	bf 90       	pop	r11
    4712:	af 90       	pop	r10
    4714:	9f 90       	pop	r9
    4716:	8f 90       	pop	r8
    4718:	7f 90       	pop	r7
    471a:	6f 90       	pop	r6
    471c:	5f 90       	pop	r5
    471e:	4f 90       	pop	r4
    4720:	3f 90       	pop	r3
    4722:	2f 90       	pop	r2
    4724:	08 95       	ret

00004726 <strnlen_P>:
    4726:	fc 01       	movw	r30, r24
    4728:	05 90       	lpm	r0, Z+
    472a:	61 50       	subi	r22, 0x01	; 1
    472c:	70 40       	sbci	r23, 0x00	; 0
    472e:	01 10       	cpse	r0, r1
    4730:	d8 f7       	brcc	.-10     	; 0x4728 <strnlen_P+0x2>
    4732:	80 95       	com	r24
    4734:	90 95       	com	r25
    4736:	8e 0f       	add	r24, r30
    4738:	9f 1f       	adc	r25, r31
    473a:	08 95       	ret

0000473c <strnlen>:
    473c:	fc 01       	movw	r30, r24
    473e:	61 50       	subi	r22, 0x01	; 1
    4740:	70 40       	sbci	r23, 0x00	; 0
    4742:	01 90       	ld	r0, Z+
    4744:	01 10       	cpse	r0, r1
    4746:	d8 f7       	brcc	.-10     	; 0x473e <strnlen+0x2>
    4748:	80 95       	com	r24
    474a:	90 95       	com	r25
    474c:	8e 0f       	add	r24, r30
    474e:	9f 1f       	adc	r25, r31
    4750:	08 95       	ret

00004752 <strrev>:
    4752:	dc 01       	movw	r26, r24
    4754:	fc 01       	movw	r30, r24
    4756:	67 2f       	mov	r22, r23
    4758:	71 91       	ld	r23, Z+
    475a:	77 23       	and	r23, r23
    475c:	e1 f7       	brne	.-8      	; 0x4756 <strrev+0x4>
    475e:	32 97       	sbiw	r30, 0x02	; 2
    4760:	04 c0       	rjmp	.+8      	; 0x476a <strrev+0x18>
    4762:	7c 91       	ld	r23, X
    4764:	6d 93       	st	X+, r22
    4766:	70 83       	st	Z, r23
    4768:	62 91       	ld	r22, -Z
    476a:	ae 17       	cp	r26, r30
    476c:	bf 07       	cpc	r27, r31
    476e:	c8 f3       	brcs	.-14     	; 0x4762 <strrev+0x10>
    4770:	08 95       	ret

00004772 <fputc>:
    4772:	0f 93       	push	r16
    4774:	1f 93       	push	r17
    4776:	cf 93       	push	r28
    4778:	df 93       	push	r29
    477a:	fb 01       	movw	r30, r22
    477c:	23 81       	ldd	r18, Z+3	; 0x03
    477e:	21 fd       	sbrc	r18, 1
    4780:	03 c0       	rjmp	.+6      	; 0x4788 <fputc+0x16>
    4782:	8f ef       	ldi	r24, 0xFF	; 255
    4784:	9f ef       	ldi	r25, 0xFF	; 255
    4786:	28 c0       	rjmp	.+80     	; 0x47d8 <fputc+0x66>
    4788:	22 ff       	sbrs	r18, 2
    478a:	16 c0       	rjmp	.+44     	; 0x47b8 <fputc+0x46>
    478c:	46 81       	ldd	r20, Z+6	; 0x06
    478e:	57 81       	ldd	r21, Z+7	; 0x07
    4790:	24 81       	ldd	r18, Z+4	; 0x04
    4792:	35 81       	ldd	r19, Z+5	; 0x05
    4794:	42 17       	cp	r20, r18
    4796:	53 07       	cpc	r21, r19
    4798:	44 f4       	brge	.+16     	; 0x47aa <fputc+0x38>
    479a:	a0 81       	ld	r26, Z
    479c:	b1 81       	ldd	r27, Z+1	; 0x01
    479e:	9d 01       	movw	r18, r26
    47a0:	2f 5f       	subi	r18, 0xFF	; 255
    47a2:	3f 4f       	sbci	r19, 0xFF	; 255
    47a4:	20 83       	st	Z, r18
    47a6:	31 83       	std	Z+1, r19	; 0x01
    47a8:	8c 93       	st	X, r24
    47aa:	26 81       	ldd	r18, Z+6	; 0x06
    47ac:	37 81       	ldd	r19, Z+7	; 0x07
    47ae:	2f 5f       	subi	r18, 0xFF	; 255
    47b0:	3f 4f       	sbci	r19, 0xFF	; 255
    47b2:	26 83       	std	Z+6, r18	; 0x06
    47b4:	37 83       	std	Z+7, r19	; 0x07
    47b6:	10 c0       	rjmp	.+32     	; 0x47d8 <fputc+0x66>
    47b8:	eb 01       	movw	r28, r22
    47ba:	09 2f       	mov	r16, r25
    47bc:	18 2f       	mov	r17, r24
    47be:	00 84       	ldd	r0, Z+8	; 0x08
    47c0:	f1 85       	ldd	r31, Z+9	; 0x09
    47c2:	e0 2d       	mov	r30, r0
    47c4:	19 95       	eicall
    47c6:	89 2b       	or	r24, r25
    47c8:	e1 f6       	brne	.-72     	; 0x4782 <fputc+0x10>
    47ca:	8e 81       	ldd	r24, Y+6	; 0x06
    47cc:	9f 81       	ldd	r25, Y+7	; 0x07
    47ce:	01 96       	adiw	r24, 0x01	; 1
    47d0:	8e 83       	std	Y+6, r24	; 0x06
    47d2:	9f 83       	std	Y+7, r25	; 0x07
    47d4:	81 2f       	mov	r24, r17
    47d6:	90 2f       	mov	r25, r16
    47d8:	df 91       	pop	r29
    47da:	cf 91       	pop	r28
    47dc:	1f 91       	pop	r17
    47de:	0f 91       	pop	r16
    47e0:	08 95       	ret

000047e2 <__ultoa_invert>:
    47e2:	fa 01       	movw	r30, r20
    47e4:	aa 27       	eor	r26, r26
    47e6:	28 30       	cpi	r18, 0x08	; 8
    47e8:	51 f1       	breq	.+84     	; 0x483e <__ultoa_invert+0x5c>
    47ea:	20 31       	cpi	r18, 0x10	; 16
    47ec:	81 f1       	breq	.+96     	; 0x484e <__ultoa_invert+0x6c>
    47ee:	e8 94       	clt
    47f0:	6f 93       	push	r22
    47f2:	6e 7f       	andi	r22, 0xFE	; 254
    47f4:	6e 5f       	subi	r22, 0xFE	; 254
    47f6:	7f 4f       	sbci	r23, 0xFF	; 255
    47f8:	8f 4f       	sbci	r24, 0xFF	; 255
    47fa:	9f 4f       	sbci	r25, 0xFF	; 255
    47fc:	af 4f       	sbci	r26, 0xFF	; 255
    47fe:	b1 e0       	ldi	r27, 0x01	; 1
    4800:	3e d0       	rcall	.+124    	; 0x487e <__ultoa_invert+0x9c>
    4802:	b4 e0       	ldi	r27, 0x04	; 4
    4804:	3c d0       	rcall	.+120    	; 0x487e <__ultoa_invert+0x9c>
    4806:	67 0f       	add	r22, r23
    4808:	78 1f       	adc	r23, r24
    480a:	89 1f       	adc	r24, r25
    480c:	9a 1f       	adc	r25, r26
    480e:	a1 1d       	adc	r26, r1
    4810:	68 0f       	add	r22, r24
    4812:	79 1f       	adc	r23, r25
    4814:	8a 1f       	adc	r24, r26
    4816:	91 1d       	adc	r25, r1
    4818:	a1 1d       	adc	r26, r1
    481a:	6a 0f       	add	r22, r26
    481c:	71 1d       	adc	r23, r1
    481e:	81 1d       	adc	r24, r1
    4820:	91 1d       	adc	r25, r1
    4822:	a1 1d       	adc	r26, r1
    4824:	20 d0       	rcall	.+64     	; 0x4866 <__ultoa_invert+0x84>
    4826:	09 f4       	brne	.+2      	; 0x482a <__ultoa_invert+0x48>
    4828:	68 94       	set
    482a:	3f 91       	pop	r19
    482c:	2a e0       	ldi	r18, 0x0A	; 10
    482e:	26 9f       	mul	r18, r22
    4830:	11 24       	eor	r1, r1
    4832:	30 19       	sub	r19, r0
    4834:	30 5d       	subi	r19, 0xD0	; 208
    4836:	31 93       	st	Z+, r19
    4838:	de f6       	brtc	.-74     	; 0x47f0 <__ultoa_invert+0xe>
    483a:	cf 01       	movw	r24, r30
    483c:	08 95       	ret
    483e:	46 2f       	mov	r20, r22
    4840:	47 70       	andi	r20, 0x07	; 7
    4842:	40 5d       	subi	r20, 0xD0	; 208
    4844:	41 93       	st	Z+, r20
    4846:	b3 e0       	ldi	r27, 0x03	; 3
    4848:	0f d0       	rcall	.+30     	; 0x4868 <__ultoa_invert+0x86>
    484a:	c9 f7       	brne	.-14     	; 0x483e <__ultoa_invert+0x5c>
    484c:	f6 cf       	rjmp	.-20     	; 0x483a <__ultoa_invert+0x58>
    484e:	46 2f       	mov	r20, r22
    4850:	4f 70       	andi	r20, 0x0F	; 15
    4852:	40 5d       	subi	r20, 0xD0	; 208
    4854:	4a 33       	cpi	r20, 0x3A	; 58
    4856:	18 f0       	brcs	.+6      	; 0x485e <__ultoa_invert+0x7c>
    4858:	49 5d       	subi	r20, 0xD9	; 217
    485a:	31 fd       	sbrc	r19, 1
    485c:	40 52       	subi	r20, 0x20	; 32
    485e:	41 93       	st	Z+, r20
    4860:	02 d0       	rcall	.+4      	; 0x4866 <__ultoa_invert+0x84>
    4862:	a9 f7       	brne	.-22     	; 0x484e <__ultoa_invert+0x6c>
    4864:	ea cf       	rjmp	.-44     	; 0x483a <__ultoa_invert+0x58>
    4866:	b4 e0       	ldi	r27, 0x04	; 4
    4868:	a6 95       	lsr	r26
    486a:	97 95       	ror	r25
    486c:	87 95       	ror	r24
    486e:	77 95       	ror	r23
    4870:	67 95       	ror	r22
    4872:	ba 95       	dec	r27
    4874:	c9 f7       	brne	.-14     	; 0x4868 <__ultoa_invert+0x86>
    4876:	00 97       	sbiw	r24, 0x00	; 0
    4878:	61 05       	cpc	r22, r1
    487a:	71 05       	cpc	r23, r1
    487c:	08 95       	ret
    487e:	9b 01       	movw	r18, r22
    4880:	ac 01       	movw	r20, r24
    4882:	0a 2e       	mov	r0, r26
    4884:	06 94       	lsr	r0
    4886:	57 95       	ror	r21
    4888:	47 95       	ror	r20
    488a:	37 95       	ror	r19
    488c:	27 95       	ror	r18
    488e:	ba 95       	dec	r27
    4890:	c9 f7       	brne	.-14     	; 0x4884 <__ultoa_invert+0xa2>
    4892:	62 0f       	add	r22, r18
    4894:	73 1f       	adc	r23, r19
    4896:	84 1f       	adc	r24, r20
    4898:	95 1f       	adc	r25, r21
    489a:	a0 1d       	adc	r26, r0
    489c:	08 95       	ret

0000489e <_exit>:
    489e:	f8 94       	cli

000048a0 <__stop_program>:
    48a0:	ff cf       	rjmp	.-2      	; 0x48a0 <__stop_program>
