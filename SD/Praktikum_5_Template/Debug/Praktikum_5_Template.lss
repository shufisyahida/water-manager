
Praktikum_5_Template.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003bbc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000050  00802000  00003bbc  00003c50  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000359  00802050  00802050  00003ca0  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003ca0  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000006c8  00000000  00000000  00003d00  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000126a0  00000000  00000000  000043c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00003040  00000000  00000000  00016a68  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000b11c  00000000  00000000  00019aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000016b4  00000000  00000000  00024bc4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00034ec3  00000000  00000000  00026278  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00009417  00000000  00000000  0005b13b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000008a8  00000000  00000000  00064558  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0000c5bf  00000000  00000000  00064e00  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 88 0d 	jmp	0x1b10	; 0x1b10 <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ef c7       	rjmp	.+4062   	; 0x107c <__vector_39>
      9e:	00 00       	nop
      a0:	0c 94 70 08 	jmp	0x10e0	; 0x10e0 <__vector_40>
      a4:	0c 94 a2 08 	jmp	0x1144	; 0x1144 <__vector_41>
      a8:	0c 94 d4 08 	jmp	0x11a8	; 0x11a8 <__vector_42>
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	e7 c6       	rjmp	.+3534   	; 0xeec <__vector_71>
     11e:	00 00       	nop
     120:	17 c7       	rjmp	.+3630   	; 0xf50 <__vector_72>
     122:	00 00       	nop
     124:	47 c7       	rjmp	.+3726   	; 0xfb4 <__vector_73>
     126:	00 00       	nop
     128:	77 c7       	rjmp	.+3822   	; 0x1018 <__vector_74>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	86 16       	cp	r8, r22
     1fe:	86 16       	cp	r8, r22
     200:	86 16       	cp	r8, r22
     202:	be 16       	cp	r11, r30
     204:	ad 16       	cp	r10, r29
     206:	bb 16       	cp	r11, r27
     208:	86 16       	cp	r8, r22
     20a:	86 16       	cp	r8, r22
     20c:	be 16       	cp	r11, r30
     20e:	ad 16       	cp	r10, r29

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__trampolines_end+0x21e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__trampolines_end+0x24e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	ec eb       	ldi	r30, 0xBC	; 188
     4ba:	fb e3       	ldi	r31, 0x3B	; 59
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	a0 35       	cpi	r26, 0x50	; 80
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	23 e2       	ldi	r18, 0x23	; 35
     4ce:	a0 e5       	ldi	r26, 0x50	; 80
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	a9 3a       	cpi	r26, 0xA9	; 169
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 bf 18 	call	0x317e	; 0x317e <main>
     4e0:	0c 94 dc 1d 	jmp	0x3bb8	; 0x3bb8 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4e6:	bf 92       	push	r11
     4e8:	cf 92       	push	r12
     4ea:	df 92       	push	r13
     4ec:	ef 92       	push	r14
     4ee:	ff 92       	push	r15
     4f0:	0f 93       	push	r16
     4f2:	1f 93       	push	r17
     4f4:	cf 93       	push	r28
     4f6:	df 93       	push	r29
     4f8:	1f 92       	push	r1
     4fa:	cd b7       	in	r28, 0x3d	; 61
     4fc:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     4fe:	88 e0       	ldi	r24, 0x08	; 8
     500:	e0 e0       	ldi	r30, 0x00	; 0
     502:	f6 e0       	ldi	r31, 0x06	; 6
     504:	86 83       	std	Z+6, r24	; 0x06
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     506:	85 83       	std	Z+5, r24	; 0x05
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     508:	0f 2e       	mov	r0, r31
     50a:	fb e2       	ldi	r31, 0x2B	; 43
     50c:	bf 2e       	mov	r11, r31
     50e:	f0 2d       	mov	r31, r0
     510:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     512:	80 ea       	ldi	r24, 0xA0	; 160
     514:	99 e0       	ldi	r25, 0x09	; 9
     516:	22 d4       	rcall	.+2116   	; 0xd5c <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     518:	c1 2c       	mov	r12, r1
     51a:	d1 2c       	mov	r13, r1
     51c:	76 01       	movw	r14, r12
     51e:	00 e4       	ldi	r16, 0x40	; 64
     520:	12 e4       	ldi	r17, 0x42	; 66
     522:	2f e0       	ldi	r18, 0x0F	; 15
     524:	30 e0       	ldi	r19, 0x00	; 0
     526:	43 e0       	ldi	r20, 0x03	; 3
     528:	be 01       	movw	r22, r28
     52a:	6f 5f       	subi	r22, 0xFF	; 255
     52c:	7f 4f       	sbci	r23, 0xFF	; 255
     52e:	80 ea       	ldi	r24, 0xA0	; 160
     530:	99 e0       	ldi	r25, 0x09	; 9
     532:	43 d4       	rcall	.+2182   	; 0xdba <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     534:	00 e6       	ldi	r16, 0x60	; 96
     536:	16 e0       	ldi	r17, 0x06	; 6
     538:	ff 24       	eor	r15, r15
     53a:	f3 94       	inc	r15
     53c:	f8 01       	movw	r30, r16
     53e:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     540:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     542:	be 01       	movw	r22, r28
     544:	6f 5f       	subi	r22, 0xFF	; 255
     546:	7f 4f       	sbci	r23, 0xFF	; 255
     548:	80 ea       	ldi	r24, 0xA0	; 160
     54a:	99 e0       	ldi	r25, 0x09	; 9
     54c:	50 d4       	rcall	.+2208   	; 0xdee <usart_spi_select_device>
     54e:	f8 01       	movw	r30, r16
     550:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     552:	e0 ea       	ldi	r30, 0xA0	; 160
     554:	f9 e0       	ldi	r31, 0x09	; 9
     556:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     558:	85 ff       	sbrs	r24, 5
     55a:	fd cf       	rjmp	.-6      	; 0x556 <st7565r_init+0x70>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     55c:	80 ea       	ldi	r24, 0xA0	; 160
     55e:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     562:	e0 ea       	ldi	r30, 0xA0	; 160
     564:	f9 e0       	ldi	r31, 0x09	; 9
     566:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     568:	86 ff       	sbrs	r24, 6
     56a:	fd cf       	rjmp	.-6      	; 0x566 <st7565r_init+0x80>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     56c:	e0 ea       	ldi	r30, 0xA0	; 160
     56e:	f9 e0       	ldi	r31, 0x09	; 9
     570:	80 e4       	ldi	r24, 0x40	; 64
     572:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     574:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     576:	be 01       	movw	r22, r28
     578:	6f 5f       	subi	r22, 0xFF	; 255
     57a:	7f 4f       	sbci	r23, 0xFF	; 255
     57c:	80 ea       	ldi	r24, 0xA0	; 160
     57e:	99 e0       	ldi	r25, 0x09	; 9
     580:	4c d4       	rcall	.+2200   	; 0xe1a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     582:	8b e2       	ldi	r24, 0x2B	; 43
     584:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     586:	be 01       	movw	r22, r28
     588:	6f 5f       	subi	r22, 0xFF	; 255
     58a:	7f 4f       	sbci	r23, 0xFF	; 255
     58c:	80 ea       	ldi	r24, 0xA0	; 160
     58e:	99 e0       	ldi	r25, 0x09	; 9
     590:	2e d4       	rcall	.+2140   	; 0xdee <usart_spi_select_device>
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	e0 e6       	ldi	r30, 0x60	; 96
     596:	f6 e0       	ldi	r31, 0x06	; 6
     598:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     59a:	e0 ea       	ldi	r30, 0xA0	; 160
     59c:	f9 e0       	ldi	r31, 0x09	; 9
     59e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5a0:	85 ff       	sbrs	r24, 5
     5a2:	fd cf       	rjmp	.-6      	; 0x59e <st7565r_init+0xb8>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5a4:	86 ea       	ldi	r24, 0xA6	; 166
     5a6:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5aa:	e0 ea       	ldi	r30, 0xA0	; 160
     5ac:	f9 e0       	ldi	r31, 0x09	; 9
     5ae:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5b0:	86 ff       	sbrs	r24, 6
     5b2:	fd cf       	rjmp	.-6      	; 0x5ae <st7565r_init+0xc8>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5b4:	e0 ea       	ldi	r30, 0xA0	; 160
     5b6:	f9 e0       	ldi	r31, 0x09	; 9
     5b8:	80 e4       	ldi	r24, 0x40	; 64
     5ba:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5bc:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5be:	be 01       	movw	r22, r28
     5c0:	6f 5f       	subi	r22, 0xFF	; 255
     5c2:	7f 4f       	sbci	r23, 0xFF	; 255
     5c4:	80 ea       	ldi	r24, 0xA0	; 160
     5c6:	99 e0       	ldi	r25, 0x09	; 9
     5c8:	28 d4       	rcall	.+2128   	; 0xe1a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5ca:	8b e2       	ldi	r24, 0x2B	; 43
     5cc:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5ce:	be 01       	movw	r22, r28
     5d0:	6f 5f       	subi	r22, 0xFF	; 255
     5d2:	7f 4f       	sbci	r23, 0xFF	; 255
     5d4:	80 ea       	ldi	r24, 0xA0	; 160
     5d6:	99 e0       	ldi	r25, 0x09	; 9
     5d8:	0a d4       	rcall	.+2068   	; 0xdee <usart_spi_select_device>
     5da:	81 e0       	ldi	r24, 0x01	; 1
     5dc:	e0 e6       	ldi	r30, 0x60	; 96
     5de:	f6 e0       	ldi	r31, 0x06	; 6
     5e0:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5e2:	e0 ea       	ldi	r30, 0xA0	; 160
     5e4:	f9 e0       	ldi	r31, 0x09	; 9
     5e6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5e8:	85 ff       	sbrs	r24, 5
     5ea:	fd cf       	rjmp	.-6      	; 0x5e6 <st7565r_init+0x100>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5ec:	88 ec       	ldi	r24, 0xC8	; 200
     5ee:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5f2:	e0 ea       	ldi	r30, 0xA0	; 160
     5f4:	f9 e0       	ldi	r31, 0x09	; 9
     5f6:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5f8:	86 ff       	sbrs	r24, 6
     5fa:	fd cf       	rjmp	.-6      	; 0x5f6 <st7565r_init+0x110>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5fc:	e0 ea       	ldi	r30, 0xA0	; 160
     5fe:	f9 e0       	ldi	r31, 0x09	; 9
     600:	80 e4       	ldi	r24, 0x40	; 64
     602:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     604:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     606:	be 01       	movw	r22, r28
     608:	6f 5f       	subi	r22, 0xFF	; 255
     60a:	7f 4f       	sbci	r23, 0xFF	; 255
     60c:	80 ea       	ldi	r24, 0xA0	; 160
     60e:	99 e0       	ldi	r25, 0x09	; 9
     610:	04 d4       	rcall	.+2056   	; 0xe1a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     612:	8b e2       	ldi	r24, 0x2B	; 43
     614:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     616:	be 01       	movw	r22, r28
     618:	6f 5f       	subi	r22, 0xFF	; 255
     61a:	7f 4f       	sbci	r23, 0xFF	; 255
     61c:	80 ea       	ldi	r24, 0xA0	; 160
     61e:	99 e0       	ldi	r25, 0x09	; 9
     620:	e6 d3       	rcall	.+1996   	; 0xdee <usart_spi_select_device>
     622:	81 e0       	ldi	r24, 0x01	; 1
     624:	e0 e6       	ldi	r30, 0x60	; 96
     626:	f6 e0       	ldi	r31, 0x06	; 6
     628:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     62a:	e0 ea       	ldi	r30, 0xA0	; 160
     62c:	f9 e0       	ldi	r31, 0x09	; 9
     62e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     630:	85 ff       	sbrs	r24, 5
     632:	fd cf       	rjmp	.-6      	; 0x62e <st7565r_init+0x148>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     634:	82 ea       	ldi	r24, 0xA2	; 162
     636:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     63a:	e0 ea       	ldi	r30, 0xA0	; 160
     63c:	f9 e0       	ldi	r31, 0x09	; 9
     63e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     640:	86 ff       	sbrs	r24, 6
     642:	fd cf       	rjmp	.-6      	; 0x63e <st7565r_init+0x158>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     644:	e0 ea       	ldi	r30, 0xA0	; 160
     646:	f9 e0       	ldi	r31, 0x09	; 9
     648:	80 e4       	ldi	r24, 0x40	; 64
     64a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     64c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     64e:	be 01       	movw	r22, r28
     650:	6f 5f       	subi	r22, 0xFF	; 255
     652:	7f 4f       	sbci	r23, 0xFF	; 255
     654:	80 ea       	ldi	r24, 0xA0	; 160
     656:	99 e0       	ldi	r25, 0x09	; 9
     658:	e0 d3       	rcall	.+1984   	; 0xe1a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     65a:	8b e2       	ldi	r24, 0x2B	; 43
     65c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     65e:	be 01       	movw	r22, r28
     660:	6f 5f       	subi	r22, 0xFF	; 255
     662:	7f 4f       	sbci	r23, 0xFF	; 255
     664:	80 ea       	ldi	r24, 0xA0	; 160
     666:	99 e0       	ldi	r25, 0x09	; 9
     668:	c2 d3       	rcall	.+1924   	; 0xdee <usart_spi_select_device>
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	e0 e6       	ldi	r30, 0x60	; 96
     66e:	f6 e0       	ldi	r31, 0x06	; 6
     670:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     672:	e0 ea       	ldi	r30, 0xA0	; 160
     674:	f9 e0       	ldi	r31, 0x09	; 9
     676:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     678:	85 ff       	sbrs	r24, 5
     67a:	fd cf       	rjmp	.-6      	; 0x676 <st7565r_init+0x190>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     67c:	8f e2       	ldi	r24, 0x2F	; 47
     67e:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     682:	e0 ea       	ldi	r30, 0xA0	; 160
     684:	f9 e0       	ldi	r31, 0x09	; 9
     686:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     688:	86 ff       	sbrs	r24, 6
     68a:	fd cf       	rjmp	.-6      	; 0x686 <st7565r_init+0x1a0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     68c:	e0 ea       	ldi	r30, 0xA0	; 160
     68e:	f9 e0       	ldi	r31, 0x09	; 9
     690:	80 e4       	ldi	r24, 0x40	; 64
     692:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     694:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     696:	be 01       	movw	r22, r28
     698:	6f 5f       	subi	r22, 0xFF	; 255
     69a:	7f 4f       	sbci	r23, 0xFF	; 255
     69c:	80 ea       	ldi	r24, 0xA0	; 160
     69e:	99 e0       	ldi	r25, 0x09	; 9
     6a0:	bc d3       	rcall	.+1912   	; 0xe1a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6a2:	8b e2       	ldi	r24, 0x2B	; 43
     6a4:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6a6:	be 01       	movw	r22, r28
     6a8:	6f 5f       	subi	r22, 0xFF	; 255
     6aa:	7f 4f       	sbci	r23, 0xFF	; 255
     6ac:	80 ea       	ldi	r24, 0xA0	; 160
     6ae:	99 e0       	ldi	r25, 0x09	; 9
     6b0:	9e d3       	rcall	.+1852   	; 0xdee <usart_spi_select_device>
     6b2:	81 e0       	ldi	r24, 0x01	; 1
     6b4:	e0 e6       	ldi	r30, 0x60	; 96
     6b6:	f6 e0       	ldi	r31, 0x06	; 6
     6b8:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6ba:	e0 ea       	ldi	r30, 0xA0	; 160
     6bc:	f9 e0       	ldi	r31, 0x09	; 9
     6be:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6c0:	85 ff       	sbrs	r24, 5
     6c2:	fd cf       	rjmp	.-6      	; 0x6be <st7565r_init+0x1d8>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6c4:	88 ef       	ldi	r24, 0xF8	; 248
     6c6:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6ca:	e0 ea       	ldi	r30, 0xA0	; 160
     6cc:	f9 e0       	ldi	r31, 0x09	; 9
     6ce:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6d0:	86 ff       	sbrs	r24, 6
     6d2:	fd cf       	rjmp	.-6      	; 0x6ce <st7565r_init+0x1e8>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6d4:	e0 ea       	ldi	r30, 0xA0	; 160
     6d6:	f9 e0       	ldi	r31, 0x09	; 9
     6d8:	80 e4       	ldi	r24, 0x40	; 64
     6da:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6dc:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6de:	be 01       	movw	r22, r28
     6e0:	6f 5f       	subi	r22, 0xFF	; 255
     6e2:	7f 4f       	sbci	r23, 0xFF	; 255
     6e4:	80 ea       	ldi	r24, 0xA0	; 160
     6e6:	99 e0       	ldi	r25, 0x09	; 9
     6e8:	98 d3       	rcall	.+1840   	; 0xe1a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6ea:	8b e2       	ldi	r24, 0x2B	; 43
     6ec:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6ee:	be 01       	movw	r22, r28
     6f0:	6f 5f       	subi	r22, 0xFF	; 255
     6f2:	7f 4f       	sbci	r23, 0xFF	; 255
     6f4:	80 ea       	ldi	r24, 0xA0	; 160
     6f6:	99 e0       	ldi	r25, 0x09	; 9
     6f8:	7a d3       	rcall	.+1780   	; 0xdee <usart_spi_select_device>
     6fa:	81 e0       	ldi	r24, 0x01	; 1
     6fc:	e0 e6       	ldi	r30, 0x60	; 96
     6fe:	f6 e0       	ldi	r31, 0x06	; 6
     700:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     702:	e0 ea       	ldi	r30, 0xA0	; 160
     704:	f9 e0       	ldi	r31, 0x09	; 9
     706:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     708:	85 ff       	sbrs	r24, 5
     70a:	fd cf       	rjmp	.-6      	; 0x706 <st7565r_init+0x220>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     70c:	10 92 a0 09 	sts	0x09A0, r1
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     710:	e0 ea       	ldi	r30, 0xA0	; 160
     712:	f9 e0       	ldi	r31, 0x09	; 9
     714:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     716:	86 ff       	sbrs	r24, 6
     718:	fd cf       	rjmp	.-6      	; 0x714 <st7565r_init+0x22e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     71a:	e0 ea       	ldi	r30, 0xA0	; 160
     71c:	f9 e0       	ldi	r31, 0x09	; 9
     71e:	80 e4       	ldi	r24, 0x40	; 64
     720:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     722:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     724:	be 01       	movw	r22, r28
     726:	6f 5f       	subi	r22, 0xFF	; 255
     728:	7f 4f       	sbci	r23, 0xFF	; 255
     72a:	80 ea       	ldi	r24, 0xA0	; 160
     72c:	99 e0       	ldi	r25, 0x09	; 9
     72e:	75 d3       	rcall	.+1770   	; 0xe1a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     730:	8b e2       	ldi	r24, 0x2B	; 43
     732:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     734:	be 01       	movw	r22, r28
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	80 ea       	ldi	r24, 0xA0	; 160
     73c:	99 e0       	ldi	r25, 0x09	; 9
     73e:	57 d3       	rcall	.+1710   	; 0xdee <usart_spi_select_device>
     740:	81 e0       	ldi	r24, 0x01	; 1
     742:	e0 e6       	ldi	r30, 0x60	; 96
     744:	f6 e0       	ldi	r31, 0x06	; 6
     746:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     748:	e0 ea       	ldi	r30, 0xA0	; 160
     74a:	f9 e0       	ldi	r31, 0x09	; 9
     74c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     74e:	85 ff       	sbrs	r24, 5
     750:	fd cf       	rjmp	.-6      	; 0x74c <st7565r_init+0x266>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     752:	81 e2       	ldi	r24, 0x21	; 33
     754:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     758:	e0 ea       	ldi	r30, 0xA0	; 160
     75a:	f9 e0       	ldi	r31, 0x09	; 9
     75c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     75e:	86 ff       	sbrs	r24, 6
     760:	fd cf       	rjmp	.-6      	; 0x75c <st7565r_init+0x276>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     762:	e0 ea       	ldi	r30, 0xA0	; 160
     764:	f9 e0       	ldi	r31, 0x09	; 9
     766:	80 e4       	ldi	r24, 0x40	; 64
     768:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     76a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     76c:	be 01       	movw	r22, r28
     76e:	6f 5f       	subi	r22, 0xFF	; 255
     770:	7f 4f       	sbci	r23, 0xFF	; 255
     772:	80 ea       	ldi	r24, 0xA0	; 160
     774:	99 e0       	ldi	r25, 0x09	; 9
     776:	51 d3       	rcall	.+1698   	; 0xe1a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     778:	8b e2       	ldi	r24, 0x2B	; 43
     77a:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     77c:	be 01       	movw	r22, r28
     77e:	6f 5f       	subi	r22, 0xFF	; 255
     780:	7f 4f       	sbci	r23, 0xFF	; 255
     782:	80 ea       	ldi	r24, 0xA0	; 160
     784:	99 e0       	ldi	r25, 0x09	; 9
     786:	33 d3       	rcall	.+1638   	; 0xdee <usart_spi_select_device>
     788:	81 e0       	ldi	r24, 0x01	; 1
     78a:	e0 e6       	ldi	r30, 0x60	; 96
     78c:	f6 e0       	ldi	r31, 0x06	; 6
     78e:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     790:	e0 ea       	ldi	r30, 0xA0	; 160
     792:	f9 e0       	ldi	r31, 0x09	; 9
     794:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     796:	85 ff       	sbrs	r24, 5
     798:	fd cf       	rjmp	.-6      	; 0x794 <st7565r_init+0x2ae>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     79a:	81 e8       	ldi	r24, 0x81	; 129
     79c:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7a0:	e0 ea       	ldi	r30, 0xA0	; 160
     7a2:	f9 e0       	ldi	r31, 0x09	; 9
     7a4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7a6:	86 ff       	sbrs	r24, 6
     7a8:	fd cf       	rjmp	.-6      	; 0x7a4 <st7565r_init+0x2be>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7aa:	e0 ea       	ldi	r30, 0xA0	; 160
     7ac:	f9 e0       	ldi	r31, 0x09	; 9
     7ae:	80 e4       	ldi	r24, 0x40	; 64
     7b0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7b2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7b4:	be 01       	movw	r22, r28
     7b6:	6f 5f       	subi	r22, 0xFF	; 255
     7b8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ba:	80 ea       	ldi	r24, 0xA0	; 160
     7bc:	99 e0       	ldi	r25, 0x09	; 9
     7be:	2d d3       	rcall	.+1626   	; 0xe1a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7c0:	8b e2       	ldi	r24, 0x2B	; 43
     7c2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7c4:	be 01       	movw	r22, r28
     7c6:	6f 5f       	subi	r22, 0xFF	; 255
     7c8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ca:	80 ea       	ldi	r24, 0xA0	; 160
     7cc:	99 e0       	ldi	r25, 0x09	; 9
     7ce:	0f d3       	rcall	.+1566   	; 0xdee <usart_spi_select_device>
     7d0:	81 e0       	ldi	r24, 0x01	; 1
     7d2:	e0 e6       	ldi	r30, 0x60	; 96
     7d4:	f6 e0       	ldi	r31, 0x06	; 6
     7d6:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7d8:	e0 ea       	ldi	r30, 0xA0	; 160
     7da:	f9 e0       	ldi	r31, 0x09	; 9
     7dc:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7de:	85 ff       	sbrs	r24, 5
     7e0:	fd cf       	rjmp	.-6      	; 0x7dc <st7565r_init+0x2f6>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7e2:	81 e2       	ldi	r24, 0x21	; 33
     7e4:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7e8:	e0 ea       	ldi	r30, 0xA0	; 160
     7ea:	f9 e0       	ldi	r31, 0x09	; 9
     7ec:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7ee:	86 ff       	sbrs	r24, 6
     7f0:	fd cf       	rjmp	.-6      	; 0x7ec <st7565r_init+0x306>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7f2:	e0 ea       	ldi	r30, 0xA0	; 160
     7f4:	f9 e0       	ldi	r31, 0x09	; 9
     7f6:	80 e4       	ldi	r24, 0x40	; 64
     7f8:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7fa:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7fc:	be 01       	movw	r22, r28
     7fe:	6f 5f       	subi	r22, 0xFF	; 255
     800:	7f 4f       	sbci	r23, 0xFF	; 255
     802:	80 ea       	ldi	r24, 0xA0	; 160
     804:	99 e0       	ldi	r25, 0x09	; 9
     806:	09 d3       	rcall	.+1554   	; 0xe1a <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     808:	8b e2       	ldi	r24, 0x2B	; 43
     80a:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     80c:	be 01       	movw	r22, r28
     80e:	6f 5f       	subi	r22, 0xFF	; 255
     810:	7f 4f       	sbci	r23, 0xFF	; 255
     812:	80 ea       	ldi	r24, 0xA0	; 160
     814:	99 e0       	ldi	r25, 0x09	; 9
     816:	eb d2       	rcall	.+1494   	; 0xdee <usart_spi_select_device>
     818:	81 e0       	ldi	r24, 0x01	; 1
     81a:	e0 e6       	ldi	r30, 0x60	; 96
     81c:	f6 e0       	ldi	r31, 0x06	; 6
     81e:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     820:	e0 ea       	ldi	r30, 0xA0	; 160
     822:	f9 e0       	ldi	r31, 0x09	; 9
     824:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     826:	85 ff       	sbrs	r24, 5
     828:	fd cf       	rjmp	.-6      	; 0x824 <st7565r_init+0x33e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     82a:	8f ea       	ldi	r24, 0xAF	; 175
     82c:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     830:	e0 ea       	ldi	r30, 0xA0	; 160
     832:	f9 e0       	ldi	r31, 0x09	; 9
     834:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     836:	86 ff       	sbrs	r24, 6
     838:	fd cf       	rjmp	.-6      	; 0x834 <st7565r_init+0x34e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     83a:	e0 ea       	ldi	r30, 0xA0	; 160
     83c:	f9 e0       	ldi	r31, 0x09	; 9
     83e:	80 e4       	ldi	r24, 0x40	; 64
     840:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     842:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     844:	be 01       	movw	r22, r28
     846:	6f 5f       	subi	r22, 0xFF	; 255
     848:	7f 4f       	sbci	r23, 0xFF	; 255
     84a:	80 ea       	ldi	r24, 0xA0	; 160
     84c:	99 e0       	ldi	r25, 0x09	; 9
     84e:	e5 d2       	rcall	.+1482   	; 0xe1a <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     850:	0f 90       	pop	r0
     852:	df 91       	pop	r29
     854:	cf 91       	pop	r28
     856:	1f 91       	pop	r17
     858:	0f 91       	pop	r16
     85a:	ff 90       	pop	r15
     85c:	ef 90       	pop	r14
     85e:	df 90       	pop	r13
     860:	cf 90       	pop	r12
     862:	bf 90       	pop	r11
     864:	08 95       	ret

00000866 <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     866:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     868:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
     86a:	e8 2f       	mov	r30, r24
     86c:	f0 e0       	ldi	r31, 0x00	; 0
     86e:	e0 59       	subi	r30, 0x90	; 144
     870:	ff 4f       	sbci	r31, 0xFF	; 255
     872:	60 95       	com	r22
     874:	80 81       	ld	r24, Z
     876:	68 23       	and	r22, r24
     878:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     87a:	9f bf       	out	0x3f, r25	; 63
     87c:	08 95       	ret

0000087e <sysclk_disable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     87e:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     880:	f8 94       	cli

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
     882:	e8 2f       	mov	r30, r24
     884:	f0 e0       	ldi	r31, 0x00	; 0
     886:	e0 59       	subi	r30, 0x90	; 144
     888:	ff 4f       	sbci	r31, 0xFF	; 255
     88a:	80 81       	ld	r24, Z
     88c:	68 2b       	or	r22, r24
     88e:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     890:	9f bf       	out	0x3f, r25	; 63
     892:	08 95       	ret

00000894 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     894:	ff 92       	push	r15
     896:	0f 93       	push	r16
     898:	1f 93       	push	r17
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	1f 92       	push	r1
     8a0:	cd b7       	in	r28, 0x3d	; 61
     8a2:	de b7       	in	r29, 0x3e	; 62
     8a4:	f8 2e       	mov	r15, r24
     8a6:	06 2f       	mov	r16, r22
     8a8:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     8aa:	29 d1       	rcall	.+594    	; 0xafe <gfx_mono_framebuffer_put_byte>
 * \param address the page address
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
     8ac:	8f 2d       	mov	r24, r15
     8ae:	8f 70       	andi	r24, 0x0F	; 15
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     8b0:	80 6b       	ori	r24, 0xB0	; 176
     8b2:	f8 2e       	mov	r15, r24
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8b4:	8b e2       	ldi	r24, 0x2B	; 43
     8b6:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8b8:	be 01       	movw	r22, r28
     8ba:	6f 5f       	subi	r22, 0xFF	; 255
     8bc:	7f 4f       	sbci	r23, 0xFF	; 255
     8be:	80 ea       	ldi	r24, 0xA0	; 160
     8c0:	99 e0       	ldi	r25, 0x09	; 9
     8c2:	95 d2       	rcall	.+1322   	; 0xdee <usart_spi_select_device>
     8c4:	81 e0       	ldi	r24, 0x01	; 1
     8c6:	e0 e6       	ldi	r30, 0x60	; 96
     8c8:	f6 e0       	ldi	r31, 0x06	; 6
     8ca:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8cc:	e0 ea       	ldi	r30, 0xA0	; 160
     8ce:	f9 e0       	ldi	r31, 0x09	; 9
     8d0:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8d2:	95 ff       	sbrs	r25, 5
     8d4:	fd cf       	rjmp	.-6      	; 0x8d0 <gfx_mono_st7565r_put_byte+0x3c>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     8d6:	f0 92 a0 09 	sts	0x09A0, r15
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     8da:	e0 ea       	ldi	r30, 0xA0	; 160
     8dc:	f9 e0       	ldi	r31, 0x09	; 9
     8de:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     8e0:	86 ff       	sbrs	r24, 6
     8e2:	fd cf       	rjmp	.-6      	; 0x8de <gfx_mono_st7565r_put_byte+0x4a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     8e4:	e0 ea       	ldi	r30, 0xA0	; 160
     8e6:	f9 e0       	ldi	r31, 0x09	; 9
     8e8:	80 e4       	ldi	r24, 0x40	; 64
     8ea:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     8ec:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     8ee:	be 01       	movw	r22, r28
     8f0:	6f 5f       	subi	r22, 0xFF	; 255
     8f2:	7f 4f       	sbci	r23, 0xFF	; 255
     8f4:	80 ea       	ldi	r24, 0xA0	; 160
     8f6:	99 e0       	ldi	r25, 0x09	; 9
     8f8:	90 d2       	rcall	.+1312   	; 0xe1a <usart_spi_deselect_device>
 * \param address the column address
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
     8fa:	80 2f       	mov	r24, r16
     8fc:	8f 77       	andi	r24, 0x7F	; 127
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     8fe:	82 95       	swap	r24
     900:	8f 70       	andi	r24, 0x0F	; 15
     902:	80 61       	ori	r24, 0x10	; 16
     904:	f8 2e       	mov	r15, r24
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     906:	8b e2       	ldi	r24, 0x2B	; 43
     908:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     90a:	be 01       	movw	r22, r28
     90c:	6f 5f       	subi	r22, 0xFF	; 255
     90e:	7f 4f       	sbci	r23, 0xFF	; 255
     910:	80 ea       	ldi	r24, 0xA0	; 160
     912:	99 e0       	ldi	r25, 0x09	; 9
     914:	6c d2       	rcall	.+1240   	; 0xdee <usart_spi_select_device>
     916:	81 e0       	ldi	r24, 0x01	; 1
     918:	e0 e6       	ldi	r30, 0x60	; 96
     91a:	f6 e0       	ldi	r31, 0x06	; 6
     91c:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     91e:	e0 ea       	ldi	r30, 0xA0	; 160
     920:	f9 e0       	ldi	r31, 0x09	; 9
     922:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     924:	85 ff       	sbrs	r24, 5
     926:	fd cf       	rjmp	.-6      	; 0x922 <gfx_mono_st7565r_put_byte+0x8e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     928:	f0 92 a0 09 	sts	0x09A0, r15
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     92c:	e0 ea       	ldi	r30, 0xA0	; 160
     92e:	f9 e0       	ldi	r31, 0x09	; 9
     930:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     932:	86 ff       	sbrs	r24, 6
     934:	fd cf       	rjmp	.-6      	; 0x930 <gfx_mono_st7565r_put_byte+0x9c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     936:	e0 ea       	ldi	r30, 0xA0	; 160
     938:	f9 e0       	ldi	r31, 0x09	; 9
     93a:	80 e4       	ldi	r24, 0x40	; 64
     93c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     93e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     940:	be 01       	movw	r22, r28
     942:	6f 5f       	subi	r22, 0xFF	; 255
     944:	7f 4f       	sbci	r23, 0xFF	; 255
     946:	80 ea       	ldi	r24, 0xA0	; 160
     948:	99 e0       	ldi	r25, 0x09	; 9
     94a:	67 d2       	rcall	.+1230   	; 0xe1a <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     94c:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     94e:	8b e2       	ldi	r24, 0x2B	; 43
     950:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     952:	be 01       	movw	r22, r28
     954:	6f 5f       	subi	r22, 0xFF	; 255
     956:	7f 4f       	sbci	r23, 0xFF	; 255
     958:	80 ea       	ldi	r24, 0xA0	; 160
     95a:	99 e0       	ldi	r25, 0x09	; 9
     95c:	48 d2       	rcall	.+1168   	; 0xdee <usart_spi_select_device>
     95e:	81 e0       	ldi	r24, 0x01	; 1
     960:	e0 e6       	ldi	r30, 0x60	; 96
     962:	f6 e0       	ldi	r31, 0x06	; 6
     964:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     966:	e0 ea       	ldi	r30, 0xA0	; 160
     968:	f9 e0       	ldi	r31, 0x09	; 9
     96a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     96c:	85 ff       	sbrs	r24, 5
     96e:	fd cf       	rjmp	.-6      	; 0x96a <gfx_mono_st7565r_put_byte+0xd6>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     970:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     974:	e0 ea       	ldi	r30, 0xA0	; 160
     976:	f9 e0       	ldi	r31, 0x09	; 9
     978:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     97a:	86 ff       	sbrs	r24, 6
     97c:	fd cf       	rjmp	.-6      	; 0x978 <gfx_mono_st7565r_put_byte+0xe4>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     97e:	e0 ea       	ldi	r30, 0xA0	; 160
     980:	f9 e0       	ldi	r31, 0x09	; 9
     982:	80 e4       	ldi	r24, 0x40	; 64
     984:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     986:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     988:	be 01       	movw	r22, r28
     98a:	6f 5f       	subi	r22, 0xFF	; 255
     98c:	7f 4f       	sbci	r23, 0xFF	; 255
     98e:	80 ea       	ldi	r24, 0xA0	; 160
     990:	99 e0       	ldi	r25, 0x09	; 9
     992:	43 d2       	rcall	.+1158   	; 0xe1a <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     994:	8b e2       	ldi	r24, 0x2B	; 43
     996:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     998:	be 01       	movw	r22, r28
     99a:	6f 5f       	subi	r22, 0xFF	; 255
     99c:	7f 4f       	sbci	r23, 0xFF	; 255
     99e:	80 ea       	ldi	r24, 0xA0	; 160
     9a0:	99 e0       	ldi	r25, 0x09	; 9
     9a2:	25 d2       	rcall	.+1098   	; 0xdee <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     9a4:	81 e0       	ldi	r24, 0x01	; 1
     9a6:	e0 e6       	ldi	r30, 0x60	; 96
     9a8:	f6 e0       	ldi	r31, 0x06	; 6
     9aa:	85 83       	std	Z+5, r24	; 0x05
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9ac:	e0 ea       	ldi	r30, 0xA0	; 160
     9ae:	f9 e0       	ldi	r31, 0x09	; 9
     9b0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     9b2:	85 ff       	sbrs	r24, 5
     9b4:	fd cf       	rjmp	.-6      	; 0x9b0 <gfx_mono_st7565r_put_byte+0x11c>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     9b6:	10 93 a0 09 	sts	0x09A0, r17
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9ba:	e0 ea       	ldi	r30, 0xA0	; 160
     9bc:	f9 e0       	ldi	r31, 0x09	; 9
     9be:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9c0:	86 ff       	sbrs	r24, 6
     9c2:	fd cf       	rjmp	.-6      	; 0x9be <gfx_mono_st7565r_put_byte+0x12a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9c4:	e0 ea       	ldi	r30, 0xA0	; 160
     9c6:	f9 e0       	ldi	r31, 0x09	; 9
     9c8:	80 e4       	ldi	r24, 0x40	; 64
     9ca:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9cc:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9ce:	81 e0       	ldi	r24, 0x01	; 1
     9d0:	e0 e6       	ldi	r30, 0x60	; 96
     9d2:	f6 e0       	ldi	r31, 0x06	; 6
     9d4:	86 83       	std	Z+6, r24	; 0x06
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9d6:	be 01       	movw	r22, r28
     9d8:	6f 5f       	subi	r22, 0xFF	; 255
     9da:	7f 4f       	sbci	r23, 0xFF	; 255
     9dc:	80 ea       	ldi	r24, 0xA0	; 160
     9de:	99 e0       	ldi	r25, 0x09	; 9
     9e0:	1c d2       	rcall	.+1080   	; 0xe1a <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     9e2:	0f 90       	pop	r0
     9e4:	df 91       	pop	r29
     9e6:	cf 91       	pop	r28
     9e8:	1f 91       	pop	r17
     9ea:	0f 91       	pop	r16
     9ec:	ff 90       	pop	r15
     9ee:	08 95       	ret

000009f0 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     9f0:	0f 93       	push	r16
     9f2:	1f 93       	push	r17
     9f4:	cf 93       	push	r28
     9f6:	df 93       	push	r29
     9f8:	1f 92       	push	r1
     9fa:	cd b7       	in	r28, 0x3d	; 61
     9fc:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     9fe:	80 e5       	ldi	r24, 0x50	; 80
     a00:	90 e2       	ldi	r25, 0x20	; 32
     a02:	78 d0       	rcall	.+240    	; 0xaf4 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     a04:	70 dd       	rcall	.-1312   	; 0x4e6 <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     a06:	8b e2       	ldi	r24, 0x2B	; 43
     a08:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     a0a:	be 01       	movw	r22, r28
     a0c:	6f 5f       	subi	r22, 0xFF	; 255
     a0e:	7f 4f       	sbci	r23, 0xFF	; 255
     a10:	80 ea       	ldi	r24, 0xA0	; 160
     a12:	99 e0       	ldi	r25, 0x09	; 9
     a14:	ec d1       	rcall	.+984    	; 0xdee <usart_spi_select_device>
     a16:	81 e0       	ldi	r24, 0x01	; 1
     a18:	e0 e6       	ldi	r30, 0x60	; 96
     a1a:	f6 e0       	ldi	r31, 0x06	; 6
     a1c:	86 83       	std	Z+6, r24	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a1e:	e0 ea       	ldi	r30, 0xA0	; 160
     a20:	f9 e0       	ldi	r31, 0x09	; 9
     a22:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a24:	85 ff       	sbrs	r24, 5
     a26:	fd cf       	rjmp	.-6      	; 0xa22 <gfx_mono_st7565r_init+0x32>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a28:	80 e4       	ldi	r24, 0x40	; 64
     a2a:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a2e:	e0 ea       	ldi	r30, 0xA0	; 160
     a30:	f9 e0       	ldi	r31, 0x09	; 9
     a32:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a34:	86 ff       	sbrs	r24, 6
     a36:	fd cf       	rjmp	.-6      	; 0xa32 <gfx_mono_st7565r_init+0x42>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a38:	e0 ea       	ldi	r30, 0xA0	; 160
     a3a:	f9 e0       	ldi	r31, 0x09	; 9
     a3c:	80 e4       	ldi	r24, 0x40	; 64
     a3e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a40:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a42:	be 01       	movw	r22, r28
     a44:	6f 5f       	subi	r22, 0xFF	; 255
     a46:	7f 4f       	sbci	r23, 0xFF	; 255
     a48:	80 ea       	ldi	r24, 0xA0	; 160
     a4a:	99 e0       	ldi	r25, 0x09	; 9
     a4c:	e6 d1       	rcall	.+972    	; 0xe1a <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a4e:	00 e0       	ldi	r16, 0x00	; 0
     a50:	0a c0       	rjmp	.+20     	; 0xa66 <gfx_mono_st7565r_init+0x76>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a52:	40 e0       	ldi	r20, 0x00	; 0
     a54:	61 2f       	mov	r22, r17
     a56:	80 2f       	mov	r24, r16
     a58:	1d df       	rcall	.-454    	; 0x894 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a5a:	1f 5f       	subi	r17, 0xFF	; 255
     a5c:	10 38       	cpi	r17, 0x80	; 128
     a5e:	c9 f7       	brne	.-14     	; 0xa52 <gfx_mono_st7565r_init+0x62>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a60:	0f 5f       	subi	r16, 0xFF	; 255
     a62:	04 30       	cpi	r16, 0x04	; 4
     a64:	11 f0       	breq	.+4      	; 0xa6a <gfx_mono_st7565r_init+0x7a>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a66:	10 e0       	ldi	r17, 0x00	; 0
     a68:	f4 cf       	rjmp	.-24     	; 0xa52 <gfx_mono_st7565r_init+0x62>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a6a:	0f 90       	pop	r0
     a6c:	df 91       	pop	r29
     a6e:	cf 91       	pop	r28
     a70:	1f 91       	pop	r17
     a72:	0f 91       	pop	r16
     a74:	08 95       	ret

00000a76 <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     a76:	ff 92       	push	r15
     a78:	0f 93       	push	r16
     a7a:	1f 93       	push	r17
     a7c:	cf 93       	push	r28
     a7e:	df 93       	push	r29
     a80:	18 2f       	mov	r17, r24
     a82:	04 2f       	mov	r16, r20
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     a84:	88 23       	and	r24, r24
     a86:	74 f1       	brlt	.+92     	; 0xae4 <gfx_mono_st7565r_draw_pixel+0x6e>
     a88:	60 32       	cpi	r22, 0x20	; 32
     a8a:	60 f5       	brcc	.+88     	; 0xae4 <gfx_mono_st7565r_draw_pixel+0x6e>
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     a8c:	f6 2e       	mov	r15, r22
     a8e:	f6 94       	lsr	r15
     a90:	f6 94       	lsr	r15
     a92:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     a94:	2f 2d       	mov	r18, r15
     a96:	30 e0       	ldi	r19, 0x00	; 0
     a98:	31 95       	neg	r19
     a9a:	21 95       	neg	r18
     a9c:	31 09       	sbc	r19, r1
     a9e:	22 0f       	add	r18, r18
     aa0:	33 1f       	adc	r19, r19
     aa2:	22 0f       	add	r18, r18
     aa4:	33 1f       	adc	r19, r19
     aa6:	22 0f       	add	r18, r18
     aa8:	33 1f       	adc	r19, r19
     aaa:	26 0f       	add	r18, r22
     aac:	31 1d       	adc	r19, r1
     aae:	e1 e0       	ldi	r30, 0x01	; 1
     ab0:	f0 e0       	ldi	r31, 0x00	; 0
     ab2:	ef 01       	movw	r28, r30
     ab4:	02 c0       	rjmp	.+4      	; 0xaba <gfx_mono_st7565r_draw_pixel+0x44>
     ab6:	cc 0f       	add	r28, r28
     ab8:	dd 1f       	adc	r29, r29
     aba:	2a 95       	dec	r18
     abc:	e2 f7       	brpl	.-8      	; 0xab6 <gfx_mono_st7565r_draw_pixel+0x40>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     abe:	68 2f       	mov	r22, r24
     ac0:	8f 2d       	mov	r24, r15
     ac2:	2c d0       	rcall	.+88     	; 0xb1c <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     ac4:	01 30       	cpi	r16, 0x01	; 1
     ac6:	21 f0       	breq	.+8      	; 0xad0 <gfx_mono_st7565r_draw_pixel+0x5a>
     ac8:	28 f0       	brcs	.+10     	; 0xad4 <gfx_mono_st7565r_draw_pixel+0x5e>
     aca:	02 30       	cpi	r16, 0x02	; 2
     acc:	31 f0       	breq	.+12     	; 0xada <gfx_mono_st7565r_draw_pixel+0x64>
     ace:	06 c0       	rjmp	.+12     	; 0xadc <gfx_mono_st7565r_draw_pixel+0x66>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     ad0:	8c 2b       	or	r24, r28
		break;
     ad2:	04 c0       	rjmp	.+8      	; 0xadc <gfx_mono_st7565r_draw_pixel+0x66>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     ad4:	c0 95       	com	r28
     ad6:	8c 23       	and	r24, r28
		break;
     ad8:	01 c0       	rjmp	.+2      	; 0xadc <gfx_mono_st7565r_draw_pixel+0x66>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     ada:	8c 27       	eor	r24, r28

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     adc:	48 2f       	mov	r20, r24
     ade:	61 2f       	mov	r22, r17
     ae0:	8f 2d       	mov	r24, r15
     ae2:	d8 de       	rcall	.-592    	; 0x894 <gfx_mono_st7565r_put_byte>
}
     ae4:	df 91       	pop	r29
     ae6:	cf 91       	pop	r28
     ae8:	1f 91       	pop	r17
     aea:	0f 91       	pop	r16
     aec:	ff 90       	pop	r15
     aee:	08 95       	ret

00000af0 <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     af0:	15 c0       	rjmp	.+42     	; 0xb1c <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     af2:	08 95       	ret

00000af4 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
     af4:	80 93 50 22 	sts	0x2250, r24
     af8:	90 93 51 22 	sts	0x2251, r25
     afc:	08 95       	ret

00000afe <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     afe:	20 e8       	ldi	r18, 0x80	; 128
     b00:	82 9f       	mul	r24, r18
     b02:	c0 01       	movw	r24, r0
     b04:	11 24       	eor	r1, r1
     b06:	fc 01       	movw	r30, r24
     b08:	e6 0f       	add	r30, r22
     b0a:	f1 1d       	adc	r31, r1
     b0c:	80 91 50 22 	lds	r24, 0x2250
     b10:	90 91 51 22 	lds	r25, 0x2251
     b14:	e8 0f       	add	r30, r24
     b16:	f9 1f       	adc	r31, r25
     b18:	40 83       	st	Z, r20
     b1a:	08 95       	ret

00000b1c <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     b1c:	20 e8       	ldi	r18, 0x80	; 128
     b1e:	82 9f       	mul	r24, r18
     b20:	c0 01       	movw	r24, r0
     b22:	11 24       	eor	r1, r1
     b24:	fc 01       	movw	r30, r24
     b26:	e6 0f       	add	r30, r22
     b28:	f1 1d       	adc	r31, r1
     b2a:	80 91 50 22 	lds	r24, 0x2250
     b2e:	90 91 51 22 	lds	r25, 0x2251
     b32:	e8 0f       	add	r30, r24
     b34:	f9 1f       	adc	r31, r25
}
     b36:	80 81       	ld	r24, Z
     b38:	08 95       	ret

00000b3a <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
     b3a:	ff 92       	push	r15
     b3c:	0f 93       	push	r16
     b3e:	1f 93       	push	r17
     b40:	cf 93       	push	r28
     b42:	df 93       	push	r29
     b44:	e4 2f       	mov	r30, r20
     b46:	f0 e0       	ldi	r31, 0x00	; 0
     b48:	e8 0f       	add	r30, r24
     b4a:	f1 1d       	adc	r31, r1
     b4c:	e1 38       	cpi	r30, 0x81	; 129
     b4e:	f1 05       	cpc	r31, r1
     b50:	14 f0       	brlt	.+4      	; 0xb56 <gfx_mono_generic_draw_horizontal_line+0x1c>
     b52:	40 e8       	ldi	r20, 0x80	; 128
     b54:	48 1b       	sub	r20, r24
     b56:	44 23       	and	r20, r20
     b58:	09 f4       	brne	.+2      	; 0xb5c <gfx_mono_generic_draw_horizontal_line+0x22>
     b5a:	59 c0       	rjmp	.+178    	; 0xc0e <gfx_mono_generic_draw_horizontal_line+0xd4>
     b5c:	c6 2f       	mov	r28, r22
     b5e:	c6 95       	lsr	r28
     b60:	c6 95       	lsr	r28
     b62:	c6 95       	lsr	r28
     b64:	ec 2f       	mov	r30, r28
     b66:	f0 e0       	ldi	r31, 0x00	; 0
     b68:	f1 95       	neg	r31
     b6a:	e1 95       	neg	r30
     b6c:	f1 09       	sbc	r31, r1
     b6e:	ee 0f       	add	r30, r30
     b70:	ff 1f       	adc	r31, r31
     b72:	ee 0f       	add	r30, r30
     b74:	ff 1f       	adc	r31, r31
     b76:	ee 0f       	add	r30, r30
     b78:	ff 1f       	adc	r31, r31
     b7a:	df 01       	movw	r26, r30
     b7c:	a6 0f       	add	r26, r22
     b7e:	b1 1d       	adc	r27, r1
     b80:	bd 01       	movw	r22, r26
     b82:	e1 e0       	ldi	r30, 0x01	; 1
     b84:	f0 e0       	ldi	r31, 0x00	; 0
     b86:	df 01       	movw	r26, r30
     b88:	02 c0       	rjmp	.+4      	; 0xb8e <gfx_mono_generic_draw_horizontal_line+0x54>
     b8a:	aa 0f       	add	r26, r26
     b8c:	bb 1f       	adc	r27, r27
     b8e:	6a 95       	dec	r22
     b90:	e2 f7       	brpl	.-8      	; 0xb8a <gfx_mono_generic_draw_horizontal_line+0x50>
     b92:	0a 2f       	mov	r16, r26
     b94:	21 30       	cpi	r18, 0x01	; 1
     b96:	49 f0       	breq	.+18     	; 0xbaa <gfx_mono_generic_draw_horizontal_line+0x70>
     b98:	68 f0       	brcs	.+26     	; 0xbb4 <gfx_mono_generic_draw_horizontal_line+0x7a>
     b9a:	22 30       	cpi	r18, 0x02	; 2
     b9c:	09 f0       	breq	.+2      	; 0xba0 <gfx_mono_generic_draw_horizontal_line+0x66>
     b9e:	37 c0       	rjmp	.+110    	; 0xc0e <gfx_mono_generic_draw_horizontal_line+0xd4>
     ba0:	d4 2f       	mov	r29, r20
     ba2:	ff 24       	eor	r15, r15
     ba4:	fa 94       	dec	r15
     ba6:	f8 0e       	add	r15, r24
     ba8:	26 c0       	rjmp	.+76     	; 0xbf6 <gfx_mono_generic_draw_horizontal_line+0xbc>
     baa:	d4 2f       	mov	r29, r20
     bac:	ff 24       	eor	r15, r15
     bae:	fa 94       	dec	r15
     bb0:	f8 0e       	add	r15, r24
     bb2:	07 c0       	rjmp	.+14     	; 0xbc2 <gfx_mono_generic_draw_horizontal_line+0x88>
     bb4:	d4 2f       	mov	r29, r20
     bb6:	ff 24       	eor	r15, r15
     bb8:	fa 94       	dec	r15
     bba:	f8 0e       	add	r15, r24
     bbc:	0a 2f       	mov	r16, r26
     bbe:	00 95       	com	r16
     bc0:	0d c0       	rjmp	.+26     	; 0xbdc <gfx_mono_generic_draw_horizontal_line+0xa2>
     bc2:	1f 2d       	mov	r17, r15
     bc4:	1d 0f       	add	r17, r29
     bc6:	61 2f       	mov	r22, r17
     bc8:	8c 2f       	mov	r24, r28
     bca:	92 df       	rcall	.-220    	; 0xaf0 <gfx_mono_st7565r_get_byte>
     bcc:	48 2f       	mov	r20, r24
     bce:	40 2b       	or	r20, r16
     bd0:	61 2f       	mov	r22, r17
     bd2:	8c 2f       	mov	r24, r28
     bd4:	5f de       	rcall	.-834    	; 0x894 <gfx_mono_st7565r_put_byte>
     bd6:	d1 50       	subi	r29, 0x01	; 1
     bd8:	a1 f7       	brne	.-24     	; 0xbc2 <gfx_mono_generic_draw_horizontal_line+0x88>
     bda:	19 c0       	rjmp	.+50     	; 0xc0e <gfx_mono_generic_draw_horizontal_line+0xd4>
     bdc:	1f 2d       	mov	r17, r15
     bde:	1d 0f       	add	r17, r29
     be0:	61 2f       	mov	r22, r17
     be2:	8c 2f       	mov	r24, r28
     be4:	85 df       	rcall	.-246    	; 0xaf0 <gfx_mono_st7565r_get_byte>
     be6:	48 2f       	mov	r20, r24
     be8:	40 23       	and	r20, r16
     bea:	61 2f       	mov	r22, r17
     bec:	8c 2f       	mov	r24, r28
     bee:	52 de       	rcall	.-860    	; 0x894 <gfx_mono_st7565r_put_byte>
     bf0:	d1 50       	subi	r29, 0x01	; 1
     bf2:	a1 f7       	brne	.-24     	; 0xbdc <gfx_mono_generic_draw_horizontal_line+0xa2>
     bf4:	0c c0       	rjmp	.+24     	; 0xc0e <gfx_mono_generic_draw_horizontal_line+0xd4>
     bf6:	1f 2d       	mov	r17, r15
     bf8:	1d 0f       	add	r17, r29
     bfa:	61 2f       	mov	r22, r17
     bfc:	8c 2f       	mov	r24, r28
     bfe:	78 df       	rcall	.-272    	; 0xaf0 <gfx_mono_st7565r_get_byte>
     c00:	48 2f       	mov	r20, r24
     c02:	40 27       	eor	r20, r16
     c04:	61 2f       	mov	r22, r17
     c06:	8c 2f       	mov	r24, r28
     c08:	45 de       	rcall	.-886    	; 0x894 <gfx_mono_st7565r_put_byte>
     c0a:	d1 50       	subi	r29, 0x01	; 1
     c0c:	a1 f7       	brne	.-24     	; 0xbf6 <gfx_mono_generic_draw_horizontal_line+0xbc>
     c0e:	df 91       	pop	r29
     c10:	cf 91       	pop	r28
     c12:	1f 91       	pop	r17
     c14:	0f 91       	pop	r16
     c16:	ff 90       	pop	r15
     c18:	08 95       	ret

00000c1a <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     c1a:	ff 92       	push	r15
     c1c:	0f 93       	push	r16
     c1e:	1f 93       	push	r17
     c20:	cf 93       	push	r28
     c22:	df 93       	push	r29
     c24:	d8 2f       	mov	r29, r24
     c26:	14 2f       	mov	r17, r20
	if (height == 0) {
     c28:	22 23       	and	r18, r18
     c2a:	61 f0       	breq	.+24     	; 0xc44 <gfx_mono_generic_draw_filled_rect+0x2a>
     c2c:	c2 2f       	mov	r28, r18
     c2e:	ff 24       	eor	r15, r15
     c30:	fa 94       	dec	r15
     c32:	f6 0e       	add	r15, r22
     c34:	6f 2d       	mov	r22, r15
     c36:	6c 0f       	add	r22, r28
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     c38:	20 2f       	mov	r18, r16
     c3a:	41 2f       	mov	r20, r17
     c3c:	8d 2f       	mov	r24, r29
     c3e:	7d df       	rcall	.-262    	; 0xb3a <gfx_mono_generic_draw_horizontal_line>
     c40:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     c42:	c1 f7       	brne	.-16     	; 0xc34 <gfx_mono_generic_draw_filled_rect+0x1a>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     c44:	df 91       	pop	r29
     c46:	cf 91       	pop	r28
     c48:	1f 91       	pop	r17
     c4a:	0f 91       	pop	r16
     c4c:	ff 90       	pop	r15
     c4e:	08 95       	ret

00000c50 <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     c50:	af 92       	push	r10
     c52:	bf 92       	push	r11
     c54:	cf 92       	push	r12
     c56:	df 92       	push	r13
     c58:	ef 92       	push	r14
     c5a:	ff 92       	push	r15
     c5c:	0f 93       	push	r16
     c5e:	1f 93       	push	r17
     c60:	cf 93       	push	r28
     c62:	df 93       	push	r29
     c64:	c8 2f       	mov	r28, r24
     c66:	d6 2e       	mov	r13, r22
     c68:	a4 2e       	mov	r10, r20
     c6a:	79 01       	movw	r14, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     c6c:	00 e0       	ldi	r16, 0x00	; 0
     c6e:	f9 01       	movw	r30, r18
     c70:	24 81       	ldd	r18, Z+4	; 0x04
     c72:	43 81       	ldd	r20, Z+3	; 0x03
     c74:	6a 2d       	mov	r22, r10
     c76:	8d 2d       	mov	r24, r13
     c78:	d0 df       	rcall	.-96     	; 0xc1a <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
     c7a:	f7 01       	movw	r30, r14
     c7c:	90 81       	ld	r25, Z
     c7e:	91 11       	cpse	r25, r1
     c80:	39 c0       	rjmp	.+114    	; 0xcf4 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     c82:	83 81       	ldd	r24, Z+3	; 0x03
     c84:	a8 2f       	mov	r26, r24
     c86:	a6 95       	lsr	r26
     c88:	a6 95       	lsr	r26
     c8a:	a6 95       	lsr	r26
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     c8c:	87 70       	andi	r24, 0x07	; 7
     c8e:	09 f0       	breq	.+2      	; 0xc92 <gfx_mono_draw_char+0x42>
		char_row_size++;
     c90:	af 5f       	subi	r26, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
     c92:	f7 01       	movw	r30, r14
     c94:	c4 80       	ldd	r12, Z+4	; 0x04
     c96:	ac 9d       	mul	r26, r12
     c98:	d0 01       	movw	r26, r0
     c9a:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
     c9c:	ec 2f       	mov	r30, r28
     c9e:	f0 e0       	ldi	r31, 0x00	; 0
     ca0:	e7 01       	movw	r28, r14
     ca2:	8d 81       	ldd	r24, Y+5	; 0x05
     ca4:	e8 1b       	sub	r30, r24
     ca6:	f1 09       	sbc	r31, r1
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
     ca8:	ae 9f       	mul	r26, r30
     caa:	90 01       	movw	r18, r0
     cac:	af 9f       	mul	r26, r31
     cae:	30 0d       	add	r19, r0
     cb0:	be 9f       	mul	r27, r30
     cb2:	30 0d       	add	r19, r0
     cb4:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     cb6:	09 80       	ldd	r0, Y+1	; 0x01
     cb8:	da 81       	ldd	r29, Y+2	; 0x02
     cba:	c0 2d       	mov	r28, r0
     cbc:	c2 0f       	add	r28, r18
     cbe:	d3 1f       	adc	r29, r19
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     cc0:	f7 01       	movw	r30, r14
     cc2:	b3 80       	ldd	r11, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
     cc4:	bb 20       	and	r11, r11
     cc6:	99 f0       	breq	.+38     	; 0xcee <gfx_mono_draw_char+0x9e>
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
     cc8:	00 e0       	ldi	r16, 0x00	; 0
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     cca:	10 e0       	ldi	r17, 0x00	; 0
     ccc:	81 2f       	mov	r24, r17
     cce:	8d 0d       	add	r24, r13
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     cd0:	91 2f       	mov	r25, r17
     cd2:	97 70       	andi	r25, 0x07	; 7
     cd4:	19 f4       	brne	.+6      	; 0xcdc <gfx_mono_draw_char+0x8c>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     cd6:	fe 01       	movw	r30, r28
     cd8:	04 91       	lpm	r16, Z
				glyph_data++;
     cda:	21 96       	adiw	r28, 0x01	; 1
			}

			if ((glyph_byte & 0x80)) {
     cdc:	00 23       	and	r16, r16
     cde:	1c f4       	brge	.+6      	; 0xce6 <gfx_mono_draw_char+0x96>
				gfx_mono_draw_pixel(inc_x, inc_y,
     ce0:	41 e0       	ldi	r20, 0x01	; 1
     ce2:	6a 2d       	mov	r22, r10
     ce4:	c8 de       	rcall	.-624    	; 0xa76 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     ce6:	00 0f       	add	r16, r16

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     ce8:	1f 5f       	subi	r17, 0xFF	; 255
     cea:	1b 11       	cpse	r17, r11
     cec:	ef cf       	rjmp	.-34     	; 0xccc <gfx_mono_draw_char+0x7c>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     cee:	a3 94       	inc	r10
		inc_x = x;
		rows_left--;
     cf0:	ca 94       	dec	r12
	} while (rows_left > 0);
     cf2:	31 f7       	brne	.-52     	; 0xcc0 <gfx_mono_draw_char+0x70>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     cf4:	df 91       	pop	r29
     cf6:	cf 91       	pop	r28
     cf8:	1f 91       	pop	r17
     cfa:	0f 91       	pop	r16
     cfc:	ff 90       	pop	r15
     cfe:	ef 90       	pop	r14
     d00:	df 90       	pop	r13
     d02:	cf 90       	pop	r12
     d04:	bf 90       	pop	r11
     d06:	af 90       	pop	r10
     d08:	08 95       	ret

00000d0a <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     d0a:	df 92       	push	r13
     d0c:	ef 92       	push	r14
     d0e:	ff 92       	push	r15
     d10:	0f 93       	push	r16
     d12:	1f 93       	push	r17
     d14:	cf 93       	push	r28
     d16:	df 93       	push	r29
     d18:	e4 2e       	mov	r14, r20
     d1a:	89 01       	movw	r16, r18
     d1c:	ec 01       	movw	r28, r24
     d1e:	f6 2e       	mov	r15, r22

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     d20:	d6 2e       	mov	r13, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     d22:	89 91       	ld	r24, Y+
     d24:	8a 30       	cpi	r24, 0x0A	; 10
     d26:	31 f4       	brne	.+12     	; 0xd34 <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
     d28:	f8 01       	movw	r30, r16
     d2a:	84 81       	ldd	r24, Z+4	; 0x04
     d2c:	8f 5f       	subi	r24, 0xFF	; 255
     d2e:	e8 0e       	add	r14, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     d30:	fd 2c       	mov	r15, r13
     d32:	09 c0       	rjmp	.+18     	; 0xd46 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
     d34:	8d 30       	cpi	r24, 0x0D	; 13
     d36:	39 f0       	breq	.+14     	; 0xd46 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     d38:	98 01       	movw	r18, r16
     d3a:	4e 2d       	mov	r20, r14
     d3c:	6f 2d       	mov	r22, r15
     d3e:	88 df       	rcall	.-240    	; 0xc50 <gfx_mono_draw_char>
			x += font->width;
     d40:	f8 01       	movw	r30, r16
     d42:	83 81       	ldd	r24, Z+3	; 0x03
     d44:	f8 0e       	add	r15, r24
		}
	} while (*(++str));
     d46:	88 81       	ld	r24, Y
     d48:	81 11       	cpse	r24, r1
     d4a:	eb cf       	rjmp	.-42     	; 0xd22 <gfx_mono_draw_string+0x18>
}
     d4c:	df 91       	pop	r29
     d4e:	cf 91       	pop	r28
     d50:	1f 91       	pop	r17
     d52:	0f 91       	pop	r16
     d54:	ff 90       	pop	r15
     d56:	ef 90       	pop	r14
     d58:	df 90       	pop	r13
     d5a:	08 95       	ret

00000d5c <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
     d5c:	80 3a       	cpi	r24, 0xA0	; 160
     d5e:	28 e0       	ldi	r18, 0x08	; 8
     d60:	92 07       	cpc	r25, r18
     d62:	21 f4       	brne	.+8      	; 0xd6c <usart_spi_init+0x10>
     d64:	60 e1       	ldi	r22, 0x10	; 16
     d66:	83 e0       	ldi	r24, 0x03	; 3
     d68:	7e cd       	rjmp	.-1284   	; 0x866 <sysclk_enable_module>
     d6a:	08 95       	ret
     d6c:	80 3b       	cpi	r24, 0xB0	; 176
     d6e:	28 e0       	ldi	r18, 0x08	; 8
     d70:	92 07       	cpc	r25, r18
     d72:	21 f4       	brne	.+8      	; 0xd7c <usart_spi_init+0x20>
     d74:	60 e2       	ldi	r22, 0x20	; 32
     d76:	83 e0       	ldi	r24, 0x03	; 3
     d78:	76 cd       	rjmp	.-1300   	; 0x866 <sysclk_enable_module>
     d7a:	08 95       	ret
     d7c:	80 3a       	cpi	r24, 0xA0	; 160
     d7e:	29 e0       	ldi	r18, 0x09	; 9
     d80:	92 07       	cpc	r25, r18
     d82:	21 f4       	brne	.+8      	; 0xd8c <usart_spi_init+0x30>
     d84:	60 e1       	ldi	r22, 0x10	; 16
     d86:	84 e0       	ldi	r24, 0x04	; 4
     d88:	6e cd       	rjmp	.-1316   	; 0x866 <sysclk_enable_module>
     d8a:	08 95       	ret
     d8c:	80 3b       	cpi	r24, 0xB0	; 176
     d8e:	29 e0       	ldi	r18, 0x09	; 9
     d90:	92 07       	cpc	r25, r18
     d92:	21 f4       	brne	.+8      	; 0xd9c <usart_spi_init+0x40>
     d94:	60 e2       	ldi	r22, 0x20	; 32
     d96:	84 e0       	ldi	r24, 0x04	; 4
     d98:	66 cd       	rjmp	.-1332   	; 0x866 <sysclk_enable_module>
     d9a:	08 95       	ret
     d9c:	80 3a       	cpi	r24, 0xA0	; 160
     d9e:	2a e0       	ldi	r18, 0x0A	; 10
     da0:	92 07       	cpc	r25, r18
     da2:	21 f4       	brne	.+8      	; 0xdac <usart_spi_init+0x50>
     da4:	60 e1       	ldi	r22, 0x10	; 16
     da6:	85 e0       	ldi	r24, 0x05	; 5
     da8:	5e cd       	rjmp	.-1348   	; 0x866 <sysclk_enable_module>
     daa:	08 95       	ret
     dac:	80 3a       	cpi	r24, 0xA0	; 160
     dae:	9b 40       	sbci	r25, 0x0B	; 11
     db0:	19 f4       	brne	.+6      	; 0xdb8 <usart_spi_init+0x5c>
     db2:	60 e1       	ldi	r22, 0x10	; 16
     db4:	86 e0       	ldi	r24, 0x06	; 6
     db6:	57 cd       	rjmp	.-1362   	; 0x866 <sysclk_enable_module>
     db8:	08 95       	ret

00000dba <usart_spi_setup_device>:
     dba:	0f 93       	push	r16
     dbc:	1f 93       	push	r17
     dbe:	cf 93       	push	r28
     dc0:	df 93       	push	r29
     dc2:	00 d0       	rcall	.+0      	; 0xdc4 <usart_spi_setup_device+0xa>
     dc4:	00 d0       	rcall	.+0      	; 0xdc6 <usart_spi_setup_device+0xc>
     dc6:	cd b7       	in	r28, 0x3d	; 61
     dc8:	de b7       	in	r29, 0x3e	; 62
     dca:	09 83       	std	Y+1, r16	; 0x01
     dcc:	1a 83       	std	Y+2, r17	; 0x02
     dce:	2b 83       	std	Y+3, r18	; 0x03
     dd0:	3c 83       	std	Y+4, r19	; 0x04
     dd2:	4d 83       	std	Y+5, r20	; 0x05
     dd4:	1e 82       	std	Y+6, r1	; 0x06
     dd6:	be 01       	movw	r22, r28
     dd8:	6f 5f       	subi	r22, 0xFF	; 255
     dda:	7f 4f       	sbci	r23, 0xFF	; 255
     ddc:	3a d3       	rcall	.+1652   	; 0x1452 <usart_init_spi>
     dde:	26 96       	adiw	r28, 0x06	; 6
     de0:	cd bf       	out	0x3d, r28	; 61
     de2:	de bf       	out	0x3e, r29	; 62
     de4:	df 91       	pop	r29
     de6:	cf 91       	pop	r28
     de8:	1f 91       	pop	r17
     dea:	0f 91       	pop	r16
     dec:	08 95       	ret

00000dee <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
     dee:	fb 01       	movw	r30, r22
     df0:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
     df2:	e8 2f       	mov	r30, r24
     df4:	e6 95       	lsr	r30
     df6:	e6 95       	lsr	r30
     df8:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
     dfa:	40 e2       	ldi	r20, 0x20	; 32
     dfc:	e4 9f       	mul	r30, r20
     dfe:	f0 01       	movw	r30, r0
     e00:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     e02:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     e04:	87 70       	andi	r24, 0x07	; 7
     e06:	21 e0       	ldi	r18, 0x01	; 1
     e08:	30 e0       	ldi	r19, 0x00	; 0
     e0a:	a9 01       	movw	r20, r18
     e0c:	02 c0       	rjmp	.+4      	; 0xe12 <usart_spi_select_device+0x24>
     e0e:	44 0f       	add	r20, r20
     e10:	55 1f       	adc	r21, r21
     e12:	8a 95       	dec	r24
     e14:	e2 f7       	brpl	.-8      	; 0xe0e <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     e16:	46 83       	std	Z+6, r20	; 0x06
     e18:	08 95       	ret

00000e1a <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
     e1a:	fb 01       	movw	r30, r22
     e1c:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
     e1e:	e8 2f       	mov	r30, r24
     e20:	e6 95       	lsr	r30
     e22:	e6 95       	lsr	r30
     e24:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
     e26:	40 e2       	ldi	r20, 0x20	; 32
     e28:	e4 9f       	mul	r30, r20
     e2a:	f0 01       	movw	r30, r0
     e2c:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     e2e:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     e30:	87 70       	andi	r24, 0x07	; 7
     e32:	21 e0       	ldi	r18, 0x01	; 1
     e34:	30 e0       	ldi	r19, 0x00	; 0
     e36:	a9 01       	movw	r20, r18
     e38:	02 c0       	rjmp	.+4      	; 0xe3e <usart_spi_deselect_device+0x24>
     e3a:	44 0f       	add	r20, r20
     e3c:	55 1f       	adc	r21, r21
     e3e:	8a 95       	dec	r24
     e40:	e2 f7       	brpl	.-8      	; 0xe3a <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     e42:	45 83       	std	Z+5, r20	; 0x05
     e44:	08 95       	ret

00000e46 <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e46:	81 15       	cp	r24, r1
     e48:	22 e0       	ldi	r18, 0x02	; 2
     e4a:	92 07       	cpc	r25, r18
     e4c:	61 f4       	brne	.+24     	; 0xe66 <adc_enable_clock+0x20>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     e4e:	80 91 53 22 	lds	r24, 0x2253
     e52:	91 e0       	ldi	r25, 0x01	; 1
     e54:	98 0f       	add	r25, r24
     e56:	90 93 53 22 	sts	0x2253, r25
     e5a:	81 11       	cpse	r24, r1
     e5c:	12 c0       	rjmp	.+36     	; 0xe82 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e5e:	62 e0       	ldi	r22, 0x02	; 2
     e60:	81 e0       	ldi	r24, 0x01	; 1
     e62:	01 cd       	rjmp	.-1534   	; 0x866 <sysclk_enable_module>
     e64:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e66:	80 34       	cpi	r24, 0x40	; 64
     e68:	92 40       	sbci	r25, 0x02	; 2
     e6a:	59 f4       	brne	.+22     	; 0xe82 <adc_enable_clock+0x3c>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
     e6c:	80 91 52 22 	lds	r24, 0x2252
     e70:	91 e0       	ldi	r25, 0x01	; 1
     e72:	98 0f       	add	r25, r24
     e74:	90 93 52 22 	sts	0x2252, r25
     e78:	81 11       	cpse	r24, r1
     e7a:	03 c0       	rjmp	.+6      	; 0xe82 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     e7c:	62 e0       	ldi	r22, 0x02	; 2
     e7e:	82 e0       	ldi	r24, 0x02	; 2
     e80:	f2 cc       	rjmp	.-1564   	; 0x866 <sysclk_enable_module>
     e82:	08 95       	ret

00000e84 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e84:	81 15       	cp	r24, r1
     e86:	22 e0       	ldi	r18, 0x02	; 2
     e88:	92 07       	cpc	r25, r18
     e8a:	59 f4       	brne	.+22     	; 0xea2 <adc_disable_clock+0x1e>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
     e8c:	80 91 53 22 	lds	r24, 0x2253
     e90:	81 50       	subi	r24, 0x01	; 1
     e92:	80 93 53 22 	sts	0x2253, r24
     e96:	81 11       	cpse	r24, r1
     e98:	11 c0       	rjmp	.+34     	; 0xebc <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e9a:	62 e0       	ldi	r22, 0x02	; 2
     e9c:	81 e0       	ldi	r24, 0x01	; 1
     e9e:	ef cc       	rjmp	.-1570   	; 0x87e <sysclk_disable_module>
     ea0:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     ea2:	80 34       	cpi	r24, 0x40	; 64
     ea4:	92 40       	sbci	r25, 0x02	; 2
     ea6:	51 f4       	brne	.+20     	; 0xebc <adc_disable_clock+0x38>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
     ea8:	80 91 52 22 	lds	r24, 0x2252
     eac:	81 50       	subi	r24, 0x01	; 1
     eae:	80 93 52 22 	sts	0x2252, r24
     eb2:	81 11       	cpse	r24, r1
     eb4:	03 c0       	rjmp	.+6      	; 0xebc <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     eb6:	62 e0       	ldi	r22, 0x02	; 2
     eb8:	82 e0       	ldi	r24, 0x02	; 2
     eba:	e1 cc       	rjmp	.-1598   	; 0x87e <sysclk_disable_module>
     ebc:	08 95       	ret

00000ebe <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
     ebe:	1f 93       	push	r17
     ec0:	cf 93       	push	r28
     ec2:	df 93       	push	r29
     ec4:	ec 01       	movw	r28, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     ec6:	1f b7       	in	r17, 0x3f	; 63
	cpu_irq_disable();
     ec8:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
     eca:	bd df       	rcall	.-134    	; 0xe46 <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
     ecc:	88 81       	ld	r24, Y
     ece:	81 60       	ori	r24, 0x01	; 1
     ed0:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     ed2:	1f bf       	out	0x3f, r17	; 63

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     ed4:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
     ed6:	f8 94       	cli
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
     ed8:	ec e9       	ldi	r30, 0x9C	; 156
     eda:	f3 e2       	ldi	r31, 0x23	; 35
     edc:	90 81       	ld	r25, Z
     ede:	9f 5f       	subi	r25, 0xFF	; 255
     ee0:	90 83       	st	Z, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     ee2:	8f bf       	out	0x3f, r24	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
     ee4:	df 91       	pop	r29
     ee6:	cf 91       	pop	r28
     ee8:	1f 91       	pop	r17
     eea:	08 95       	ret

00000eec <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
     eec:	1f 92       	push	r1
     eee:	0f 92       	push	r0
     ef0:	0f b6       	in	r0, 0x3f	; 63
     ef2:	0f 92       	push	r0
     ef4:	11 24       	eor	r1, r1
     ef6:	0b b6       	in	r0, 0x3b	; 59
     ef8:	0f 92       	push	r0
     efa:	2f 93       	push	r18
     efc:	3f 93       	push	r19
     efe:	4f 93       	push	r20
     f00:	5f 93       	push	r21
     f02:	6f 93       	push	r22
     f04:	7f 93       	push	r23
     f06:	8f 93       	push	r24
     f08:	9f 93       	push	r25
     f0a:	af 93       	push	r26
     f0c:	bf 93       	push	r27
     f0e:	ef 93       	push	r30
     f10:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
     f12:	e0 e0       	ldi	r30, 0x00	; 0
     f14:	f2 e0       	ldi	r31, 0x02	; 2
     f16:	44 a1       	ldd	r20, Z+36	; 0x24
     f18:	55 a1       	ldd	r21, Z+37	; 0x25
     f1a:	e0 91 a3 23 	lds	r30, 0x23A3
     f1e:	f0 91 a4 23 	lds	r31, 0x23A4
     f22:	61 e0       	ldi	r22, 0x01	; 1
     f24:	80 e0       	ldi	r24, 0x00	; 0
     f26:	92 e0       	ldi	r25, 0x02	; 2
     f28:	19 95       	eicall
}
     f2a:	ff 91       	pop	r31
     f2c:	ef 91       	pop	r30
     f2e:	bf 91       	pop	r27
     f30:	af 91       	pop	r26
     f32:	9f 91       	pop	r25
     f34:	8f 91       	pop	r24
     f36:	7f 91       	pop	r23
     f38:	6f 91       	pop	r22
     f3a:	5f 91       	pop	r21
     f3c:	4f 91       	pop	r20
     f3e:	3f 91       	pop	r19
     f40:	2f 91       	pop	r18
     f42:	0f 90       	pop	r0
     f44:	0b be       	out	0x3b, r0	; 59
     f46:	0f 90       	pop	r0
     f48:	0f be       	out	0x3f, r0	; 63
     f4a:	0f 90       	pop	r0
     f4c:	1f 90       	pop	r1
     f4e:	18 95       	reti

00000f50 <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
     f50:	1f 92       	push	r1
     f52:	0f 92       	push	r0
     f54:	0f b6       	in	r0, 0x3f	; 63
     f56:	0f 92       	push	r0
     f58:	11 24       	eor	r1, r1
     f5a:	0b b6       	in	r0, 0x3b	; 59
     f5c:	0f 92       	push	r0
     f5e:	2f 93       	push	r18
     f60:	3f 93       	push	r19
     f62:	4f 93       	push	r20
     f64:	5f 93       	push	r21
     f66:	6f 93       	push	r22
     f68:	7f 93       	push	r23
     f6a:	8f 93       	push	r24
     f6c:	9f 93       	push	r25
     f6e:	af 93       	push	r26
     f70:	bf 93       	push	r27
     f72:	ef 93       	push	r30
     f74:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
     f76:	e8 e2       	ldi	r30, 0x28	; 40
     f78:	f2 e0       	ldi	r31, 0x02	; 2
     f7a:	44 81       	ldd	r20, Z+4	; 0x04
     f7c:	55 81       	ldd	r21, Z+5	; 0x05
     f7e:	e0 91 a3 23 	lds	r30, 0x23A3
     f82:	f0 91 a4 23 	lds	r31, 0x23A4
     f86:	62 e0       	ldi	r22, 0x02	; 2
     f88:	80 e0       	ldi	r24, 0x00	; 0
     f8a:	92 e0       	ldi	r25, 0x02	; 2
     f8c:	19 95       	eicall
}
     f8e:	ff 91       	pop	r31
     f90:	ef 91       	pop	r30
     f92:	bf 91       	pop	r27
     f94:	af 91       	pop	r26
     f96:	9f 91       	pop	r25
     f98:	8f 91       	pop	r24
     f9a:	7f 91       	pop	r23
     f9c:	6f 91       	pop	r22
     f9e:	5f 91       	pop	r21
     fa0:	4f 91       	pop	r20
     fa2:	3f 91       	pop	r19
     fa4:	2f 91       	pop	r18
     fa6:	0f 90       	pop	r0
     fa8:	0b be       	out	0x3b, r0	; 59
     faa:	0f 90       	pop	r0
     fac:	0f be       	out	0x3f, r0	; 63
     fae:	0f 90       	pop	r0
     fb0:	1f 90       	pop	r1
     fb2:	18 95       	reti

00000fb4 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
     fb4:	1f 92       	push	r1
     fb6:	0f 92       	push	r0
     fb8:	0f b6       	in	r0, 0x3f	; 63
     fba:	0f 92       	push	r0
     fbc:	11 24       	eor	r1, r1
     fbe:	0b b6       	in	r0, 0x3b	; 59
     fc0:	0f 92       	push	r0
     fc2:	2f 93       	push	r18
     fc4:	3f 93       	push	r19
     fc6:	4f 93       	push	r20
     fc8:	5f 93       	push	r21
     fca:	6f 93       	push	r22
     fcc:	7f 93       	push	r23
     fce:	8f 93       	push	r24
     fd0:	9f 93       	push	r25
     fd2:	af 93       	push	r26
     fd4:	bf 93       	push	r27
     fd6:	ef 93       	push	r30
     fd8:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
     fda:	e0 e3       	ldi	r30, 0x30	; 48
     fdc:	f2 e0       	ldi	r31, 0x02	; 2
     fde:	44 81       	ldd	r20, Z+4	; 0x04
     fe0:	55 81       	ldd	r21, Z+5	; 0x05
     fe2:	e0 91 a3 23 	lds	r30, 0x23A3
     fe6:	f0 91 a4 23 	lds	r31, 0x23A4
     fea:	64 e0       	ldi	r22, 0x04	; 4
     fec:	80 e0       	ldi	r24, 0x00	; 0
     fee:	92 e0       	ldi	r25, 0x02	; 2
     ff0:	19 95       	eicall
}
     ff2:	ff 91       	pop	r31
     ff4:	ef 91       	pop	r30
     ff6:	bf 91       	pop	r27
     ff8:	af 91       	pop	r26
     ffa:	9f 91       	pop	r25
     ffc:	8f 91       	pop	r24
     ffe:	7f 91       	pop	r23
    1000:	6f 91       	pop	r22
    1002:	5f 91       	pop	r21
    1004:	4f 91       	pop	r20
    1006:	3f 91       	pop	r19
    1008:	2f 91       	pop	r18
    100a:	0f 90       	pop	r0
    100c:	0b be       	out	0x3b, r0	; 59
    100e:	0f 90       	pop	r0
    1010:	0f be       	out	0x3f, r0	; 63
    1012:	0f 90       	pop	r0
    1014:	1f 90       	pop	r1
    1016:	18 95       	reti

00001018 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    1018:	1f 92       	push	r1
    101a:	0f 92       	push	r0
    101c:	0f b6       	in	r0, 0x3f	; 63
    101e:	0f 92       	push	r0
    1020:	11 24       	eor	r1, r1
    1022:	0b b6       	in	r0, 0x3b	; 59
    1024:	0f 92       	push	r0
    1026:	2f 93       	push	r18
    1028:	3f 93       	push	r19
    102a:	4f 93       	push	r20
    102c:	5f 93       	push	r21
    102e:	6f 93       	push	r22
    1030:	7f 93       	push	r23
    1032:	8f 93       	push	r24
    1034:	9f 93       	push	r25
    1036:	af 93       	push	r26
    1038:	bf 93       	push	r27
    103a:	ef 93       	push	r30
    103c:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    103e:	e8 e3       	ldi	r30, 0x38	; 56
    1040:	f2 e0       	ldi	r31, 0x02	; 2
    1042:	44 81       	ldd	r20, Z+4	; 0x04
    1044:	55 81       	ldd	r21, Z+5	; 0x05
    1046:	e0 91 a3 23 	lds	r30, 0x23A3
    104a:	f0 91 a4 23 	lds	r31, 0x23A4
    104e:	68 e0       	ldi	r22, 0x08	; 8
    1050:	80 e0       	ldi	r24, 0x00	; 0
    1052:	92 e0       	ldi	r25, 0x02	; 2
    1054:	19 95       	eicall
}
    1056:	ff 91       	pop	r31
    1058:	ef 91       	pop	r30
    105a:	bf 91       	pop	r27
    105c:	af 91       	pop	r26
    105e:	9f 91       	pop	r25
    1060:	8f 91       	pop	r24
    1062:	7f 91       	pop	r23
    1064:	6f 91       	pop	r22
    1066:	5f 91       	pop	r21
    1068:	4f 91       	pop	r20
    106a:	3f 91       	pop	r19
    106c:	2f 91       	pop	r18
    106e:	0f 90       	pop	r0
    1070:	0b be       	out	0x3b, r0	; 59
    1072:	0f 90       	pop	r0
    1074:	0f be       	out	0x3f, r0	; 63
    1076:	0f 90       	pop	r0
    1078:	1f 90       	pop	r1
    107a:	18 95       	reti

0000107c <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    107c:	1f 92       	push	r1
    107e:	0f 92       	push	r0
    1080:	0f b6       	in	r0, 0x3f	; 63
    1082:	0f 92       	push	r0
    1084:	11 24       	eor	r1, r1
    1086:	0b b6       	in	r0, 0x3b	; 59
    1088:	0f 92       	push	r0
    108a:	2f 93       	push	r18
    108c:	3f 93       	push	r19
    108e:	4f 93       	push	r20
    1090:	5f 93       	push	r21
    1092:	6f 93       	push	r22
    1094:	7f 93       	push	r23
    1096:	8f 93       	push	r24
    1098:	9f 93       	push	r25
    109a:	af 93       	push	r26
    109c:	bf 93       	push	r27
    109e:	ef 93       	push	r30
    10a0:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    10a2:	e0 e4       	ldi	r30, 0x40	; 64
    10a4:	f2 e0       	ldi	r31, 0x02	; 2
    10a6:	44 a1       	ldd	r20, Z+36	; 0x24
    10a8:	55 a1       	ldd	r21, Z+37	; 0x25
    10aa:	e0 91 a1 23 	lds	r30, 0x23A1
    10ae:	f0 91 a2 23 	lds	r31, 0x23A2
    10b2:	61 e0       	ldi	r22, 0x01	; 1
    10b4:	80 e4       	ldi	r24, 0x40	; 64
    10b6:	92 e0       	ldi	r25, 0x02	; 2
    10b8:	19 95       	eicall
}
    10ba:	ff 91       	pop	r31
    10bc:	ef 91       	pop	r30
    10be:	bf 91       	pop	r27
    10c0:	af 91       	pop	r26
    10c2:	9f 91       	pop	r25
    10c4:	8f 91       	pop	r24
    10c6:	7f 91       	pop	r23
    10c8:	6f 91       	pop	r22
    10ca:	5f 91       	pop	r21
    10cc:	4f 91       	pop	r20
    10ce:	3f 91       	pop	r19
    10d0:	2f 91       	pop	r18
    10d2:	0f 90       	pop	r0
    10d4:	0b be       	out	0x3b, r0	; 59
    10d6:	0f 90       	pop	r0
    10d8:	0f be       	out	0x3f, r0	; 63
    10da:	0f 90       	pop	r0
    10dc:	1f 90       	pop	r1
    10de:	18 95       	reti

000010e0 <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    10e0:	1f 92       	push	r1
    10e2:	0f 92       	push	r0
    10e4:	0f b6       	in	r0, 0x3f	; 63
    10e6:	0f 92       	push	r0
    10e8:	11 24       	eor	r1, r1
    10ea:	0b b6       	in	r0, 0x3b	; 59
    10ec:	0f 92       	push	r0
    10ee:	2f 93       	push	r18
    10f0:	3f 93       	push	r19
    10f2:	4f 93       	push	r20
    10f4:	5f 93       	push	r21
    10f6:	6f 93       	push	r22
    10f8:	7f 93       	push	r23
    10fa:	8f 93       	push	r24
    10fc:	9f 93       	push	r25
    10fe:	af 93       	push	r26
    1100:	bf 93       	push	r27
    1102:	ef 93       	push	r30
    1104:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    1106:	e8 e6       	ldi	r30, 0x68	; 104
    1108:	f2 e0       	ldi	r31, 0x02	; 2
    110a:	44 81       	ldd	r20, Z+4	; 0x04
    110c:	55 81       	ldd	r21, Z+5	; 0x05
    110e:	e0 91 a1 23 	lds	r30, 0x23A1
    1112:	f0 91 a2 23 	lds	r31, 0x23A2
    1116:	62 e0       	ldi	r22, 0x02	; 2
    1118:	80 e4       	ldi	r24, 0x40	; 64
    111a:	92 e0       	ldi	r25, 0x02	; 2
    111c:	19 95       	eicall
}
    111e:	ff 91       	pop	r31
    1120:	ef 91       	pop	r30
    1122:	bf 91       	pop	r27
    1124:	af 91       	pop	r26
    1126:	9f 91       	pop	r25
    1128:	8f 91       	pop	r24
    112a:	7f 91       	pop	r23
    112c:	6f 91       	pop	r22
    112e:	5f 91       	pop	r21
    1130:	4f 91       	pop	r20
    1132:	3f 91       	pop	r19
    1134:	2f 91       	pop	r18
    1136:	0f 90       	pop	r0
    1138:	0b be       	out	0x3b, r0	; 59
    113a:	0f 90       	pop	r0
    113c:	0f be       	out	0x3f, r0	; 63
    113e:	0f 90       	pop	r0
    1140:	1f 90       	pop	r1
    1142:	18 95       	reti

00001144 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    1144:	1f 92       	push	r1
    1146:	0f 92       	push	r0
    1148:	0f b6       	in	r0, 0x3f	; 63
    114a:	0f 92       	push	r0
    114c:	11 24       	eor	r1, r1
    114e:	0b b6       	in	r0, 0x3b	; 59
    1150:	0f 92       	push	r0
    1152:	2f 93       	push	r18
    1154:	3f 93       	push	r19
    1156:	4f 93       	push	r20
    1158:	5f 93       	push	r21
    115a:	6f 93       	push	r22
    115c:	7f 93       	push	r23
    115e:	8f 93       	push	r24
    1160:	9f 93       	push	r25
    1162:	af 93       	push	r26
    1164:	bf 93       	push	r27
    1166:	ef 93       	push	r30
    1168:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    116a:	e0 e7       	ldi	r30, 0x70	; 112
    116c:	f2 e0       	ldi	r31, 0x02	; 2
    116e:	44 81       	ldd	r20, Z+4	; 0x04
    1170:	55 81       	ldd	r21, Z+5	; 0x05
    1172:	e0 91 a1 23 	lds	r30, 0x23A1
    1176:	f0 91 a2 23 	lds	r31, 0x23A2
    117a:	64 e0       	ldi	r22, 0x04	; 4
    117c:	80 e4       	ldi	r24, 0x40	; 64
    117e:	92 e0       	ldi	r25, 0x02	; 2
    1180:	19 95       	eicall
}
    1182:	ff 91       	pop	r31
    1184:	ef 91       	pop	r30
    1186:	bf 91       	pop	r27
    1188:	af 91       	pop	r26
    118a:	9f 91       	pop	r25
    118c:	8f 91       	pop	r24
    118e:	7f 91       	pop	r23
    1190:	6f 91       	pop	r22
    1192:	5f 91       	pop	r21
    1194:	4f 91       	pop	r20
    1196:	3f 91       	pop	r19
    1198:	2f 91       	pop	r18
    119a:	0f 90       	pop	r0
    119c:	0b be       	out	0x3b, r0	; 59
    119e:	0f 90       	pop	r0
    11a0:	0f be       	out	0x3f, r0	; 63
    11a2:	0f 90       	pop	r0
    11a4:	1f 90       	pop	r1
    11a6:	18 95       	reti

000011a8 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    11a8:	1f 92       	push	r1
    11aa:	0f 92       	push	r0
    11ac:	0f b6       	in	r0, 0x3f	; 63
    11ae:	0f 92       	push	r0
    11b0:	11 24       	eor	r1, r1
    11b2:	0b b6       	in	r0, 0x3b	; 59
    11b4:	0f 92       	push	r0
    11b6:	2f 93       	push	r18
    11b8:	3f 93       	push	r19
    11ba:	4f 93       	push	r20
    11bc:	5f 93       	push	r21
    11be:	6f 93       	push	r22
    11c0:	7f 93       	push	r23
    11c2:	8f 93       	push	r24
    11c4:	9f 93       	push	r25
    11c6:	af 93       	push	r26
    11c8:	bf 93       	push	r27
    11ca:	ef 93       	push	r30
    11cc:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    11ce:	e8 e7       	ldi	r30, 0x78	; 120
    11d0:	f2 e0       	ldi	r31, 0x02	; 2
    11d2:	44 81       	ldd	r20, Z+4	; 0x04
    11d4:	55 81       	ldd	r21, Z+5	; 0x05
    11d6:	e0 91 a1 23 	lds	r30, 0x23A1
    11da:	f0 91 a2 23 	lds	r31, 0x23A2
    11de:	68 e0       	ldi	r22, 0x08	; 8
    11e0:	80 e4       	ldi	r24, 0x40	; 64
    11e2:	92 e0       	ldi	r25, 0x02	; 2
    11e4:	19 95       	eicall
}
    11e6:	ff 91       	pop	r31
    11e8:	ef 91       	pop	r30
    11ea:	bf 91       	pop	r27
    11ec:	af 91       	pop	r26
    11ee:	9f 91       	pop	r25
    11f0:	8f 91       	pop	r24
    11f2:	7f 91       	pop	r23
    11f4:	6f 91       	pop	r22
    11f6:	5f 91       	pop	r21
    11f8:	4f 91       	pop	r20
    11fa:	3f 91       	pop	r19
    11fc:	2f 91       	pop	r18
    11fe:	0f 90       	pop	r0
    1200:	0b be       	out	0x3b, r0	; 59
    1202:	0f 90       	pop	r0
    1204:	0f be       	out	0x3f, r0	; 63
    1206:	0f 90       	pop	r0
    1208:	1f 90       	pop	r1
    120a:	18 95       	reti

0000120c <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    120c:	df 92       	push	r13
    120e:	ef 92       	push	r14
    1210:	ff 92       	push	r15
    1212:	0f 93       	push	r16
    1214:	1f 93       	push	r17
    1216:	cf 93       	push	r28
    1218:	df 93       	push	r29
    121a:	ec 01       	movw	r28, r24
    121c:	8b 01       	movw	r16, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    121e:	c1 15       	cp	r28, r1
    1220:	22 e0       	ldi	r18, 0x02	; 2
    1222:	d2 07       	cpc	r29, r18
    1224:	71 f4       	brne	.+28     	; 0x1242 <adc_write_configuration+0x36>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    1226:	61 e2       	ldi	r22, 0x21	; 33
    1228:	70 e0       	ldi	r23, 0x00	; 0
    122a:	82 e0       	ldi	r24, 0x02	; 2
    122c:	d6 d0       	rcall	.+428    	; 0x13da <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    122e:	e8 2e       	mov	r14, r24
    1230:	f1 2c       	mov	r15, r1
    1232:	60 e2       	ldi	r22, 0x20	; 32
    1234:	70 e0       	ldi	r23, 0x00	; 0
    1236:	82 e0       	ldi	r24, 0x02	; 2
    1238:	d0 d0       	rcall	.+416    	; 0x13da <nvm_read_byte>
		data <<= 8;
    123a:	fe 2c       	mov	r15, r14
    123c:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCACAL0);
    123e:	e8 2a       	or	r14, r24
    1240:	10 c0       	rjmp	.+32     	; 0x1262 <adc_write_configuration+0x56>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1242:	80 34       	cpi	r24, 0x40	; 64
    1244:	92 40       	sbci	r25, 0x02	; 2
    1246:	59 f5       	brne	.+86     	; 0x129e <adc_write_configuration+0x92>
    1248:	65 e2       	ldi	r22, 0x25	; 37
    124a:	70 e0       	ldi	r23, 0x00	; 0
    124c:	82 e0       	ldi	r24, 0x02	; 2
    124e:	c5 d0       	rcall	.+394    	; 0x13da <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    1250:	e8 2e       	mov	r14, r24
    1252:	f1 2c       	mov	r15, r1
    1254:	64 e2       	ldi	r22, 0x24	; 36
    1256:	70 e0       	ldi	r23, 0x00	; 0
    1258:	82 e0       	ldi	r24, 0x02	; 2
    125a:	bf d0       	rcall	.+382    	; 0x13da <nvm_read_byte>
		data <<= 8;
    125c:	fe 2c       	mov	r15, r14
    125e:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCBCAL0);
    1260:	e8 2a       	or	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1262:	df b6       	in	r13, 0x3f	; 63
	cpu_irq_disable();
    1264:	f8 94       	cli
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    1266:	ce 01       	movw	r24, r28
    1268:	ee dd       	rcall	.-1060   	; 0xe46 <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
    126a:	28 81       	ld	r18, Y

	adc->CTRLA = ADC_FLUSH_bm;
    126c:	82 e0       	ldi	r24, 0x02	; 2
    126e:	88 83       	st	Y, r24
	adc->CAL = cal;
    1270:	ec 86       	std	Y+12, r14	; 0x0c
    1272:	fd 86       	std	Y+13, r15	; 0x0d
	adc->CMP = conf->cmp;
    1274:	f8 01       	movw	r30, r16
    1276:	85 81       	ldd	r24, Z+5	; 0x05
    1278:	96 81       	ldd	r25, Z+6	; 0x06
    127a:	88 8f       	std	Y+24, r24	; 0x18
    127c:	99 8f       	std	Y+25, r25	; 0x19
	adc->REFCTRL = conf->refctrl;
    127e:	82 81       	ldd	r24, Z+2	; 0x02
    1280:	8a 83       	std	Y+2, r24	; 0x02
	adc->PRESCALER = conf->prescaler;
    1282:	84 81       	ldd	r24, Z+4	; 0x04
    1284:	8c 83       	std	Y+4, r24	; 0x04
	adc->EVCTRL = conf->evctrl;
    1286:	83 81       	ldd	r24, Z+3	; 0x03
    1288:	8b 83       	std	Y+3, r24	; 0x03
	adc->CTRLB = conf->ctrlb;
    128a:	81 81       	ldd	r24, Z+1	; 0x01
    128c:	89 83       	std	Y+1, r24	; 0x01
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
	enable = adc->CTRLA & ADC_ENABLE_bm;
    128e:	82 2f       	mov	r24, r18
    1290:	81 70       	andi	r24, 0x01	; 1
	adc->REFCTRL = conf->refctrl;
	adc->PRESCALER = conf->prescaler;
	adc->EVCTRL = conf->evctrl;
	adc->CTRLB = conf->ctrlb;

	adc->CTRLA = enable | conf->ctrla;
    1292:	90 81       	ld	r25, Z
    1294:	89 2b       	or	r24, r25
    1296:	88 83       	st	Y, r24

	adc_disable_clock(adc);
    1298:	ce 01       	movw	r24, r28
    129a:	f4 dd       	rcall	.-1048   	; 0xe84 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    129c:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    129e:	df 91       	pop	r29
    12a0:	cf 91       	pop	r28
    12a2:	1f 91       	pop	r17
    12a4:	0f 91       	pop	r16
    12a6:	ff 90       	pop	r15
    12a8:	ef 90       	pop	r14
    12aa:	df 90       	pop	r13
    12ac:	08 95       	ret

000012ae <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    12ae:	ff 92       	push	r15
    12b0:	0f 93       	push	r16
    12b2:	1f 93       	push	r17
    12b4:	cf 93       	push	r28
    12b6:	df 93       	push	r29
    12b8:	ec 01       	movw	r28, r24
    12ba:	8b 01       	movw	r16, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    12bc:	ff b6       	in	r15, 0x3f	; 63
	cpu_irq_disable();
    12be:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    12c0:	c2 dd       	rcall	.-1148   	; 0xe46 <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    12c2:	88 81       	ld	r24, Y
    12c4:	80 7c       	andi	r24, 0xC0	; 192
    12c6:	f8 01       	movw	r30, r16
    12c8:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    12ca:	88 8d       	ldd	r24, Y+24	; 0x18
    12cc:	99 8d       	ldd	r25, Y+25	; 0x19
    12ce:	85 83       	std	Z+5, r24	; 0x05
    12d0:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    12d2:	8a 81       	ldd	r24, Y+2	; 0x02
    12d4:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    12d6:	8c 81       	ldd	r24, Y+4	; 0x04
    12d8:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    12da:	8b 81       	ldd	r24, Y+3	; 0x03
    12dc:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    12de:	89 81       	ldd	r24, Y+1	; 0x01
    12e0:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    12e2:	ce 01       	movw	r24, r28
    12e4:	cf dd       	rcall	.-1122   	; 0xe84 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    12e6:	ff be       	out	0x3f, r15	; 63

	cpu_irq_restore(flags);
}
    12e8:	df 91       	pop	r29
    12ea:	cf 91       	pop	r28
    12ec:	1f 91       	pop	r17
    12ee:	0f 91       	pop	r16
    12f0:	ff 90       	pop	r15
    12f2:	08 95       	ret

000012f4 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    12f4:	cf 92       	push	r12
    12f6:	df 92       	push	r13
    12f8:	ef 92       	push	r14
    12fa:	ff 92       	push	r15
    12fc:	0f 93       	push	r16
    12fe:	1f 93       	push	r17
    1300:	cf 93       	push	r28
    1302:	df 93       	push	r29
    1304:	7c 01       	movw	r14, r24
    1306:	d6 2e       	mov	r13, r22
    1308:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    130a:	86 2f       	mov	r24, r22
    130c:	83 70       	andi	r24, 0x03	; 3
    130e:	29 f4       	brne	.+10     	; 0x131a <adcch_write_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    1310:	96 2f       	mov	r25, r22
    1312:	96 95       	lsr	r25
    1314:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1316:	82 e0       	ldi	r24, 0x02	; 2
    1318:	02 c0       	rjmp	.+4      	; 0x131e <adcch_write_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    131a:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    131c:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    131e:	90 ff       	sbrs	r25, 0
		index++;
    1320:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1322:	e7 01       	movw	r28, r14
    1324:	a0 96       	adiw	r28, 0x20	; 32
    1326:	98 e0       	ldi	r25, 0x08	; 8
    1328:	89 9f       	mul	r24, r25
    132a:	c0 0d       	add	r28, r0
    132c:	d1 1d       	adc	r29, r1
    132e:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1330:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1332:	f8 94       	cli
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    1334:	c7 01       	movw	r24, r14
    1336:	87 dd       	rcall	.-1266   	; 0xe46 <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    1338:	f8 01       	movw	r30, r16
    133a:	80 81       	ld	r24, Z
    133c:	88 83       	st	Y, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    133e:	82 81       	ldd	r24, Z+2	; 0x02
    1340:	8a 83       	std	Y+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    1342:	81 81       	ldd	r24, Z+1	; 0x01
    1344:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1346:	d0 fe       	sbrs	r13, 0
    1348:	02 c0       	rjmp	.+4      	; 0x134e <adcch_write_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    134a:	83 81       	ldd	r24, Z+3	; 0x03
    134c:	8e 83       	std	Y+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    134e:	c7 01       	movw	r24, r14
    1350:	99 dd       	rcall	.-1230   	; 0xe84 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1352:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	1f 91       	pop	r17
    135a:	0f 91       	pop	r16
    135c:	ff 90       	pop	r15
    135e:	ef 90       	pop	r14
    1360:	df 90       	pop	r13
    1362:	cf 90       	pop	r12
    1364:	08 95       	ret

00001366 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    1366:	cf 92       	push	r12
    1368:	df 92       	push	r13
    136a:	ef 92       	push	r14
    136c:	ff 92       	push	r15
    136e:	0f 93       	push	r16
    1370:	1f 93       	push	r17
    1372:	cf 93       	push	r28
    1374:	df 93       	push	r29
    1376:	7c 01       	movw	r14, r24
    1378:	d6 2e       	mov	r13, r22
    137a:	ea 01       	movw	r28, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    137c:	86 2f       	mov	r24, r22
    137e:	83 70       	andi	r24, 0x03	; 3
    1380:	29 f4       	brne	.+10     	; 0x138c <adcch_read_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    1382:	96 2f       	mov	r25, r22
    1384:	96 95       	lsr	r25
    1386:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1388:	82 e0       	ldi	r24, 0x02	; 2
    138a:	02 c0       	rjmp	.+4      	; 0x1390 <adcch_read_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    138c:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    138e:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1390:	90 ff       	sbrs	r25, 0
		index++;
    1392:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1394:	87 01       	movw	r16, r14
    1396:	00 5e       	subi	r16, 0xE0	; 224
    1398:	1f 4f       	sbci	r17, 0xFF	; 255
    139a:	98 e0       	ldi	r25, 0x08	; 8
    139c:	89 9f       	mul	r24, r25
    139e:	00 0d       	add	r16, r0
    13a0:	11 1d       	adc	r17, r1
    13a2:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    13a4:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    13a6:	f8 94       	cli

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    13a8:	c7 01       	movw	r24, r14
    13aa:	4d dd       	rcall	.-1382   	; 0xe46 <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    13ac:	f8 01       	movw	r30, r16
    13ae:	80 81       	ld	r24, Z
    13b0:	88 83       	st	Y, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    13b2:	82 81       	ldd	r24, Z+2	; 0x02
    13b4:	8a 83       	std	Y+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    13b6:	81 81       	ldd	r24, Z+1	; 0x01
    13b8:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    13ba:	d0 fe       	sbrs	r13, 0
    13bc:	02 c0       	rjmp	.+4      	; 0x13c2 <adcch_read_configuration+0x5c>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    13be:	86 81       	ldd	r24, Z+6	; 0x06
    13c0:	8b 83       	std	Y+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    13c2:	c7 01       	movw	r24, r14
    13c4:	5f dd       	rcall	.-1346   	; 0xe84 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    13c6:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    13c8:	df 91       	pop	r29
    13ca:	cf 91       	pop	r28
    13cc:	1f 91       	pop	r17
    13ce:	0f 91       	pop	r16
    13d0:	ff 90       	pop	r15
    13d2:	ef 90       	pop	r14
    13d4:	df 90       	pop	r13
    13d6:	cf 90       	pop	r12
    13d8:	08 95       	ret

000013da <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    13da:	40 91 ca 01 	lds	r20, 0x01CA
	mov ZL, r22               ; Load byte index into low byte of Z.
    13de:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    13e0:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    13e2:	80 93 ca 01 	sts	0x01CA, r24
	lpm r24, Z                ; Perform an LPM to read out byte
    13e6:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    13e8:	40 93 ca 01 	sts	0x01CA, r20
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    13ec:	08 95       	ret

000013ee <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    13ee:	cf 92       	push	r12
    13f0:	df 92       	push	r13
    13f2:	ef 92       	push	r14
    13f4:	ff 92       	push	r15
    13f6:	0f 93       	push	r16
    13f8:	1f 93       	push	r17
    13fa:	cf 93       	push	r28
    13fc:	df 93       	push	r29
    13fe:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    1400:	68 01       	movw	r12, r16
    1402:	79 01       	movw	r14, r18
    1404:	f6 94       	lsr	r15
    1406:	e7 94       	ror	r14
    1408:	d7 94       	ror	r13
    140a:	c7 94       	ror	r12
    140c:	4c 15       	cp	r20, r12
    140e:	5d 05       	cpc	r21, r13
    1410:	6e 05       	cpc	r22, r14
    1412:	7f 05       	cpc	r23, r15
    1414:	78 f4       	brcc	.+30     	; 0x1434 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1416:	6a 01       	movw	r12, r20
    1418:	7b 01       	movw	r14, r22
    141a:	cc 0c       	add	r12, r12
    141c:	dd 1c       	adc	r13, r13
    141e:	ee 1c       	adc	r14, r14
    1420:	ff 1c       	adc	r15, r15
    1422:	c9 01       	movw	r24, r18
    1424:	b8 01       	movw	r22, r16
    1426:	a7 01       	movw	r20, r14
    1428:	96 01       	movw	r18, r12
    142a:	0e 94 c0 19 	call	0x3380	; 0x3380 <__udivmodsi4>
    142e:	21 50       	subi	r18, 0x01	; 1
    1430:	31 09       	sbc	r19, r1
    1432:	02 c0       	rjmp	.+4      	; 0x1438 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1434:	20 e0       	ldi	r18, 0x00	; 0
    1436:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1438:	83 2f       	mov	r24, r19
    143a:	8f 70       	andi	r24, 0x0F	; 15
    143c:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    143e:	2e 83       	std	Y+6, r18	; 0x06
}
    1440:	df 91       	pop	r29
    1442:	cf 91       	pop	r28
    1444:	1f 91       	pop	r17
    1446:	0f 91       	pop	r16
    1448:	ff 90       	pop	r15
    144a:	ef 90       	pop	r14
    144c:	df 90       	pop	r13
    144e:	cf 90       	pop	r12
    1450:	08 95       	ret

00001452 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1452:	ff 92       	push	r15
    1454:	0f 93       	push	r16
    1456:	1f 93       	push	r17
    1458:	cf 93       	push	r28
    145a:	df 93       	push	r29
    145c:	ec 01       	movw	r28, r24
    145e:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1460:	00 97       	sbiw	r24, 0x00	; 0
    1462:	09 f4       	brne	.+2      	; 0x1466 <usart_init_spi+0x14>
    1464:	9b c1       	rjmp	.+822    	; 0x179c <usart_init_spi+0x34a>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1466:	80 3c       	cpi	r24, 0xC0	; 192
    1468:	91 05       	cpc	r25, r1
    146a:	21 f4       	brne	.+8      	; 0x1474 <usart_init_spi+0x22>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    146c:	60 e1       	ldi	r22, 0x10	; 16
    146e:	80 e0       	ldi	r24, 0x00	; 0
    1470:	fa d9       	rcall	.-3084   	; 0x866 <sysclk_enable_module>
    1472:	94 c1       	rjmp	.+808    	; 0x179c <usart_init_spi+0x34a>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1474:	80 38       	cpi	r24, 0x80	; 128
    1476:	21 e0       	ldi	r18, 0x01	; 1
    1478:	92 07       	cpc	r25, r18
    147a:	21 f4       	brne	.+8      	; 0x1484 <usart_init_spi+0x32>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    147c:	62 e0       	ldi	r22, 0x02	; 2
    147e:	80 e0       	ldi	r24, 0x00	; 0
    1480:	f2 d9       	rcall	.-3100   	; 0x866 <sysclk_enable_module>
    1482:	8c c1       	rjmp	.+792    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1484:	c1 15       	cp	r28, r1
    1486:	81 e0       	ldi	r24, 0x01	; 1
    1488:	d8 07       	cpc	r29, r24
    148a:	21 f4       	brne	.+8      	; 0x1494 <usart_init_spi+0x42>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    148c:	61 e0       	ldi	r22, 0x01	; 1
    148e:	80 e0       	ldi	r24, 0x00	; 0
    1490:	ea d9       	rcall	.-3116   	; 0x866 <sysclk_enable_module>
    1492:	84 c1       	rjmp	.+776    	; 0x179c <usart_init_spi+0x34a>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1494:	c0 38       	cpi	r28, 0x80	; 128
    1496:	e3 e0       	ldi	r30, 0x03	; 3
    1498:	de 07       	cpc	r29, r30
    149a:	21 f4       	brne	.+8      	; 0x14a4 <usart_init_spi+0x52>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    149c:	61 e0       	ldi	r22, 0x01	; 1
    149e:	81 e0       	ldi	r24, 0x01	; 1
    14a0:	e2 d9       	rcall	.-3132   	; 0x866 <sysclk_enable_module>
    14a2:	7c c1       	rjmp	.+760    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    14a4:	c0 39       	cpi	r28, 0x90	; 144
    14a6:	f3 e0       	ldi	r31, 0x03	; 3
    14a8:	df 07       	cpc	r29, r31
    14aa:	21 f4       	brne	.+8      	; 0x14b4 <usart_init_spi+0x62>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    14ac:	61 e0       	ldi	r22, 0x01	; 1
    14ae:	82 e0       	ldi	r24, 0x02	; 2
    14b0:	da d9       	rcall	.-3148   	; 0x866 <sysclk_enable_module>
    14b2:	74 c1       	rjmp	.+744    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    14b4:	c1 15       	cp	r28, r1
    14b6:	22 e0       	ldi	r18, 0x02	; 2
    14b8:	d2 07       	cpc	r29, r18
    14ba:	21 f4       	brne	.+8      	; 0x14c4 <usart_init_spi+0x72>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    14bc:	62 e0       	ldi	r22, 0x02	; 2
    14be:	81 e0       	ldi	r24, 0x01	; 1
    14c0:	d2 d9       	rcall	.-3164   	; 0x866 <sysclk_enable_module>
    14c2:	6c c1       	rjmp	.+728    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    14c4:	c0 34       	cpi	r28, 0x40	; 64
    14c6:	82 e0       	ldi	r24, 0x02	; 2
    14c8:	d8 07       	cpc	r29, r24
    14ca:	21 f4       	brne	.+8      	; 0x14d4 <usart_init_spi+0x82>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    14cc:	62 e0       	ldi	r22, 0x02	; 2
    14ce:	82 e0       	ldi	r24, 0x02	; 2
    14d0:	ca d9       	rcall	.-3180   	; 0x866 <sysclk_enable_module>
    14d2:	64 c1       	rjmp	.+712    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    14d4:	c0 32       	cpi	r28, 0x20	; 32
    14d6:	e3 e0       	ldi	r30, 0x03	; 3
    14d8:	de 07       	cpc	r29, r30
    14da:	21 f4       	brne	.+8      	; 0x14e4 <usart_init_spi+0x92>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    14dc:	64 e0       	ldi	r22, 0x04	; 4
    14de:	82 e0       	ldi	r24, 0x02	; 2
    14e0:	c2 d9       	rcall	.-3196   	; 0x866 <sysclk_enable_module>
    14e2:	5c c1       	rjmp	.+696    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    14e4:	c1 15       	cp	r28, r1
    14e6:	f8 e0       	ldi	r31, 0x08	; 8
    14e8:	df 07       	cpc	r29, r31
    14ea:	21 f4       	brne	.+8      	; 0x14f4 <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    14ec:	61 e0       	ldi	r22, 0x01	; 1
    14ee:	83 e0       	ldi	r24, 0x03	; 3
    14f0:	ba d9       	rcall	.-3212   	; 0x866 <sysclk_enable_module>
    14f2:	54 c1       	rjmp	.+680    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    14f4:	c1 15       	cp	r28, r1
    14f6:	29 e0       	ldi	r18, 0x09	; 9
    14f8:	d2 07       	cpc	r29, r18
    14fa:	21 f4       	brne	.+8      	; 0x1504 <usart_init_spi+0xb2>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    14fc:	61 e0       	ldi	r22, 0x01	; 1
    14fe:	84 e0       	ldi	r24, 0x04	; 4
    1500:	b2 d9       	rcall	.-3228   	; 0x866 <sysclk_enable_module>
    1502:	4c c1       	rjmp	.+664    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1504:	c1 15       	cp	r28, r1
    1506:	8a e0       	ldi	r24, 0x0A	; 10
    1508:	d8 07       	cpc	r29, r24
    150a:	21 f4       	brne	.+8      	; 0x1514 <usart_init_spi+0xc2>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    150c:	61 e0       	ldi	r22, 0x01	; 1
    150e:	85 e0       	ldi	r24, 0x05	; 5
    1510:	aa d9       	rcall	.-3244   	; 0x866 <sysclk_enable_module>
    1512:	44 c1       	rjmp	.+648    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1514:	c1 15       	cp	r28, r1
    1516:	eb e0       	ldi	r30, 0x0B	; 11
    1518:	de 07       	cpc	r29, r30
    151a:	21 f4       	brne	.+8      	; 0x1524 <usart_init_spi+0xd2>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    151c:	61 e0       	ldi	r22, 0x01	; 1
    151e:	86 e0       	ldi	r24, 0x06	; 6
    1520:	a2 d9       	rcall	.-3260   	; 0x866 <sysclk_enable_module>
    1522:	3c c1       	rjmp	.+632    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1524:	c0 34       	cpi	r28, 0x40	; 64
    1526:	f8 e0       	ldi	r31, 0x08	; 8
    1528:	df 07       	cpc	r29, r31
    152a:	21 f4       	brne	.+8      	; 0x1534 <usart_init_spi+0xe2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    152c:	62 e0       	ldi	r22, 0x02	; 2
    152e:	83 e0       	ldi	r24, 0x03	; 3
    1530:	9a d9       	rcall	.-3276   	; 0x866 <sysclk_enable_module>
    1532:	34 c1       	rjmp	.+616    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1534:	c0 34       	cpi	r28, 0x40	; 64
    1536:	29 e0       	ldi	r18, 0x09	; 9
    1538:	d2 07       	cpc	r29, r18
    153a:	21 f4       	brne	.+8      	; 0x1544 <usart_init_spi+0xf2>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    153c:	62 e0       	ldi	r22, 0x02	; 2
    153e:	84 e0       	ldi	r24, 0x04	; 4
    1540:	92 d9       	rcall	.-3292   	; 0x866 <sysclk_enable_module>
    1542:	2c c1       	rjmp	.+600    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1544:	c0 34       	cpi	r28, 0x40	; 64
    1546:	8a e0       	ldi	r24, 0x0A	; 10
    1548:	d8 07       	cpc	r29, r24
    154a:	21 f4       	brne	.+8      	; 0x1554 <usart_init_spi+0x102>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    154c:	62 e0       	ldi	r22, 0x02	; 2
    154e:	85 e0       	ldi	r24, 0x05	; 5
    1550:	8a d9       	rcall	.-3308   	; 0x866 <sysclk_enable_module>
    1552:	24 c1       	rjmp	.+584    	; 0x179c <usart_init_spi+0x34a>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1554:	c0 39       	cpi	r28, 0x90	; 144
    1556:	e8 e0       	ldi	r30, 0x08	; 8
    1558:	de 07       	cpc	r29, r30
    155a:	21 f4       	brne	.+8      	; 0x1564 <usart_init_spi+0x112>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    155c:	64 e0       	ldi	r22, 0x04	; 4
    155e:	83 e0       	ldi	r24, 0x03	; 3
    1560:	82 d9       	rcall	.-3324   	; 0x866 <sysclk_enable_module>
    1562:	1c c1       	rjmp	.+568    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1564:	c0 39       	cpi	r28, 0x90	; 144
    1566:	f9 e0       	ldi	r31, 0x09	; 9
    1568:	df 07       	cpc	r29, r31
    156a:	21 f4       	brne	.+8      	; 0x1574 <usart_init_spi+0x122>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    156c:	64 e0       	ldi	r22, 0x04	; 4
    156e:	84 e0       	ldi	r24, 0x04	; 4
    1570:	7a d9       	rcall	.-3340   	; 0x866 <sysclk_enable_module>
    1572:	14 c1       	rjmp	.+552    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1574:	c0 39       	cpi	r28, 0x90	; 144
    1576:	2a e0       	ldi	r18, 0x0A	; 10
    1578:	d2 07       	cpc	r29, r18
    157a:	21 f4       	brne	.+8      	; 0x1584 <usart_init_spi+0x132>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    157c:	64 e0       	ldi	r22, 0x04	; 4
    157e:	85 e0       	ldi	r24, 0x05	; 5
    1580:	72 d9       	rcall	.-3356   	; 0x866 <sysclk_enable_module>
    1582:	0c c1       	rjmp	.+536    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    1584:	c0 39       	cpi	r28, 0x90	; 144
    1586:	8b e0       	ldi	r24, 0x0B	; 11
    1588:	d8 07       	cpc	r29, r24
    158a:	21 f4       	brne	.+8      	; 0x1594 <usart_init_spi+0x142>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    158c:	64 e0       	ldi	r22, 0x04	; 4
    158e:	86 e0       	ldi	r24, 0x06	; 6
    1590:	6a d9       	rcall	.-3372   	; 0x866 <sysclk_enable_module>
    1592:	04 c1       	rjmp	.+520    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    1594:	c0 3c       	cpi	r28, 0xC0	; 192
    1596:	e8 e0       	ldi	r30, 0x08	; 8
    1598:	de 07       	cpc	r29, r30
    159a:	21 f4       	brne	.+8      	; 0x15a4 <usart_init_spi+0x152>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    159c:	68 e0       	ldi	r22, 0x08	; 8
    159e:	83 e0       	ldi	r24, 0x03	; 3
    15a0:	62 d9       	rcall	.-3388   	; 0x866 <sysclk_enable_module>
    15a2:	fc c0       	rjmp	.+504    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    15a4:	c0 3c       	cpi	r28, 0xC0	; 192
    15a6:	f9 e0       	ldi	r31, 0x09	; 9
    15a8:	df 07       	cpc	r29, r31
    15aa:	21 f4       	brne	.+8      	; 0x15b4 <usart_init_spi+0x162>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    15ac:	68 e0       	ldi	r22, 0x08	; 8
    15ae:	84 e0       	ldi	r24, 0x04	; 4
    15b0:	5a d9       	rcall	.-3404   	; 0x866 <sysclk_enable_module>
    15b2:	f4 c0       	rjmp	.+488    	; 0x179c <usart_init_spi+0x34a>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    15b4:	c0 3a       	cpi	r28, 0xA0	; 160
    15b6:	28 e0       	ldi	r18, 0x08	; 8
    15b8:	d2 07       	cpc	r29, r18
    15ba:	71 f4       	brne	.+28     	; 0x15d8 <usart_init_spi+0x186>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    15bc:	60 e1       	ldi	r22, 0x10	; 16
    15be:	83 e0       	ldi	r24, 0x03	; 3
    15c0:	52 d9       	rcall	.-3420   	; 0x866 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    15c2:	e0 ea       	ldi	r30, 0xA0	; 160
    15c4:	f8 e0       	ldi	r31, 0x08	; 8
    15c6:	84 81       	ldd	r24, Z+4	; 0x04
    15c8:	8f 7e       	andi	r24, 0xEF	; 239
    15ca:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    15cc:	f8 01       	movw	r30, r16
    15ce:	34 81       	ldd	r19, Z+4	; 0x04
    15d0:	32 50       	subi	r19, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    15d2:	80 ea       	ldi	r24, 0xA0	; 160
    15d4:	98 e0       	ldi	r25, 0x08	; 8
    15d6:	43 c0       	rjmp	.+134    	; 0x165e <usart_init_spi+0x20c>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    15d8:	c0 3a       	cpi	r28, 0xA0	; 160
    15da:	f9 e0       	ldi	r31, 0x09	; 9
    15dc:	df 07       	cpc	r29, r31
    15de:	21 f4       	brne	.+8      	; 0x15e8 <usart_init_spi+0x196>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    15e0:	60 e1       	ldi	r22, 0x10	; 16
    15e2:	84 e0       	ldi	r24, 0x04	; 4
    15e4:	40 d9       	rcall	.-3456   	; 0x866 <sysclk_enable_module>
    15e6:	da c0       	rjmp	.+436    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    15e8:	c0 3a       	cpi	r28, 0xA0	; 160
    15ea:	2a e0       	ldi	r18, 0x0A	; 10
    15ec:	d2 07       	cpc	r29, r18
    15ee:	21 f4       	brne	.+8      	; 0x15f8 <usart_init_spi+0x1a6>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    15f0:	60 e1       	ldi	r22, 0x10	; 16
    15f2:	85 e0       	ldi	r24, 0x05	; 5
    15f4:	38 d9       	rcall	.-3472   	; 0x866 <sysclk_enable_module>
    15f6:	d2 c0       	rjmp	.+420    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    15f8:	c0 3a       	cpi	r28, 0xA0	; 160
    15fa:	8b e0       	ldi	r24, 0x0B	; 11
    15fc:	d8 07       	cpc	r29, r24
    15fe:	21 f4       	brne	.+8      	; 0x1608 <usart_init_spi+0x1b6>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1600:	60 e1       	ldi	r22, 0x10	; 16
    1602:	86 e0       	ldi	r24, 0x06	; 6
    1604:	30 d9       	rcall	.-3488   	; 0x866 <sysclk_enable_module>
    1606:	ca c0       	rjmp	.+404    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1608:	c0 3b       	cpi	r28, 0xB0	; 176
    160a:	e8 e0       	ldi	r30, 0x08	; 8
    160c:	de 07       	cpc	r29, r30
    160e:	21 f4       	brne	.+8      	; 0x1618 <usart_init_spi+0x1c6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1610:	60 e2       	ldi	r22, 0x20	; 32
    1612:	83 e0       	ldi	r24, 0x03	; 3
    1614:	28 d9       	rcall	.-3504   	; 0x866 <sysclk_enable_module>
    1616:	c2 c0       	rjmp	.+388    	; 0x179c <usart_init_spi+0x34a>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1618:	c0 3b       	cpi	r28, 0xB0	; 176
    161a:	f9 e0       	ldi	r31, 0x09	; 9
    161c:	df 07       	cpc	r29, r31
    161e:	21 f4       	brne	.+8      	; 0x1628 <usart_init_spi+0x1d6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1620:	60 e2       	ldi	r22, 0x20	; 32
    1622:	84 e0       	ldi	r24, 0x04	; 4
    1624:	20 d9       	rcall	.-3520   	; 0x866 <sysclk_enable_module>
    1626:	ba c0       	rjmp	.+372    	; 0x179c <usart_init_spi+0x34a>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1628:	c0 38       	cpi	r28, 0x80	; 128
    162a:	24 e0       	ldi	r18, 0x04	; 4
    162c:	d2 07       	cpc	r29, r18
    162e:	21 f4       	brne	.+8      	; 0x1638 <usart_init_spi+0x1e6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1630:	60 e4       	ldi	r22, 0x40	; 64
    1632:	83 e0       	ldi	r24, 0x03	; 3
    1634:	18 d9       	rcall	.-3536   	; 0x866 <sysclk_enable_module>
    1636:	b2 c0       	rjmp	.+356    	; 0x179c <usart_init_spi+0x34a>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1638:	c0 3a       	cpi	r28, 0xA0	; 160
    163a:	84 e0       	ldi	r24, 0x04	; 4
    163c:	d8 07       	cpc	r29, r24
    163e:	21 f4       	brne	.+8      	; 0x1648 <usart_init_spi+0x1f6>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1640:	60 e4       	ldi	r22, 0x40	; 64
    1642:	85 e0       	ldi	r24, 0x05	; 5
    1644:	10 d9       	rcall	.-3552   	; 0x866 <sysclk_enable_module>
    1646:	aa c0       	rjmp	.+340    	; 0x179c <usart_init_spi+0x34a>
    1648:	8c 81       	ldd	r24, Y+4	; 0x04
    164a:	8f 7e       	andi	r24, 0xEF	; 239
    164c:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    164e:	fb 01       	movw	r30, r22
    1650:	34 81       	ldd	r19, Z+4	; 0x04
    1652:	32 50       	subi	r19, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1654:	ce 01       	movw	r24, r28
    1656:	c0 3a       	cpi	r28, 0xA0	; 160
    1658:	f8 e0       	ldi	r31, 0x08	; 8
    165a:	df 07       	cpc	r29, r31
    165c:	51 f4       	brne	.+20     	; 0x1672 <usart_init_spi+0x220>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    165e:	e0 e4       	ldi	r30, 0x40	; 64
    1660:	f6 e0       	ldi	r31, 0x06	; 6
    1662:	26 85       	ldd	r18, Z+14	; 0x0e
    1664:	24 fd       	sbrc	r18, 4
    1666:	a2 c0       	rjmp	.+324    	; 0x17ac <usart_init_spi+0x35a>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    1668:	0f 2e       	mov	r0, r31
    166a:	f1 e1       	ldi	r31, 0x11	; 17
    166c:	ff 2e       	mov	r15, r31
    166e:	f0 2d       	mov	r31, r0
    1670:	04 c0       	rjmp	.+8      	; 0x167a <usart_init_spi+0x228>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    1672:	80 3b       	cpi	r24, 0xB0	; 176
    1674:	28 e0       	ldi	r18, 0x08	; 8
    1676:	92 07       	cpc	r25, r18
    1678:	99 f0       	breq	.+38     	; 0x16a0 <usart_init_spi+0x24e>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    167a:	80 3a       	cpi	r24, 0xA0	; 160
    167c:	e9 e0       	ldi	r30, 0x09	; 9
    167e:	9e 07       	cpc	r25, r30
    1680:	51 f4       	brne	.+20     	; 0x1696 <usart_init_spi+0x244>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    1682:	e0 e6       	ldi	r30, 0x60	; 96
    1684:	f6 e0       	ldi	r31, 0x06	; 6
    1686:	26 85       	ldd	r18, Z+14	; 0x0e
    1688:	24 fd       	sbrc	r18, 4
    168a:	95 c0       	rjmp	.+298    	; 0x17b6 <usart_init_spi+0x364>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    168c:	0f 2e       	mov	r0, r31
    168e:	f9 e1       	ldi	r31, 0x19	; 25
    1690:	ff 2e       	mov	r15, r31
    1692:	f0 2d       	mov	r31, r0
    1694:	17 c0       	rjmp	.+46     	; 0x16c4 <usart_init_spi+0x272>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    1696:	80 3b       	cpi	r24, 0xB0	; 176
    1698:	f9 e0       	ldi	r31, 0x09	; 9
    169a:	9f 07       	cpc	r25, r31
    169c:	01 f1       	breq	.+64     	; 0x16de <usart_init_spi+0x28c>
    169e:	04 c0       	rjmp	.+8      	; 0x16a8 <usart_init_spi+0x256>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    16a0:	0f 2e       	mov	r0, r31
    16a2:	f5 e1       	ldi	r31, 0x15	; 21
    16a4:	ff 2e       	mov	r15, r31
    16a6:	f0 2d       	mov	r31, r0
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    16a8:	80 3a       	cpi	r24, 0xA0	; 160
    16aa:	2a e0       	ldi	r18, 0x0A	; 10
    16ac:	92 07       	cpc	r25, r18
    16ae:	51 f4       	brne	.+20     	; 0x16c4 <usart_init_spi+0x272>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    16b0:	e0 e8       	ldi	r30, 0x80	; 128
    16b2:	f6 e0       	ldi	r31, 0x06	; 6
    16b4:	86 85       	ldd	r24, Z+14	; 0x0e
    16b6:	84 fd       	sbrc	r24, 4
    16b8:	83 c0       	rjmp	.+262    	; 0x17c0 <usart_init_spi+0x36e>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    16ba:	0f 2e       	mov	r0, r31
    16bc:	f1 e2       	ldi	r31, 0x21	; 33
    16be:	ff 2e       	mov	r15, r31
    16c0:	f0 2d       	mov	r31, r0
    16c2:	16 c0       	rjmp	.+44     	; 0x16f0 <usart_init_spi+0x29e>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    16c4:	80 3a       	cpi	r24, 0xA0	; 160
    16c6:	9b 40       	sbci	r25, 0x0B	; 11
    16c8:	99 f4       	brne	.+38     	; 0x16f0 <usart_init_spi+0x29e>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    16ca:	e0 ea       	ldi	r30, 0xA0	; 160
    16cc:	f6 e0       	ldi	r31, 0x06	; 6
    16ce:	86 85       	ldd	r24, Z+14	; 0x0e
    16d0:	84 ff       	sbrs	r24, 4
    16d2:	0a c0       	rjmp	.+20     	; 0x16e8 <usart_init_spi+0x296>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    16d4:	0f 2e       	mov	r0, r31
    16d6:	fd e2       	ldi	r31, 0x2D	; 45
    16d8:	ff 2e       	mov	r15, r31
    16da:	f0 2d       	mov	r31, r0
    16dc:	09 c0       	rjmp	.+18     	; 0x16f0 <usart_init_spi+0x29e>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    16de:	0f 2e       	mov	r0, r31
    16e0:	fd e1       	ldi	r31, 0x1D	; 29
    16e2:	ff 2e       	mov	r15, r31
    16e4:	f0 2d       	mov	r31, r0
    16e6:	04 c0       	rjmp	.+8      	; 0x16f0 <usart_init_spi+0x29e>
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    16e8:	0f 2e       	mov	r0, r31
    16ea:	f9 e2       	ldi	r31, 0x29	; 41
    16ec:	ff 2e       	mov	r15, r31
    16ee:	f0 2d       	mov	r31, r0
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    16f0:	af 2d       	mov	r26, r15
    16f2:	a6 95       	lsr	r26
    16f4:	a6 95       	lsr	r26
    16f6:	a6 95       	lsr	r26
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    16f8:	f0 e2       	ldi	r31, 0x20	; 32
    16fa:	af 9f       	mul	r26, r31
    16fc:	d0 01       	movw	r26, r0
    16fe:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    1700:	ba 5f       	subi	r27, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    1702:	2f 2d       	mov	r18, r15
    1704:	27 70       	andi	r18, 0x07	; 7
    1706:	81 e0       	ldi	r24, 0x01	; 1
    1708:	90 e0       	ldi	r25, 0x00	; 0
    170a:	02 2e       	mov	r0, r18
    170c:	02 c0       	rjmp	.+4      	; 0x1712 <usart_init_spi+0x2c0>
    170e:	88 0f       	add	r24, r24
    1710:	99 1f       	adc	r25, r25
    1712:	0a 94       	dec	r0
    1714:	e2 f7       	brpl	.-8      	; 0x170e <usart_init_spi+0x2bc>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    1716:	11 96       	adiw	r26, 0x01	; 1
    1718:	8c 93       	st	X, r24
    171a:	11 97       	sbiw	r26, 0x01	; 1
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    171c:	32 30       	cpi	r19, 0x02	; 2
    171e:	10 f4       	brcc	.+4      	; 0x1724 <usart_init_spi+0x2d2>
    1720:	30 e4       	ldi	r19, 0x40	; 64
    1722:	01 c0       	rjmp	.+2      	; 0x1726 <usart_init_spi+0x2d4>
    1724:	30 e0       	ldi	r19, 0x00	; 0
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    1726:	fd 01       	movw	r30, r26
    1728:	70 96       	adiw	r30, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    172a:	e2 0f       	add	r30, r18
    172c:	f1 1d       	adc	r31, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    172e:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    1730:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    1732:	20 81       	ld	r18, Z
    1734:	27 70       	andi	r18, 0x07	; 7
    1736:	20 83       	st	Z, r18
	*pin_ctrl |= mode;
    1738:	20 81       	ld	r18, Z
    173a:	23 2b       	or	r18, r19
    173c:	20 83       	st	Z, r18
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    173e:	9f bf       	out	0x3f, r25	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1740:	15 96       	adiw	r26, 0x05	; 5
    1742:	8c 93       	st	X, r24
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1744:	8d 81       	ldd	r24, Y+5	; 0x05
    1746:	80 6c       	ori	r24, 0xC0	; 192
    1748:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    174a:	f8 01       	movw	r30, r16
    174c:	84 81       	ldd	r24, Z+4	; 0x04
    174e:	8d 7f       	andi	r24, 0xFD	; 253
    1750:	81 30       	cpi	r24, 0x01	; 1
    1752:	21 f4       	brne	.+8      	; 0x175c <usart_init_spi+0x30a>
		usart->CTRLC |= USART_UCPHA_bm;
    1754:	8d 81       	ldd	r24, Y+5	; 0x05
    1756:	82 60       	ori	r24, 0x02	; 2
    1758:	8d 83       	std	Y+5, r24	; 0x05
    175a:	03 c0       	rjmp	.+6      	; 0x1762 <usart_init_spi+0x310>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    175c:	8d 81       	ldd	r24, Y+5	; 0x05
    175e:	8d 7f       	andi	r24, 0xFD	; 253
    1760:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    1762:	f8 01       	movw	r30, r16
    1764:	85 81       	ldd	r24, Z+5	; 0x05
    1766:	88 23       	and	r24, r24
    1768:	21 f0       	breq	.+8      	; 0x1772 <usart_init_spi+0x320>
		(usart)->CTRLC |= USART_DORD_bm;
    176a:	8d 81       	ldd	r24, Y+5	; 0x05
    176c:	84 60       	ori	r24, 0x04	; 4
    176e:	8d 83       	std	Y+5, r24	; 0x05
    1770:	03 c0       	rjmp	.+6      	; 0x1778 <usart_init_spi+0x326>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    1772:	8d 81       	ldd	r24, Y+5	; 0x05
    1774:	8b 7f       	andi	r24, 0xFB	; 251
    1776:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1778:	f8 01       	movw	r30, r16
    177a:	40 81       	ld	r20, Z
    177c:	51 81       	ldd	r21, Z+1	; 0x01
    177e:	62 81       	ldd	r22, Z+2	; 0x02
    1780:	73 81       	ldd	r23, Z+3	; 0x03
    1782:	00 e8       	ldi	r16, 0x80	; 128
    1784:	14 e8       	ldi	r17, 0x84	; 132
    1786:	2e e1       	ldi	r18, 0x1E	; 30
    1788:	30 e0       	ldi	r19, 0x00	; 0
    178a:	ce 01       	movw	r24, r28
    178c:	30 de       	rcall	.-928    	; 0x13ee <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    178e:	8c 81       	ldd	r24, Y+4	; 0x04
    1790:	88 60       	ori	r24, 0x08	; 8
    1792:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1794:	8c 81       	ldd	r24, Y+4	; 0x04
    1796:	80 61       	ori	r24, 0x10	; 16
    1798:	8c 83       	std	Y+4, r24	; 0x04
    179a:	17 c0       	rjmp	.+46     	; 0x17ca <usart_init_spi+0x378>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    179c:	8c 81       	ldd	r24, Y+4	; 0x04
    179e:	8f 7e       	andi	r24, 0xEF	; 239
    17a0:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    17a2:	f8 01       	movw	r30, r16
    17a4:	34 81       	ldd	r19, Z+4	; 0x04
    17a6:	32 50       	subi	r19, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    17a8:	ce 01       	movw	r24, r28
    17aa:	63 cf       	rjmp	.-314    	; 0x1672 <usart_init_spi+0x220>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    17ac:	0f 2e       	mov	r0, r31
    17ae:	f5 e1       	ldi	r31, 0x15	; 21
    17b0:	ff 2e       	mov	r15, r31
    17b2:	f0 2d       	mov	r31, r0
    17b4:	62 cf       	rjmp	.-316    	; 0x167a <usart_init_spi+0x228>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    17b6:	0f 2e       	mov	r0, r31
    17b8:	fd e1       	ldi	r31, 0x1D	; 29
    17ba:	ff 2e       	mov	r15, r31
    17bc:	f0 2d       	mov	r31, r0
    17be:	82 cf       	rjmp	.-252    	; 0x16c4 <usart_init_spi+0x272>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    17c0:	0f 2e       	mov	r0, r31
    17c2:	f5 e2       	ldi	r31, 0x25	; 37
    17c4:	ff 2e       	mov	r15, r31
    17c6:	f0 2d       	mov	r31, r0
    17c8:	93 cf       	rjmp	.-218    	; 0x16f0 <usart_init_spi+0x29e>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    17ca:	df 91       	pop	r29
    17cc:	cf 91       	pop	r28
    17ce:	1f 91       	pop	r17
    17d0:	0f 91       	pop	r16
    17d2:	ff 90       	pop	r15
    17d4:	08 95       	ret

000017d6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    17d6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    17d8:	03 96       	adiw	r24, 0x03	; 3
    17da:	81 83       	std	Z+1, r24	; 0x01
    17dc:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    17de:	2f ef       	ldi	r18, 0xFF	; 255
    17e0:	3f ef       	ldi	r19, 0xFF	; 255
    17e2:	23 83       	std	Z+3, r18	; 0x03
    17e4:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    17e6:	85 83       	std	Z+5, r24	; 0x05
    17e8:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    17ea:	87 83       	std	Z+7, r24	; 0x07
    17ec:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    17ee:	10 82       	st	Z, r1
    17f0:	08 95       	ret

000017f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    17f2:	fc 01       	movw	r30, r24
    17f4:	10 86       	std	Z+8, r1	; 0x08
    17f6:	11 86       	std	Z+9, r1	; 0x09
    17f8:	08 95       	ret

000017fa <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    17fa:	cf 93       	push	r28
    17fc:	df 93       	push	r29
    17fe:	9c 01       	movw	r18, r24
    1800:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1802:	dc 01       	movw	r26, r24
    1804:	11 96       	adiw	r26, 0x01	; 1
    1806:	cd 91       	ld	r28, X+
    1808:	dc 91       	ld	r29, X
    180a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    180c:	c2 83       	std	Z+2, r28	; 0x02
    180e:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1810:	8c 81       	ldd	r24, Y+4	; 0x04
    1812:	9d 81       	ldd	r25, Y+5	; 0x05
    1814:	84 83       	std	Z+4, r24	; 0x04
    1816:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1818:	8c 81       	ldd	r24, Y+4	; 0x04
    181a:	9d 81       	ldd	r25, Y+5	; 0x05
    181c:	dc 01       	movw	r26, r24
    181e:	12 96       	adiw	r26, 0x02	; 2
    1820:	6d 93       	st	X+, r22
    1822:	7c 93       	st	X, r23
    1824:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    1826:	6c 83       	std	Y+4, r22	; 0x04
    1828:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    182a:	20 87       	std	Z+8, r18	; 0x08
    182c:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    182e:	f9 01       	movw	r30, r18
    1830:	80 81       	ld	r24, Z
    1832:	8f 5f       	subi	r24, 0xFF	; 255
    1834:	80 83       	st	Z, r24
}
    1836:	df 91       	pop	r29
    1838:	cf 91       	pop	r28
    183a:	08 95       	ret

0000183c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    183c:	cf 93       	push	r28
    183e:	df 93       	push	r29
    1840:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1842:	48 81       	ld	r20, Y
    1844:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1846:	4f 3f       	cpi	r20, 0xFF	; 255
    1848:	2f ef       	ldi	r18, 0xFF	; 255
    184a:	52 07       	cpc	r21, r18
    184c:	21 f4       	brne	.+8      	; 0x1856 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    184e:	fc 01       	movw	r30, r24
    1850:	a7 81       	ldd	r26, Z+7	; 0x07
    1852:	b0 85       	ldd	r27, Z+8	; 0x08
    1854:	0d c0       	rjmp	.+26     	; 0x1870 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1856:	dc 01       	movw	r26, r24
    1858:	13 96       	adiw	r26, 0x03	; 3
    185a:	12 96       	adiw	r26, 0x02	; 2
    185c:	ed 91       	ld	r30, X+
    185e:	fc 91       	ld	r31, X
    1860:	13 97       	sbiw	r26, 0x03	; 3
    1862:	20 81       	ld	r18, Z
    1864:	31 81       	ldd	r19, Z+1	; 0x01
    1866:	42 17       	cp	r20, r18
    1868:	53 07       	cpc	r21, r19
    186a:	10 f0       	brcs	.+4      	; 0x1870 <vListInsert+0x34>
    186c:	df 01       	movw	r26, r30
    186e:	f5 cf       	rjmp	.-22     	; 0x185a <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1870:	12 96       	adiw	r26, 0x02	; 2
    1872:	ed 91       	ld	r30, X+
    1874:	fc 91       	ld	r31, X
    1876:	13 97       	sbiw	r26, 0x03	; 3
    1878:	ea 83       	std	Y+2, r30	; 0x02
    187a:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    187c:	c4 83       	std	Z+4, r28	; 0x04
    187e:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1880:	ac 83       	std	Y+4, r26	; 0x04
    1882:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1884:	12 96       	adiw	r26, 0x02	; 2
    1886:	cd 93       	st	X+, r28
    1888:	dc 93       	st	X, r29
    188a:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    188c:	88 87       	std	Y+8, r24	; 0x08
    188e:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1890:	fc 01       	movw	r30, r24
    1892:	20 81       	ld	r18, Z
    1894:	2f 5f       	subi	r18, 0xFF	; 255
    1896:	20 83       	st	Z, r18
}
    1898:	df 91       	pop	r29
    189a:	cf 91       	pop	r28
    189c:	08 95       	ret

0000189e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    189e:	cf 93       	push	r28
    18a0:	df 93       	push	r29
    18a2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    18a4:	a0 85       	ldd	r26, Z+8	; 0x08
    18a6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    18a8:	c2 81       	ldd	r28, Z+2	; 0x02
    18aa:	d3 81       	ldd	r29, Z+3	; 0x03
    18ac:	84 81       	ldd	r24, Z+4	; 0x04
    18ae:	95 81       	ldd	r25, Z+5	; 0x05
    18b0:	8c 83       	std	Y+4, r24	; 0x04
    18b2:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    18b4:	c4 81       	ldd	r28, Z+4	; 0x04
    18b6:	d5 81       	ldd	r29, Z+5	; 0x05
    18b8:	82 81       	ldd	r24, Z+2	; 0x02
    18ba:	93 81       	ldd	r25, Z+3	; 0x03
    18bc:	8a 83       	std	Y+2, r24	; 0x02
    18be:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    18c0:	11 96       	adiw	r26, 0x01	; 1
    18c2:	cd 91       	ld	r28, X+
    18c4:	dc 91       	ld	r29, X
    18c6:	12 97       	sbiw	r26, 0x02	; 2
    18c8:	ce 17       	cp	r28, r30
    18ca:	df 07       	cpc	r29, r31
    18cc:	31 f4       	brne	.+12     	; 0x18da <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    18ce:	8c 81       	ldd	r24, Y+4	; 0x04
    18d0:	9d 81       	ldd	r25, Y+5	; 0x05
    18d2:	11 96       	adiw	r26, 0x01	; 1
    18d4:	8d 93       	st	X+, r24
    18d6:	9c 93       	st	X, r25
    18d8:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    18da:	10 86       	std	Z+8, r1	; 0x08
    18dc:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    18de:	8c 91       	ld	r24, X
    18e0:	81 50       	subi	r24, 0x01	; 1
    18e2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    18e4:	df 91       	pop	r29
    18e6:	cf 91       	pop	r28
    18e8:	08 95       	ret

000018ea <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    18ea:	0f 93       	push	r16
    18ec:	1f 93       	push	r17
    18ee:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    18f0:	71 e1       	ldi	r23, 0x11	; 17
    18f2:	fc 01       	movw	r30, r24
    18f4:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    18f6:	31 97       	sbiw	r30, 0x01	; 1
    18f8:	62 e2       	ldi	r22, 0x22	; 34
    18fa:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    18fc:	31 97       	sbiw	r30, 0x01	; 1
    18fe:	23 e3       	ldi	r18, 0x33	; 51
    1900:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    1902:	22 27       	eor	r18, r18
    1904:	17 fd       	sbrc	r17, 7
    1906:	20 95       	com	r18
    1908:	32 2f       	mov	r19, r18
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    190a:	31 97       	sbiw	r30, 0x01	; 1
    190c:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    190e:	31 97       	sbiw	r30, 0x01	; 1
    1910:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1912:	31 97       	sbiw	r30, 0x01	; 1
    1914:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    1916:	31 97       	sbiw	r30, 0x01	; 1
    1918:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    191a:	31 97       	sbiw	r30, 0x01	; 1
    191c:	20 e8       	ldi	r18, 0x80	; 128
    191e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    1920:	31 97       	sbiw	r30, 0x01	; 1
    1922:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    1924:	31 97       	sbiw	r30, 0x01	; 1
    1926:	22 e0       	ldi	r18, 0x02	; 2
    1928:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    192a:	31 97       	sbiw	r30, 0x01	; 1
    192c:	23 e0       	ldi	r18, 0x03	; 3
    192e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    1930:	31 97       	sbiw	r30, 0x01	; 1
    1932:	24 e0       	ldi	r18, 0x04	; 4
    1934:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    1936:	31 97       	sbiw	r30, 0x01	; 1
    1938:	25 e0       	ldi	r18, 0x05	; 5
    193a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    193c:	31 97       	sbiw	r30, 0x01	; 1
    193e:	26 e0       	ldi	r18, 0x06	; 6
    1940:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    1942:	31 97       	sbiw	r30, 0x01	; 1
    1944:	27 e0       	ldi	r18, 0x07	; 7
    1946:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    1948:	31 97       	sbiw	r30, 0x01	; 1
    194a:	28 e0       	ldi	r18, 0x08	; 8
    194c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    194e:	31 97       	sbiw	r30, 0x01	; 1
    1950:	29 e0       	ldi	r18, 0x09	; 9
    1952:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    1954:	31 97       	sbiw	r30, 0x01	; 1
    1956:	20 e1       	ldi	r18, 0x10	; 16
    1958:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    195a:	31 97       	sbiw	r30, 0x01	; 1
    195c:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    195e:	31 97       	sbiw	r30, 0x01	; 1
    1960:	22 e1       	ldi	r18, 0x12	; 18
    1962:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    1964:	31 97       	sbiw	r30, 0x01	; 1
    1966:	23 e1       	ldi	r18, 0x13	; 19
    1968:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    196a:	31 97       	sbiw	r30, 0x01	; 1
    196c:	24 e1       	ldi	r18, 0x14	; 20
    196e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    1970:	31 97       	sbiw	r30, 0x01	; 1
    1972:	25 e1       	ldi	r18, 0x15	; 21
    1974:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    1976:	31 97       	sbiw	r30, 0x01	; 1
    1978:	26 e1       	ldi	r18, 0x16	; 22
    197a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    197c:	31 97       	sbiw	r30, 0x01	; 1
    197e:	27 e1       	ldi	r18, 0x17	; 23
    1980:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    1982:	31 97       	sbiw	r30, 0x01	; 1
    1984:	28 e1       	ldi	r18, 0x18	; 24
    1986:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    1988:	31 97       	sbiw	r30, 0x01	; 1
    198a:	29 e1       	ldi	r18, 0x19	; 25
    198c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    198e:	31 97       	sbiw	r30, 0x01	; 1
    1990:	20 e2       	ldi	r18, 0x20	; 32
    1992:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    1994:	31 97       	sbiw	r30, 0x01	; 1
    1996:	21 e2       	ldi	r18, 0x21	; 33
    1998:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    199a:	31 97       	sbiw	r30, 0x01	; 1
    199c:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    199e:	31 97       	sbiw	r30, 0x01	; 1
    19a0:	23 e2       	ldi	r18, 0x23	; 35
    19a2:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    19a4:	31 97       	sbiw	r30, 0x01	; 1
    19a6:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    19a8:	31 97       	sbiw	r30, 0x01	; 1
    19aa:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    19ac:	31 97       	sbiw	r30, 0x01	; 1
    19ae:	26 e2       	ldi	r18, 0x26	; 38
    19b0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    19b2:	31 97       	sbiw	r30, 0x01	; 1
    19b4:	27 e2       	ldi	r18, 0x27	; 39
    19b6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    19b8:	31 97       	sbiw	r30, 0x01	; 1
    19ba:	28 e2       	ldi	r18, 0x28	; 40
    19bc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    19be:	31 97       	sbiw	r30, 0x01	; 1
    19c0:	29 e2       	ldi	r18, 0x29	; 41
    19c2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    19c4:	31 97       	sbiw	r30, 0x01	; 1
    19c6:	20 e3       	ldi	r18, 0x30	; 48
    19c8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    19ca:	31 97       	sbiw	r30, 0x01	; 1
    19cc:	21 e3       	ldi	r18, 0x31	; 49
    19ce:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    19d0:	87 97       	sbiw	r24, 0x27	; 39
    19d2:	1f 91       	pop	r17
    19d4:	0f 91       	pop	r16
    19d6:	08 95       	ret

000019d8 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    19d8:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    19da:	e0 e7       	ldi	r30, 0x70	; 112
    19dc:	f0 e0       	ldi	r31, 0x00	; 0
    19de:	83 81       	ldd	r24, Z+3	; 0x03
    19e0:	8a 7f       	andi	r24, 0xFA	; 250
    19e2:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    19e4:	e0 e0       	ldi	r30, 0x00	; 0
    19e6:	f8 e0       	ldi	r31, 0x08	; 8
    19e8:	80 e0       	ldi	r24, 0x00	; 0
    19ea:	9a ef       	ldi	r25, 0xFA	; 250
    19ec:	86 a3       	std	Z+38, r24	; 0x26
    19ee:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    19f0:	81 e0       	ldi	r24, 0x01	; 1
    19f2:	86 83       	std	Z+6, r24	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    19f4:	a0 ea       	ldi	r26, 0xA0	; 160
    19f6:	b0 e0       	ldi	r27, 0x00	; 0
    19f8:	12 96       	adiw	r26, 0x02	; 2
    19fa:	9c 91       	ld	r25, X
    19fc:	12 97       	sbiw	r26, 0x02	; 2
    19fe:	91 60       	ori	r25, 0x01	; 1
    1a00:	12 96       	adiw	r26, 0x02	; 2
    1a02:	9c 93       	st	X, r25

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    1a04:	80 83       	st	Z, r24

    }

    // enable global interrupt
    sei();
    1a06:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    1a08:	a0 91 ac 22 	lds	r26, 0x22AC
    1a0c:	b0 91 ad 22 	lds	r27, 0x22AD
    1a10:	0d 90       	ld	r0, X+
    1a12:	0d be       	out	0x3d, r0	; 61
    1a14:	0d 90       	ld	r0, X+
    1a16:	0e be       	out	0x3e, r0	; 62
    1a18:	ff 91       	pop	r31
    1a1a:	ef 91       	pop	r30
    1a1c:	df 91       	pop	r29
    1a1e:	cf 91       	pop	r28
    1a20:	bf 91       	pop	r27
    1a22:	af 91       	pop	r26
    1a24:	9f 91       	pop	r25
    1a26:	8f 91       	pop	r24
    1a28:	7f 91       	pop	r23
    1a2a:	6f 91       	pop	r22
    1a2c:	5f 91       	pop	r21
    1a2e:	4f 91       	pop	r20
    1a30:	3f 91       	pop	r19
    1a32:	2f 91       	pop	r18
    1a34:	1f 91       	pop	r17
    1a36:	0f 91       	pop	r16
    1a38:	ff 90       	pop	r15
    1a3a:	ef 90       	pop	r14
    1a3c:	df 90       	pop	r13
    1a3e:	cf 90       	pop	r12
    1a40:	bf 90       	pop	r11
    1a42:	af 90       	pop	r10
    1a44:	9f 90       	pop	r9
    1a46:	8f 90       	pop	r8
    1a48:	7f 90       	pop	r7
    1a4a:	6f 90       	pop	r6
    1a4c:	5f 90       	pop	r5
    1a4e:	4f 90       	pop	r4
    1a50:	3f 90       	pop	r3
    1a52:	2f 90       	pop	r2
    1a54:	1f 90       	pop	r1
    1a56:	0f 90       	pop	r0
    1a58:	0f be       	out	0x3f, r0	; 63
    1a5a:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    1a5c:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    1a5e:	08 95       	ret

00001a60 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1a60:	0f 92       	push	r0
    1a62:	0f b6       	in	r0, 0x3f	; 63
    1a64:	f8 94       	cli
    1a66:	0f 92       	push	r0
    1a68:	1f 92       	push	r1
    1a6a:	11 24       	eor	r1, r1
    1a6c:	2f 92       	push	r2
    1a6e:	3f 92       	push	r3
    1a70:	4f 92       	push	r4
    1a72:	5f 92       	push	r5
    1a74:	6f 92       	push	r6
    1a76:	7f 92       	push	r7
    1a78:	8f 92       	push	r8
    1a7a:	9f 92       	push	r9
    1a7c:	af 92       	push	r10
    1a7e:	bf 92       	push	r11
    1a80:	cf 92       	push	r12
    1a82:	df 92       	push	r13
    1a84:	ef 92       	push	r14
    1a86:	ff 92       	push	r15
    1a88:	0f 93       	push	r16
    1a8a:	1f 93       	push	r17
    1a8c:	2f 93       	push	r18
    1a8e:	3f 93       	push	r19
    1a90:	4f 93       	push	r20
    1a92:	5f 93       	push	r21
    1a94:	6f 93       	push	r22
    1a96:	7f 93       	push	r23
    1a98:	8f 93       	push	r24
    1a9a:	9f 93       	push	r25
    1a9c:	af 93       	push	r26
    1a9e:	bf 93       	push	r27
    1aa0:	cf 93       	push	r28
    1aa2:	df 93       	push	r29
    1aa4:	ef 93       	push	r30
    1aa6:	ff 93       	push	r31
    1aa8:	a0 91 ac 22 	lds	r26, 0x22AC
    1aac:	b0 91 ad 22 	lds	r27, 0x22AD
    1ab0:	0d b6       	in	r0, 0x3d	; 61
    1ab2:	0d 92       	st	X+, r0
    1ab4:	0e b6       	in	r0, 0x3e	; 62
    1ab6:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    1ab8:	0e d6       	rcall	.+3100   	; 0x26d6 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    1aba:	a0 91 ac 22 	lds	r26, 0x22AC
    1abe:	b0 91 ad 22 	lds	r27, 0x22AD
    1ac2:	0d 90       	ld	r0, X+
    1ac4:	0d be       	out	0x3d, r0	; 61
    1ac6:	0d 90       	ld	r0, X+
    1ac8:	0e be       	out	0x3e, r0	; 62
    1aca:	ff 91       	pop	r31
    1acc:	ef 91       	pop	r30
    1ace:	df 91       	pop	r29
    1ad0:	cf 91       	pop	r28
    1ad2:	bf 91       	pop	r27
    1ad4:	af 91       	pop	r26
    1ad6:	9f 91       	pop	r25
    1ad8:	8f 91       	pop	r24
    1ada:	7f 91       	pop	r23
    1adc:	6f 91       	pop	r22
    1ade:	5f 91       	pop	r21
    1ae0:	4f 91       	pop	r20
    1ae2:	3f 91       	pop	r19
    1ae4:	2f 91       	pop	r18
    1ae6:	1f 91       	pop	r17
    1ae8:	0f 91       	pop	r16
    1aea:	ff 90       	pop	r15
    1aec:	ef 90       	pop	r14
    1aee:	df 90       	pop	r13
    1af0:	cf 90       	pop	r12
    1af2:	bf 90       	pop	r11
    1af4:	af 90       	pop	r10
    1af6:	9f 90       	pop	r9
    1af8:	8f 90       	pop	r8
    1afa:	7f 90       	pop	r7
    1afc:	6f 90       	pop	r6
    1afe:	5f 90       	pop	r5
    1b00:	4f 90       	pop	r4
    1b02:	3f 90       	pop	r3
    1b04:	2f 90       	pop	r2
    1b06:	1f 90       	pop	r1
    1b08:	0f 90       	pop	r0
    1b0a:	0f be       	out	0x3f, r0	; 63
    1b0c:	0f 90       	pop	r0

    asm volatile ( "ret" );
    1b0e:	08 95       	ret

00001b10 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    1b10:	0f 92       	push	r0
    1b12:	0f b6       	in	r0, 0x3f	; 63
    1b14:	f8 94       	cli
    1b16:	0f 92       	push	r0
    1b18:	1f 92       	push	r1
    1b1a:	11 24       	eor	r1, r1
    1b1c:	2f 92       	push	r2
    1b1e:	3f 92       	push	r3
    1b20:	4f 92       	push	r4
    1b22:	5f 92       	push	r5
    1b24:	6f 92       	push	r6
    1b26:	7f 92       	push	r7
    1b28:	8f 92       	push	r8
    1b2a:	9f 92       	push	r9
    1b2c:	af 92       	push	r10
    1b2e:	bf 92       	push	r11
    1b30:	cf 92       	push	r12
    1b32:	df 92       	push	r13
    1b34:	ef 92       	push	r14
    1b36:	ff 92       	push	r15
    1b38:	0f 93       	push	r16
    1b3a:	1f 93       	push	r17
    1b3c:	2f 93       	push	r18
    1b3e:	3f 93       	push	r19
    1b40:	4f 93       	push	r20
    1b42:	5f 93       	push	r21
    1b44:	6f 93       	push	r22
    1b46:	7f 93       	push	r23
    1b48:	8f 93       	push	r24
    1b4a:	9f 93       	push	r25
    1b4c:	af 93       	push	r26
    1b4e:	bf 93       	push	r27
    1b50:	cf 93       	push	r28
    1b52:	df 93       	push	r29
    1b54:	ef 93       	push	r30
    1b56:	ff 93       	push	r31
    1b58:	a0 91 ac 22 	lds	r26, 0x22AC
    1b5c:	b0 91 ad 22 	lds	r27, 0x22AD
    1b60:	0d b6       	in	r0, 0x3d	; 61
    1b62:	0d 92       	st	X+, r0
    1b64:	0e b6       	in	r0, 0x3e	; 62
    1b66:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    1b68:	48 d4       	rcall	.+2192   	; 0x23fa <xTaskIncrementTick>
    1b6a:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    1b6c:	b4 d5       	rcall	.+2920   	; 0x26d6 <vTaskSwitchContext>
        }
        portRESTORE_CONTEXT();
    1b6e:	a0 91 ac 22 	lds	r26, 0x22AC
    1b72:	b0 91 ad 22 	lds	r27, 0x22AD
    1b76:	0d 90       	ld	r0, X+
    1b78:	0d be       	out	0x3d, r0	; 61
    1b7a:	0d 90       	ld	r0, X+
    1b7c:	0e be       	out	0x3e, r0	; 62
    1b7e:	ff 91       	pop	r31
    1b80:	ef 91       	pop	r30
    1b82:	df 91       	pop	r29
    1b84:	cf 91       	pop	r28
    1b86:	bf 91       	pop	r27
    1b88:	af 91       	pop	r26
    1b8a:	9f 91       	pop	r25
    1b8c:	8f 91       	pop	r24
    1b8e:	7f 91       	pop	r23
    1b90:	6f 91       	pop	r22
    1b92:	5f 91       	pop	r21
    1b94:	4f 91       	pop	r20
    1b96:	3f 91       	pop	r19
    1b98:	2f 91       	pop	r18
    1b9a:	1f 91       	pop	r17
    1b9c:	0f 91       	pop	r16
    1b9e:	ff 90       	pop	r15
    1ba0:	ef 90       	pop	r14
    1ba2:	df 90       	pop	r13
    1ba4:	cf 90       	pop	r12
    1ba6:	bf 90       	pop	r11
    1ba8:	af 90       	pop	r10
    1baa:	9f 90       	pop	r9
    1bac:	8f 90       	pop	r8
    1bae:	7f 90       	pop	r7
    1bb0:	6f 90       	pop	r6
    1bb2:	5f 90       	pop	r5
    1bb4:	4f 90       	pop	r4
    1bb6:	3f 90       	pop	r3
    1bb8:	2f 90       	pop	r2
    1bba:	1f 90       	pop	r1
    1bbc:	0f 90       	pop	r0
    1bbe:	0f be       	out	0x3f, r0	; 63
    1bc0:	0f 90       	pop	r0

        asm volatile ( "reti" );
    1bc2:	18 95       	reti

00001bc4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1bc4:	cf 93       	push	r28
    1bc6:	df 93       	push	r29
    1bc8:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    1bca:	07 d4       	rcall	.+2062   	; 0x23da <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    1bcc:	ce 01       	movw	r24, r28
    1bce:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <malloc>
    1bd2:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1bd4:	e7 d4       	rcall	.+2510   	; 0x25a4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1bd6:	ce 01       	movw	r24, r28
    1bd8:	df 91       	pop	r29
    1bda:	cf 91       	pop	r28
    1bdc:	08 95       	ret

00001bde <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1bde:	cf 93       	push	r28
    1be0:	df 93       	push	r29
    1be2:	ec 01       	movw	r28, r24
	if( pv )
    1be4:	00 97       	sbiw	r24, 0x00	; 0
    1be6:	29 f0       	breq	.+10     	; 0x1bf2 <vPortFree+0x14>
	{
		vTaskSuspendAll();
    1be8:	f8 d3       	rcall	.+2032   	; 0x23da <vTaskSuspendAll>
		{
			free( pv );
    1bea:	ce 01       	movw	r24, r28
    1bec:	0e 94 80 1a 	call	0x3500	; 0x3500 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    1bf0:	d9 d4       	rcall	.+2482   	; 0x25a4 <xTaskResumeAll>
	}
}
    1bf2:	df 91       	pop	r29
    1bf4:	cf 91       	pop	r28
    1bf6:	08 95       	ret

00001bf8 <prvCopyDataToQueue>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1bf8:	1f 93       	push	r17
    1bfa:	cf 93       	push	r28
    1bfc:	df 93       	push	r29
    1bfe:	ec 01       	movw	r28, r24
    1c00:	14 2f       	mov	r17, r20
    1c02:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1c04:	88 23       	and	r24, r24
    1c06:	e9 f1       	breq	.+122    	; 0x1c82 <prvCopyDataToQueue+0x8a>
    1c08:	41 11       	cpse	r20, r1
    1c0a:	17 c0       	rjmp	.+46     	; 0x1c3a <prvCopyDataToQueue+0x42>
    1c0c:	48 2f       	mov	r20, r24
    1c0e:	50 e0       	ldi	r21, 0x00	; 0
    1c10:	8c 81       	ldd	r24, Y+4	; 0x04
    1c12:	9d 81       	ldd	r25, Y+5	; 0x05
    1c14:	0e 94 0f 1b 	call	0x361e	; 0x361e <memcpy>
    1c18:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1c1a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c1c:	9d 81       	ldd	r25, Y+5	; 0x05
    1c1e:	82 0f       	add	r24, r18
    1c20:	91 1d       	adc	r25, r1
    1c22:	8c 83       	std	Y+4, r24	; 0x04
    1c24:	9d 83       	std	Y+5, r25	; 0x05
    1c26:	2a 81       	ldd	r18, Y+2	; 0x02
    1c28:	3b 81       	ldd	r19, Y+3	; 0x03
    1c2a:	82 17       	cp	r24, r18
    1c2c:	93 07       	cpc	r25, r19
    1c2e:	48 f1       	brcs	.+82     	; 0x1c82 <prvCopyDataToQueue+0x8a>
    1c30:	88 81       	ld	r24, Y
    1c32:	99 81       	ldd	r25, Y+1	; 0x01
    1c34:	8c 83       	std	Y+4, r24	; 0x04
    1c36:	9d 83       	std	Y+5, r25	; 0x05
    1c38:	24 c0       	rjmp	.+72     	; 0x1c82 <prvCopyDataToQueue+0x8a>
    1c3a:	48 2f       	mov	r20, r24
    1c3c:	50 e0       	ldi	r21, 0x00	; 0
    1c3e:	8e 81       	ldd	r24, Y+6	; 0x06
    1c40:	9f 81       	ldd	r25, Y+7	; 0x07
    1c42:	0e 94 0f 1b 	call	0x361e	; 0x361e <memcpy>
    1c46:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1c48:	30 e0       	ldi	r19, 0x00	; 0
    1c4a:	31 95       	neg	r19
    1c4c:	21 95       	neg	r18
    1c4e:	31 09       	sbc	r19, r1
    1c50:	8e 81       	ldd	r24, Y+6	; 0x06
    1c52:	9f 81       	ldd	r25, Y+7	; 0x07
    1c54:	82 0f       	add	r24, r18
    1c56:	93 1f       	adc	r25, r19
    1c58:	8e 83       	std	Y+6, r24	; 0x06
    1c5a:	9f 83       	std	Y+7, r25	; 0x07
    1c5c:	68 81       	ld	r22, Y
    1c5e:	79 81       	ldd	r23, Y+1	; 0x01
    1c60:	86 17       	cp	r24, r22
    1c62:	97 07       	cpc	r25, r23
    1c64:	30 f4       	brcc	.+12     	; 0x1c72 <prvCopyDataToQueue+0x7a>
    1c66:	8a 81       	ldd	r24, Y+2	; 0x02
    1c68:	9b 81       	ldd	r25, Y+3	; 0x03
    1c6a:	28 0f       	add	r18, r24
    1c6c:	39 1f       	adc	r19, r25
    1c6e:	2e 83       	std	Y+6, r18	; 0x06
    1c70:	3f 83       	std	Y+7, r19	; 0x07
    1c72:	12 30       	cpi	r17, 0x02	; 2
    1c74:	31 f4       	brne	.+12     	; 0x1c82 <prvCopyDataToQueue+0x8a>
    1c76:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c78:	88 23       	and	r24, r24
    1c7a:	19 f0       	breq	.+6      	; 0x1c82 <prvCopyDataToQueue+0x8a>
    1c7c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c7e:	81 50       	subi	r24, 0x01	; 1
    1c80:	8a 8f       	std	Y+26, r24	; 0x1a
    1c82:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c84:	8f 5f       	subi	r24, 0xFF	; 255
    1c86:	8a 8f       	std	Y+26, r24	; 0x1a
    1c88:	80 e0       	ldi	r24, 0x00	; 0
    1c8a:	df 91       	pop	r29
    1c8c:	cf 91       	pop	r28
    1c8e:	1f 91       	pop	r17
    1c90:	08 95       	ret

00001c92 <prvCopyDataFromQueue>:
    1c92:	fc 01       	movw	r30, r24
    1c94:	cb 01       	movw	r24, r22
    1c96:	44 8d       	ldd	r20, Z+28	; 0x1c
    1c98:	44 23       	and	r20, r20
    1c9a:	a1 f0       	breq	.+40     	; 0x1cc4 <prvCopyDataFromQueue+0x32>
    1c9c:	50 e0       	ldi	r21, 0x00	; 0
    1c9e:	26 81       	ldd	r18, Z+6	; 0x06
    1ca0:	37 81       	ldd	r19, Z+7	; 0x07
    1ca2:	24 0f       	add	r18, r20
    1ca4:	35 1f       	adc	r19, r21
    1ca6:	26 83       	std	Z+6, r18	; 0x06
    1ca8:	37 83       	std	Z+7, r19	; 0x07
    1caa:	62 81       	ldd	r22, Z+2	; 0x02
    1cac:	73 81       	ldd	r23, Z+3	; 0x03
    1cae:	26 17       	cp	r18, r22
    1cb0:	37 07       	cpc	r19, r23
    1cb2:	20 f0       	brcs	.+8      	; 0x1cbc <prvCopyDataFromQueue+0x2a>
    1cb4:	20 81       	ld	r18, Z
    1cb6:	31 81       	ldd	r19, Z+1	; 0x01
    1cb8:	26 83       	std	Z+6, r18	; 0x06
    1cba:	37 83       	std	Z+7, r19	; 0x07
    1cbc:	66 81       	ldd	r22, Z+6	; 0x06
    1cbe:	77 81       	ldd	r23, Z+7	; 0x07
    1cc0:	0c 94 0f 1b 	jmp	0x361e	; 0x361e <memcpy>
    1cc4:	08 95       	ret

00001cc6 <prvUnlockQueue>:
    1cc6:	0f 93       	push	r16
    1cc8:	1f 93       	push	r17
    1cca:	cf 93       	push	r28
    1ccc:	df 93       	push	r29
    1cce:	ec 01       	movw	r28, r24
    1cd0:	0f b6       	in	r0, 0x3f	; 63
    1cd2:	f8 94       	cli
    1cd4:	0f 92       	push	r0
    1cd6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1cd8:	18 16       	cp	r1, r24
    1cda:	a4 f4       	brge	.+40     	; 0x1d04 <prvUnlockQueue+0x3e>
    1cdc:	89 89       	ldd	r24, Y+17	; 0x11
    1cde:	88 23       	and	r24, r24
    1ce0:	89 f0       	breq	.+34     	; 0x1d04 <prvUnlockQueue+0x3e>
    1ce2:	8e 01       	movw	r16, r28
    1ce4:	0f 5e       	subi	r16, 0xEF	; 239
    1ce6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ce8:	03 c0       	rjmp	.+6      	; 0x1cf0 <prvUnlockQueue+0x2a>
    1cea:	89 89       	ldd	r24, Y+17	; 0x11
    1cec:	88 23       	and	r24, r24
    1cee:	51 f0       	breq	.+20     	; 0x1d04 <prvUnlockQueue+0x3e>
    1cf0:	c8 01       	movw	r24, r16
    1cf2:	83 d5       	rcall	.+2822   	; 0x27fa <xTaskRemoveFromEventList>
    1cf4:	81 11       	cpse	r24, r1
    1cf6:	04 d6       	rcall	.+3080   	; 0x2900 <vTaskMissedYield>
    1cf8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1cfa:	81 50       	subi	r24, 0x01	; 1
    1cfc:	8e 8f       	std	Y+30, r24	; 0x1e
    1cfe:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1d00:	18 16       	cp	r1, r24
    1d02:	9c f3       	brlt	.-26     	; 0x1cea <prvUnlockQueue+0x24>
    1d04:	8f ef       	ldi	r24, 0xFF	; 255
    1d06:	8e 8f       	std	Y+30, r24	; 0x1e
    1d08:	0f 90       	pop	r0
    1d0a:	0f be       	out	0x3f, r0	; 63
    1d0c:	0f b6       	in	r0, 0x3f	; 63
    1d0e:	f8 94       	cli
    1d10:	0f 92       	push	r0
    1d12:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d14:	18 16       	cp	r1, r24
    1d16:	a4 f4       	brge	.+40     	; 0x1d40 <prvUnlockQueue+0x7a>
    1d18:	88 85       	ldd	r24, Y+8	; 0x08
    1d1a:	88 23       	and	r24, r24
    1d1c:	89 f0       	breq	.+34     	; 0x1d40 <prvUnlockQueue+0x7a>
    1d1e:	8e 01       	movw	r16, r28
    1d20:	08 5f       	subi	r16, 0xF8	; 248
    1d22:	1f 4f       	sbci	r17, 0xFF	; 255
    1d24:	03 c0       	rjmp	.+6      	; 0x1d2c <prvUnlockQueue+0x66>
    1d26:	88 85       	ldd	r24, Y+8	; 0x08
    1d28:	88 23       	and	r24, r24
    1d2a:	51 f0       	breq	.+20     	; 0x1d40 <prvUnlockQueue+0x7a>
    1d2c:	c8 01       	movw	r24, r16
    1d2e:	65 d5       	rcall	.+2762   	; 0x27fa <xTaskRemoveFromEventList>
    1d30:	81 11       	cpse	r24, r1
    1d32:	e6 d5       	rcall	.+3020   	; 0x2900 <vTaskMissedYield>
    1d34:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d36:	81 50       	subi	r24, 0x01	; 1
    1d38:	8d 8f       	std	Y+29, r24	; 0x1d
    1d3a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d3c:	18 16       	cp	r1, r24
    1d3e:	9c f3       	brlt	.-26     	; 0x1d26 <prvUnlockQueue+0x60>
    1d40:	8f ef       	ldi	r24, 0xFF	; 255
    1d42:	8d 8f       	std	Y+29, r24	; 0x1d
    1d44:	0f 90       	pop	r0
    1d46:	0f be       	out	0x3f, r0	; 63
    1d48:	df 91       	pop	r29
    1d4a:	cf 91       	pop	r28
    1d4c:	1f 91       	pop	r17
    1d4e:	0f 91       	pop	r16
    1d50:	08 95       	ret

00001d52 <xQueueGenericReset>:
    1d52:	cf 93       	push	r28
    1d54:	df 93       	push	r29
    1d56:	ec 01       	movw	r28, r24
    1d58:	0f b6       	in	r0, 0x3f	; 63
    1d5a:	f8 94       	cli
    1d5c:	0f 92       	push	r0
    1d5e:	88 81       	ld	r24, Y
    1d60:	99 81       	ldd	r25, Y+1	; 0x01
    1d62:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1d64:	30 e0       	ldi	r19, 0x00	; 0
    1d66:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1d68:	72 9f       	mul	r23, r18
    1d6a:	a0 01       	movw	r20, r0
    1d6c:	73 9f       	mul	r23, r19
    1d6e:	50 0d       	add	r21, r0
    1d70:	11 24       	eor	r1, r1
    1d72:	fc 01       	movw	r30, r24
    1d74:	e4 0f       	add	r30, r20
    1d76:	f5 1f       	adc	r31, r21
    1d78:	ea 83       	std	Y+2, r30	; 0x02
    1d7a:	fb 83       	std	Y+3, r31	; 0x03
    1d7c:	1a 8e       	std	Y+26, r1	; 0x1a
    1d7e:	8c 83       	std	Y+4, r24	; 0x04
    1d80:	9d 83       	std	Y+5, r25	; 0x05
    1d82:	42 1b       	sub	r20, r18
    1d84:	53 0b       	sbc	r21, r19
    1d86:	84 0f       	add	r24, r20
    1d88:	95 1f       	adc	r25, r21
    1d8a:	8e 83       	std	Y+6, r24	; 0x06
    1d8c:	9f 83       	std	Y+7, r25	; 0x07
    1d8e:	8f ef       	ldi	r24, 0xFF	; 255
    1d90:	8d 8f       	std	Y+29, r24	; 0x1d
    1d92:	8e 8f       	std	Y+30, r24	; 0x1e
    1d94:	61 11       	cpse	r22, r1
    1d96:	0a c0       	rjmp	.+20     	; 0x1dac <xQueueGenericReset+0x5a>
    1d98:	88 85       	ldd	r24, Y+8	; 0x08
    1d9a:	88 23       	and	r24, r24
    1d9c:	69 f0       	breq	.+26     	; 0x1db8 <xQueueGenericReset+0x66>
    1d9e:	ce 01       	movw	r24, r28
    1da0:	08 96       	adiw	r24, 0x08	; 8
    1da2:	2b d5       	rcall	.+2646   	; 0x27fa <xTaskRemoveFromEventList>
    1da4:	81 30       	cpi	r24, 0x01	; 1
    1da6:	41 f4       	brne	.+16     	; 0x1db8 <xQueueGenericReset+0x66>
    1da8:	5b de       	rcall	.-842    	; 0x1a60 <vPortYield>
    1daa:	06 c0       	rjmp	.+12     	; 0x1db8 <xQueueGenericReset+0x66>
    1dac:	ce 01       	movw	r24, r28
    1dae:	08 96       	adiw	r24, 0x08	; 8
    1db0:	12 dd       	rcall	.-1500   	; 0x17d6 <vListInitialise>
    1db2:	ce 01       	movw	r24, r28
    1db4:	41 96       	adiw	r24, 0x11	; 17
    1db6:	0f dd       	rcall	.-1506   	; 0x17d6 <vListInitialise>
    1db8:	0f 90       	pop	r0
    1dba:	0f be       	out	0x3f, r0	; 63
    1dbc:	81 e0       	ldi	r24, 0x01	; 1
    1dbe:	df 91       	pop	r29
    1dc0:	cf 91       	pop	r28
    1dc2:	08 95       	ret

00001dc4 <xQueueGenericCreate>:
    1dc4:	0f 93       	push	r16
    1dc6:	1f 93       	push	r17
    1dc8:	cf 93       	push	r28
    1dca:	df 93       	push	r29
    1dcc:	08 2f       	mov	r16, r24
    1dce:	16 2f       	mov	r17, r22
    1dd0:	66 23       	and	r22, r22
    1dd2:	b9 f0       	breq	.+46     	; 0x1e02 <xQueueGenericCreate+0x3e>
    1dd4:	86 9f       	mul	r24, r22
    1dd6:	c0 01       	movw	r24, r0
    1dd8:	11 24       	eor	r1, r1
    1dda:	80 96       	adiw	r24, 0x20	; 32
    1ddc:	f3 de       	rcall	.-538    	; 0x1bc4 <pvPortMalloc>
    1dde:	ec 01       	movw	r28, r24
    1de0:	00 97       	sbiw	r24, 0x00	; 0
    1de2:	21 f4       	brne	.+8      	; 0x1dec <xQueueGenericCreate+0x28>
    1de4:	14 c0       	rjmp	.+40     	; 0x1e0e <xQueueGenericCreate+0x4a>
    1de6:	c8 83       	st	Y, r28
    1de8:	d9 83       	std	Y+1, r29	; 0x01
    1dea:	05 c0       	rjmp	.+10     	; 0x1df6 <xQueueGenericCreate+0x32>
    1dec:	9c 01       	movw	r18, r24
    1dee:	21 5e       	subi	r18, 0xE1	; 225
    1df0:	3f 4f       	sbci	r19, 0xFF	; 255
    1df2:	28 83       	st	Y, r18
    1df4:	39 83       	std	Y+1, r19	; 0x01
    1df6:	0b 8f       	std	Y+27, r16	; 0x1b
    1df8:	1c 8f       	std	Y+28, r17	; 0x1c
    1dfa:	61 e0       	ldi	r22, 0x01	; 1
    1dfc:	ce 01       	movw	r24, r28
    1dfe:	a9 df       	rcall	.-174    	; 0x1d52 <xQueueGenericReset>
    1e00:	06 c0       	rjmp	.+12     	; 0x1e0e <xQueueGenericCreate+0x4a>
    1e02:	8f e1       	ldi	r24, 0x1F	; 31
    1e04:	90 e0       	ldi	r25, 0x00	; 0
    1e06:	de de       	rcall	.-580    	; 0x1bc4 <pvPortMalloc>
    1e08:	ec 01       	movw	r28, r24
    1e0a:	00 97       	sbiw	r24, 0x00	; 0
    1e0c:	61 f7       	brne	.-40     	; 0x1de6 <xQueueGenericCreate+0x22>
    1e0e:	ce 01       	movw	r24, r28
    1e10:	df 91       	pop	r29
    1e12:	cf 91       	pop	r28
    1e14:	1f 91       	pop	r17
    1e16:	0f 91       	pop	r16
    1e18:	08 95       	ret

00001e1a <xQueueGenericSend>:
    1e1a:	af 92       	push	r10
    1e1c:	bf 92       	push	r11
    1e1e:	cf 92       	push	r12
    1e20:	df 92       	push	r13
    1e22:	ef 92       	push	r14
    1e24:	ff 92       	push	r15
    1e26:	0f 93       	push	r16
    1e28:	1f 93       	push	r17
    1e2a:	cf 93       	push	r28
    1e2c:	df 93       	push	r29
    1e2e:	cd b7       	in	r28, 0x3d	; 61
    1e30:	de b7       	in	r29, 0x3e	; 62
    1e32:	25 97       	sbiw	r28, 0x05	; 5
    1e34:	cd bf       	out	0x3d, r28	; 61
    1e36:	de bf       	out	0x3e, r29	; 62
    1e38:	8c 01       	movw	r16, r24
    1e3a:	6b 01       	movw	r12, r22
    1e3c:	4c 83       	std	Y+4, r20	; 0x04
    1e3e:	5d 83       	std	Y+5, r21	; 0x05
    1e40:	a2 2e       	mov	r10, r18
    1e42:	b1 2c       	mov	r11, r1
    1e44:	7c 01       	movw	r14, r24
    1e46:	88 e0       	ldi	r24, 0x08	; 8
    1e48:	e8 0e       	add	r14, r24
    1e4a:	f1 1c       	adc	r15, r1
    1e4c:	0f b6       	in	r0, 0x3f	; 63
    1e4e:	f8 94       	cli
    1e50:	0f 92       	push	r0
    1e52:	f8 01       	movw	r30, r16
    1e54:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e56:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e58:	98 17       	cp	r25, r24
    1e5a:	18 f0       	brcs	.+6      	; 0x1e62 <xQueueGenericSend+0x48>
    1e5c:	f2 e0       	ldi	r31, 0x02	; 2
    1e5e:	af 12       	cpse	r10, r31
    1e60:	15 c0       	rjmp	.+42     	; 0x1e8c <xQueueGenericSend+0x72>
    1e62:	4a 2d       	mov	r20, r10
    1e64:	b6 01       	movw	r22, r12
    1e66:	c8 01       	movw	r24, r16
    1e68:	c7 de       	rcall	.-626    	; 0x1bf8 <prvCopyDataToQueue>
    1e6a:	f8 01       	movw	r30, r16
    1e6c:	91 89       	ldd	r25, Z+17	; 0x11
    1e6e:	99 23       	and	r25, r25
    1e70:	39 f0       	breq	.+14     	; 0x1e80 <xQueueGenericSend+0x66>
    1e72:	c8 01       	movw	r24, r16
    1e74:	41 96       	adiw	r24, 0x11	; 17
    1e76:	c1 d4       	rcall	.+2434   	; 0x27fa <xTaskRemoveFromEventList>
    1e78:	81 30       	cpi	r24, 0x01	; 1
    1e7a:	21 f4       	brne	.+8      	; 0x1e84 <xQueueGenericSend+0x6a>
    1e7c:	f1 dd       	rcall	.-1054   	; 0x1a60 <vPortYield>
    1e7e:	02 c0       	rjmp	.+4      	; 0x1e84 <xQueueGenericSend+0x6a>
    1e80:	81 11       	cpse	r24, r1
    1e82:	ee dd       	rcall	.-1060   	; 0x1a60 <vPortYield>
    1e84:	0f 90       	pop	r0
    1e86:	0f be       	out	0x3f, r0	; 63
    1e88:	81 e0       	ldi	r24, 0x01	; 1
    1e8a:	47 c0       	rjmp	.+142    	; 0x1f1a <xQueueGenericSend+0x100>
    1e8c:	ec 81       	ldd	r30, Y+4	; 0x04
    1e8e:	fd 81       	ldd	r31, Y+5	; 0x05
    1e90:	ef 2b       	or	r30, r31
    1e92:	21 f4       	brne	.+8      	; 0x1e9c <xQueueGenericSend+0x82>
    1e94:	0f 90       	pop	r0
    1e96:	0f be       	out	0x3f, r0	; 63
    1e98:	80 e0       	ldi	r24, 0x00	; 0
    1e9a:	3f c0       	rjmp	.+126    	; 0x1f1a <xQueueGenericSend+0x100>
    1e9c:	b1 10       	cpse	r11, r1
    1e9e:	05 c0       	rjmp	.+10     	; 0x1eaa <xQueueGenericSend+0x90>
    1ea0:	ce 01       	movw	r24, r28
    1ea2:	01 96       	adiw	r24, 0x01	; 1
    1ea4:	f0 d4       	rcall	.+2528   	; 0x2886 <vTaskSetTimeOutState>
    1ea6:	bb 24       	eor	r11, r11
    1ea8:	b3 94       	inc	r11
    1eaa:	0f 90       	pop	r0
    1eac:	0f be       	out	0x3f, r0	; 63
    1eae:	95 d2       	rcall	.+1322   	; 0x23da <vTaskSuspendAll>
    1eb0:	0f b6       	in	r0, 0x3f	; 63
    1eb2:	f8 94       	cli
    1eb4:	0f 92       	push	r0
    1eb6:	f8 01       	movw	r30, r16
    1eb8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1eba:	8f 3f       	cpi	r24, 0xFF	; 255
    1ebc:	09 f4       	brne	.+2      	; 0x1ec0 <xQueueGenericSend+0xa6>
    1ebe:	15 8e       	std	Z+29, r1	; 0x1d
    1ec0:	f8 01       	movw	r30, r16
    1ec2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ec4:	8f 3f       	cpi	r24, 0xFF	; 255
    1ec6:	09 f4       	brne	.+2      	; 0x1eca <xQueueGenericSend+0xb0>
    1ec8:	16 8e       	std	Z+30, r1	; 0x1e
    1eca:	0f 90       	pop	r0
    1ecc:	0f be       	out	0x3f, r0	; 63
    1ece:	be 01       	movw	r22, r28
    1ed0:	6c 5f       	subi	r22, 0xFC	; 252
    1ed2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed4:	ce 01       	movw	r24, r28
    1ed6:	01 96       	adiw	r24, 0x01	; 1
    1ed8:	e1 d4       	rcall	.+2498   	; 0x289c <xTaskCheckForTimeOut>
    1eda:	81 11       	cpse	r24, r1
    1edc:	1a c0       	rjmp	.+52     	; 0x1f12 <xQueueGenericSend+0xf8>
    1ede:	0f b6       	in	r0, 0x3f	; 63
    1ee0:	f8 94       	cli
    1ee2:	0f 92       	push	r0
    1ee4:	f8 01       	movw	r30, r16
    1ee6:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ee8:	0f 90       	pop	r0
    1eea:	0f be       	out	0x3f, r0	; 63
    1eec:	f8 01       	movw	r30, r16
    1eee:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ef0:	98 13       	cpse	r25, r24
    1ef2:	0b c0       	rjmp	.+22     	; 0x1f0a <xQueueGenericSend+0xf0>
    1ef4:	6c 81       	ldd	r22, Y+4	; 0x04
    1ef6:	7d 81       	ldd	r23, Y+5	; 0x05
    1ef8:	c7 01       	movw	r24, r14
    1efa:	4b d4       	rcall	.+2198   	; 0x2792 <vTaskPlaceOnEventList>
    1efc:	c8 01       	movw	r24, r16
    1efe:	e3 de       	rcall	.-570    	; 0x1cc6 <prvUnlockQueue>
    1f00:	51 d3       	rcall	.+1698   	; 0x25a4 <xTaskResumeAll>
    1f02:	81 11       	cpse	r24, r1
    1f04:	a3 cf       	rjmp	.-186    	; 0x1e4c <xQueueGenericSend+0x32>
    1f06:	ac dd       	rcall	.-1192   	; 0x1a60 <vPortYield>
    1f08:	a1 cf       	rjmp	.-190    	; 0x1e4c <xQueueGenericSend+0x32>
    1f0a:	c8 01       	movw	r24, r16
    1f0c:	dc de       	rcall	.-584    	; 0x1cc6 <prvUnlockQueue>
    1f0e:	4a d3       	rcall	.+1684   	; 0x25a4 <xTaskResumeAll>
    1f10:	9d cf       	rjmp	.-198    	; 0x1e4c <xQueueGenericSend+0x32>
    1f12:	c8 01       	movw	r24, r16
    1f14:	d8 de       	rcall	.-592    	; 0x1cc6 <prvUnlockQueue>
    1f16:	46 d3       	rcall	.+1676   	; 0x25a4 <xTaskResumeAll>
    1f18:	80 e0       	ldi	r24, 0x00	; 0
    1f1a:	25 96       	adiw	r28, 0x05	; 5
    1f1c:	cd bf       	out	0x3d, r28	; 61
    1f1e:	de bf       	out	0x3e, r29	; 62
    1f20:	df 91       	pop	r29
    1f22:	cf 91       	pop	r28
    1f24:	1f 91       	pop	r17
    1f26:	0f 91       	pop	r16
    1f28:	ff 90       	pop	r15
    1f2a:	ef 90       	pop	r14
    1f2c:	df 90       	pop	r13
    1f2e:	cf 90       	pop	r12
    1f30:	bf 90       	pop	r11
    1f32:	af 90       	pop	r10
    1f34:	08 95       	ret

00001f36 <xQueueGenericSendFromISR>:
    1f36:	0f 93       	push	r16
    1f38:	1f 93       	push	r17
    1f3a:	cf 93       	push	r28
    1f3c:	df 93       	push	r29
    1f3e:	ec 01       	movw	r28, r24
    1f40:	8a 01       	movw	r16, r20
    1f42:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1f44:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1f46:	98 17       	cp	r25, r24
    1f48:	10 f0       	brcs	.+4      	; 0x1f4e <xQueueGenericSendFromISR+0x18>
    1f4a:	22 30       	cpi	r18, 0x02	; 2
    1f4c:	d1 f4       	brne	.+52     	; 0x1f82 <xQueueGenericSendFromISR+0x4c>
    1f4e:	42 2f       	mov	r20, r18
    1f50:	ce 01       	movw	r24, r28
    1f52:	52 de       	rcall	.-860    	; 0x1bf8 <prvCopyDataToQueue>
    1f54:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f56:	8f 3f       	cpi	r24, 0xFF	; 255
    1f58:	79 f4       	brne	.+30     	; 0x1f78 <xQueueGenericSendFromISR+0x42>
    1f5a:	89 89       	ldd	r24, Y+17	; 0x11
    1f5c:	88 23       	and	r24, r24
    1f5e:	99 f0       	breq	.+38     	; 0x1f86 <xQueueGenericSendFromISR+0x50>
    1f60:	ce 01       	movw	r24, r28
    1f62:	41 96       	adiw	r24, 0x11	; 17
    1f64:	4a d4       	rcall	.+2196   	; 0x27fa <xTaskRemoveFromEventList>
    1f66:	88 23       	and	r24, r24
    1f68:	81 f0       	breq	.+32     	; 0x1f8a <xQueueGenericSendFromISR+0x54>
    1f6a:	01 15       	cp	r16, r1
    1f6c:	11 05       	cpc	r17, r1
    1f6e:	79 f0       	breq	.+30     	; 0x1f8e <xQueueGenericSendFromISR+0x58>
    1f70:	81 e0       	ldi	r24, 0x01	; 1
    1f72:	f8 01       	movw	r30, r16
    1f74:	80 83       	st	Z, r24
    1f76:	0c c0       	rjmp	.+24     	; 0x1f90 <xQueueGenericSendFromISR+0x5a>
    1f78:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f7a:	8f 5f       	subi	r24, 0xFF	; 255
    1f7c:	8e 8f       	std	Y+30, r24	; 0x1e
    1f7e:	81 e0       	ldi	r24, 0x01	; 1
    1f80:	07 c0       	rjmp	.+14     	; 0x1f90 <xQueueGenericSendFromISR+0x5a>
    1f82:	80 e0       	ldi	r24, 0x00	; 0
    1f84:	05 c0       	rjmp	.+10     	; 0x1f90 <xQueueGenericSendFromISR+0x5a>
    1f86:	81 e0       	ldi	r24, 0x01	; 1
    1f88:	03 c0       	rjmp	.+6      	; 0x1f90 <xQueueGenericSendFromISR+0x5a>
    1f8a:	81 e0       	ldi	r24, 0x01	; 1
    1f8c:	01 c0       	rjmp	.+2      	; 0x1f90 <xQueueGenericSendFromISR+0x5a>
    1f8e:	81 e0       	ldi	r24, 0x01	; 1
    1f90:	df 91       	pop	r29
    1f92:	cf 91       	pop	r28
    1f94:	1f 91       	pop	r17
    1f96:	0f 91       	pop	r16
    1f98:	08 95       	ret

00001f9a <xQueueGenericReceive>:
    1f9a:	af 92       	push	r10
    1f9c:	bf 92       	push	r11
    1f9e:	cf 92       	push	r12
    1fa0:	df 92       	push	r13
    1fa2:	ef 92       	push	r14
    1fa4:	ff 92       	push	r15
    1fa6:	0f 93       	push	r16
    1fa8:	1f 93       	push	r17
    1faa:	cf 93       	push	r28
    1fac:	df 93       	push	r29
    1fae:	cd b7       	in	r28, 0x3d	; 61
    1fb0:	de b7       	in	r29, 0x3e	; 62
    1fb2:	25 97       	sbiw	r28, 0x05	; 5
    1fb4:	cd bf       	out	0x3d, r28	; 61
    1fb6:	de bf       	out	0x3e, r29	; 62
    1fb8:	8c 01       	movw	r16, r24
    1fba:	6b 01       	movw	r12, r22
    1fbc:	4c 83       	std	Y+4, r20	; 0x04
    1fbe:	5d 83       	std	Y+5, r21	; 0x05
    1fc0:	b2 2e       	mov	r11, r18
    1fc2:	a1 2c       	mov	r10, r1
    1fc4:	7c 01       	movw	r14, r24
    1fc6:	81 e1       	ldi	r24, 0x11	; 17
    1fc8:	e8 0e       	add	r14, r24
    1fca:	f1 1c       	adc	r15, r1
    1fcc:	0f b6       	in	r0, 0x3f	; 63
    1fce:	f8 94       	cli
    1fd0:	0f 92       	push	r0
    1fd2:	f8 01       	movw	r30, r16
    1fd4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fd6:	88 23       	and	r24, r24
    1fd8:	21 f1       	breq	.+72     	; 0x2022 <xQueueGenericReceive+0x88>
    1fda:	e6 80       	ldd	r14, Z+6	; 0x06
    1fdc:	f7 80       	ldd	r15, Z+7	; 0x07
    1fde:	b6 01       	movw	r22, r12
    1fe0:	c8 01       	movw	r24, r16
    1fe2:	57 de       	rcall	.-850    	; 0x1c92 <prvCopyDataFromQueue>
    1fe4:	b1 10       	cpse	r11, r1
    1fe6:	0e c0       	rjmp	.+28     	; 0x2004 <xQueueGenericReceive+0x6a>
    1fe8:	f8 01       	movw	r30, r16
    1fea:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fec:	81 50       	subi	r24, 0x01	; 1
    1fee:	82 8f       	std	Z+26, r24	; 0x1a
    1ff0:	80 85       	ldd	r24, Z+8	; 0x08
    1ff2:	88 23       	and	r24, r24
    1ff4:	91 f0       	breq	.+36     	; 0x201a <xQueueGenericReceive+0x80>
    1ff6:	c8 01       	movw	r24, r16
    1ff8:	08 96       	adiw	r24, 0x08	; 8
    1ffa:	ff d3       	rcall	.+2046   	; 0x27fa <xTaskRemoveFromEventList>
    1ffc:	81 30       	cpi	r24, 0x01	; 1
    1ffe:	69 f4       	brne	.+26     	; 0x201a <xQueueGenericReceive+0x80>
    2000:	2f dd       	rcall	.-1442   	; 0x1a60 <vPortYield>
    2002:	0b c0       	rjmp	.+22     	; 0x201a <xQueueGenericReceive+0x80>
    2004:	f8 01       	movw	r30, r16
    2006:	e6 82       	std	Z+6, r14	; 0x06
    2008:	f7 82       	std	Z+7, r15	; 0x07
    200a:	81 89       	ldd	r24, Z+17	; 0x11
    200c:	88 23       	and	r24, r24
    200e:	29 f0       	breq	.+10     	; 0x201a <xQueueGenericReceive+0x80>
    2010:	c8 01       	movw	r24, r16
    2012:	41 96       	adiw	r24, 0x11	; 17
    2014:	f2 d3       	rcall	.+2020   	; 0x27fa <xTaskRemoveFromEventList>
    2016:	81 11       	cpse	r24, r1
    2018:	23 dd       	rcall	.-1466   	; 0x1a60 <vPortYield>
    201a:	0f 90       	pop	r0
    201c:	0f be       	out	0x3f, r0	; 63
    201e:	81 e0       	ldi	r24, 0x01	; 1
    2020:	45 c0       	rjmp	.+138    	; 0x20ac <xQueueGenericReceive+0x112>
    2022:	4c 81       	ldd	r20, Y+4	; 0x04
    2024:	5d 81       	ldd	r21, Y+5	; 0x05
    2026:	45 2b       	or	r20, r21
    2028:	21 f4       	brne	.+8      	; 0x2032 <xQueueGenericReceive+0x98>
    202a:	0f 90       	pop	r0
    202c:	0f be       	out	0x3f, r0	; 63
    202e:	80 e0       	ldi	r24, 0x00	; 0
    2030:	3d c0       	rjmp	.+122    	; 0x20ac <xQueueGenericReceive+0x112>
    2032:	a1 10       	cpse	r10, r1
    2034:	05 c0       	rjmp	.+10     	; 0x2040 <xQueueGenericReceive+0xa6>
    2036:	ce 01       	movw	r24, r28
    2038:	01 96       	adiw	r24, 0x01	; 1
    203a:	25 d4       	rcall	.+2122   	; 0x2886 <vTaskSetTimeOutState>
    203c:	aa 24       	eor	r10, r10
    203e:	a3 94       	inc	r10
    2040:	0f 90       	pop	r0
    2042:	0f be       	out	0x3f, r0	; 63
    2044:	ca d1       	rcall	.+916    	; 0x23da <vTaskSuspendAll>
    2046:	0f b6       	in	r0, 0x3f	; 63
    2048:	f8 94       	cli
    204a:	0f 92       	push	r0
    204c:	f8 01       	movw	r30, r16
    204e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2050:	8f 3f       	cpi	r24, 0xFF	; 255
    2052:	09 f4       	brne	.+2      	; 0x2056 <xQueueGenericReceive+0xbc>
    2054:	15 8e       	std	Z+29, r1	; 0x1d
    2056:	f8 01       	movw	r30, r16
    2058:	86 8d       	ldd	r24, Z+30	; 0x1e
    205a:	8f 3f       	cpi	r24, 0xFF	; 255
    205c:	09 f4       	brne	.+2      	; 0x2060 <xQueueGenericReceive+0xc6>
    205e:	16 8e       	std	Z+30, r1	; 0x1e
    2060:	0f 90       	pop	r0
    2062:	0f be       	out	0x3f, r0	; 63
    2064:	be 01       	movw	r22, r28
    2066:	6c 5f       	subi	r22, 0xFC	; 252
    2068:	7f 4f       	sbci	r23, 0xFF	; 255
    206a:	ce 01       	movw	r24, r28
    206c:	01 96       	adiw	r24, 0x01	; 1
    206e:	16 d4       	rcall	.+2092   	; 0x289c <xTaskCheckForTimeOut>
    2070:	81 11       	cpse	r24, r1
    2072:	18 c0       	rjmp	.+48     	; 0x20a4 <xQueueGenericReceive+0x10a>
    2074:	0f b6       	in	r0, 0x3f	; 63
    2076:	f8 94       	cli
    2078:	0f 92       	push	r0
    207a:	f8 01       	movw	r30, r16
    207c:	82 8d       	ldd	r24, Z+26	; 0x1a
    207e:	0f 90       	pop	r0
    2080:	0f be       	out	0x3f, r0	; 63
    2082:	81 11       	cpse	r24, r1
    2084:	0b c0       	rjmp	.+22     	; 0x209c <xQueueGenericReceive+0x102>
    2086:	6c 81       	ldd	r22, Y+4	; 0x04
    2088:	7d 81       	ldd	r23, Y+5	; 0x05
    208a:	c7 01       	movw	r24, r14
    208c:	82 d3       	rcall	.+1796   	; 0x2792 <vTaskPlaceOnEventList>
    208e:	c8 01       	movw	r24, r16
    2090:	1a de       	rcall	.-972    	; 0x1cc6 <prvUnlockQueue>
    2092:	88 d2       	rcall	.+1296   	; 0x25a4 <xTaskResumeAll>
    2094:	81 11       	cpse	r24, r1
    2096:	9a cf       	rjmp	.-204    	; 0x1fcc <xQueueGenericReceive+0x32>
    2098:	e3 dc       	rcall	.-1594   	; 0x1a60 <vPortYield>
    209a:	98 cf       	rjmp	.-208    	; 0x1fcc <xQueueGenericReceive+0x32>
    209c:	c8 01       	movw	r24, r16
    209e:	13 de       	rcall	.-986    	; 0x1cc6 <prvUnlockQueue>
    20a0:	81 d2       	rcall	.+1282   	; 0x25a4 <xTaskResumeAll>
    20a2:	94 cf       	rjmp	.-216    	; 0x1fcc <xQueueGenericReceive+0x32>
    20a4:	c8 01       	movw	r24, r16
    20a6:	0f de       	rcall	.-994    	; 0x1cc6 <prvUnlockQueue>
    20a8:	7d d2       	rcall	.+1274   	; 0x25a4 <xTaskResumeAll>
    20aa:	80 e0       	ldi	r24, 0x00	; 0
    20ac:	25 96       	adiw	r28, 0x05	; 5
    20ae:	cd bf       	out	0x3d, r28	; 61
    20b0:	de bf       	out	0x3e, r29	; 62
    20b2:	df 91       	pop	r29
    20b4:	cf 91       	pop	r28
    20b6:	1f 91       	pop	r17
    20b8:	0f 91       	pop	r16
    20ba:	ff 90       	pop	r15
    20bc:	ef 90       	pop	r14
    20be:	df 90       	pop	r13
    20c0:	cf 90       	pop	r12
    20c2:	bf 90       	pop	r11
    20c4:	af 90       	pop	r10
    20c6:	08 95       	ret

000020c8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    20c8:	cf 93       	push	r28
    20ca:	df 93       	push	r29
    20cc:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    20ce:	0f b6       	in	r0, 0x3f	; 63
    20d0:	f8 94       	cli
    20d2:	0f 92       	push	r0
    20d4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    20d6:	8f 3f       	cpi	r24, 0xFF	; 255
    20d8:	09 f4       	brne	.+2      	; 0x20dc <vQueueWaitForMessageRestricted+0x14>
    20da:	1d 8e       	std	Y+29, r1	; 0x1d
    20dc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    20de:	8f 3f       	cpi	r24, 0xFF	; 255
    20e0:	09 f4       	brne	.+2      	; 0x20e4 <vQueueWaitForMessageRestricted+0x1c>
    20e2:	1e 8e       	std	Y+30, r1	; 0x1e
    20e4:	0f 90       	pop	r0
    20e6:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    20e8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    20ea:	81 11       	cpse	r24, r1
    20ec:	03 c0       	rjmp	.+6      	; 0x20f4 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    20ee:	ce 01       	movw	r24, r28
    20f0:	41 96       	adiw	r24, 0x11	; 17
    20f2:	69 d3       	rcall	.+1746   	; 0x27c6 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    20f4:	ce 01       	movw	r24, r28
    20f6:	e7 dd       	rcall	.-1074   	; 0x1cc6 <prvUnlockQueue>
	}
    20f8:	df 91       	pop	r29
    20fa:	cf 91       	pop	r28
    20fc:	08 95       	ret

000020fe <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    20fe:	cf e7       	ldi	r28, 0x7F	; 127
    2100:	d2 e2       	ldi	r29, 0x22	; 34
    2102:	88 81       	ld	r24, Y
    2104:	82 30       	cpi	r24, 0x02	; 2
    2106:	08 f4       	brcc	.+2      	; 0x210a <prvIdleTask+0xc>
    2108:	ff cf       	rjmp	.-2      	; 0x2108 <prvIdleTask+0xa>
    210a:	aa dc       	rcall	.-1708   	; 0x1a60 <vPortYield>
    210c:	fa cf       	rjmp	.-12     	; 0x2102 <prvIdleTask+0x4>

0000210e <prvAddCurrentTaskToDelayedList>:
    210e:	cf 93       	push	r28
    2110:	df 93       	push	r29
    2112:	ec 01       	movw	r28, r24
    2114:	e0 91 ac 22 	lds	r30, 0x22AC
    2118:	f0 91 ad 22 	lds	r31, 0x22AD
    211c:	82 83       	std	Z+2, r24	; 0x02
    211e:	93 83       	std	Z+3, r25	; 0x03
    2120:	80 91 5d 22 	lds	r24, 0x225D
    2124:	90 91 5e 22 	lds	r25, 0x225E
    2128:	c8 17       	cp	r28, r24
    212a:	d9 07       	cpc	r29, r25
    212c:	60 f4       	brcc	.+24     	; 0x2146 <prvAddCurrentTaskToDelayedList+0x38>
    212e:	60 91 ac 22 	lds	r22, 0x22AC
    2132:	70 91 ad 22 	lds	r23, 0x22AD
    2136:	80 91 69 22 	lds	r24, 0x2269
    213a:	90 91 6a 22 	lds	r25, 0x226A
    213e:	6e 5f       	subi	r22, 0xFE	; 254
    2140:	7f 4f       	sbci	r23, 0xFF	; 255
    2142:	7c db       	rcall	.-2312   	; 0x183c <vListInsert>
    2144:	16 c0       	rjmp	.+44     	; 0x2172 <prvAddCurrentTaskToDelayedList+0x64>
    2146:	60 91 ac 22 	lds	r22, 0x22AC
    214a:	70 91 ad 22 	lds	r23, 0x22AD
    214e:	80 91 6b 22 	lds	r24, 0x226B
    2152:	90 91 6c 22 	lds	r25, 0x226C
    2156:	6e 5f       	subi	r22, 0xFE	; 254
    2158:	7f 4f       	sbci	r23, 0xFF	; 255
    215a:	70 db       	rcall	.-2336   	; 0x183c <vListInsert>
    215c:	80 91 55 22 	lds	r24, 0x2255
    2160:	90 91 56 22 	lds	r25, 0x2256
    2164:	c8 17       	cp	r28, r24
    2166:	d9 07       	cpc	r29, r25
    2168:	20 f4       	brcc	.+8      	; 0x2172 <prvAddCurrentTaskToDelayedList+0x64>
    216a:	c0 93 55 22 	sts	0x2255, r28
    216e:	d0 93 56 22 	sts	0x2256, r29
    2172:	df 91       	pop	r29
    2174:	cf 91       	pop	r28
    2176:	08 95       	ret

00002178 <xTaskGenericCreate>:
    2178:	4f 92       	push	r4
    217a:	5f 92       	push	r5
    217c:	6f 92       	push	r6
    217e:	7f 92       	push	r7
    2180:	8f 92       	push	r8
    2182:	9f 92       	push	r9
    2184:	af 92       	push	r10
    2186:	bf 92       	push	r11
    2188:	cf 92       	push	r12
    218a:	df 92       	push	r13
    218c:	ef 92       	push	r14
    218e:	ff 92       	push	r15
    2190:	0f 93       	push	r16
    2192:	1f 93       	push	r17
    2194:	cf 93       	push	r28
    2196:	df 93       	push	r29
    2198:	4c 01       	movw	r8, r24
    219a:	5b 01       	movw	r10, r22
    219c:	2a 01       	movw	r4, r20
    219e:	39 01       	movw	r6, r18
    21a0:	c1 14       	cp	r12, r1
    21a2:	d1 04       	cpc	r13, r1
    21a4:	31 f4       	brne	.+12     	; 0x21b2 <xTaskGenericCreate+0x3a>
    21a6:	ca 01       	movw	r24, r20
    21a8:	0d dd       	rcall	.-1510   	; 0x1bc4 <pvPortMalloc>
    21aa:	6c 01       	movw	r12, r24
    21ac:	00 97       	sbiw	r24, 0x00	; 0
    21ae:	09 f4       	brne	.+2      	; 0x21b2 <xTaskGenericCreate+0x3a>
    21b0:	cf c0       	rjmp	.+414    	; 0x2350 <xTaskGenericCreate+0x1d8>
    21b2:	86 e2       	ldi	r24, 0x26	; 38
    21b4:	90 e0       	ldi	r25, 0x00	; 0
    21b6:	06 dd       	rcall	.-1524   	; 0x1bc4 <pvPortMalloc>
    21b8:	ec 01       	movw	r28, r24
    21ba:	00 97       	sbiw	r24, 0x00	; 0
    21bc:	71 f0       	breq	.+28     	; 0x21da <xTaskGenericCreate+0x62>
    21be:	cf 8a       	std	Y+23, r12	; 0x17
    21c0:	d8 8e       	std	Y+24, r13	; 0x18
    21c2:	81 e0       	ldi	r24, 0x01	; 1
    21c4:	48 1a       	sub	r4, r24
    21c6:	51 08       	sbc	r5, r1
    21c8:	c4 0c       	add	r12, r4
    21ca:	d5 1c       	adc	r13, r5
    21cc:	d5 01       	movw	r26, r10
    21ce:	8c 91       	ld	r24, X
    21d0:	89 8f       	std	Y+25, r24	; 0x19
    21d2:	8c 91       	ld	r24, X
    21d4:	81 11       	cpse	r24, r1
    21d6:	04 c0       	rjmp	.+8      	; 0x21e0 <xTaskGenericCreate+0x68>
    21d8:	14 c0       	rjmp	.+40     	; 0x2202 <xTaskGenericCreate+0x8a>
    21da:	c6 01       	movw	r24, r12
    21dc:	00 dd       	rcall	.-1536   	; 0x1bde <vPortFree>
    21de:	b8 c0       	rjmp	.+368    	; 0x2350 <xTaskGenericCreate+0x1d8>
    21e0:	ae 01       	movw	r20, r28
    21e2:	46 5e       	subi	r20, 0xE6	; 230
    21e4:	5f 4f       	sbci	r21, 0xFF	; 255
    21e6:	f5 01       	movw	r30, r10
    21e8:	31 96       	adiw	r30, 0x01	; 1
    21ea:	27 e0       	ldi	r18, 0x07	; 7
    21ec:	cf 01       	movw	r24, r30
    21ee:	31 91       	ld	r19, Z+
    21f0:	da 01       	movw	r26, r20
    21f2:	3d 93       	st	X+, r19
    21f4:	ad 01       	movw	r20, r26
    21f6:	dc 01       	movw	r26, r24
    21f8:	8c 91       	ld	r24, X
    21fa:	88 23       	and	r24, r24
    21fc:	11 f0       	breq	.+4      	; 0x2202 <xTaskGenericCreate+0x8a>
    21fe:	21 50       	subi	r18, 0x01	; 1
    2200:	a9 f7       	brne	.-22     	; 0x21ec <xTaskGenericCreate+0x74>
    2202:	18 a2       	std	Y+32, r1	; 0x20
    2204:	10 2f       	mov	r17, r16
    2206:	05 30       	cpi	r16, 0x05	; 5
    2208:	08 f0       	brcs	.+2      	; 0x220c <xTaskGenericCreate+0x94>
    220a:	14 e0       	ldi	r17, 0x04	; 4
    220c:	1e 8b       	std	Y+22, r17	; 0x16
    220e:	5e 01       	movw	r10, r28
    2210:	b2 e0       	ldi	r27, 0x02	; 2
    2212:	ab 0e       	add	r10, r27
    2214:	b1 1c       	adc	r11, r1
    2216:	c5 01       	movw	r24, r10
    2218:	ec da       	rcall	.-2600   	; 0x17f2 <vListInitialiseItem>
    221a:	ce 01       	movw	r24, r28
    221c:	0c 96       	adiw	r24, 0x0c	; 12
    221e:	e9 da       	rcall	.-2606   	; 0x17f2 <vListInitialiseItem>
    2220:	c8 87       	std	Y+8, r28	; 0x08
    2222:	d9 87       	std	Y+9, r29	; 0x09
    2224:	85 e0       	ldi	r24, 0x05	; 5
    2226:	90 e0       	ldi	r25, 0x00	; 0
    2228:	81 1b       	sub	r24, r17
    222a:	91 09       	sbc	r25, r1
    222c:	8c 87       	std	Y+12, r24	; 0x0c
    222e:	9d 87       	std	Y+13, r25	; 0x0d
    2230:	ca 8b       	std	Y+18, r28	; 0x12
    2232:	db 8b       	std	Y+19, r29	; 0x13
    2234:	19 a2       	std	Y+33, r1	; 0x21
    2236:	1a a2       	std	Y+34, r1	; 0x22
    2238:	1b a2       	std	Y+35, r1	; 0x23
    223a:	1c a2       	std	Y+36, r1	; 0x24
    223c:	1d a2       	std	Y+37, r1	; 0x25
    223e:	a3 01       	movw	r20, r6
    2240:	b4 01       	movw	r22, r8
    2242:	c6 01       	movw	r24, r12
    2244:	52 db       	rcall	.-2396   	; 0x18ea <pxPortInitialiseStack>
    2246:	88 83       	st	Y, r24
    2248:	99 83       	std	Y+1, r25	; 0x01
    224a:	e1 14       	cp	r14, r1
    224c:	f1 04       	cpc	r15, r1
    224e:	19 f0       	breq	.+6      	; 0x2256 <xTaskGenericCreate+0xde>
    2250:	f7 01       	movw	r30, r14
    2252:	c0 83       	st	Z, r28
    2254:	d1 83       	std	Z+1, r29	; 0x01
    2256:	0f b6       	in	r0, 0x3f	; 63
    2258:	f8 94       	cli
    225a:	0f 92       	push	r0
    225c:	80 91 5f 22 	lds	r24, 0x225F
    2260:	8f 5f       	subi	r24, 0xFF	; 255
    2262:	80 93 5f 22 	sts	0x225F, r24
    2266:	80 91 ac 22 	lds	r24, 0x22AC
    226a:	90 91 ad 22 	lds	r25, 0x22AD
    226e:	89 2b       	or	r24, r25
    2270:	91 f5       	brne	.+100    	; 0x22d6 <xTaskGenericCreate+0x15e>
    2272:	c0 93 ac 22 	sts	0x22AC, r28
    2276:	d0 93 ad 22 	sts	0x22AD, r29
    227a:	80 91 5f 22 	lds	r24, 0x225F
    227e:	81 30       	cpi	r24, 0x01	; 1
    2280:	c9 f5       	brne	.+114    	; 0x22f4 <xTaskGenericCreate+0x17c>
    2282:	0f 2e       	mov	r0, r31
    2284:	ff e7       	ldi	r31, 0x7F	; 127
    2286:	ef 2e       	mov	r14, r31
    2288:	f2 e2       	ldi	r31, 0x22	; 34
    228a:	ff 2e       	mov	r15, r31
    228c:	f0 2d       	mov	r31, r0
    228e:	0f 2e       	mov	r0, r31
    2290:	fc ea       	ldi	r31, 0xAC	; 172
    2292:	cf 2e       	mov	r12, r31
    2294:	f2 e2       	ldi	r31, 0x22	; 34
    2296:	df 2e       	mov	r13, r31
    2298:	f0 2d       	mov	r31, r0
    229a:	c7 01       	movw	r24, r14
    229c:	9c da       	rcall	.-2760   	; 0x17d6 <vListInitialise>
    229e:	f9 e0       	ldi	r31, 0x09	; 9
    22a0:	ef 0e       	add	r14, r31
    22a2:	f1 1c       	adc	r15, r1
    22a4:	ec 14       	cp	r14, r12
    22a6:	fd 04       	cpc	r15, r13
    22a8:	c1 f7       	brne	.-16     	; 0x229a <xTaskGenericCreate+0x122>
    22aa:	86 e7       	ldi	r24, 0x76	; 118
    22ac:	92 e2       	ldi	r25, 0x22	; 34
    22ae:	93 da       	rcall	.-2778   	; 0x17d6 <vListInitialise>
    22b0:	8d e6       	ldi	r24, 0x6D	; 109
    22b2:	92 e2       	ldi	r25, 0x22	; 34
    22b4:	90 da       	rcall	.-2784   	; 0x17d6 <vListInitialise>
    22b6:	80 e6       	ldi	r24, 0x60	; 96
    22b8:	92 e2       	ldi	r25, 0x22	; 34
    22ba:	8d da       	rcall	.-2790   	; 0x17d6 <vListInitialise>
    22bc:	86 e7       	ldi	r24, 0x76	; 118
    22be:	92 e2       	ldi	r25, 0x22	; 34
    22c0:	80 93 6b 22 	sts	0x226B, r24
    22c4:	90 93 6c 22 	sts	0x226C, r25
    22c8:	8d e6       	ldi	r24, 0x6D	; 109
    22ca:	92 e2       	ldi	r25, 0x22	; 34
    22cc:	80 93 69 22 	sts	0x2269, r24
    22d0:	90 93 6a 22 	sts	0x226A, r25
    22d4:	0f c0       	rjmp	.+30     	; 0x22f4 <xTaskGenericCreate+0x17c>
    22d6:	80 91 5b 22 	lds	r24, 0x225B
    22da:	81 11       	cpse	r24, r1
    22dc:	0b c0       	rjmp	.+22     	; 0x22f4 <xTaskGenericCreate+0x17c>
    22de:	e0 91 ac 22 	lds	r30, 0x22AC
    22e2:	f0 91 ad 22 	lds	r31, 0x22AD
    22e6:	86 89       	ldd	r24, Z+22	; 0x16
    22e8:	08 17       	cp	r16, r24
    22ea:	20 f0       	brcs	.+8      	; 0x22f4 <xTaskGenericCreate+0x17c>
    22ec:	c0 93 ac 22 	sts	0x22AC, r28
    22f0:	d0 93 ad 22 	sts	0x22AD, r29
    22f4:	80 91 57 22 	lds	r24, 0x2257
    22f8:	8f 5f       	subi	r24, 0xFF	; 255
    22fa:	80 93 57 22 	sts	0x2257, r24
    22fe:	8e 89       	ldd	r24, Y+22	; 0x16
    2300:	90 91 5c 22 	lds	r25, 0x225C
    2304:	98 17       	cp	r25, r24
    2306:	10 f4       	brcc	.+4      	; 0x230c <xTaskGenericCreate+0x194>
    2308:	80 93 5c 22 	sts	0x225C, r24
    230c:	90 e0       	ldi	r25, 0x00	; 0
    230e:	9c 01       	movw	r18, r24
    2310:	22 0f       	add	r18, r18
    2312:	33 1f       	adc	r19, r19
    2314:	22 0f       	add	r18, r18
    2316:	33 1f       	adc	r19, r19
    2318:	22 0f       	add	r18, r18
    231a:	33 1f       	adc	r19, r19
    231c:	82 0f       	add	r24, r18
    231e:	93 1f       	adc	r25, r19
    2320:	b5 01       	movw	r22, r10
    2322:	81 58       	subi	r24, 0x81	; 129
    2324:	9d 4d       	sbci	r25, 0xDD	; 221
    2326:	69 da       	rcall	.-2862   	; 0x17fa <vListInsertEnd>
    2328:	0f 90       	pop	r0
    232a:	0f be       	out	0x3f, r0	; 63
    232c:	80 91 5b 22 	lds	r24, 0x225B
    2330:	88 23       	and	r24, r24
    2332:	51 f0       	breq	.+20     	; 0x2348 <xTaskGenericCreate+0x1d0>
    2334:	e0 91 ac 22 	lds	r30, 0x22AC
    2338:	f0 91 ad 22 	lds	r31, 0x22AD
    233c:	86 89       	ldd	r24, Z+22	; 0x16
    233e:	80 17       	cp	r24, r16
    2340:	28 f4       	brcc	.+10     	; 0x234c <xTaskGenericCreate+0x1d4>
    2342:	8e db       	rcall	.-2276   	; 0x1a60 <vPortYield>
    2344:	81 e0       	ldi	r24, 0x01	; 1
    2346:	05 c0       	rjmp	.+10     	; 0x2352 <xTaskGenericCreate+0x1da>
    2348:	81 e0       	ldi	r24, 0x01	; 1
    234a:	03 c0       	rjmp	.+6      	; 0x2352 <xTaskGenericCreate+0x1da>
    234c:	81 e0       	ldi	r24, 0x01	; 1
    234e:	01 c0       	rjmp	.+2      	; 0x2352 <xTaskGenericCreate+0x1da>
    2350:	8f ef       	ldi	r24, 0xFF	; 255
    2352:	df 91       	pop	r29
    2354:	cf 91       	pop	r28
    2356:	1f 91       	pop	r17
    2358:	0f 91       	pop	r16
    235a:	ff 90       	pop	r15
    235c:	ef 90       	pop	r14
    235e:	df 90       	pop	r13
    2360:	cf 90       	pop	r12
    2362:	bf 90       	pop	r11
    2364:	af 90       	pop	r10
    2366:	9f 90       	pop	r9
    2368:	8f 90       	pop	r8
    236a:	7f 90       	pop	r7
    236c:	6f 90       	pop	r6
    236e:	5f 90       	pop	r5
    2370:	4f 90       	pop	r4
    2372:	08 95       	ret

00002374 <vTaskStartScheduler>:
    2374:	af 92       	push	r10
    2376:	bf 92       	push	r11
    2378:	cf 92       	push	r12
    237a:	df 92       	push	r13
    237c:	ef 92       	push	r14
    237e:	ff 92       	push	r15
    2380:	0f 93       	push	r16
    2382:	a1 2c       	mov	r10, r1
    2384:	b1 2c       	mov	r11, r1
    2386:	c1 2c       	mov	r12, r1
    2388:	d1 2c       	mov	r13, r1
    238a:	e1 2c       	mov	r14, r1
    238c:	f1 2c       	mov	r15, r1
    238e:	00 e0       	ldi	r16, 0x00	; 0
    2390:	20 e0       	ldi	r18, 0x00	; 0
    2392:	30 e0       	ldi	r19, 0x00	; 0
    2394:	45 e5       	ldi	r20, 0x55	; 85
    2396:	50 e0       	ldi	r21, 0x00	; 0
    2398:	6d e0       	ldi	r22, 0x0D	; 13
    239a:	70 e2       	ldi	r23, 0x20	; 32
    239c:	8f e7       	ldi	r24, 0x7F	; 127
    239e:	90 e1       	ldi	r25, 0x10	; 16
    23a0:	eb de       	rcall	.-554    	; 0x2178 <xTaskGenericCreate>
    23a2:	81 30       	cpi	r24, 0x01	; 1
    23a4:	91 f4       	brne	.+36     	; 0x23ca <vTaskStartScheduler+0x56>
    23a6:	15 d3       	rcall	.+1578   	; 0x29d2 <xTimerCreateTimerTask>
    23a8:	81 30       	cpi	r24, 0x01	; 1
    23aa:	79 f4       	brne	.+30     	; 0x23ca <vTaskStartScheduler+0x56>
    23ac:	f8 94       	cli
    23ae:	8f ef       	ldi	r24, 0xFF	; 255
    23b0:	9f ef       	ldi	r25, 0xFF	; 255
    23b2:	80 93 55 22 	sts	0x2255, r24
    23b6:	90 93 56 22 	sts	0x2256, r25
    23ba:	81 e0       	ldi	r24, 0x01	; 1
    23bc:	80 93 5b 22 	sts	0x225B, r24
    23c0:	10 92 5d 22 	sts	0x225D, r1
    23c4:	10 92 5e 22 	sts	0x225E, r1
    23c8:	07 db       	rcall	.-2546   	; 0x19d8 <xPortStartScheduler>
    23ca:	0f 91       	pop	r16
    23cc:	ff 90       	pop	r15
    23ce:	ef 90       	pop	r14
    23d0:	df 90       	pop	r13
    23d2:	cf 90       	pop	r12
    23d4:	bf 90       	pop	r11
    23d6:	af 90       	pop	r10
    23d8:	08 95       	ret

000023da <vTaskSuspendAll>:
    23da:	80 91 54 22 	lds	r24, 0x2254
    23de:	8f 5f       	subi	r24, 0xFF	; 255
    23e0:	80 93 54 22 	sts	0x2254, r24
    23e4:	08 95       	ret

000023e6 <xTaskGetTickCount>:
    23e6:	0f b6       	in	r0, 0x3f	; 63
    23e8:	f8 94       	cli
    23ea:	0f 92       	push	r0
    23ec:	80 91 5d 22 	lds	r24, 0x225D
    23f0:	90 91 5e 22 	lds	r25, 0x225E
    23f4:	0f 90       	pop	r0
    23f6:	0f be       	out	0x3f, r0	; 63
    23f8:	08 95       	ret

000023fa <xTaskIncrementTick>:
    23fa:	df 92       	push	r13
    23fc:	ef 92       	push	r14
    23fe:	ff 92       	push	r15
    2400:	0f 93       	push	r16
    2402:	1f 93       	push	r17
    2404:	cf 93       	push	r28
    2406:	df 93       	push	r29
    2408:	80 91 54 22 	lds	r24, 0x2254
    240c:	81 11       	cpse	r24, r1
    240e:	b2 c0       	rjmp	.+356    	; 0x2574 <xTaskIncrementTick+0x17a>
    2410:	80 91 5d 22 	lds	r24, 0x225D
    2414:	90 91 5e 22 	lds	r25, 0x225E
    2418:	01 96       	adiw	r24, 0x01	; 1
    241a:	80 93 5d 22 	sts	0x225D, r24
    241e:	90 93 5e 22 	sts	0x225E, r25
    2422:	e0 90 5d 22 	lds	r14, 0x225D
    2426:	f0 90 5e 22 	lds	r15, 0x225E
    242a:	e1 14       	cp	r14, r1
    242c:	f1 04       	cpc	r15, r1
    242e:	99 f5       	brne	.+102    	; 0x2496 <xTaskIncrementTick+0x9c>
    2430:	80 91 6b 22 	lds	r24, 0x226B
    2434:	90 91 6c 22 	lds	r25, 0x226C
    2438:	20 91 69 22 	lds	r18, 0x2269
    243c:	30 91 6a 22 	lds	r19, 0x226A
    2440:	20 93 6b 22 	sts	0x226B, r18
    2444:	30 93 6c 22 	sts	0x226C, r19
    2448:	80 93 69 22 	sts	0x2269, r24
    244c:	90 93 6a 22 	sts	0x226A, r25
    2450:	80 91 58 22 	lds	r24, 0x2258
    2454:	8f 5f       	subi	r24, 0xFF	; 255
    2456:	80 93 58 22 	sts	0x2258, r24
    245a:	e0 91 6b 22 	lds	r30, 0x226B
    245e:	f0 91 6c 22 	lds	r31, 0x226C
    2462:	80 81       	ld	r24, Z
    2464:	81 11       	cpse	r24, r1
    2466:	07 c0       	rjmp	.+14     	; 0x2476 <xTaskIncrementTick+0x7c>
    2468:	8f ef       	ldi	r24, 0xFF	; 255
    246a:	9f ef       	ldi	r25, 0xFF	; 255
    246c:	80 93 55 22 	sts	0x2255, r24
    2470:	90 93 56 22 	sts	0x2256, r25
    2474:	10 c0       	rjmp	.+32     	; 0x2496 <xTaskIncrementTick+0x9c>
    2476:	e0 91 6b 22 	lds	r30, 0x226B
    247a:	f0 91 6c 22 	lds	r31, 0x226C
    247e:	05 80       	ldd	r0, Z+5	; 0x05
    2480:	f6 81       	ldd	r31, Z+6	; 0x06
    2482:	e0 2d       	mov	r30, r0
    2484:	06 80       	ldd	r0, Z+6	; 0x06
    2486:	f7 81       	ldd	r31, Z+7	; 0x07
    2488:	e0 2d       	mov	r30, r0
    248a:	82 81       	ldd	r24, Z+2	; 0x02
    248c:	93 81       	ldd	r25, Z+3	; 0x03
    248e:	80 93 55 22 	sts	0x2255, r24
    2492:	90 93 56 22 	sts	0x2256, r25
    2496:	80 91 55 22 	lds	r24, 0x2255
    249a:	90 91 56 22 	lds	r25, 0x2256
    249e:	e8 16       	cp	r14, r24
    24a0:	f9 06       	cpc	r15, r25
    24a2:	08 f4       	brcc	.+2      	; 0x24a6 <xTaskIncrementTick+0xac>
    24a4:	50 c0       	rjmp	.+160    	; 0x2546 <xTaskIncrementTick+0x14c>
    24a6:	d1 2c       	mov	r13, r1
    24a8:	02 c0       	rjmp	.+4      	; 0x24ae <xTaskIncrementTick+0xb4>
    24aa:	dd 24       	eor	r13, r13
    24ac:	d3 94       	inc	r13
    24ae:	e0 91 6b 22 	lds	r30, 0x226B
    24b2:	f0 91 6c 22 	lds	r31, 0x226C
    24b6:	80 81       	ld	r24, Z
    24b8:	81 11       	cpse	r24, r1
    24ba:	07 c0       	rjmp	.+14     	; 0x24ca <xTaskIncrementTick+0xd0>
    24bc:	8f ef       	ldi	r24, 0xFF	; 255
    24be:	9f ef       	ldi	r25, 0xFF	; 255
    24c0:	80 93 55 22 	sts	0x2255, r24
    24c4:	90 93 56 22 	sts	0x2256, r25
    24c8:	3f c0       	rjmp	.+126    	; 0x2548 <xTaskIncrementTick+0x14e>
    24ca:	e0 91 6b 22 	lds	r30, 0x226B
    24ce:	f0 91 6c 22 	lds	r31, 0x226C
    24d2:	05 80       	ldd	r0, Z+5	; 0x05
    24d4:	f6 81       	ldd	r31, Z+6	; 0x06
    24d6:	e0 2d       	mov	r30, r0
    24d8:	c6 81       	ldd	r28, Z+6	; 0x06
    24da:	d7 81       	ldd	r29, Z+7	; 0x07
    24dc:	2a 81       	ldd	r18, Y+2	; 0x02
    24de:	3b 81       	ldd	r19, Y+3	; 0x03
    24e0:	e2 16       	cp	r14, r18
    24e2:	f3 06       	cpc	r15, r19
    24e4:	28 f4       	brcc	.+10     	; 0x24f0 <xTaskIncrementTick+0xf6>
    24e6:	20 93 55 22 	sts	0x2255, r18
    24ea:	30 93 56 22 	sts	0x2256, r19
    24ee:	2c c0       	rjmp	.+88     	; 0x2548 <xTaskIncrementTick+0x14e>
    24f0:	8e 01       	movw	r16, r28
    24f2:	0e 5f       	subi	r16, 0xFE	; 254
    24f4:	1f 4f       	sbci	r17, 0xFF	; 255
    24f6:	c8 01       	movw	r24, r16
    24f8:	d2 d9       	rcall	.-3164   	; 0x189e <uxListRemove>
    24fa:	8c 89       	ldd	r24, Y+20	; 0x14
    24fc:	9d 89       	ldd	r25, Y+21	; 0x15
    24fe:	89 2b       	or	r24, r25
    2500:	19 f0       	breq	.+6      	; 0x2508 <xTaskIncrementTick+0x10e>
    2502:	ce 01       	movw	r24, r28
    2504:	0c 96       	adiw	r24, 0x0c	; 12
    2506:	cb d9       	rcall	.-3178   	; 0x189e <uxListRemove>
    2508:	2e 89       	ldd	r18, Y+22	; 0x16
    250a:	80 91 5c 22 	lds	r24, 0x225C
    250e:	82 17       	cp	r24, r18
    2510:	10 f4       	brcc	.+4      	; 0x2516 <xTaskIncrementTick+0x11c>
    2512:	20 93 5c 22 	sts	0x225C, r18
    2516:	30 e0       	ldi	r19, 0x00	; 0
    2518:	c9 01       	movw	r24, r18
    251a:	88 0f       	add	r24, r24
    251c:	99 1f       	adc	r25, r25
    251e:	88 0f       	add	r24, r24
    2520:	99 1f       	adc	r25, r25
    2522:	88 0f       	add	r24, r24
    2524:	99 1f       	adc	r25, r25
    2526:	82 0f       	add	r24, r18
    2528:	93 1f       	adc	r25, r19
    252a:	b8 01       	movw	r22, r16
    252c:	81 58       	subi	r24, 0x81	; 129
    252e:	9d 4d       	sbci	r25, 0xDD	; 221
    2530:	64 d9       	rcall	.-3384   	; 0x17fa <vListInsertEnd>
    2532:	e0 91 ac 22 	lds	r30, 0x22AC
    2536:	f0 91 ad 22 	lds	r31, 0x22AD
    253a:	9e 89       	ldd	r25, Y+22	; 0x16
    253c:	86 89       	ldd	r24, Z+22	; 0x16
    253e:	98 17       	cp	r25, r24
    2540:	08 f0       	brcs	.+2      	; 0x2544 <xTaskIncrementTick+0x14a>
    2542:	b3 cf       	rjmp	.-154    	; 0x24aa <xTaskIncrementTick+0xb0>
    2544:	b4 cf       	rjmp	.-152    	; 0x24ae <xTaskIncrementTick+0xb4>
    2546:	d1 2c       	mov	r13, r1
    2548:	e0 91 ac 22 	lds	r30, 0x22AC
    254c:	f0 91 ad 22 	lds	r31, 0x22AD
    2550:	86 89       	ldd	r24, Z+22	; 0x16
    2552:	90 e0       	ldi	r25, 0x00	; 0
    2554:	fc 01       	movw	r30, r24
    2556:	ee 0f       	add	r30, r30
    2558:	ff 1f       	adc	r31, r31
    255a:	ee 0f       	add	r30, r30
    255c:	ff 1f       	adc	r31, r31
    255e:	ee 0f       	add	r30, r30
    2560:	ff 1f       	adc	r31, r31
    2562:	8e 0f       	add	r24, r30
    2564:	9f 1f       	adc	r25, r31
    2566:	fc 01       	movw	r30, r24
    2568:	e1 58       	subi	r30, 0x81	; 129
    256a:	fd 4d       	sbci	r31, 0xDD	; 221
    256c:	80 81       	ld	r24, Z
    256e:	82 30       	cpi	r24, 0x02	; 2
    2570:	40 f4       	brcc	.+16     	; 0x2582 <xTaskIncrementTick+0x188>
    2572:	09 c0       	rjmp	.+18     	; 0x2586 <xTaskIncrementTick+0x18c>
    2574:	80 91 5a 22 	lds	r24, 0x225A
    2578:	8f 5f       	subi	r24, 0xFF	; 255
    257a:	80 93 5a 22 	sts	0x225A, r24
    257e:	d1 2c       	mov	r13, r1
    2580:	02 c0       	rjmp	.+4      	; 0x2586 <xTaskIncrementTick+0x18c>
    2582:	dd 24       	eor	r13, r13
    2584:	d3 94       	inc	r13
    2586:	80 91 59 22 	lds	r24, 0x2259
    258a:	88 23       	and	r24, r24
    258c:	11 f0       	breq	.+4      	; 0x2592 <xTaskIncrementTick+0x198>
    258e:	dd 24       	eor	r13, r13
    2590:	d3 94       	inc	r13
    2592:	8d 2d       	mov	r24, r13
    2594:	df 91       	pop	r29
    2596:	cf 91       	pop	r28
    2598:	1f 91       	pop	r17
    259a:	0f 91       	pop	r16
    259c:	ff 90       	pop	r15
    259e:	ef 90       	pop	r14
    25a0:	df 90       	pop	r13
    25a2:	08 95       	ret

000025a4 <xTaskResumeAll>:
    25a4:	df 92       	push	r13
    25a6:	ef 92       	push	r14
    25a8:	ff 92       	push	r15
    25aa:	0f 93       	push	r16
    25ac:	1f 93       	push	r17
    25ae:	cf 93       	push	r28
    25b0:	df 93       	push	r29
    25b2:	0f b6       	in	r0, 0x3f	; 63
    25b4:	f8 94       	cli
    25b6:	0f 92       	push	r0
    25b8:	80 91 54 22 	lds	r24, 0x2254
    25bc:	81 50       	subi	r24, 0x01	; 1
    25be:	80 93 54 22 	sts	0x2254, r24
    25c2:	80 91 54 22 	lds	r24, 0x2254
    25c6:	81 11       	cpse	r24, r1
    25c8:	5c c0       	rjmp	.+184    	; 0x2682 <xTaskResumeAll+0xde>
    25ca:	80 91 5f 22 	lds	r24, 0x225F
    25ce:	88 23       	and	r24, r24
    25d0:	09 f4       	brne	.+2      	; 0x25d4 <xTaskResumeAll+0x30>
    25d2:	59 c0       	rjmp	.+178    	; 0x2686 <xTaskResumeAll+0xe2>
    25d4:	0f 2e       	mov	r0, r31
    25d6:	f0 e6       	ldi	r31, 0x60	; 96
    25d8:	ef 2e       	mov	r14, r31
    25da:	f2 e2       	ldi	r31, 0x22	; 34
    25dc:	ff 2e       	mov	r15, r31
    25de:	f0 2d       	mov	r31, r0
    25e0:	dd 24       	eor	r13, r13
    25e2:	d3 94       	inc	r13
    25e4:	2d c0       	rjmp	.+90     	; 0x2640 <xTaskResumeAll+0x9c>
    25e6:	e0 91 65 22 	lds	r30, 0x2265
    25ea:	f0 91 66 22 	lds	r31, 0x2266
    25ee:	c6 81       	ldd	r28, Z+6	; 0x06
    25f0:	d7 81       	ldd	r29, Z+7	; 0x07
    25f2:	ce 01       	movw	r24, r28
    25f4:	0c 96       	adiw	r24, 0x0c	; 12
    25f6:	53 d9       	rcall	.-3418   	; 0x189e <uxListRemove>
    25f8:	8e 01       	movw	r16, r28
    25fa:	0e 5f       	subi	r16, 0xFE	; 254
    25fc:	1f 4f       	sbci	r17, 0xFF	; 255
    25fe:	c8 01       	movw	r24, r16
    2600:	4e d9       	rcall	.-3428   	; 0x189e <uxListRemove>
    2602:	8e 89       	ldd	r24, Y+22	; 0x16
    2604:	90 91 5c 22 	lds	r25, 0x225C
    2608:	98 17       	cp	r25, r24
    260a:	10 f4       	brcc	.+4      	; 0x2610 <xTaskResumeAll+0x6c>
    260c:	80 93 5c 22 	sts	0x225C, r24
    2610:	90 e0       	ldi	r25, 0x00	; 0
    2612:	9c 01       	movw	r18, r24
    2614:	22 0f       	add	r18, r18
    2616:	33 1f       	adc	r19, r19
    2618:	22 0f       	add	r18, r18
    261a:	33 1f       	adc	r19, r19
    261c:	22 0f       	add	r18, r18
    261e:	33 1f       	adc	r19, r19
    2620:	82 0f       	add	r24, r18
    2622:	93 1f       	adc	r25, r19
    2624:	b8 01       	movw	r22, r16
    2626:	81 58       	subi	r24, 0x81	; 129
    2628:	9d 4d       	sbci	r25, 0xDD	; 221
    262a:	e7 d8       	rcall	.-3634   	; 0x17fa <vListInsertEnd>
    262c:	e0 91 ac 22 	lds	r30, 0x22AC
    2630:	f0 91 ad 22 	lds	r31, 0x22AD
    2634:	9e 89       	ldd	r25, Y+22	; 0x16
    2636:	86 89       	ldd	r24, Z+22	; 0x16
    2638:	98 17       	cp	r25, r24
    263a:	10 f0       	brcs	.+4      	; 0x2640 <xTaskResumeAll+0x9c>
    263c:	d0 92 59 22 	sts	0x2259, r13
    2640:	f7 01       	movw	r30, r14
    2642:	80 81       	ld	r24, Z
    2644:	81 11       	cpse	r24, r1
    2646:	cf cf       	rjmp	.-98     	; 0x25e6 <xTaskResumeAll+0x42>
    2648:	80 91 5a 22 	lds	r24, 0x225A
    264c:	88 23       	and	r24, r24
    264e:	91 f0       	breq	.+36     	; 0x2674 <xTaskResumeAll+0xd0>
    2650:	80 91 5a 22 	lds	r24, 0x225A
    2654:	88 23       	and	r24, r24
    2656:	71 f0       	breq	.+28     	; 0x2674 <xTaskResumeAll+0xd0>
    2658:	c1 e0       	ldi	r28, 0x01	; 1
    265a:	cf de       	rcall	.-610    	; 0x23fa <xTaskIncrementTick>
    265c:	81 11       	cpse	r24, r1
    265e:	c0 93 59 22 	sts	0x2259, r28
    2662:	80 91 5a 22 	lds	r24, 0x225A
    2666:	81 50       	subi	r24, 0x01	; 1
    2668:	80 93 5a 22 	sts	0x225A, r24
    266c:	80 91 5a 22 	lds	r24, 0x225A
    2670:	81 11       	cpse	r24, r1
    2672:	f3 cf       	rjmp	.-26     	; 0x265a <xTaskResumeAll+0xb6>
    2674:	80 91 59 22 	lds	r24, 0x2259
    2678:	81 30       	cpi	r24, 0x01	; 1
    267a:	39 f4       	brne	.+14     	; 0x268a <xTaskResumeAll+0xe6>
    267c:	f1 d9       	rcall	.-3102   	; 0x1a60 <vPortYield>
    267e:	81 e0       	ldi	r24, 0x01	; 1
    2680:	05 c0       	rjmp	.+10     	; 0x268c <xTaskResumeAll+0xe8>
    2682:	80 e0       	ldi	r24, 0x00	; 0
    2684:	03 c0       	rjmp	.+6      	; 0x268c <xTaskResumeAll+0xe8>
    2686:	80 e0       	ldi	r24, 0x00	; 0
    2688:	01 c0       	rjmp	.+2      	; 0x268c <xTaskResumeAll+0xe8>
    268a:	80 e0       	ldi	r24, 0x00	; 0
    268c:	0f 90       	pop	r0
    268e:	0f be       	out	0x3f, r0	; 63
    2690:	df 91       	pop	r29
    2692:	cf 91       	pop	r28
    2694:	1f 91       	pop	r17
    2696:	0f 91       	pop	r16
    2698:	ff 90       	pop	r15
    269a:	ef 90       	pop	r14
    269c:	df 90       	pop	r13
    269e:	08 95       	ret

000026a0 <vTaskDelay>:
    26a0:	cf 93       	push	r28
    26a2:	df 93       	push	r29
    26a4:	ec 01       	movw	r28, r24
    26a6:	00 97       	sbiw	r24, 0x00	; 0
    26a8:	91 f0       	breq	.+36     	; 0x26ce <vTaskDelay+0x2e>
    26aa:	97 de       	rcall	.-722    	; 0x23da <vTaskSuspendAll>
    26ac:	80 91 5d 22 	lds	r24, 0x225D
    26b0:	90 91 5e 22 	lds	r25, 0x225E
    26b4:	c8 0f       	add	r28, r24
    26b6:	d9 1f       	adc	r29, r25
    26b8:	80 91 ac 22 	lds	r24, 0x22AC
    26bc:	90 91 ad 22 	lds	r25, 0x22AD
    26c0:	02 96       	adiw	r24, 0x02	; 2
    26c2:	ed d8       	rcall	.-3622   	; 0x189e <uxListRemove>
    26c4:	ce 01       	movw	r24, r28
    26c6:	23 dd       	rcall	.-1466   	; 0x210e <prvAddCurrentTaskToDelayedList>
    26c8:	6d df       	rcall	.-294    	; 0x25a4 <xTaskResumeAll>
    26ca:	81 11       	cpse	r24, r1
    26cc:	01 c0       	rjmp	.+2      	; 0x26d0 <vTaskDelay+0x30>
    26ce:	c8 d9       	rcall	.-3184   	; 0x1a60 <vPortYield>
    26d0:	df 91       	pop	r29
    26d2:	cf 91       	pop	r28
    26d4:	08 95       	ret

000026d6 <vTaskSwitchContext>:
    26d6:	80 91 54 22 	lds	r24, 0x2254
    26da:	88 23       	and	r24, r24
    26dc:	21 f0       	breq	.+8      	; 0x26e6 <vTaskSwitchContext+0x10>
    26de:	81 e0       	ldi	r24, 0x01	; 1
    26e0:	80 93 59 22 	sts	0x2259, r24
    26e4:	08 95       	ret
    26e6:	10 92 59 22 	sts	0x2259, r1
    26ea:	80 91 5c 22 	lds	r24, 0x225C
    26ee:	90 e0       	ldi	r25, 0x00	; 0
    26f0:	fc 01       	movw	r30, r24
    26f2:	ee 0f       	add	r30, r30
    26f4:	ff 1f       	adc	r31, r31
    26f6:	ee 0f       	add	r30, r30
    26f8:	ff 1f       	adc	r31, r31
    26fa:	ee 0f       	add	r30, r30
    26fc:	ff 1f       	adc	r31, r31
    26fe:	8e 0f       	add	r24, r30
    2700:	9f 1f       	adc	r25, r31
    2702:	fc 01       	movw	r30, r24
    2704:	e1 58       	subi	r30, 0x81	; 129
    2706:	fd 4d       	sbci	r31, 0xDD	; 221
    2708:	80 81       	ld	r24, Z
    270a:	81 11       	cpse	r24, r1
    270c:	17 c0       	rjmp	.+46     	; 0x273c <vTaskSwitchContext+0x66>
    270e:	80 91 5c 22 	lds	r24, 0x225C
    2712:	81 50       	subi	r24, 0x01	; 1
    2714:	80 93 5c 22 	sts	0x225C, r24
    2718:	80 91 5c 22 	lds	r24, 0x225C
    271c:	90 e0       	ldi	r25, 0x00	; 0
    271e:	fc 01       	movw	r30, r24
    2720:	ee 0f       	add	r30, r30
    2722:	ff 1f       	adc	r31, r31
    2724:	ee 0f       	add	r30, r30
    2726:	ff 1f       	adc	r31, r31
    2728:	ee 0f       	add	r30, r30
    272a:	ff 1f       	adc	r31, r31
    272c:	8e 0f       	add	r24, r30
    272e:	9f 1f       	adc	r25, r31
    2730:	fc 01       	movw	r30, r24
    2732:	e1 58       	subi	r30, 0x81	; 129
    2734:	fd 4d       	sbci	r31, 0xDD	; 221
    2736:	80 81       	ld	r24, Z
    2738:	88 23       	and	r24, r24
    273a:	49 f3       	breq	.-46     	; 0x270e <vTaskSwitchContext+0x38>
    273c:	e0 91 5c 22 	lds	r30, 0x225C
    2740:	f0 e0       	ldi	r31, 0x00	; 0
    2742:	cf 01       	movw	r24, r30
    2744:	88 0f       	add	r24, r24
    2746:	99 1f       	adc	r25, r25
    2748:	88 0f       	add	r24, r24
    274a:	99 1f       	adc	r25, r25
    274c:	88 0f       	add	r24, r24
    274e:	99 1f       	adc	r25, r25
    2750:	e8 0f       	add	r30, r24
    2752:	f9 1f       	adc	r31, r25
    2754:	e1 58       	subi	r30, 0x81	; 129
    2756:	fd 4d       	sbci	r31, 0xDD	; 221
    2758:	a1 81       	ldd	r26, Z+1	; 0x01
    275a:	b2 81       	ldd	r27, Z+2	; 0x02
    275c:	12 96       	adiw	r26, 0x02	; 2
    275e:	0d 90       	ld	r0, X+
    2760:	bc 91       	ld	r27, X
    2762:	a0 2d       	mov	r26, r0
    2764:	a1 83       	std	Z+1, r26	; 0x01
    2766:	b2 83       	std	Z+2, r27	; 0x02
    2768:	cf 01       	movw	r24, r30
    276a:	03 96       	adiw	r24, 0x03	; 3
    276c:	a8 17       	cp	r26, r24
    276e:	b9 07       	cpc	r27, r25
    2770:	31 f4       	brne	.+12     	; 0x277e <vTaskSwitchContext+0xa8>
    2772:	12 96       	adiw	r26, 0x02	; 2
    2774:	8d 91       	ld	r24, X+
    2776:	9c 91       	ld	r25, X
    2778:	13 97       	sbiw	r26, 0x03	; 3
    277a:	81 83       	std	Z+1, r24	; 0x01
    277c:	92 83       	std	Z+2, r25	; 0x02
    277e:	01 80       	ldd	r0, Z+1	; 0x01
    2780:	f2 81       	ldd	r31, Z+2	; 0x02
    2782:	e0 2d       	mov	r30, r0
    2784:	86 81       	ldd	r24, Z+6	; 0x06
    2786:	97 81       	ldd	r25, Z+7	; 0x07
    2788:	80 93 ac 22 	sts	0x22AC, r24
    278c:	90 93 ad 22 	sts	0x22AD, r25
    2790:	08 95       	ret

00002792 <vTaskPlaceOnEventList>:
    2792:	cf 93       	push	r28
    2794:	df 93       	push	r29
    2796:	eb 01       	movw	r28, r22
    2798:	60 91 ac 22 	lds	r22, 0x22AC
    279c:	70 91 ad 22 	lds	r23, 0x22AD
    27a0:	64 5f       	subi	r22, 0xF4	; 244
    27a2:	7f 4f       	sbci	r23, 0xFF	; 255
    27a4:	4b d8       	rcall	.-3946   	; 0x183c <vListInsert>
    27a6:	80 91 ac 22 	lds	r24, 0x22AC
    27aa:	90 91 ad 22 	lds	r25, 0x22AD
    27ae:	02 96       	adiw	r24, 0x02	; 2
    27b0:	76 d8       	rcall	.-3860   	; 0x189e <uxListRemove>
    27b2:	80 91 5d 22 	lds	r24, 0x225D
    27b6:	90 91 5e 22 	lds	r25, 0x225E
    27ba:	8c 0f       	add	r24, r28
    27bc:	9d 1f       	adc	r25, r29
    27be:	a7 dc       	rcall	.-1714   	; 0x210e <prvAddCurrentTaskToDelayedList>
    27c0:	df 91       	pop	r29
    27c2:	cf 91       	pop	r28
    27c4:	08 95       	ret

000027c6 <vTaskPlaceOnEventListRestricted>:
    27c6:	cf 93       	push	r28
    27c8:	df 93       	push	r29
    27ca:	eb 01       	movw	r28, r22
    27cc:	60 91 ac 22 	lds	r22, 0x22AC
    27d0:	70 91 ad 22 	lds	r23, 0x22AD
    27d4:	64 5f       	subi	r22, 0xF4	; 244
    27d6:	7f 4f       	sbci	r23, 0xFF	; 255
    27d8:	10 d8       	rcall	.-4064   	; 0x17fa <vListInsertEnd>
    27da:	80 91 ac 22 	lds	r24, 0x22AC
    27de:	90 91 ad 22 	lds	r25, 0x22AD
    27e2:	02 96       	adiw	r24, 0x02	; 2
    27e4:	5c d8       	rcall	.-3912   	; 0x189e <uxListRemove>
    27e6:	80 91 5d 22 	lds	r24, 0x225D
    27ea:	90 91 5e 22 	lds	r25, 0x225E
    27ee:	8c 0f       	add	r24, r28
    27f0:	9d 1f       	adc	r25, r29
    27f2:	8d dc       	rcall	.-1766   	; 0x210e <prvAddCurrentTaskToDelayedList>
    27f4:	df 91       	pop	r29
    27f6:	cf 91       	pop	r28
    27f8:	08 95       	ret

000027fa <xTaskRemoveFromEventList>:
    27fa:	0f 93       	push	r16
    27fc:	1f 93       	push	r17
    27fe:	cf 93       	push	r28
    2800:	df 93       	push	r29
    2802:	dc 01       	movw	r26, r24
    2804:	15 96       	adiw	r26, 0x05	; 5
    2806:	ed 91       	ld	r30, X+
    2808:	fc 91       	ld	r31, X
    280a:	16 97       	sbiw	r26, 0x06	; 6
    280c:	c6 81       	ldd	r28, Z+6	; 0x06
    280e:	d7 81       	ldd	r29, Z+7	; 0x07
    2810:	8e 01       	movw	r16, r28
    2812:	04 5f       	subi	r16, 0xF4	; 244
    2814:	1f 4f       	sbci	r17, 0xFF	; 255
    2816:	c8 01       	movw	r24, r16
    2818:	42 d8       	rcall	.-3964   	; 0x189e <uxListRemove>
    281a:	80 91 54 22 	lds	r24, 0x2254
    281e:	81 11       	cpse	r24, r1
    2820:	1b c0       	rjmp	.+54     	; 0x2858 <xTaskRemoveFromEventList+0x5e>
    2822:	0a 50       	subi	r16, 0x0A	; 10
    2824:	11 09       	sbc	r17, r1
    2826:	c8 01       	movw	r24, r16
    2828:	3a d8       	rcall	.-3980   	; 0x189e <uxListRemove>
    282a:	8e 89       	ldd	r24, Y+22	; 0x16
    282c:	90 91 5c 22 	lds	r25, 0x225C
    2830:	98 17       	cp	r25, r24
    2832:	10 f4       	brcc	.+4      	; 0x2838 <xTaskRemoveFromEventList+0x3e>
    2834:	80 93 5c 22 	sts	0x225C, r24
    2838:	90 e0       	ldi	r25, 0x00	; 0
    283a:	9c 01       	movw	r18, r24
    283c:	22 0f       	add	r18, r18
    283e:	33 1f       	adc	r19, r19
    2840:	22 0f       	add	r18, r18
    2842:	33 1f       	adc	r19, r19
    2844:	22 0f       	add	r18, r18
    2846:	33 1f       	adc	r19, r19
    2848:	82 0f       	add	r24, r18
    284a:	93 1f       	adc	r25, r19
    284c:	b8 01       	movw	r22, r16
    284e:	81 58       	subi	r24, 0x81	; 129
    2850:	9d 4d       	sbci	r25, 0xDD	; 221
    2852:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <vListInsertEnd>
    2856:	05 c0       	rjmp	.+10     	; 0x2862 <xTaskRemoveFromEventList+0x68>
    2858:	b8 01       	movw	r22, r16
    285a:	80 e6       	ldi	r24, 0x60	; 96
    285c:	92 e2       	ldi	r25, 0x22	; 34
    285e:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <vListInsertEnd>
    2862:	e0 91 ac 22 	lds	r30, 0x22AC
    2866:	f0 91 ad 22 	lds	r31, 0x22AD
    286a:	9e 89       	ldd	r25, Y+22	; 0x16
    286c:	86 89       	ldd	r24, Z+22	; 0x16
    286e:	89 17       	cp	r24, r25
    2870:	20 f4       	brcc	.+8      	; 0x287a <xTaskRemoveFromEventList+0x80>
    2872:	81 e0       	ldi	r24, 0x01	; 1
    2874:	80 93 59 22 	sts	0x2259, r24
    2878:	01 c0       	rjmp	.+2      	; 0x287c <xTaskRemoveFromEventList+0x82>
    287a:	80 e0       	ldi	r24, 0x00	; 0
    287c:	df 91       	pop	r29
    287e:	cf 91       	pop	r28
    2880:	1f 91       	pop	r17
    2882:	0f 91       	pop	r16
    2884:	08 95       	ret

00002886 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2886:	20 91 58 22 	lds	r18, 0x2258
    288a:	fc 01       	movw	r30, r24
    288c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    288e:	20 91 5d 22 	lds	r18, 0x225D
    2892:	30 91 5e 22 	lds	r19, 0x225E
    2896:	21 83       	std	Z+1, r18	; 0x01
    2898:	32 83       	std	Z+2, r19	; 0x02
    289a:	08 95       	ret

0000289c <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    289c:	0f b6       	in	r0, 0x3f	; 63
    289e:	f8 94       	cli
    28a0:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    28a2:	20 91 5d 22 	lds	r18, 0x225D
    28a6:	30 91 5e 22 	lds	r19, 0x225E
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    28aa:	40 91 58 22 	lds	r20, 0x2258
    28ae:	dc 01       	movw	r26, r24
    28b0:	5c 91       	ld	r21, X
    28b2:	54 17       	cp	r21, r20
    28b4:	39 f0       	breq	.+14     	; 0x28c4 <xTaskCheckForTimeOut+0x28>
    28b6:	11 96       	adiw	r26, 0x01	; 1
    28b8:	4d 91       	ld	r20, X+
    28ba:	5c 91       	ld	r21, X
    28bc:	12 97       	sbiw	r26, 0x02	; 2
    28be:	24 17       	cp	r18, r20
    28c0:	35 07       	cpc	r19, r21
    28c2:	c0 f4       	brcc	.+48     	; 0x28f4 <xTaskCheckForTimeOut+0x58>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    28c4:	dc 01       	movw	r26, r24
    28c6:	11 96       	adiw	r26, 0x01	; 1
    28c8:	ed 91       	ld	r30, X+
    28ca:	fc 91       	ld	r31, X
    28cc:	12 97       	sbiw	r26, 0x02	; 2
    28ce:	db 01       	movw	r26, r22
    28d0:	4d 91       	ld	r20, X+
    28d2:	5c 91       	ld	r21, X
    28d4:	d9 01       	movw	r26, r18
    28d6:	ae 1b       	sub	r26, r30
    28d8:	bf 0b       	sbc	r27, r31
    28da:	a4 17       	cp	r26, r20
    28dc:	b5 07       	cpc	r27, r21
    28de:	60 f4       	brcc	.+24     	; 0x28f8 <xTaskCheckForTimeOut+0x5c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    28e0:	e2 1b       	sub	r30, r18
    28e2:	f3 0b       	sbc	r31, r19
    28e4:	4e 0f       	add	r20, r30
    28e6:	5f 1f       	adc	r21, r31
    28e8:	fb 01       	movw	r30, r22
    28ea:	40 83       	st	Z, r20
    28ec:	51 83       	std	Z+1, r21	; 0x01
			vTaskSetTimeOutState( pxTimeOut );
    28ee:	cb df       	rcall	.-106    	; 0x2886 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    28f0:	80 e0       	ldi	r24, 0x00	; 0
    28f2:	03 c0       	rjmp	.+6      	; 0x28fa <xTaskCheckForTimeOut+0x5e>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    28f4:	81 e0       	ldi	r24, 0x01	; 1
    28f6:	01 c0       	rjmp	.+2      	; 0x28fa <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    28f8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    28fa:	0f 90       	pop	r0
    28fc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    28fe:	08 95       	ret

00002900 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2900:	81 e0       	ldi	r24, 0x01	; 1
    2902:	80 93 59 22 	sts	0x2259, r24
    2906:	08 95       	ret

00002908 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    2908:	80 91 5b 22 	lds	r24, 0x225B
    290c:	88 23       	and	r24, r24
    290e:	31 f0       	breq	.+12     	; 0x291c <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2910:	80 91 54 22 	lds	r24, 0x2254
    2914:	81 11       	cpse	r24, r1
    2916:	04 c0       	rjmp	.+8      	; 0x2920 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
    2918:	82 e0       	ldi	r24, 0x02	; 2
    291a:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    291c:	81 e0       	ldi	r24, 0x01	; 1
    291e:	08 95       	ret
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2920:	80 e0       	ldi	r24, 0x00	; 0
			}
		}

		return xReturn;
	}
    2922:	08 95       	ret

00002924 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2924:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2926:	62 83       	std	Z+2, r22	; 0x02
    2928:	73 83       	std	Z+3, r23	; 0x03
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    292a:	80 87       	std	Z+8, r24	; 0x08
    292c:	91 87       	std	Z+9, r25	; 0x09

	if( xNextExpiryTime <= xTimeNow )
    292e:	46 17       	cp	r20, r22
    2930:	57 07       	cpc	r21, r23
    2932:	90 f0       	brcs	.+36     	; 0x2958 <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    2934:	42 1b       	sub	r20, r18
    2936:	53 0b       	sbc	r21, r19
    2938:	84 85       	ldd	r24, Z+12	; 0x0c
    293a:	95 85       	ldd	r25, Z+13	; 0x0d
    293c:	48 17       	cp	r20, r24
    293e:	59 07       	cpc	r21, r25
    2940:	e0 f4       	brcc	.+56     	; 0x297a <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2942:	bf 01       	movw	r22, r30
    2944:	6e 5f       	subi	r22, 0xFE	; 254
    2946:	7f 4f       	sbci	r23, 0xFF	; 255
    2948:	80 91 b2 22 	lds	r24, 0x22B2
    294c:	90 91 b3 22 	lds	r25, 0x22B3
    2950:	0e 94 1e 0c 	call	0x183c	; 0x183c <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2954:	80 e0       	ldi	r24, 0x00	; 0
    2956:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    2958:	42 17       	cp	r20, r18
    295a:	53 07       	cpc	r21, r19
    295c:	18 f4       	brcc	.+6      	; 0x2964 <prvInsertTimerInActiveList+0x40>
    295e:	62 17       	cp	r22, r18
    2960:	73 07       	cpc	r23, r19
    2962:	68 f4       	brcc	.+26     	; 0x297e <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2964:	bf 01       	movw	r22, r30
    2966:	6e 5f       	subi	r22, 0xFE	; 254
    2968:	7f 4f       	sbci	r23, 0xFF	; 255
    296a:	80 91 b4 22 	lds	r24, 0x22B4
    296e:	90 91 b5 22 	lds	r25, 0x22B5
    2972:	0e 94 1e 0c 	call	0x183c	; 0x183c <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2976:	80 e0       	ldi	r24, 0x00	; 0
    2978:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    297a:	81 e0       	ldi	r24, 0x01	; 1
    297c:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    297e:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    2980:	08 95       	ret

00002982 <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    2982:	0f b6       	in	r0, 0x3f	; 63
    2984:	f8 94       	cli
    2986:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    2988:	80 91 b0 22 	lds	r24, 0x22B0
    298c:	90 91 b1 22 	lds	r25, 0x22B1
    2990:	89 2b       	or	r24, r25
    2992:	e1 f4       	brne	.+56     	; 0x29cc <prvCheckForValidListAndQueue+0x4a>
		{
			vListInitialise( &xActiveTimerList1 );
    2994:	8f eb       	ldi	r24, 0xBF	; 191
    2996:	92 e2       	ldi	r25, 0x22	; 34
    2998:	0e 94 eb 0b 	call	0x17d6	; 0x17d6 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    299c:	86 eb       	ldi	r24, 0xB6	; 182
    299e:	92 e2       	ldi	r25, 0x22	; 34
    29a0:	0e 94 eb 0b 	call	0x17d6	; 0x17d6 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    29a4:	8f eb       	ldi	r24, 0xBF	; 191
    29a6:	92 e2       	ldi	r25, 0x22	; 34
    29a8:	80 93 b4 22 	sts	0x22B4, r24
    29ac:	90 93 b5 22 	sts	0x22B5, r25
			pxOverflowTimerList = &xActiveTimerList2;
    29b0:	86 eb       	ldi	r24, 0xB6	; 182
    29b2:	92 e2       	ldi	r25, 0x22	; 34
    29b4:	80 93 b2 22 	sts	0x22B2, r24
    29b8:	90 93 b3 22 	sts	0x22B3, r25
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    29bc:	40 e0       	ldi	r20, 0x00	; 0
    29be:	65 e0       	ldi	r22, 0x05	; 5
    29c0:	8a e0       	ldi	r24, 0x0A	; 10
    29c2:	00 da       	rcall	.-3072   	; 0x1dc4 <xQueueGenericCreate>
    29c4:	80 93 b0 22 	sts	0x22B0, r24
    29c8:	90 93 b1 22 	sts	0x22B1, r25
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    29cc:	0f 90       	pop	r0
    29ce:	0f be       	out	0x3f, r0	; 63
    29d0:	08 95       	ret

000029d2 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    29d2:	af 92       	push	r10
    29d4:	bf 92       	push	r11
    29d6:	cf 92       	push	r12
    29d8:	df 92       	push	r13
    29da:	ef 92       	push	r14
    29dc:	ff 92       	push	r15
    29de:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    29e0:	d0 df       	rcall	.-96     	; 0x2982 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    29e2:	80 91 b0 22 	lds	r24, 0x22B0
    29e6:	90 91 b1 22 	lds	r25, 0x22B1
    29ea:	89 2b       	or	r24, r25
    29ec:	89 f0       	breq	.+34     	; 0x2a10 <xTimerCreateTimerTask+0x3e>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    29ee:	a1 2c       	mov	r10, r1
    29f0:	b1 2c       	mov	r11, r1
    29f2:	c1 2c       	mov	r12, r1
    29f4:	d1 2c       	mov	r13, r1
    29f6:	e1 2c       	mov	r14, r1
    29f8:	f1 2c       	mov	r15, r1
    29fa:	03 e0       	ldi	r16, 0x03	; 3
    29fc:	20 e0       	ldi	r18, 0x00	; 0
    29fe:	30 e0       	ldi	r19, 0x00	; 0
    2a00:	45 e5       	ldi	r20, 0x55	; 85
    2a02:	50 e0       	ldi	r21, 0x00	; 0
    2a04:	62 e1       	ldi	r22, 0x12	; 18
    2a06:	70 e2       	ldi	r23, 0x20	; 32
    2a08:	87 ef       	ldi	r24, 0xF7	; 247
    2a0a:	95 e1       	ldi	r25, 0x15	; 21
    2a0c:	b5 db       	rcall	.-2198   	; 0x2178 <xTaskGenericCreate>
    2a0e:	01 c0       	rjmp	.+2      	; 0x2a12 <xTimerCreateTimerTask+0x40>

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    2a10:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    2a12:	0f 91       	pop	r16
    2a14:	ff 90       	pop	r15
    2a16:	ef 90       	pop	r14
    2a18:	df 90       	pop	r13
    2a1a:	cf 90       	pop	r12
    2a1c:	bf 90       	pop	r11
    2a1e:	af 90       	pop	r10
    2a20:	08 95       	ret

00002a22 <xTimerCreate>:
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2a22:	9f 92       	push	r9
    2a24:	af 92       	push	r10
    2a26:	bf 92       	push	r11
    2a28:	cf 92       	push	r12
    2a2a:	df 92       	push	r13
    2a2c:	ef 92       	push	r14
    2a2e:	ff 92       	push	r15
    2a30:	0f 93       	push	r16
    2a32:	1f 93       	push	r17
    2a34:	cf 93       	push	r28
    2a36:	df 93       	push	r29
    2a38:	5c 01       	movw	r10, r24
    2a3a:	7b 01       	movw	r14, r22
    2a3c:	94 2e       	mov	r9, r20
    2a3e:	69 01       	movw	r12, r18
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
    2a40:	61 15       	cp	r22, r1
    2a42:	71 05       	cpc	r23, r1
    2a44:	a9 f0       	breq	.+42     	; 0x2a70 <xTimerCreate+0x4e>
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    2a46:	83 e1       	ldi	r24, 0x13	; 19
    2a48:	90 e0       	ldi	r25, 0x00	; 0
    2a4a:	bc d8       	rcall	.-3720   	; 0x1bc4 <pvPortMalloc>
    2a4c:	ec 01       	movw	r28, r24
		if( pxNewTimer != NULL )
    2a4e:	00 97       	sbiw	r24, 0x00	; 0
    2a50:	89 f0       	breq	.+34     	; 0x2a74 <xTimerCreate+0x52>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
    2a52:	97 df       	rcall	.-210    	; 0x2982 <prvCheckForValidListAndQueue>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
    2a54:	a8 82       	st	Y, r10
    2a56:	b9 82       	std	Y+1, r11	; 0x01
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    2a58:	ec 86       	std	Y+12, r14	; 0x0c
    2a5a:	fd 86       	std	Y+13, r15	; 0x0d
			pxNewTimer->uxAutoReload = uxAutoReload;
    2a5c:	9e 86       	std	Y+14, r9	; 0x0e
			pxNewTimer->pvTimerID = pvTimerID;
    2a5e:	cf 86       	std	Y+15, r12	; 0x0f
    2a60:	d8 8a       	std	Y+16, r13	; 0x10
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    2a62:	09 8b       	std	Y+17, r16	; 0x11
    2a64:	1a 8b       	std	Y+18, r17	; 0x12
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    2a66:	ce 01       	movw	r24, r28
    2a68:	02 96       	adiw	r24, 0x02	; 2
    2a6a:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <vListInitialiseItem>
    2a6e:	02 c0       	rjmp	.+4      	; 0x2a74 <xTimerCreate+0x52>
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
	{
		pxNewTimer = NULL;
    2a70:	c0 e0       	ldi	r28, 0x00	; 0
    2a72:	d0 e0       	ldi	r29, 0x00	; 0

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    2a74:	ce 01       	movw	r24, r28
    2a76:	df 91       	pop	r29
    2a78:	cf 91       	pop	r28
    2a7a:	1f 91       	pop	r17
    2a7c:	0f 91       	pop	r16
    2a7e:	ff 90       	pop	r15
    2a80:	ef 90       	pop	r14
    2a82:	df 90       	pop	r13
    2a84:	cf 90       	pop	r12
    2a86:	bf 90       	pop	r11
    2a88:	af 90       	pop	r10
    2a8a:	9f 90       	pop	r9
    2a8c:	08 95       	ret

00002a8e <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2a8e:	0f 93       	push	r16
    2a90:	1f 93       	push	r17
    2a92:	cf 93       	push	r28
    2a94:	df 93       	push	r29
    2a96:	cd b7       	in	r28, 0x3d	; 61
    2a98:	de b7       	in	r29, 0x3e	; 62
    2a9a:	25 97       	sbiw	r28, 0x05	; 5
    2a9c:	cd bf       	out	0x3d, r28	; 61
    2a9e:	de bf       	out	0x3e, r29	; 62
    2aa0:	d9 01       	movw	r26, r18

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    2aa2:	e0 91 b0 22 	lds	r30, 0x22B0
    2aa6:	f0 91 b1 22 	lds	r31, 0x22B1
    2aaa:	30 97       	sbiw	r30, 0x00	; 0
    2aac:	49 f1       	breq	.+82     	; 0x2b00 <xTimerGenericCommand+0x72>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    2aae:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2ab0:	4a 83       	std	Y+2, r20	; 0x02
    2ab2:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    2ab4:	8c 83       	std	Y+4, r24	; 0x04
    2ab6:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2ab8:	66 30       	cpi	r22, 0x06	; 6
    2aba:	d4 f4       	brge	.+52     	; 0x2af0 <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2abc:	25 df       	rcall	.-438    	; 0x2908 <xTaskGetSchedulerState>
    2abe:	82 30       	cpi	r24, 0x02	; 2
    2ac0:	59 f4       	brne	.+22     	; 0x2ad8 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2ac2:	20 e0       	ldi	r18, 0x00	; 0
    2ac4:	a8 01       	movw	r20, r16
    2ac6:	be 01       	movw	r22, r28
    2ac8:	6f 5f       	subi	r22, 0xFF	; 255
    2aca:	7f 4f       	sbci	r23, 0xFF	; 255
    2acc:	80 91 b0 22 	lds	r24, 0x22B0
    2ad0:	90 91 b1 22 	lds	r25, 0x22B1
    2ad4:	a2 d9       	rcall	.-3260   	; 0x1e1a <xQueueGenericSend>
    2ad6:	15 c0       	rjmp	.+42     	; 0x2b02 <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2ad8:	20 e0       	ldi	r18, 0x00	; 0
    2ada:	40 e0       	ldi	r20, 0x00	; 0
    2adc:	50 e0       	ldi	r21, 0x00	; 0
    2ade:	be 01       	movw	r22, r28
    2ae0:	6f 5f       	subi	r22, 0xFF	; 255
    2ae2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae4:	80 91 b0 22 	lds	r24, 0x22B0
    2ae8:	90 91 b1 22 	lds	r25, 0x22B1
    2aec:	96 d9       	rcall	.-3284   	; 0x1e1a <xQueueGenericSend>
    2aee:	09 c0       	rjmp	.+18     	; 0x2b02 <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2af0:	20 e0       	ldi	r18, 0x00	; 0
    2af2:	ad 01       	movw	r20, r26
    2af4:	be 01       	movw	r22, r28
    2af6:	6f 5f       	subi	r22, 0xFF	; 255
    2af8:	7f 4f       	sbci	r23, 0xFF	; 255
    2afa:	cf 01       	movw	r24, r30
    2afc:	1c da       	rcall	.-3016   	; 0x1f36 <xQueueGenericSendFromISR>
    2afe:	01 c0       	rjmp	.+2      	; 0x2b02 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2b00:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    2b02:	25 96       	adiw	r28, 0x05	; 5
    2b04:	cd bf       	out	0x3d, r28	; 61
    2b06:	de bf       	out	0x3e, r29	; 62
    2b08:	df 91       	pop	r29
    2b0a:	cf 91       	pop	r28
    2b0c:	1f 91       	pop	r17
    2b0e:	0f 91       	pop	r16
    2b10:	08 95       	ret

00002b12 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2b12:	af 92       	push	r10
    2b14:	bf 92       	push	r11
    2b16:	cf 92       	push	r12
    2b18:	df 92       	push	r13
    2b1a:	ef 92       	push	r14
    2b1c:	ff 92       	push	r15
    2b1e:	0f 93       	push	r16
    2b20:	1f 93       	push	r17
    2b22:	cf 93       	push	r28
    2b24:	df 93       	push	r29
    2b26:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2b28:	5e dc       	rcall	.-1860   	; 0x23e6 <xTaskGetTickCount>
    2b2a:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    2b2c:	80 91 ae 22 	lds	r24, 0x22AE
    2b30:	90 91 af 22 	lds	r25, 0x22AF
    2b34:	e8 16       	cp	r14, r24
    2b36:	f9 06       	cpc	r15, r25
    2b38:	08 f0       	brcs	.+2      	; 0x2b3c <prvSampleTimeNow+0x2a>
    2b3a:	47 c0       	rjmp	.+142    	; 0x2bca <prvSampleTimeNow+0xb8>
    2b3c:	2f c0       	rjmp	.+94     	; 0x2b9c <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2b3e:	05 80       	ldd	r0, Z+5	; 0x05
    2b40:	f6 81       	ldd	r31, Z+6	; 0x06
    2b42:	e0 2d       	mov	r30, r0
    2b44:	a0 80       	ld	r10, Z
    2b46:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2b48:	c6 81       	ldd	r28, Z+6	; 0x06
    2b4a:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2b4c:	8e 01       	movw	r16, r28
    2b4e:	0e 5f       	subi	r16, 0xFE	; 254
    2b50:	1f 4f       	sbci	r17, 0xFF	; 255
    2b52:	c8 01       	movw	r24, r16
    2b54:	0e 94 4f 0c 	call	0x189e	; 0x189e <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2b58:	e9 89       	ldd	r30, Y+17	; 0x11
    2b5a:	fa 89       	ldd	r31, Y+18	; 0x12
    2b5c:	ce 01       	movw	r24, r28
    2b5e:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2b60:	8e 85       	ldd	r24, Y+14	; 0x0e
    2b62:	81 30       	cpi	r24, 0x01	; 1
    2b64:	d9 f4       	brne	.+54     	; 0x2b9c <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2b66:	8c 85       	ldd	r24, Y+12	; 0x0c
    2b68:	9d 85       	ldd	r25, Y+13	; 0x0d
    2b6a:	8a 0d       	add	r24, r10
    2b6c:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    2b6e:	a8 16       	cp	r10, r24
    2b70:	b9 06       	cpc	r11, r25
    2b72:	60 f4       	brcc	.+24     	; 0x2b8c <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2b74:	8a 83       	std	Y+2, r24	; 0x02
    2b76:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2b78:	c8 87       	std	Y+8, r28	; 0x08
    2b7a:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2b7c:	b8 01       	movw	r22, r16
    2b7e:	80 91 b4 22 	lds	r24, 0x22B4
    2b82:	90 91 b5 22 	lds	r25, 0x22B5
    2b86:	0e 94 1e 0c 	call	0x183c	; 0x183c <vListInsert>
    2b8a:	08 c0       	rjmp	.+16     	; 0x2b9c <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2b8c:	00 e0       	ldi	r16, 0x00	; 0
    2b8e:	10 e0       	ldi	r17, 0x00	; 0
    2b90:	20 e0       	ldi	r18, 0x00	; 0
    2b92:	30 e0       	ldi	r19, 0x00	; 0
    2b94:	a5 01       	movw	r20, r10
    2b96:	60 e0       	ldi	r22, 0x00	; 0
    2b98:	ce 01       	movw	r24, r28
    2b9a:	79 df       	rcall	.-270    	; 0x2a8e <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2b9c:	e0 91 b4 22 	lds	r30, 0x22B4
    2ba0:	f0 91 b5 22 	lds	r31, 0x22B5
    2ba4:	80 81       	ld	r24, Z
    2ba6:	81 11       	cpse	r24, r1
    2ba8:	ca cf       	rjmp	.-108    	; 0x2b3e <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    2baa:	80 91 b2 22 	lds	r24, 0x22B2
    2bae:	90 91 b3 22 	lds	r25, 0x22B3
    2bb2:	80 93 b4 22 	sts	0x22B4, r24
    2bb6:	90 93 b5 22 	sts	0x22B5, r25
	pxOverflowTimerList = pxTemp;
    2bba:	e0 93 b2 22 	sts	0x22B2, r30
    2bbe:	f0 93 b3 22 	sts	0x22B3, r31
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    2bc2:	81 e0       	ldi	r24, 0x01	; 1
    2bc4:	f6 01       	movw	r30, r12
    2bc6:	80 83       	st	Z, r24
    2bc8:	02 c0       	rjmp	.+4      	; 0x2bce <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    2bca:	f6 01       	movw	r30, r12
    2bcc:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    2bce:	e0 92 ae 22 	sts	0x22AE, r14
    2bd2:	f0 92 af 22 	sts	0x22AF, r15

	return xTimeNow;
}
    2bd6:	c7 01       	movw	r24, r14
    2bd8:	df 91       	pop	r29
    2bda:	cf 91       	pop	r28
    2bdc:	1f 91       	pop	r17
    2bde:	0f 91       	pop	r16
    2be0:	ff 90       	pop	r15
    2be2:	ef 90       	pop	r14
    2be4:	df 90       	pop	r13
    2be6:	cf 90       	pop	r12
    2be8:	bf 90       	pop	r11
    2bea:	af 90       	pop	r10
    2bec:	08 95       	ret

00002bee <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2bee:	cf 93       	push	r28
    2bf0:	df 93       	push	r29
    2bf2:	00 d0       	rcall	.+0      	; 0x2bf4 <prvTimerTask+0x6>
    2bf4:	00 d0       	rcall	.+0      	; 0x2bf6 <prvTimerTask+0x8>
    2bf6:	cd b7       	in	r28, 0x3d	; 61
    2bf8:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2bfa:	ce 01       	movw	r24, r28
    2bfc:	01 96       	adiw	r24, 0x01	; 1
    2bfe:	6c 01       	movw	r12, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2c00:	a8 2e       	mov	r10, r24
    2c02:	bd 2c       	mov	r11, r13
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2c04:	e0 91 b4 22 	lds	r30, 0x22B4
    2c08:	f0 91 b5 22 	lds	r31, 0x22B5
	if( *pxListWasEmpty == pdFALSE )
    2c0c:	80 81       	ld	r24, Z
    2c0e:	88 23       	and	r24, r24
    2c10:	09 f4       	brne	.+2      	; 0x2c14 <prvTimerTask+0x26>
    2c12:	c1 c0       	rjmp	.+386    	; 0x2d96 <prvTimerTask+0x1a8>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2c14:	05 80       	ldd	r0, Z+5	; 0x05
    2c16:	f6 81       	ldd	r31, Z+6	; 0x06
    2c18:	e0 2d       	mov	r30, r0
    2c1a:	e0 80       	ld	r14, Z
    2c1c:	f1 80       	ldd	r15, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2c1e:	dd db       	rcall	.-2118   	; 0x23da <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2c20:	c6 01       	movw	r24, r12
    2c22:	77 df       	rcall	.-274    	; 0x2b12 <prvSampleTimeNow>
    2c24:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2c26:	89 81       	ldd	r24, Y+1	; 0x01
    2c28:	81 11       	cpse	r24, r1
    2c2a:	4e c0       	rjmp	.+156    	; 0x2cc8 <prvTimerTask+0xda>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2c2c:	0e 15       	cp	r16, r14
    2c2e:	1f 05       	cpc	r17, r15
    2c30:	08 f4       	brcc	.+2      	; 0x2c34 <prvTimerTask+0x46>
    2c32:	3b c0       	rjmp	.+118    	; 0x2caa <prvTimerTask+0xbc>
			{
				( void ) xTaskResumeAll();
    2c34:	b7 dc       	rcall	.-1682   	; 0x25a4 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2c36:	e0 91 b4 22 	lds	r30, 0x22B4
    2c3a:	f0 91 b5 22 	lds	r31, 0x22B5
    2c3e:	05 80       	ldd	r0, Z+5	; 0x05
    2c40:	f6 81       	ldd	r31, Z+6	; 0x06
    2c42:	e0 2d       	mov	r30, r0
    2c44:	86 80       	ldd	r8, Z+6	; 0x06
    2c46:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2c48:	c4 01       	movw	r24, r8
    2c4a:	02 96       	adiw	r24, 0x02	; 2
    2c4c:	0e 94 4f 0c 	call	0x189e	; 0x189e <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2c50:	d4 01       	movw	r26, r8
    2c52:	1e 96       	adiw	r26, 0x0e	; 14
    2c54:	8c 91       	ld	r24, X
    2c56:	1e 97       	sbiw	r26, 0x0e	; 14
    2c58:	81 30       	cpi	r24, 0x01	; 1
    2c5a:	a1 f4       	brne	.+40     	; 0x2c84 <prvTimerTask+0x96>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    2c5c:	1c 96       	adiw	r26, 0x0c	; 12
    2c5e:	6d 91       	ld	r22, X+
    2c60:	7c 91       	ld	r23, X
    2c62:	1d 97       	sbiw	r26, 0x0d	; 13
    2c64:	6e 0d       	add	r22, r14
    2c66:	7f 1d       	adc	r23, r15
    2c68:	97 01       	movw	r18, r14
    2c6a:	a8 01       	movw	r20, r16
    2c6c:	c4 01       	movw	r24, r8
    2c6e:	5a de       	rcall	.-844    	; 0x2924 <prvInsertTimerInActiveList>
    2c70:	81 30       	cpi	r24, 0x01	; 1
    2c72:	41 f4       	brne	.+16     	; 0x2c84 <prvTimerTask+0x96>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2c74:	00 e0       	ldi	r16, 0x00	; 0
    2c76:	10 e0       	ldi	r17, 0x00	; 0
    2c78:	20 e0       	ldi	r18, 0x00	; 0
    2c7a:	30 e0       	ldi	r19, 0x00	; 0
    2c7c:	a7 01       	movw	r20, r14
    2c7e:	60 e0       	ldi	r22, 0x00	; 0
    2c80:	c4 01       	movw	r24, r8
    2c82:	05 df       	rcall	.-502    	; 0x2a8e <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2c84:	d4 01       	movw	r26, r8
    2c86:	51 96       	adiw	r26, 0x11	; 17
    2c88:	ed 91       	ld	r30, X+
    2c8a:	fc 91       	ld	r31, X
    2c8c:	52 97       	sbiw	r26, 0x12	; 18
    2c8e:	c4 01       	movw	r24, r8
    2c90:	19 95       	eicall
    2c92:	74 c0       	rjmp	.+232    	; 0x2d7c <prvTimerTask+0x18e>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2c94:	e0 91 b2 22 	lds	r30, 0x22B2
    2c98:	f0 91 b3 22 	lds	r31, 0x22B3
    2c9c:	41 e0       	ldi	r20, 0x01	; 1
    2c9e:	80 81       	ld	r24, Z
    2ca0:	81 11       	cpse	r24, r1
    2ca2:	40 e0       	ldi	r20, 0x00	; 0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2ca4:	e1 2c       	mov	r14, r1
    2ca6:	f1 2c       	mov	r15, r1
    2ca8:	01 c0       	rjmp	.+2      	; 0x2cac <prvTimerTask+0xbe>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2caa:	40 e0       	ldi	r20, 0x00	; 0
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2cac:	b7 01       	movw	r22, r14
    2cae:	60 1b       	sub	r22, r16
    2cb0:	71 0b       	sbc	r23, r17
    2cb2:	80 91 b0 22 	lds	r24, 0x22B0
    2cb6:	90 91 b1 22 	lds	r25, 0x22B1
    2cba:	06 da       	rcall	.-3060   	; 0x20c8 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    2cbc:	73 dc       	rcall	.-1818   	; 0x25a4 <xTaskResumeAll>
    2cbe:	81 11       	cpse	r24, r1
    2cc0:	5d c0       	rjmp	.+186    	; 0x2d7c <prvTimerTask+0x18e>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    2cc2:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <vPortYield>
    2cc6:	5a c0       	rjmp	.+180    	; 0x2d7c <prvTimerTask+0x18e>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    2cc8:	6d dc       	rcall	.-1830   	; 0x25a4 <xTaskResumeAll>
    2cca:	58 c0       	rjmp	.+176    	; 0x2d7c <prvTimerTask+0x18e>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2ccc:	89 81       	ldd	r24, Y+1	; 0x01
    2cce:	88 23       	and	r24, r24
    2cd0:	0c f4       	brge	.+2      	; 0x2cd4 <prvTimerTask+0xe6>
    2cd2:	54 c0       	rjmp	.+168    	; 0x2d7c <prvTimerTask+0x18e>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2cd4:	ec 80       	ldd	r14, Y+4	; 0x04
    2cd6:	fd 80       	ldd	r15, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    2cd8:	f7 01       	movw	r30, r14
    2cda:	82 85       	ldd	r24, Z+10	; 0x0a
    2cdc:	93 85       	ldd	r25, Z+11	; 0x0b
    2cde:	89 2b       	or	r24, r25
    2ce0:	21 f0       	breq	.+8      	; 0x2cea <prvTimerTask+0xfc>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2ce2:	c7 01       	movw	r24, r14
    2ce4:	02 96       	adiw	r24, 0x02	; 2
    2ce6:	0e 94 4f 0c 	call	0x189e	; 0x189e <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2cea:	ce 01       	movw	r24, r28
    2cec:	06 96       	adiw	r24, 0x06	; 6
    2cee:	11 df       	rcall	.-478    	; 0x2b12 <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    2cf0:	09 81       	ldd	r16, Y+1	; 0x01
    2cf2:	11 27       	eor	r17, r17
    2cf4:	07 fd       	sbrc	r16, 7
    2cf6:	10 95       	com	r17
    2cf8:	21 2f       	mov	r18, r17
    2cfa:	31 2f       	mov	r19, r17
    2cfc:	0a 30       	cpi	r16, 0x0A	; 10
    2cfe:	11 05       	cpc	r17, r1
    2d00:	08 f0       	brcs	.+2      	; 0x2d04 <prvTimerTask+0x116>
    2d02:	3c c0       	rjmp	.+120    	; 0x2d7c <prvTimerTask+0x18e>
    2d04:	f8 01       	movw	r30, r16
    2d06:	e2 50       	subi	r30, 0x02	; 2
    2d08:	ff 4f       	sbci	r31, 0xFF	; 255
    2d0a:	5c c3       	rjmp	.+1720   	; 0x33c4 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    2d0c:	2a 81       	ldd	r18, Y+2	; 0x02
    2d0e:	3b 81       	ldd	r19, Y+3	; 0x03
    2d10:	d7 01       	movw	r26, r14
    2d12:	1c 96       	adiw	r26, 0x0c	; 12
    2d14:	6d 91       	ld	r22, X+
    2d16:	7c 91       	ld	r23, X
    2d18:	1d 97       	sbiw	r26, 0x0d	; 13
    2d1a:	62 0f       	add	r22, r18
    2d1c:	73 1f       	adc	r23, r19
    2d1e:	ac 01       	movw	r20, r24
    2d20:	c7 01       	movw	r24, r14
    2d22:	00 de       	rcall	.-1024   	; 0x2924 <prvInsertTimerInActiveList>
    2d24:	81 30       	cpi	r24, 0x01	; 1
    2d26:	51 f5       	brne	.+84     	; 0x2d7c <prvTimerTask+0x18e>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2d28:	d7 01       	movw	r26, r14
    2d2a:	51 96       	adiw	r26, 0x11	; 17
    2d2c:	ed 91       	ld	r30, X+
    2d2e:	fc 91       	ld	r31, X
    2d30:	52 97       	sbiw	r26, 0x12	; 18
    2d32:	c7 01       	movw	r24, r14
    2d34:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2d36:	f7 01       	movw	r30, r14
    2d38:	86 85       	ldd	r24, Z+14	; 0x0e
    2d3a:	81 30       	cpi	r24, 0x01	; 1
    2d3c:	f9 f4       	brne	.+62     	; 0x2d7c <prvTimerTask+0x18e>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2d3e:	44 85       	ldd	r20, Z+12	; 0x0c
    2d40:	55 85       	ldd	r21, Z+13	; 0x0d
    2d42:	8a 81       	ldd	r24, Y+2	; 0x02
    2d44:	9b 81       	ldd	r25, Y+3	; 0x03
    2d46:	48 0f       	add	r20, r24
    2d48:	59 1f       	adc	r21, r25
    2d4a:	00 e0       	ldi	r16, 0x00	; 0
    2d4c:	10 e0       	ldi	r17, 0x00	; 0
    2d4e:	20 e0       	ldi	r18, 0x00	; 0
    2d50:	30 e0       	ldi	r19, 0x00	; 0
    2d52:	60 e0       	ldi	r22, 0x00	; 0
    2d54:	c7 01       	movw	r24, r14
    2d56:	9b de       	rcall	.-714    	; 0x2a8e <xTimerGenericCommand>
    2d58:	11 c0       	rjmp	.+34     	; 0x2d7c <prvTimerTask+0x18e>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2d5a:	6a 81       	ldd	r22, Y+2	; 0x02
    2d5c:	7b 81       	ldd	r23, Y+3	; 0x03
    2d5e:	d7 01       	movw	r26, r14
    2d60:	1c 96       	adiw	r26, 0x0c	; 12
    2d62:	6d 93       	st	X+, r22
    2d64:	7c 93       	st	X, r23
    2d66:	1d 97       	sbiw	r26, 0x0d	; 13
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2d68:	68 0f       	add	r22, r24
    2d6a:	79 1f       	adc	r23, r25
    2d6c:	9c 01       	movw	r18, r24
    2d6e:	ac 01       	movw	r20, r24
    2d70:	c7 01       	movw	r24, r14
    2d72:	d8 dd       	rcall	.-1104   	; 0x2924 <prvInsertTimerInActiveList>
    2d74:	03 c0       	rjmp	.+6      	; 0x2d7c <prvTimerTask+0x18e>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    2d76:	c7 01       	movw	r24, r14
    2d78:	0e 94 ef 0d 	call	0x1bde	; 0x1bde <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2d7c:	20 e0       	ldi	r18, 0x00	; 0
    2d7e:	40 e0       	ldi	r20, 0x00	; 0
    2d80:	50 e0       	ldi	r21, 0x00	; 0
    2d82:	6a 2d       	mov	r22, r10
    2d84:	7b 2d       	mov	r23, r11
    2d86:	80 91 b0 22 	lds	r24, 0x22B0
    2d8a:	90 91 b1 22 	lds	r25, 0x22B1
    2d8e:	05 d9       	rcall	.-3574   	; 0x1f9a <xQueueGenericReceive>
    2d90:	81 11       	cpse	r24, r1
    2d92:	9c cf       	rjmp	.-200    	; 0x2ccc <prvTimerTask+0xde>
    2d94:	37 cf       	rjmp	.-402    	; 0x2c04 <prvTimerTask+0x16>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2d96:	21 db       	rcall	.-2494   	; 0x23da <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2d98:	c6 01       	movw	r24, r12
    2d9a:	bb de       	rcall	.-650    	; 0x2b12 <prvSampleTimeNow>
    2d9c:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2d9e:	89 81       	ldd	r24, Y+1	; 0x01
    2da0:	88 23       	and	r24, r24
    2da2:	09 f4       	brne	.+2      	; 0x2da6 <prvTimerTask+0x1b8>
    2da4:	77 cf       	rjmp	.-274    	; 0x2c94 <prvTimerTask+0xa6>
    2da6:	90 cf       	rjmp	.-224    	; 0x2cc8 <prvTimerTask+0xda>

00002da8 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    2da8:	cf 93       	push	r28
    2daa:	df 93       	push	r29
    2dac:	fc 01       	movw	r30, r24
    2dae:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    2db0:	20 e0       	ldi	r18, 0x00	; 0
    2db2:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    2db4:	c6 2f       	mov	r28, r22
    2db6:	d0 e0       	ldi	r29, 0x00	; 0
    2db8:	de 01       	movw	r26, r28
    2dba:	02 2e       	mov	r0, r18
    2dbc:	02 c0       	rjmp	.+4      	; 0x2dc2 <ioport_configure_port_pin+0x1a>
    2dbe:	b5 95       	asr	r27
    2dc0:	a7 95       	ror	r26
    2dc2:	0a 94       	dec	r0
    2dc4:	e2 f7       	brpl	.-8      	; 0x2dbe <ioport_configure_port_pin+0x16>
    2dc6:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    2dc8:	50 83       	st	Z, r21
    2dca:	2f 5f       	subi	r18, 0xFF	; 255
    2dcc:	3f 4f       	sbci	r19, 0xFF	; 255
    2dce:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    2dd0:	28 30       	cpi	r18, 0x08	; 8
    2dd2:	31 05       	cpc	r19, r1
    2dd4:	89 f7       	brne	.-30     	; 0x2db8 <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    2dd6:	40 ff       	sbrs	r20, 0
    2dd8:	0a c0       	rjmp	.+20     	; 0x2dee <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
    2dda:	41 ff       	sbrs	r20, 1
    2ddc:	03 c0       	rjmp	.+6      	; 0x2de4 <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    2dde:	fc 01       	movw	r30, r24
    2de0:	65 83       	std	Z+5, r22	; 0x05
    2de2:	02 c0       	rjmp	.+4      	; 0x2de8 <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    2de4:	fc 01       	movw	r30, r24
    2de6:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    2de8:	fc 01       	movw	r30, r24
    2dea:	61 83       	std	Z+1, r22	; 0x01
    2dec:	02 c0       	rjmp	.+4      	; 0x2df2 <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    2dee:	fc 01       	movw	r30, r24
    2df0:	62 83       	std	Z+2, r22	; 0x02
	}
}
    2df2:	df 91       	pop	r29
    2df4:	cf 91       	pop	r28
    2df6:	08 95       	ret

00002df8 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    2df8:	43 e0       	ldi	r20, 0x03	; 3
    2dfa:	50 e0       	ldi	r21, 0x00	; 0
    2dfc:	61 e0       	ldi	r22, 0x01	; 1
    2dfe:	80 ee       	ldi	r24, 0xE0	; 224
    2e00:	97 e0       	ldi	r25, 0x07	; 7
    2e02:	d2 df       	rcall	.-92     	; 0x2da8 <ioport_configure_port_pin>
    2e04:	43 e0       	ldi	r20, 0x03	; 3
    2e06:	50 e0       	ldi	r21, 0x00	; 0
    2e08:	62 e0       	ldi	r22, 0x02	; 2
    2e0a:	80 ee       	ldi	r24, 0xE0	; 224
    2e0c:	97 e0       	ldi	r25, 0x07	; 7
    2e0e:	cc df       	rcall	.-104    	; 0x2da8 <ioport_configure_port_pin>
    2e10:	43 e0       	ldi	r20, 0x03	; 3
    2e12:	50 e0       	ldi	r21, 0x00	; 0
    2e14:	60 e1       	ldi	r22, 0x10	; 16
    2e16:	80 e6       	ldi	r24, 0x60	; 96
    2e18:	96 e0       	ldi	r25, 0x06	; 6
    2e1a:	c6 df       	rcall	.-116    	; 0x2da8 <ioport_configure_port_pin>
    2e1c:	41 e0       	ldi	r20, 0x01	; 1
    2e1e:	50 e4       	ldi	r21, 0x40	; 64
    2e20:	60 e2       	ldi	r22, 0x20	; 32
    2e22:	80 e6       	ldi	r24, 0x60	; 96
    2e24:	96 e0       	ldi	r25, 0x06	; 6
    2e26:	c0 df       	rcall	.-128    	; 0x2da8 <ioport_configure_port_pin>
    2e28:	40 e0       	ldi	r20, 0x00	; 0
    2e2a:	5b e1       	ldi	r21, 0x1B	; 27
    2e2c:	60 e2       	ldi	r22, 0x20	; 32
    2e2e:	80 e8       	ldi	r24, 0x80	; 128
    2e30:	96 e0       	ldi	r25, 0x06	; 6
    2e32:	ba df       	rcall	.-140    	; 0x2da8 <ioport_configure_port_pin>
    2e34:	40 e0       	ldi	r20, 0x00	; 0
    2e36:	5b e1       	ldi	r21, 0x1B	; 27
    2e38:	62 e0       	ldi	r22, 0x02	; 2
    2e3a:	80 ea       	ldi	r24, 0xA0	; 160
    2e3c:	96 e0       	ldi	r25, 0x06	; 6
    2e3e:	b4 df       	rcall	.-152    	; 0x2da8 <ioport_configure_port_pin>
    2e40:	40 e0       	ldi	r20, 0x00	; 0
    2e42:	5b e1       	ldi	r21, 0x1B	; 27
    2e44:	64 e0       	ldi	r22, 0x04	; 4
    2e46:	80 ea       	ldi	r24, 0xA0	; 160
    2e48:	96 e0       	ldi	r25, 0x06	; 6
    2e4a:	ae df       	rcall	.-164    	; 0x2da8 <ioport_configure_port_pin>
    2e4c:	43 e0       	ldi	r20, 0x03	; 3
    2e4e:	50 e0       	ldi	r21, 0x00	; 0
    2e50:	62 e0       	ldi	r22, 0x02	; 2
    2e52:	80 e6       	ldi	r24, 0x60	; 96
    2e54:	96 e0       	ldi	r25, 0x06	; 6
    2e56:	a8 df       	rcall	.-176    	; 0x2da8 <ioport_configure_port_pin>
    2e58:	43 e0       	ldi	r20, 0x03	; 3
    2e5a:	50 e0       	ldi	r21, 0x00	; 0
    2e5c:	68 e0       	ldi	r22, 0x08	; 8
    2e5e:	80 e6       	ldi	r24, 0x60	; 96
    2e60:	96 e0       	ldi	r25, 0x06	; 6
    2e62:	a2 df       	rcall	.-188    	; 0x2da8 <ioport_configure_port_pin>
    2e64:	43 e0       	ldi	r20, 0x03	; 3
    2e66:	50 e0       	ldi	r21, 0x00	; 0
    2e68:	68 e0       	ldi	r22, 0x08	; 8
    2e6a:	80 ea       	ldi	r24, 0xA0	; 160
    2e6c:	96 e0       	ldi	r25, 0x06	; 6
    2e6e:	9c df       	rcall	.-200    	; 0x2da8 <ioport_configure_port_pin>
    2e70:	43 e0       	ldi	r20, 0x03	; 3
    2e72:	50 e0       	ldi	r21, 0x00	; 0
    2e74:	61 e0       	ldi	r22, 0x01	; 1
    2e76:	80 e6       	ldi	r24, 0x60	; 96
    2e78:	96 e0       	ldi	r25, 0x06	; 6
    2e7a:	96 df       	rcall	.-212    	; 0x2da8 <ioport_configure_port_pin>
    2e7c:	43 e0       	ldi	r20, 0x03	; 3
    2e7e:	50 e0       	ldi	r21, 0x00	; 0
    2e80:	68 e0       	ldi	r22, 0x08	; 8
    2e82:	80 e0       	ldi	r24, 0x00	; 0
    2e84:	96 e0       	ldi	r25, 0x06	; 6
    2e86:	90 df       	rcall	.-224    	; 0x2da8 <ioport_configure_port_pin>
    2e88:	41 e0       	ldi	r20, 0x01	; 1
    2e8a:	50 e0       	ldi	r21, 0x00	; 0
    2e8c:	60 e1       	ldi	r22, 0x10	; 16
    2e8e:	80 e8       	ldi	r24, 0x80	; 128
    2e90:	96 e0       	ldi	r25, 0x06	; 6
    2e92:	8a df       	rcall	.-236    	; 0x2da8 <ioport_configure_port_pin>
    2e94:	43 e0       	ldi	r20, 0x03	; 3
    2e96:	50 e0       	ldi	r21, 0x00	; 0
    2e98:	62 e0       	ldi	r22, 0x02	; 2
    2e9a:	80 e6       	ldi	r24, 0x60	; 96
    2e9c:	96 e0       	ldi	r25, 0x06	; 6
    2e9e:	84 df       	rcall	.-248    	; 0x2da8 <ioport_configure_port_pin>
    2ea0:	43 e0       	ldi	r20, 0x03	; 3
    2ea2:	50 e0       	ldi	r21, 0x00	; 0
    2ea4:	68 e0       	ldi	r22, 0x08	; 8
    2ea6:	80 e6       	ldi	r24, 0x60	; 96
    2ea8:	96 e0       	ldi	r25, 0x06	; 6
    2eaa:	7e df       	rcall	.-260    	; 0x2da8 <ioport_configure_port_pin>
    2eac:	40 e0       	ldi	r20, 0x00	; 0
    2eae:	50 e0       	ldi	r21, 0x00	; 0
    2eb0:	64 e0       	ldi	r22, 0x04	; 4
    2eb2:	80 e6       	ldi	r24, 0x60	; 96
    2eb4:	96 e0       	ldi	r25, 0x06	; 6
    2eb6:	78 df       	rcall	.-272    	; 0x2da8 <ioport_configure_port_pin>
    2eb8:	43 e0       	ldi	r20, 0x03	; 3
    2eba:	50 e0       	ldi	r21, 0x00	; 0
    2ebc:	60 e1       	ldi	r22, 0x10	; 16
    2ebe:	80 ea       	ldi	r24, 0xA0	; 160
    2ec0:	96 e0       	ldi	r25, 0x06	; 6
    2ec2:	72 df       	rcall	.-284    	; 0x2da8 <ioport_configure_port_pin>
    2ec4:	40 e0       	ldi	r20, 0x00	; 0
    2ec6:	50 e0       	ldi	r21, 0x00	; 0
    2ec8:	61 e0       	ldi	r22, 0x01	; 1
    2eca:	80 e0       	ldi	r24, 0x00	; 0
    2ecc:	96 e0       	ldi	r25, 0x06	; 6
    2ece:	6c df       	rcall	.-296    	; 0x2da8 <ioport_configure_port_pin>
    2ed0:	40 e0       	ldi	r20, 0x00	; 0
    2ed2:	50 e0       	ldi	r21, 0x00	; 0
    2ed4:	64 e0       	ldi	r22, 0x04	; 4
    2ed6:	80 e0       	ldi	r24, 0x00	; 0
    2ed8:	96 e0       	ldi	r25, 0x06	; 6
    2eda:	66 df       	rcall	.-308    	; 0x2da8 <ioport_configure_port_pin>
    2edc:	40 e0       	ldi	r20, 0x00	; 0
    2ede:	50 e0       	ldi	r21, 0x00	; 0
    2ee0:	62 e0       	ldi	r22, 0x02	; 2
    2ee2:	80 e2       	ldi	r24, 0x20	; 32
    2ee4:	96 e0       	ldi	r25, 0x06	; 6
    2ee6:	60 df       	rcall	.-320    	; 0x2da8 <ioport_configure_port_pin>
    2ee8:	43 e0       	ldi	r20, 0x03	; 3
    2eea:	50 e0       	ldi	r21, 0x00	; 0
    2eec:	68 e0       	ldi	r22, 0x08	; 8
    2eee:	80 e4       	ldi	r24, 0x40	; 64
    2ef0:	96 e0       	ldi	r25, 0x06	; 6
    2ef2:	5a df       	rcall	.-332    	; 0x2da8 <ioport_configure_port_pin>
    2ef4:	40 e0       	ldi	r20, 0x00	; 0
    2ef6:	50 e0       	ldi	r21, 0x00	; 0
    2ef8:	64 e0       	ldi	r22, 0x04	; 4
    2efa:	80 e4       	ldi	r24, 0x40	; 64
    2efc:	96 e0       	ldi	r25, 0x06	; 6
    2efe:	54 df       	rcall	.-344    	; 0x2da8 <ioport_configure_port_pin>
    2f00:	43 e0       	ldi	r20, 0x03	; 3
    2f02:	50 e0       	ldi	r21, 0x00	; 0
    2f04:	68 e0       	ldi	r22, 0x08	; 8
    2f06:	80 e6       	ldi	r24, 0x60	; 96
    2f08:	96 e0       	ldi	r25, 0x06	; 6
    2f0a:	4e df       	rcall	.-356    	; 0x2da8 <ioport_configure_port_pin>
    2f0c:	40 e0       	ldi	r20, 0x00	; 0
    2f0e:	50 e0       	ldi	r21, 0x00	; 0
    2f10:	64 e0       	ldi	r22, 0x04	; 4
    2f12:	80 e6       	ldi	r24, 0x60	; 96
    2f14:	96 e0       	ldi	r25, 0x06	; 6
    2f16:	48 df       	rcall	.-368    	; 0x2da8 <ioport_configure_port_pin>
    2f18:	43 e0       	ldi	r20, 0x03	; 3
    2f1a:	50 e0       	ldi	r21, 0x00	; 0
    2f1c:	68 e0       	ldi	r22, 0x08	; 8
    2f1e:	80 e8       	ldi	r24, 0x80	; 128
    2f20:	96 e0       	ldi	r25, 0x06	; 6
    2f22:	42 df       	rcall	.-380    	; 0x2da8 <ioport_configure_port_pin>
    2f24:	40 e0       	ldi	r20, 0x00	; 0
    2f26:	50 e0       	ldi	r21, 0x00	; 0
    2f28:	64 e0       	ldi	r22, 0x04	; 4
    2f2a:	80 e8       	ldi	r24, 0x80	; 128
    2f2c:	96 e0       	ldi	r25, 0x06	; 6
    2f2e:	3c cf       	rjmp	.-392    	; 0x2da8 <ioport_configure_port_pin>
    2f30:	08 95       	ret

00002f32 <vTimerCallback>:
static portTASK_FUNCTION_PROTO(testTempS, p_);
static portTASK_FUNCTION_PROTO(testServo, p_);
static portTASK_FUNCTION_PROTO(testPot, p_);

void vTimerCallback(){
	increment++;
    2f32:	80 91 91 23 	lds	r24, 0x2391
    2f36:	90 91 92 23 	lds	r25, 0x2392
    2f3a:	a0 91 93 23 	lds	r26, 0x2393
    2f3e:	b0 91 94 23 	lds	r27, 0x2394
    2f42:	01 96       	adiw	r24, 0x01	; 1
    2f44:	a1 1d       	adc	r26, r1
    2f46:	b1 1d       	adc	r27, r1
    2f48:	80 93 91 23 	sts	0x2391, r24
    2f4c:	90 93 92 23 	sts	0x2392, r25
    2f50:	a0 93 93 23 	sts	0x2393, r26
    2f54:	b0 93 94 23 	sts	0x2394, r27
    2f58:	08 95       	ret

00002f5a <testLamp>:
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    2f5a:	c0 ee       	ldi	r28, 0xE0	; 224
    2f5c:	d7 e0       	ldi	r29, 0x07	; 7
    2f5e:	11 e0       	ldi	r17, 0x01	; 1
    2f60:	01 2f       	mov	r16, r17
    2f62:	0e 83       	std	Y+6, r16	; 0x06
static portTASK_FUNCTION(testLamp, p_){
	//ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, false);
	
	while(1){
		gpio_set_pin_low(LED0_GPIO);
		vTaskDelay(100/portTICK_PERIOD_MS);
    2f64:	82 e3       	ldi	r24, 0x32	; 50
    2f66:	90 e0       	ldi	r25, 0x00	; 0
    2f68:	9b db       	rcall	.-2250   	; 0x26a0 <vTaskDelay>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2f6a:	1d 83       	std	Y+5, r17	; 0x05
		gpio_set_pin_high(LED0_GPIO);
		vTaskDelay(100/portTICK_PERIOD_MS);
    2f6c:	82 e3       	ldi	r24, 0x32	; 50
    2f6e:	90 e0       	ldi	r25, 0x00	; 0
    2f70:	97 db       	rcall	.-2258   	; 0x26a0 <vTaskDelay>
    2f72:	f7 cf       	rjmp	.-18     	; 0x2f62 <testLamp+0x8>

00002f74 <testPot>:
	return result;
}

static uint16_t adc_read3(){
	uint16_t result;
	adc_enable(&MY_ADC3);
    2f74:	c0 e0       	ldi	r28, 0x00	; 0
    2f76:	d2 e0       	ldi	r29, 0x02	; 2
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    2f78:	68 94       	set
    2f7a:	ff 24       	eor	r15, r15
    2f7c:	f2 f8       	bld	r15, 2
	adc_start_conversion(&MY_ADC3, MY_ADC3_CH);
	adc_wait_for_interrupt_flag(&MY_ADC3, MY_ADC3_CH);
	result = adc_get_result(&MY_ADC3, MY_ADC3_CH);
    2f7e:	00 e3       	ldi	r16, 0x30	; 48
    2f80:	12 e0       	ldi	r17, 0x02	; 2
	return result;
}

static uint16_t adc_read3(){
	uint16_t result;
	adc_enable(&MY_ADC3);
    2f82:	ce 01       	movw	r24, r28
    2f84:	0e 94 5f 07 	call	0xebe	; 0xebe <adc_enable>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    2f88:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
    2f8a:	f8 94       	cli
 */
static inline void adc_start_conversion(ADC_t *adc, uint8_t ch_mask)
{
	irqflags_t flags = cpu_irq_save();
#if !XMEGA_E
	adc->CTRLA |= ch_mask << ADC_CH0START_bp;
    2f8c:	98 81       	ld	r25, Y
    2f8e:	90 61       	ori	r25, 0x10	; 16
    2f90:	98 83       	st	Y, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    2f92:	8f bf       	out	0x3f, r24	; 63
 *
 * \return Mask with interrupt flags.
 */
static inline uint8_t adc_get_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	return (adc->INTFLAGS >> ADC_CH0IF_bp) & ch_mask;
    2f94:	8e 81       	ldd	r24, Y+6	; 0x06
 * \arg \c ADC_CHn , where \c n specifies the channel. (These can be OR'ed
 * together.)
 */
static inline void adc_wait_for_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	do { } while (adc_get_interrupt_flag(adc, ch_mask) != ch_mask);
    2f96:	82 ff       	sbrs	r24, 2
    2f98:	fd cf       	rjmp	.-6      	; 0x2f94 <testPot+0x20>
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    2f9a:	fe 82       	std	Y+6, r15	; 0x06
	adc_start_conversion(&MY_ADC3, MY_ADC3_CH);
	adc_wait_for_interrupt_flag(&MY_ADC3, MY_ADC3_CH);
	result = adc_get_result(&MY_ADC3, MY_ADC3_CH);
    2f9c:	f8 01       	movw	r30, r16
    2f9e:	84 81       	ldd	r24, Z+4	; 0x04
    2fa0:	95 81       	ldd	r25, Z+5	; 0x05
	}
}

static portTASK_FUNCTION(testPot, p_){
	while(1){
		result3 = adc_read3();
    2fa2:	80 93 95 23 	sts	0x2395, r24
    2fa6:	90 93 96 23 	sts	0x2396, r25
		vTaskDelay(10/portTICK_PERIOD_MS);
    2faa:	85 e0       	ldi	r24, 0x05	; 5
    2fac:	90 e0       	ldi	r25, 0x00	; 0
    2fae:	78 db       	rcall	.-2320   	; 0x26a0 <vTaskDelay>
	}
    2fb0:	e8 cf       	rjmp	.-48     	; 0x2f82 <testPot+0xe>

00002fb2 <testTempS>:
	return result;
}

static uint16_t adc_read2(){
	uint16_t result;
	adc_enable(&MY_ADC2);
    2fb2:	c0 e0       	ldi	r28, 0x00	; 0
    2fb4:	d2 e0       	ldi	r29, 0x02	; 2
    2fb6:	68 94       	set
    2fb8:	ff 24       	eor	r15, r15
    2fba:	f1 f8       	bld	r15, 1
	adc_start_conversion(&MY_ADC2, MY_ADC2_CH);
	adc_wait_for_interrupt_flag(&MY_ADC2, MY_ADC2_CH);
	result = adc_get_result(&MY_ADC2, MY_ADC2_CH);
    2fbc:	08 e2       	ldi	r16, 0x28	; 40
    2fbe:	12 e0       	ldi	r17, 0x02	; 2
	return result;
}

static uint16_t adc_read2(){
	uint16_t result;
	adc_enable(&MY_ADC2);
    2fc0:	ce 01       	movw	r24, r28
    2fc2:	0e 94 5f 07 	call	0xebe	; 0xebe <adc_enable>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    2fc6:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
    2fc8:	f8 94       	cli
 */
static inline void adc_start_conversion(ADC_t *adc, uint8_t ch_mask)
{
	irqflags_t flags = cpu_irq_save();
#if !XMEGA_E
	adc->CTRLA |= ch_mask << ADC_CH0START_bp;
    2fca:	98 81       	ld	r25, Y
    2fcc:	98 60       	ori	r25, 0x08	; 8
    2fce:	98 83       	st	Y, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    2fd0:	8f bf       	out	0x3f, r24	; 63
 *
 * \return Mask with interrupt flags.
 */
static inline uint8_t adc_get_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	return (adc->INTFLAGS >> ADC_CH0IF_bp) & ch_mask;
    2fd2:	8e 81       	ldd	r24, Y+6	; 0x06
 * \arg \c ADC_CHn , where \c n specifies the channel. (These can be OR'ed
 * together.)
 */
static inline void adc_wait_for_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	do { } while (adc_get_interrupt_flag(adc, ch_mask) != ch_mask);
    2fd4:	81 ff       	sbrs	r24, 1
    2fd6:	fd cf       	rjmp	.-6      	; 0x2fd2 <testTempS+0x20>
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    2fd8:	fe 82       	std	Y+6, r15	; 0x06
	adc_start_conversion(&MY_ADC2, MY_ADC2_CH);
	adc_wait_for_interrupt_flag(&MY_ADC2, MY_ADC2_CH);
	result = adc_get_result(&MY_ADC2, MY_ADC2_CH);
    2fda:	f8 01       	movw	r30, r16
    2fdc:	84 81       	ldd	r24, Z+4	; 0x04
    2fde:	95 81       	ldd	r25, Z+5	; 0x05
	}
}

static portTASK_FUNCTION(testTempS, p_){
	while(1){
		result2 = adc_read2();
    2fe0:	80 93 97 23 	sts	0x2397, r24
    2fe4:	90 93 98 23 	sts	0x2398, r25
		vTaskDelay(10/portTICK_PERIOD_MS);
    2fe8:	85 e0       	ldi	r24, 0x05	; 5
    2fea:	90 e0       	ldi	r25, 0x00	; 0
    2fec:	59 db       	rcall	.-2382   	; 0x26a0 <vTaskDelay>
	}
    2fee:	e8 cf       	rjmp	.-48     	; 0x2fc0 <testTempS+0xe>

00002ff0 <testLightS>:
	adcch_write_configuration(&MY_ADC3, MY_ADC3_CH, &adcch_conf);
}

static uint16_t adc_read(){
	uint16_t result;
	adc_enable(&MY_ADC);
    2ff0:	c0 e0       	ldi	r28, 0x00	; 0
    2ff2:	d2 e0       	ldi	r29, 0x02	; 2
    2ff4:	11 e0       	ldi	r17, 0x01	; 1
    2ff6:	ce 01       	movw	r24, r28
    2ff8:	0e 94 5f 07 	call	0xebe	; 0xebe <adc_enable>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    2ffc:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
    2ffe:	f8 94       	cli
 */
static inline void adc_start_conversion(ADC_t *adc, uint8_t ch_mask)
{
	irqflags_t flags = cpu_irq_save();
#if !XMEGA_E
	adc->CTRLA |= ch_mask << ADC_CH0START_bp;
    3000:	98 81       	ld	r25, Y
    3002:	94 60       	ori	r25, 0x04	; 4
    3004:	98 83       	st	Y, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    3006:	8f bf       	out	0x3f, r24	; 63
 *
 * \return Mask with interrupt flags.
 */
static inline uint8_t adc_get_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	return (adc->INTFLAGS >> ADC_CH0IF_bp) & ch_mask;
    3008:	8e 81       	ldd	r24, Y+6	; 0x06
 * \arg \c ADC_CHn , where \c n specifies the channel. (These can be OR'ed
 * together.)
 */
static inline void adc_wait_for_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	do { } while (adc_get_interrupt_flag(adc, ch_mask) != ch_mask);
    300a:	80 ff       	sbrs	r24, 0
    300c:	fd cf       	rjmp	.-6      	; 0x3008 <testLightS+0x18>
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    300e:	1e 83       	std	Y+6, r17	; 0x06
	adc_start_conversion(&MY_ADC, MY_ADC_CH);
	adc_wait_for_interrupt_flag(&MY_ADC, MY_ADC_CH);
	result = adc_get_result(&MY_ADC, MY_ADC_CH);
    3010:	8c a1       	ldd	r24, Y+36	; 0x24
    3012:	9d a1       	ldd	r25, Y+37	; 0x25
	}
}

static portTASK_FUNCTION(testLightS, p_){
	while(1){
		result = adc_read();
    3014:	80 93 99 23 	sts	0x2399, r24
    3018:	90 93 9a 23 	sts	0x239A, r25
		vTaskDelay(10/portTICK_PERIOD_MS);
    301c:	85 e0       	ldi	r24, 0x05	; 5
    301e:	90 e0       	ldi	r25, 0x00	; 0
    3020:	3f db       	rcall	.-2434   	; 0x26a0 <vTaskDelay>
	}
    3022:	e9 cf       	rjmp	.-46     	; 0x2ff6 <testLightS+0x6>

00003024 <testLCD>:
    3024:	80 e1       	ldi	r24, 0x10	; 16
    3026:	e0 e8       	ldi	r30, 0x80	; 128
    3028:	f6 e0       	ldi	r31, 0x06	; 6
    302a:	85 83       	std	Z+5, r24	; 0x05
static portTASK_FUNCTION(testLCD, p_){
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	while(1){
		
		//print light
		snprintf(strbuf, sizeof(strbuf), "Read Light : %3d",result);
    302c:	0f 2e       	mov	r0, r31
    302e:	fa e1       	ldi	r31, 0x1A	; 26
    3030:	cf 2e       	mov	r12, r31
    3032:	f0 e2       	ldi	r31, 0x20	; 32
    3034:	df 2e       	mov	r13, r31
    3036:	f0 2d       	mov	r31, r0
    3038:	0f 2e       	mov	r0, r31
    303a:	f9 ec       	ldi	r31, 0xC9	; 201
    303c:	bf 2e       	mov	r11, r31
    303e:	f0 2d       	mov	r31, r0
    3040:	c8 ec       	ldi	r28, 0xC8	; 200
    3042:	d2 e2       	ldi	r29, 0x22	; 34
		gfx_mono_draw_string(strbuf,0, 0, &sysfont);
		
		//print temp
		snprintf(strbuf, sizeof(strbuf), "Read Temp : %3d",result2);
    3044:	0f 2e       	mov	r0, r31
    3046:	fb e2       	ldi	r31, 0x2B	; 43
    3048:	ef 2e       	mov	r14, r31
    304a:	f0 e2       	ldi	r31, 0x20	; 32
    304c:	ff 2e       	mov	r15, r31
    304e:	f0 2d       	mov	r31, r0
		gfx_mono_draw_string(strbuf,0, 10, &sysfont);
		
		//print timer
		//snprintf(strbuf, sizeof(strbuf), "Timer : %3d",increment);
		snprintf(strbuf, sizeof(strbuf), "Read Pot : %3d",result3);
    3050:	0b e3       	ldi	r16, 0x3B	; 59
    3052:	10 e2       	ldi	r17, 0x20	; 32
static portTASK_FUNCTION(testLCD, p_){
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	while(1){
		
		//print light
		snprintf(strbuf, sizeof(strbuf), "Read Light : %3d",result);
    3054:	80 91 9a 23 	lds	r24, 0x239A
    3058:	8f 93       	push	r24
    305a:	80 91 99 23 	lds	r24, 0x2399
    305e:	8f 93       	push	r24
    3060:	df 92       	push	r13
    3062:	cf 92       	push	r12
    3064:	1f 92       	push	r1
    3066:	bf 92       	push	r11
    3068:	df 93       	push	r29
    306a:	cf 93       	push	r28
    306c:	e1 d2       	rcall	.+1474   	; 0x3630 <snprintf>
		gfx_mono_draw_string(strbuf,0, 0, &sysfont);
    306e:	26 e0       	ldi	r18, 0x06	; 6
    3070:	30 e2       	ldi	r19, 0x20	; 32
    3072:	40 e0       	ldi	r20, 0x00	; 0
    3074:	60 e0       	ldi	r22, 0x00	; 0
    3076:	ce 01       	movw	r24, r28
    3078:	0e 94 85 06 	call	0xd0a	; 0xd0a <gfx_mono_draw_string>
		
		//print temp
		snprintf(strbuf, sizeof(strbuf), "Read Temp : %3d",result2);
    307c:	80 91 98 23 	lds	r24, 0x2398
    3080:	8f 93       	push	r24
    3082:	80 91 97 23 	lds	r24, 0x2397
    3086:	8f 93       	push	r24
    3088:	ff 92       	push	r15
    308a:	ef 92       	push	r14
    308c:	1f 92       	push	r1
    308e:	bf 92       	push	r11
    3090:	df 93       	push	r29
    3092:	cf 93       	push	r28
    3094:	cd d2       	rcall	.+1434   	; 0x3630 <snprintf>
		gfx_mono_draw_string(strbuf,0, 10, &sysfont);
    3096:	26 e0       	ldi	r18, 0x06	; 6
    3098:	30 e2       	ldi	r19, 0x20	; 32
    309a:	4a e0       	ldi	r20, 0x0A	; 10
    309c:	60 e0       	ldi	r22, 0x00	; 0
    309e:	ce 01       	movw	r24, r28
    30a0:	0e 94 85 06 	call	0xd0a	; 0xd0a <gfx_mono_draw_string>
		
		//print timer
		//snprintf(strbuf, sizeof(strbuf), "Timer : %3d",increment);
		snprintf(strbuf, sizeof(strbuf), "Read Pot : %3d",result3);
    30a4:	80 91 96 23 	lds	r24, 0x2396
    30a8:	8f 93       	push	r24
    30aa:	80 91 95 23 	lds	r24, 0x2395
    30ae:	8f 93       	push	r24
    30b0:	1f 93       	push	r17
    30b2:	0f 93       	push	r16
    30b4:	1f 92       	push	r1
    30b6:	bf 92       	push	r11
    30b8:	df 93       	push	r29
    30ba:	cf 93       	push	r28
    30bc:	b9 d2       	rcall	.+1394   	; 0x3630 <snprintf>
		gfx_mono_draw_string(strbuf,0, 20, &sysfont);
    30be:	26 e0       	ldi	r18, 0x06	; 6
    30c0:	30 e2       	ldi	r19, 0x20	; 32
    30c2:	44 e1       	ldi	r20, 0x14	; 20
    30c4:	60 e0       	ldi	r22, 0x00	; 0
    30c6:	ce 01       	movw	r24, r28
    30c8:	0e 94 85 06 	call	0xd0a	; 0xd0a <gfx_mono_draw_string>
		
		vTaskDelay(5/portTICK_PERIOD_MS);
    30cc:	82 e0       	ldi	r24, 0x02	; 2
    30ce:	90 e0       	ldi	r25, 0x00	; 0
    30d0:	e7 da       	rcall	.-2610   	; 0x26a0 <vTaskDelay>
    30d2:	8d b7       	in	r24, 0x3d	; 61
    30d4:	9e b7       	in	r25, 0x3e	; 62
    30d6:	48 96       	adiw	r24, 0x18	; 24
    30d8:	8d bf       	out	0x3d, r24	; 61
    30da:	9e bf       	out	0x3e, r25	; 62
    30dc:	bb cf       	rjmp	.-138    	; 0x3054 <testLCD+0x30>

000030de <PWM_Init>:
}

void PWM_Init(void)
{
	/* Set output */
	PORTC.DIR |= PIN0_bm;
    30de:	e0 e4       	ldi	r30, 0x40	; 64
    30e0:	f6 e0       	ldi	r31, 0x06	; 6
    30e2:	80 81       	ld	r24, Z
    30e4:	81 60       	ori	r24, 0x01	; 1
    30e6:	80 83       	st	Z, r24

	/* Set Register */
	TCC0.CTRLA = (PIN2_bm) | (PIN0_bm);
    30e8:	e0 e0       	ldi	r30, 0x00	; 0
    30ea:	f8 e0       	ldi	r31, 0x08	; 8
    30ec:	85 e0       	ldi	r24, 0x05	; 5
    30ee:	80 83       	st	Z, r24
	TCC0.CTRLB = (PIN4_bm) | (PIN2_bm) | (PIN1_bm);
    30f0:	86 e1       	ldi	r24, 0x16	; 22
    30f2:	81 83       	std	Z+1, r24	; 0x01
	
	/* Set Period */
	TCC0.PER = 1000;
    30f4:	88 ee       	ldi	r24, 0xE8	; 232
    30f6:	93 e0       	ldi	r25, 0x03	; 3
    30f8:	86 a3       	std	Z+38, r24	; 0x26
    30fa:	97 a3       	std	Z+39, r25	; 0x27

	/* Set Compare Register value*/
	TCC0.CCA = 375;
    30fc:	87 e7       	ldi	r24, 0x77	; 119
    30fe:	91 e0       	ldi	r25, 0x01	; 1
    3100:	80 a7       	std	Z+40, r24	; 0x28
    3102:	91 a7       	std	Z+41, r25	; 0x29
    3104:	08 95       	ret

00003106 <testServo>:
	}
}


static portTASK_FUNCTION(testServo, p_){
	PWM_Init();
    3106:	eb df       	rcall	.-42     	; 0x30de <PWM_Init>

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	return base->IN & arch_ioport_pin_to_mask(pin);
    3108:	e0 ea       	ldi	r30, 0xA0	; 160
    310a:	f6 e0       	ldi	r31, 0x06	; 6
			TCC0.CCA = 1;
			gpio_set_pin_low(LED3_GPIO);
			gpio_set_pin_high(LED2_GPIO);
			door = 2;
		}else if(gpio_pin_is_high(GPIO_PUSH_BUTTON_1) && gpio_pin_is_high(GPIO_PUSH_BUTTON_2)){
			TCC0.CCA = 350;
    310c:	c0 e0       	ldi	r28, 0x00	; 0
    310e:	d8 e0       	ldi	r29, 0x08	; 8
    3110:	4e e5       	ldi	r20, 0x5E	; 94
    3112:	51 e0       	ldi	r21, 0x01	; 1
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3114:	a0 e6       	ldi	r26, 0x60	; 96
    3116:	b6 e0       	ldi	r27, 0x06	; 6
    3118:	10 e2       	ldi	r17, 0x20	; 32
    311a:	70 e1       	ldi	r23, 0x10	; 16
			TCC0.CCA = 130;
			gpio_set_pin_low(LED2_GPIO);
			gpio_set_pin_high(LED3_GPIO);
			door = 1;
		}else if(gpio_pin_is_low(GPIO_PUSH_BUTTON_2) && gpio_pin_is_high(GPIO_PUSH_BUTTON_1)){
			TCC0.CCA = 1;
    311c:	21 e0       	ldi	r18, 0x01	; 1
    311e:	30 e0       	ldi	r19, 0x00	; 0
	PWM_Init();
	
	while(1){
		if(gpio_pin_is_low(GPIO_PUSH_BUTTON_1) && gpio_pin_is_high(GPIO_PUSH_BUTTON_2)){
			//delay_ms(50);
			TCC0.CCA = 130;
    3120:	82 e8       	ldi	r24, 0x82	; 130
    3122:	90 e0       	ldi	r25, 0x00	; 0

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	return base->IN & arch_ioport_pin_to_mask(pin);
    3124:	60 85       	ldd	r22, Z+8	; 0x08

static portTASK_FUNCTION(testServo, p_){
	PWM_Init();
	
	while(1){
		if(gpio_pin_is_low(GPIO_PUSH_BUTTON_1) && gpio_pin_is_high(GPIO_PUSH_BUTTON_2)){
    3126:	61 fd       	sbrc	r22, 1
    3128:	0c c0       	rjmp	.+24     	; 0x3142 <testServo+0x3c>
    312a:	60 85       	ldd	r22, Z+8	; 0x08
    312c:	62 ff       	sbrs	r22, 2
    312e:	09 c0       	rjmp	.+18     	; 0x3142 <testServo+0x3c>
			//delay_ms(50);
			TCC0.CCA = 130;
    3130:	88 a7       	std	Y+40, r24	; 0x28
    3132:	99 a7       	std	Y+41, r25	; 0x29
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    3134:	16 96       	adiw	r26, 0x06	; 6
    3136:	7c 93       	st	X, r23
    3138:	16 97       	sbiw	r26, 0x06	; 6
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    313a:	15 96       	adiw	r26, 0x05	; 5
    313c:	1c 93       	st	X, r17
    313e:	15 97       	sbiw	r26, 0x05	; 5
			gpio_set_pin_low(LED2_GPIO);
			gpio_set_pin_high(LED3_GPIO);
			door = 1;
    3140:	f1 cf       	rjmp	.-30     	; 0x3124 <testServo+0x1e>

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	return base->IN & arch_ioport_pin_to_mask(pin);
    3142:	60 85       	ldd	r22, Z+8	; 0x08
		}else if(gpio_pin_is_low(GPIO_PUSH_BUTTON_2) && gpio_pin_is_high(GPIO_PUSH_BUTTON_1)){
    3144:	62 fd       	sbrc	r22, 2
    3146:	0c c0       	rjmp	.+24     	; 0x3160 <testServo+0x5a>
    3148:	60 85       	ldd	r22, Z+8	; 0x08
    314a:	61 ff       	sbrs	r22, 1
    314c:	09 c0       	rjmp	.+18     	; 0x3160 <testServo+0x5a>
			TCC0.CCA = 1;
    314e:	28 a7       	std	Y+40, r18	; 0x28
    3150:	39 a7       	std	Y+41, r19	; 0x29
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    3152:	16 96       	adiw	r26, 0x06	; 6
    3154:	1c 93       	st	X, r17
    3156:	16 97       	sbiw	r26, 0x06	; 6
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3158:	15 96       	adiw	r26, 0x05	; 5
    315a:	7c 93       	st	X, r23
    315c:	15 97       	sbiw	r26, 0x05	; 5
			gpio_set_pin_low(LED3_GPIO);
			gpio_set_pin_high(LED2_GPIO);
			door = 2;
    315e:	e2 cf       	rjmp	.-60     	; 0x3124 <testServo+0x1e>

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	return base->IN & arch_ioport_pin_to_mask(pin);
    3160:	60 85       	ldd	r22, Z+8	; 0x08
		}else if(gpio_pin_is_high(GPIO_PUSH_BUTTON_1) && gpio_pin_is_high(GPIO_PUSH_BUTTON_2)){
    3162:	61 ff       	sbrs	r22, 1
    3164:	df cf       	rjmp	.-66     	; 0x3124 <testServo+0x1e>
    3166:	60 85       	ldd	r22, Z+8	; 0x08
    3168:	62 ff       	sbrs	r22, 2
    316a:	dc cf       	rjmp	.-72     	; 0x3124 <testServo+0x1e>
			TCC0.CCA = 350;
    316c:	48 a7       	std	Y+40, r20	; 0x28
    316e:	59 a7       	std	Y+41, r21	; 0x29
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3170:	15 96       	adiw	r26, 0x05	; 5
    3172:	1c 93       	st	X, r17
    3174:	15 97       	sbiw	r26, 0x05	; 5
    3176:	15 96       	adiw	r26, 0x05	; 5
    3178:	7c 93       	st	X, r23
    317a:	15 97       	sbiw	r26, 0x05	; 5
    317c:	d3 cf       	rjmp	.-90     	; 0x3124 <testServo+0x1e>

0000317e <main>:
	result = adc_get_result(&MY_ADC3, MY_ADC3_CH);
	return result;
}

int main (void)
{
    317e:	8f 92       	push	r8
    3180:	9f 92       	push	r9
    3182:	af 92       	push	r10
    3184:	bf 92       	push	r11
    3186:	cf 92       	push	r12
    3188:	df 92       	push	r13
    318a:	ef 92       	push	r14
    318c:	ff 92       	push	r15
    318e:	0f 93       	push	r16
    3190:	1f 93       	push	r17
    3192:	cf 93       	push	r28
    3194:	df 93       	push	r29
    3196:	cd b7       	in	r28, 0x3d	; 61
    3198:	de b7       	in	r29, 0x3e	; 62
    319a:	2b 97       	sbiw	r28, 0x0b	; 11
    319c:	cd bf       	out	0x3d, r28	; 61
    319e:	de bf       	out	0x3e, r29	; 62
	// Insert system clock initialization code here (sysclk_init()).

	
	board_init();
    31a0:	2b de       	rcall	.-938    	; 0x2df8 <board_init>
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    31a2:	87 e0       	ldi	r24, 0x07	; 7
    31a4:	e0 ea       	ldi	r30, 0xA0	; 160
    31a6:	f0 e0       	ldi	r31, 0x00	; 0
    31a8:	82 83       	std	Z+2, r24	; 0x02
static void adc_init(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC, &adc_conf);
    31aa:	be 01       	movw	r22, r28
    31ac:	6f 5f       	subi	r22, 0xFF	; 255
    31ae:	7f 4f       	sbci	r23, 0xFF	; 255
    31b0:	80 e0       	ldi	r24, 0x00	; 0
    31b2:	92 e0       	ldi	r25, 0x02	; 2
    31b4:	0e 94 57 09 	call	0x12ae	; 0x12ae <adc_read_configuration>
	adcch_read_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    31b8:	ae 01       	movw	r20, r28
    31ba:	48 5f       	subi	r20, 0xF8	; 248
    31bc:	5f 4f       	sbci	r21, 0xFF	; 255
    31be:	61 e0       	ldi	r22, 0x01	; 1
    31c0:	80 e0       	ldi	r24, 0x00	; 0
    31c2:	92 e0       	ldi	r25, 0x02	; 2
    31c4:	0e 94 b3 09 	call	0x1366	; 0x1366 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    31c8:	8a 81       	ldd	r24, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    31ca:	9b 81       	ldd	r25, Y+3	; 0x03
    31cc:	9f 78       	andi	r25, 0x8F	; 143
	conf->refctrl |= ref;
    31ce:	90 61       	ori	r25, 0x10	; 16
    31d0:	9b 83       	std	Y+3, r25	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    31d2:	81 7e       	andi	r24, 0xE1	; 225
    31d4:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    31d6:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    31d8:	02 e0       	ldi	r16, 0x02	; 2
    31da:	0d 83       	std	Y+5, r16	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    31dc:	11 e0       	ldi	r17, 0x01	; 1
    31de:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    31e0:	19 86       	std	Y+9, r1	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN0, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC, &adc_conf);
    31e2:	be 01       	movw	r22, r28
    31e4:	6f 5f       	subi	r22, 0xFF	; 255
    31e6:	7f 4f       	sbci	r23, 0xFF	; 255
    31e8:	80 e0       	ldi	r24, 0x00	; 0
    31ea:	92 e0       	ldi	r25, 0x02	; 2
    31ec:	0e 94 06 09 	call	0x120c	; 0x120c <adc_write_configuration>
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    31f0:	ae 01       	movw	r20, r28
    31f2:	48 5f       	subi	r20, 0xF8	; 248
    31f4:	5f 4f       	sbci	r21, 0xFF	; 255
    31f6:	61 e0       	ldi	r22, 0x01	; 1
    31f8:	80 e0       	ldi	r24, 0x00	; 0
    31fa:	92 e0       	ldi	r25, 0x02	; 2
    31fc:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <adcch_write_configuration>
static void adc_init2(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC2, &adc_conf);
    3200:	be 01       	movw	r22, r28
    3202:	6f 5f       	subi	r22, 0xFF	; 255
    3204:	7f 4f       	sbci	r23, 0xFF	; 255
    3206:	80 e0       	ldi	r24, 0x00	; 0
    3208:	92 e0       	ldi	r25, 0x02	; 2
    320a:	0e 94 57 09 	call	0x12ae	; 0x12ae <adc_read_configuration>
	adcch_read_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    320e:	ae 01       	movw	r20, r28
    3210:	48 5f       	subi	r20, 0xF8	; 248
    3212:	5f 4f       	sbci	r21, 0xFF	; 255
    3214:	62 e0       	ldi	r22, 0x02	; 2
    3216:	80 e0       	ldi	r24, 0x00	; 0
    3218:	92 e0       	ldi	r25, 0x02	; 2
    321a:	0e 94 b3 09 	call	0x1366	; 0x1366 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    321e:	8a 81       	ldd	r24, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    3220:	9b 81       	ldd	r25, Y+3	; 0x03
    3222:	9f 78       	andi	r25, 0x8F	; 143
	conf->refctrl |= ref;
    3224:	90 61       	ori	r25, 0x10	; 16
    3226:	9b 83       	std	Y+3, r25	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    3228:	81 7e       	andi	r24, 0xE1	; 225
    322a:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    322c:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    322e:	0d 83       	std	Y+5, r16	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    3230:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    3232:	88 e0       	ldi	r24, 0x08	; 8
    3234:	89 87       	std	Y+9, r24	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN1, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC2, &adc_conf);
    3236:	be 01       	movw	r22, r28
    3238:	6f 5f       	subi	r22, 0xFF	; 255
    323a:	7f 4f       	sbci	r23, 0xFF	; 255
    323c:	80 e0       	ldi	r24, 0x00	; 0
    323e:	92 e0       	ldi	r25, 0x02	; 2
    3240:	0e 94 06 09 	call	0x120c	; 0x120c <adc_write_configuration>
	adcch_write_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    3244:	ae 01       	movw	r20, r28
    3246:	48 5f       	subi	r20, 0xF8	; 248
    3248:	5f 4f       	sbci	r21, 0xFF	; 255
    324a:	62 e0       	ldi	r22, 0x02	; 2
    324c:	80 e0       	ldi	r24, 0x00	; 0
    324e:	92 e0       	ldi	r25, 0x02	; 2
    3250:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <adcch_write_configuration>
static void adc_init3(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC3, &adc_conf);
    3254:	be 01       	movw	r22, r28
    3256:	6f 5f       	subi	r22, 0xFF	; 255
    3258:	7f 4f       	sbci	r23, 0xFF	; 255
    325a:	80 e0       	ldi	r24, 0x00	; 0
    325c:	92 e0       	ldi	r25, 0x02	; 2
    325e:	0e 94 57 09 	call	0x12ae	; 0x12ae <adc_read_configuration>
	adcch_read_configuration(&MY_ADC3, MY_ADC3_CH, &adcch_conf);
    3262:	ae 01       	movw	r20, r28
    3264:	48 5f       	subi	r20, 0xF8	; 248
    3266:	5f 4f       	sbci	r21, 0xFF	; 255
    3268:	64 e0       	ldi	r22, 0x04	; 4
    326a:	80 e0       	ldi	r24, 0x00	; 0
    326c:	92 e0       	ldi	r25, 0x02	; 2
    326e:	0e 94 b3 09 	call	0x1366	; 0x1366 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    3272:	8a 81       	ldd	r24, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    3274:	9b 81       	ldd	r25, Y+3	; 0x03
    3276:	9f 78       	andi	r25, 0x8F	; 143
	conf->refctrl |= ref;
    3278:	90 61       	ori	r25, 0x10	; 16
    327a:	9b 83       	std	Y+3, r25	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    327c:	81 7e       	andi	r24, 0xE1	; 225
    327e:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    3280:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    3282:	0d 83       	std	Y+5, r16	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    3284:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    3286:	80 e1       	ldi	r24, 0x10	; 16
    3288:	89 87       	std	Y+9, r24	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN2, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC3, &adc_conf);
    328a:	be 01       	movw	r22, r28
    328c:	6f 5f       	subi	r22, 0xFF	; 255
    328e:	7f 4f       	sbci	r23, 0xFF	; 255
    3290:	80 e0       	ldi	r24, 0x00	; 0
    3292:	92 e0       	ldi	r25, 0x02	; 2
    3294:	0e 94 06 09 	call	0x120c	; 0x120c <adc_write_configuration>
	adcch_write_configuration(&MY_ADC3, MY_ADC3_CH, &adcch_conf);
    3298:	ae 01       	movw	r20, r28
    329a:	48 5f       	subi	r20, 0xF8	; 248
    329c:	5f 4f       	sbci	r21, 0xFF	; 255
    329e:	64 e0       	ldi	r22, 0x04	; 4
    32a0:	80 e0       	ldi	r24, 0x00	; 0
    32a2:	92 e0       	ldi	r25, 0x02	; 2
    32a4:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <adcch_write_configuration>
	
	
	adc_init();
	adc_init2();
	adc_init3();
	gfx_mono_init();
    32a8:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <gfx_mono_st7565r_init>
	
	TimerHandle_t timerPing = xTimerCreate("tPing", 2/portTICK_PERIOD_MS, pdTRUE, (void *) 0, vTimerCallback);
    32ac:	09 e9       	ldi	r16, 0x99	; 153
    32ae:	17 e1       	ldi	r17, 0x17	; 23
    32b0:	20 e0       	ldi	r18, 0x00	; 0
    32b2:	30 e0       	ldi	r19, 0x00	; 0
    32b4:	41 e0       	ldi	r20, 0x01	; 1
    32b6:	61 e0       	ldi	r22, 0x01	; 1
    32b8:	70 e0       	ldi	r23, 0x00	; 0
    32ba:	8a e4       	ldi	r24, 0x4A	; 74
    32bc:	90 e2       	ldi	r25, 0x20	; 32
    32be:	b1 db       	rcall	.-2206   	; 0x2a22 <xTimerCreate>
    32c0:	4c 01       	movw	r8, r24
	
	xTaskCreate(testLamp,"",500,NULL,1,NULL);
    32c2:	a1 2c       	mov	r10, r1
    32c4:	b1 2c       	mov	r11, r1
    32c6:	c1 2c       	mov	r12, r1
    32c8:	d1 2c       	mov	r13, r1
    32ca:	e1 2c       	mov	r14, r1
    32cc:	f1 2c       	mov	r15, r1
    32ce:	01 e0       	ldi	r16, 0x01	; 1
    32d0:	20 e0       	ldi	r18, 0x00	; 0
    32d2:	30 e0       	ldi	r19, 0x00	; 0
    32d4:	44 ef       	ldi	r20, 0xF4	; 244
    32d6:	51 e0       	ldi	r21, 0x01	; 1
    32d8:	61 e1       	ldi	r22, 0x11	; 17
    32da:	70 e2       	ldi	r23, 0x20	; 32
    32dc:	8d ea       	ldi	r24, 0xAD	; 173
    32de:	97 e1       	ldi	r25, 0x17	; 23
    32e0:	0e 94 bc 10 	call	0x2178	; 0x2178 <xTaskGenericCreate>
	xTaskCreate(testLCD,"",500,NULL,1,NULL);
    32e4:	20 e0       	ldi	r18, 0x00	; 0
    32e6:	30 e0       	ldi	r19, 0x00	; 0
    32e8:	44 ef       	ldi	r20, 0xF4	; 244
    32ea:	51 e0       	ldi	r21, 0x01	; 1
    32ec:	61 e1       	ldi	r22, 0x11	; 17
    32ee:	70 e2       	ldi	r23, 0x20	; 32
    32f0:	82 e1       	ldi	r24, 0x12	; 18
    32f2:	98 e1       	ldi	r25, 0x18	; 24
    32f4:	0e 94 bc 10 	call	0x2178	; 0x2178 <xTaskGenericCreate>
	xTaskCreate(testLightS,"",500,NULL,1,NULL);
    32f8:	20 e0       	ldi	r18, 0x00	; 0
    32fa:	30 e0       	ldi	r19, 0x00	; 0
    32fc:	44 ef       	ldi	r20, 0xF4	; 244
    32fe:	51 e0       	ldi	r21, 0x01	; 1
    3300:	61 e1       	ldi	r22, 0x11	; 17
    3302:	70 e2       	ldi	r23, 0x20	; 32
    3304:	88 ef       	ldi	r24, 0xF8	; 248
    3306:	97 e1       	ldi	r25, 0x17	; 23
    3308:	0e 94 bc 10 	call	0x2178	; 0x2178 <xTaskGenericCreate>
	xTaskCreate(testTempS,"",500,NULL,1,NULL);
    330c:	20 e0       	ldi	r18, 0x00	; 0
    330e:	30 e0       	ldi	r19, 0x00	; 0
    3310:	44 ef       	ldi	r20, 0xF4	; 244
    3312:	51 e0       	ldi	r21, 0x01	; 1
    3314:	61 e1       	ldi	r22, 0x11	; 17
    3316:	70 e2       	ldi	r23, 0x20	; 32
    3318:	89 ed       	ldi	r24, 0xD9	; 217
    331a:	97 e1       	ldi	r25, 0x17	; 23
    331c:	0e 94 bc 10 	call	0x2178	; 0x2178 <xTaskGenericCreate>
	xTaskCreate(testServo,"",500,NULL,1,NULL);
    3320:	20 e0       	ldi	r18, 0x00	; 0
    3322:	30 e0       	ldi	r19, 0x00	; 0
    3324:	44 ef       	ldi	r20, 0xF4	; 244
    3326:	51 e0       	ldi	r21, 0x01	; 1
    3328:	61 e1       	ldi	r22, 0x11	; 17
    332a:	70 e2       	ldi	r23, 0x20	; 32
    332c:	83 e8       	ldi	r24, 0x83	; 131
    332e:	98 e1       	ldi	r25, 0x18	; 24
    3330:	0e 94 bc 10 	call	0x2178	; 0x2178 <xTaskGenericCreate>
	xTaskCreate(testPot,"",500,NULL,1,NULL);
    3334:	20 e0       	ldi	r18, 0x00	; 0
    3336:	30 e0       	ldi	r19, 0x00	; 0
    3338:	44 ef       	ldi	r20, 0xF4	; 244
    333a:	51 e0       	ldi	r21, 0x01	; 1
    333c:	61 e1       	ldi	r22, 0x11	; 17
    333e:	70 e2       	ldi	r23, 0x20	; 32
    3340:	8a eb       	ldi	r24, 0xBA	; 186
    3342:	97 e1       	ldi	r25, 0x17	; 23
    3344:	0e 94 bc 10 	call	0x2178	; 0x2178 <xTaskGenericCreate>
	
	xTimerStart(timerPing, 0);
    3348:	4e d8       	rcall	.-3940   	; 0x23e6 <xTaskGetTickCount>
    334a:	00 e0       	ldi	r16, 0x00	; 0
    334c:	10 e0       	ldi	r17, 0x00	; 0
    334e:	20 e0       	ldi	r18, 0x00	; 0
    3350:	30 e0       	ldi	r19, 0x00	; 0
    3352:	ac 01       	movw	r20, r24
    3354:	61 e0       	ldi	r22, 0x01	; 1
    3356:	c4 01       	movw	r24, r8
    3358:	9a db       	rcall	.-2252   	; 0x2a8e <xTimerGenericCommand>
	
	vTaskStartScheduler();
    335a:	0c d8       	rcall	.-4072   	; 0x2374 <vTaskStartScheduler>

	// Insert application code here, after the board has been initialized.
}
    335c:	80 e0       	ldi	r24, 0x00	; 0
    335e:	90 e0       	ldi	r25, 0x00	; 0
    3360:	2b 96       	adiw	r28, 0x0b	; 11
    3362:	cd bf       	out	0x3d, r28	; 61
    3364:	de bf       	out	0x3e, r29	; 62
    3366:	df 91       	pop	r29
    3368:	cf 91       	pop	r28
    336a:	1f 91       	pop	r17
    336c:	0f 91       	pop	r16
    336e:	ff 90       	pop	r15
    3370:	ef 90       	pop	r14
    3372:	df 90       	pop	r13
    3374:	cf 90       	pop	r12
    3376:	bf 90       	pop	r11
    3378:	af 90       	pop	r10
    337a:	9f 90       	pop	r9
    337c:	8f 90       	pop	r8
    337e:	08 95       	ret

00003380 <__udivmodsi4>:
    3380:	a1 e2       	ldi	r26, 0x21	; 33
    3382:	1a 2e       	mov	r1, r26
    3384:	aa 1b       	sub	r26, r26
    3386:	bb 1b       	sub	r27, r27
    3388:	fd 01       	movw	r30, r26
    338a:	0d c0       	rjmp	.+26     	; 0x33a6 <__udivmodsi4_ep>

0000338c <__udivmodsi4_loop>:
    338c:	aa 1f       	adc	r26, r26
    338e:	bb 1f       	adc	r27, r27
    3390:	ee 1f       	adc	r30, r30
    3392:	ff 1f       	adc	r31, r31
    3394:	a2 17       	cp	r26, r18
    3396:	b3 07       	cpc	r27, r19
    3398:	e4 07       	cpc	r30, r20
    339a:	f5 07       	cpc	r31, r21
    339c:	20 f0       	brcs	.+8      	; 0x33a6 <__udivmodsi4_ep>
    339e:	a2 1b       	sub	r26, r18
    33a0:	b3 0b       	sbc	r27, r19
    33a2:	e4 0b       	sbc	r30, r20
    33a4:	f5 0b       	sbc	r31, r21

000033a6 <__udivmodsi4_ep>:
    33a6:	66 1f       	adc	r22, r22
    33a8:	77 1f       	adc	r23, r23
    33aa:	88 1f       	adc	r24, r24
    33ac:	99 1f       	adc	r25, r25
    33ae:	1a 94       	dec	r1
    33b0:	69 f7       	brne	.-38     	; 0x338c <__udivmodsi4_loop>
    33b2:	60 95       	com	r22
    33b4:	70 95       	com	r23
    33b6:	80 95       	com	r24
    33b8:	90 95       	com	r25
    33ba:	9b 01       	movw	r18, r22
    33bc:	ac 01       	movw	r20, r24
    33be:	bd 01       	movw	r22, r26
    33c0:	cf 01       	movw	r24, r30
    33c2:	08 95       	ret

000033c4 <__tablejump2__>:
    33c4:	ee 0f       	add	r30, r30
    33c6:	ff 1f       	adc	r31, r31

000033c8 <__tablejump__>:
    33c8:	05 90       	lpm	r0, Z+
    33ca:	f4 91       	lpm	r31, Z
    33cc:	e0 2d       	mov	r30, r0
    33ce:	19 94       	eijmp

000033d0 <malloc>:
    33d0:	cf 93       	push	r28
    33d2:	df 93       	push	r29
    33d4:	82 30       	cpi	r24, 0x02	; 2
    33d6:	91 05       	cpc	r25, r1
    33d8:	10 f4       	brcc	.+4      	; 0x33de <malloc+0xe>
    33da:	82 e0       	ldi	r24, 0x02	; 2
    33dc:	90 e0       	ldi	r25, 0x00	; 0
    33de:	e0 91 a7 23 	lds	r30, 0x23A7
    33e2:	f0 91 a8 23 	lds	r31, 0x23A8
    33e6:	20 e0       	ldi	r18, 0x00	; 0
    33e8:	30 e0       	ldi	r19, 0x00	; 0
    33ea:	a0 e0       	ldi	r26, 0x00	; 0
    33ec:	b0 e0       	ldi	r27, 0x00	; 0
    33ee:	30 97       	sbiw	r30, 0x00	; 0
    33f0:	39 f1       	breq	.+78     	; 0x3440 <malloc+0x70>
    33f2:	40 81       	ld	r20, Z
    33f4:	51 81       	ldd	r21, Z+1	; 0x01
    33f6:	48 17       	cp	r20, r24
    33f8:	59 07       	cpc	r21, r25
    33fa:	b8 f0       	brcs	.+46     	; 0x342a <malloc+0x5a>
    33fc:	48 17       	cp	r20, r24
    33fe:	59 07       	cpc	r21, r25
    3400:	71 f4       	brne	.+28     	; 0x341e <malloc+0x4e>
    3402:	82 81       	ldd	r24, Z+2	; 0x02
    3404:	93 81       	ldd	r25, Z+3	; 0x03
    3406:	10 97       	sbiw	r26, 0x00	; 0
    3408:	29 f0       	breq	.+10     	; 0x3414 <malloc+0x44>
    340a:	12 96       	adiw	r26, 0x02	; 2
    340c:	8d 93       	st	X+, r24
    340e:	9c 93       	st	X, r25
    3410:	13 97       	sbiw	r26, 0x03	; 3
    3412:	2c c0       	rjmp	.+88     	; 0x346c <malloc+0x9c>
    3414:	80 93 a7 23 	sts	0x23A7, r24
    3418:	90 93 a8 23 	sts	0x23A8, r25
    341c:	27 c0       	rjmp	.+78     	; 0x346c <malloc+0x9c>
    341e:	21 15       	cp	r18, r1
    3420:	31 05       	cpc	r19, r1
    3422:	31 f0       	breq	.+12     	; 0x3430 <malloc+0x60>
    3424:	42 17       	cp	r20, r18
    3426:	53 07       	cpc	r21, r19
    3428:	18 f0       	brcs	.+6      	; 0x3430 <malloc+0x60>
    342a:	a9 01       	movw	r20, r18
    342c:	db 01       	movw	r26, r22
    342e:	01 c0       	rjmp	.+2      	; 0x3432 <malloc+0x62>
    3430:	ef 01       	movw	r28, r30
    3432:	9a 01       	movw	r18, r20
    3434:	bd 01       	movw	r22, r26
    3436:	df 01       	movw	r26, r30
    3438:	02 80       	ldd	r0, Z+2	; 0x02
    343a:	f3 81       	ldd	r31, Z+3	; 0x03
    343c:	e0 2d       	mov	r30, r0
    343e:	d7 cf       	rjmp	.-82     	; 0x33ee <malloc+0x1e>
    3440:	21 15       	cp	r18, r1
    3442:	31 05       	cpc	r19, r1
    3444:	f9 f0       	breq	.+62     	; 0x3484 <malloc+0xb4>
    3446:	28 1b       	sub	r18, r24
    3448:	39 0b       	sbc	r19, r25
    344a:	24 30       	cpi	r18, 0x04	; 4
    344c:	31 05       	cpc	r19, r1
    344e:	80 f4       	brcc	.+32     	; 0x3470 <malloc+0xa0>
    3450:	8a 81       	ldd	r24, Y+2	; 0x02
    3452:	9b 81       	ldd	r25, Y+3	; 0x03
    3454:	61 15       	cp	r22, r1
    3456:	71 05       	cpc	r23, r1
    3458:	21 f0       	breq	.+8      	; 0x3462 <malloc+0x92>
    345a:	fb 01       	movw	r30, r22
    345c:	82 83       	std	Z+2, r24	; 0x02
    345e:	93 83       	std	Z+3, r25	; 0x03
    3460:	04 c0       	rjmp	.+8      	; 0x346a <malloc+0x9a>
    3462:	80 93 a7 23 	sts	0x23A7, r24
    3466:	90 93 a8 23 	sts	0x23A8, r25
    346a:	fe 01       	movw	r30, r28
    346c:	32 96       	adiw	r30, 0x02	; 2
    346e:	44 c0       	rjmp	.+136    	; 0x34f8 <malloc+0x128>
    3470:	fe 01       	movw	r30, r28
    3472:	e2 0f       	add	r30, r18
    3474:	f3 1f       	adc	r31, r19
    3476:	81 93       	st	Z+, r24
    3478:	91 93       	st	Z+, r25
    347a:	22 50       	subi	r18, 0x02	; 2
    347c:	31 09       	sbc	r19, r1
    347e:	28 83       	st	Y, r18
    3480:	39 83       	std	Y+1, r19	; 0x01
    3482:	3a c0       	rjmp	.+116    	; 0x34f8 <malloc+0x128>
    3484:	20 91 a5 23 	lds	r18, 0x23A5
    3488:	30 91 a6 23 	lds	r19, 0x23A6
    348c:	23 2b       	or	r18, r19
    348e:	41 f4       	brne	.+16     	; 0x34a0 <malloc+0xd0>
    3490:	20 91 02 20 	lds	r18, 0x2002
    3494:	30 91 03 20 	lds	r19, 0x2003
    3498:	20 93 a5 23 	sts	0x23A5, r18
    349c:	30 93 a6 23 	sts	0x23A6, r19
    34a0:	20 91 00 20 	lds	r18, 0x2000
    34a4:	30 91 01 20 	lds	r19, 0x2001
    34a8:	21 15       	cp	r18, r1
    34aa:	31 05       	cpc	r19, r1
    34ac:	41 f4       	brne	.+16     	; 0x34be <malloc+0xee>
    34ae:	2d b7       	in	r18, 0x3d	; 61
    34b0:	3e b7       	in	r19, 0x3e	; 62
    34b2:	40 91 04 20 	lds	r20, 0x2004
    34b6:	50 91 05 20 	lds	r21, 0x2005
    34ba:	24 1b       	sub	r18, r20
    34bc:	35 0b       	sbc	r19, r21
    34be:	e0 91 a5 23 	lds	r30, 0x23A5
    34c2:	f0 91 a6 23 	lds	r31, 0x23A6
    34c6:	e2 17       	cp	r30, r18
    34c8:	f3 07       	cpc	r31, r19
    34ca:	a0 f4       	brcc	.+40     	; 0x34f4 <malloc+0x124>
    34cc:	2e 1b       	sub	r18, r30
    34ce:	3f 0b       	sbc	r19, r31
    34d0:	28 17       	cp	r18, r24
    34d2:	39 07       	cpc	r19, r25
    34d4:	78 f0       	brcs	.+30     	; 0x34f4 <malloc+0x124>
    34d6:	ac 01       	movw	r20, r24
    34d8:	4e 5f       	subi	r20, 0xFE	; 254
    34da:	5f 4f       	sbci	r21, 0xFF	; 255
    34dc:	24 17       	cp	r18, r20
    34de:	35 07       	cpc	r19, r21
    34e0:	48 f0       	brcs	.+18     	; 0x34f4 <malloc+0x124>
    34e2:	4e 0f       	add	r20, r30
    34e4:	5f 1f       	adc	r21, r31
    34e6:	40 93 a5 23 	sts	0x23A5, r20
    34ea:	50 93 a6 23 	sts	0x23A6, r21
    34ee:	81 93       	st	Z+, r24
    34f0:	91 93       	st	Z+, r25
    34f2:	02 c0       	rjmp	.+4      	; 0x34f8 <malloc+0x128>
    34f4:	e0 e0       	ldi	r30, 0x00	; 0
    34f6:	f0 e0       	ldi	r31, 0x00	; 0
    34f8:	cf 01       	movw	r24, r30
    34fa:	df 91       	pop	r29
    34fc:	cf 91       	pop	r28
    34fe:	08 95       	ret

00003500 <free>:
    3500:	cf 93       	push	r28
    3502:	df 93       	push	r29
    3504:	00 97       	sbiw	r24, 0x00	; 0
    3506:	09 f4       	brne	.+2      	; 0x350a <free+0xa>
    3508:	87 c0       	rjmp	.+270    	; 0x3618 <free+0x118>
    350a:	fc 01       	movw	r30, r24
    350c:	32 97       	sbiw	r30, 0x02	; 2
    350e:	12 82       	std	Z+2, r1	; 0x02
    3510:	13 82       	std	Z+3, r1	; 0x03
    3512:	c0 91 a7 23 	lds	r28, 0x23A7
    3516:	d0 91 a8 23 	lds	r29, 0x23A8
    351a:	20 97       	sbiw	r28, 0x00	; 0
    351c:	81 f4       	brne	.+32     	; 0x353e <free+0x3e>
    351e:	20 81       	ld	r18, Z
    3520:	31 81       	ldd	r19, Z+1	; 0x01
    3522:	28 0f       	add	r18, r24
    3524:	39 1f       	adc	r19, r25
    3526:	80 91 a5 23 	lds	r24, 0x23A5
    352a:	90 91 a6 23 	lds	r25, 0x23A6
    352e:	82 17       	cp	r24, r18
    3530:	93 07       	cpc	r25, r19
    3532:	79 f5       	brne	.+94     	; 0x3592 <free+0x92>
    3534:	e0 93 a5 23 	sts	0x23A5, r30
    3538:	f0 93 a6 23 	sts	0x23A6, r31
    353c:	6d c0       	rjmp	.+218    	; 0x3618 <free+0x118>
    353e:	de 01       	movw	r26, r28
    3540:	20 e0       	ldi	r18, 0x00	; 0
    3542:	30 e0       	ldi	r19, 0x00	; 0
    3544:	ae 17       	cp	r26, r30
    3546:	bf 07       	cpc	r27, r31
    3548:	50 f4       	brcc	.+20     	; 0x355e <free+0x5e>
    354a:	12 96       	adiw	r26, 0x02	; 2
    354c:	4d 91       	ld	r20, X+
    354e:	5c 91       	ld	r21, X
    3550:	13 97       	sbiw	r26, 0x03	; 3
    3552:	9d 01       	movw	r18, r26
    3554:	41 15       	cp	r20, r1
    3556:	51 05       	cpc	r21, r1
    3558:	09 f1       	breq	.+66     	; 0x359c <free+0x9c>
    355a:	da 01       	movw	r26, r20
    355c:	f3 cf       	rjmp	.-26     	; 0x3544 <free+0x44>
    355e:	a2 83       	std	Z+2, r26	; 0x02
    3560:	b3 83       	std	Z+3, r27	; 0x03
    3562:	40 81       	ld	r20, Z
    3564:	51 81       	ldd	r21, Z+1	; 0x01
    3566:	84 0f       	add	r24, r20
    3568:	95 1f       	adc	r25, r21
    356a:	8a 17       	cp	r24, r26
    356c:	9b 07       	cpc	r25, r27
    356e:	71 f4       	brne	.+28     	; 0x358c <free+0x8c>
    3570:	8d 91       	ld	r24, X+
    3572:	9c 91       	ld	r25, X
    3574:	11 97       	sbiw	r26, 0x01	; 1
    3576:	84 0f       	add	r24, r20
    3578:	95 1f       	adc	r25, r21
    357a:	02 96       	adiw	r24, 0x02	; 2
    357c:	80 83       	st	Z, r24
    357e:	91 83       	std	Z+1, r25	; 0x01
    3580:	12 96       	adiw	r26, 0x02	; 2
    3582:	8d 91       	ld	r24, X+
    3584:	9c 91       	ld	r25, X
    3586:	13 97       	sbiw	r26, 0x03	; 3
    3588:	82 83       	std	Z+2, r24	; 0x02
    358a:	93 83       	std	Z+3, r25	; 0x03
    358c:	21 15       	cp	r18, r1
    358e:	31 05       	cpc	r19, r1
    3590:	29 f4       	brne	.+10     	; 0x359c <free+0x9c>
    3592:	e0 93 a7 23 	sts	0x23A7, r30
    3596:	f0 93 a8 23 	sts	0x23A8, r31
    359a:	3e c0       	rjmp	.+124    	; 0x3618 <free+0x118>
    359c:	d9 01       	movw	r26, r18
    359e:	12 96       	adiw	r26, 0x02	; 2
    35a0:	ed 93       	st	X+, r30
    35a2:	fc 93       	st	X, r31
    35a4:	13 97       	sbiw	r26, 0x03	; 3
    35a6:	4d 91       	ld	r20, X+
    35a8:	5d 91       	ld	r21, X+
    35aa:	a4 0f       	add	r26, r20
    35ac:	b5 1f       	adc	r27, r21
    35ae:	ea 17       	cp	r30, r26
    35b0:	fb 07       	cpc	r31, r27
    35b2:	79 f4       	brne	.+30     	; 0x35d2 <free+0xd2>
    35b4:	80 81       	ld	r24, Z
    35b6:	91 81       	ldd	r25, Z+1	; 0x01
    35b8:	84 0f       	add	r24, r20
    35ba:	95 1f       	adc	r25, r21
    35bc:	02 96       	adiw	r24, 0x02	; 2
    35be:	d9 01       	movw	r26, r18
    35c0:	8d 93       	st	X+, r24
    35c2:	9c 93       	st	X, r25
    35c4:	11 97       	sbiw	r26, 0x01	; 1
    35c6:	82 81       	ldd	r24, Z+2	; 0x02
    35c8:	93 81       	ldd	r25, Z+3	; 0x03
    35ca:	12 96       	adiw	r26, 0x02	; 2
    35cc:	8d 93       	st	X+, r24
    35ce:	9c 93       	st	X, r25
    35d0:	13 97       	sbiw	r26, 0x03	; 3
    35d2:	e0 e0       	ldi	r30, 0x00	; 0
    35d4:	f0 e0       	ldi	r31, 0x00	; 0
    35d6:	8a 81       	ldd	r24, Y+2	; 0x02
    35d8:	9b 81       	ldd	r25, Y+3	; 0x03
    35da:	00 97       	sbiw	r24, 0x00	; 0
    35dc:	19 f0       	breq	.+6      	; 0x35e4 <free+0xe4>
    35de:	fe 01       	movw	r30, r28
    35e0:	ec 01       	movw	r28, r24
    35e2:	f9 cf       	rjmp	.-14     	; 0x35d6 <free+0xd6>
    35e4:	ce 01       	movw	r24, r28
    35e6:	02 96       	adiw	r24, 0x02	; 2
    35e8:	28 81       	ld	r18, Y
    35ea:	39 81       	ldd	r19, Y+1	; 0x01
    35ec:	82 0f       	add	r24, r18
    35ee:	93 1f       	adc	r25, r19
    35f0:	20 91 a5 23 	lds	r18, 0x23A5
    35f4:	30 91 a6 23 	lds	r19, 0x23A6
    35f8:	28 17       	cp	r18, r24
    35fa:	39 07       	cpc	r19, r25
    35fc:	69 f4       	brne	.+26     	; 0x3618 <free+0x118>
    35fe:	30 97       	sbiw	r30, 0x00	; 0
    3600:	29 f4       	brne	.+10     	; 0x360c <free+0x10c>
    3602:	10 92 a7 23 	sts	0x23A7, r1
    3606:	10 92 a8 23 	sts	0x23A8, r1
    360a:	02 c0       	rjmp	.+4      	; 0x3610 <free+0x110>
    360c:	12 82       	std	Z+2, r1	; 0x02
    360e:	13 82       	std	Z+3, r1	; 0x03
    3610:	c0 93 a5 23 	sts	0x23A5, r28
    3614:	d0 93 a6 23 	sts	0x23A6, r29
    3618:	df 91       	pop	r29
    361a:	cf 91       	pop	r28
    361c:	08 95       	ret

0000361e <memcpy>:
    361e:	fb 01       	movw	r30, r22
    3620:	dc 01       	movw	r26, r24
    3622:	02 c0       	rjmp	.+4      	; 0x3628 <memcpy+0xa>
    3624:	01 90       	ld	r0, Z+
    3626:	0d 92       	st	X+, r0
    3628:	41 50       	subi	r20, 0x01	; 1
    362a:	50 40       	sbci	r21, 0x00	; 0
    362c:	d8 f7       	brcc	.-10     	; 0x3624 <memcpy+0x6>
    362e:	08 95       	ret

00003630 <snprintf>:
    3630:	0f 93       	push	r16
    3632:	1f 93       	push	r17
    3634:	cf 93       	push	r28
    3636:	df 93       	push	r29
    3638:	cd b7       	in	r28, 0x3d	; 61
    363a:	de b7       	in	r29, 0x3e	; 62
    363c:	2e 97       	sbiw	r28, 0x0e	; 14
    363e:	cd bf       	out	0x3d, r28	; 61
    3640:	de bf       	out	0x3e, r29	; 62
    3642:	0e 89       	ldd	r16, Y+22	; 0x16
    3644:	1f 89       	ldd	r17, Y+23	; 0x17
    3646:	88 8d       	ldd	r24, Y+24	; 0x18
    3648:	99 8d       	ldd	r25, Y+25	; 0x19
    364a:	26 e0       	ldi	r18, 0x06	; 6
    364c:	2c 83       	std	Y+4, r18	; 0x04
    364e:	09 83       	std	Y+1, r16	; 0x01
    3650:	1a 83       	std	Y+2, r17	; 0x02
    3652:	97 ff       	sbrs	r25, 7
    3654:	02 c0       	rjmp	.+4      	; 0x365a <snprintf+0x2a>
    3656:	80 e0       	ldi	r24, 0x00	; 0
    3658:	90 e8       	ldi	r25, 0x80	; 128
    365a:	01 97       	sbiw	r24, 0x01	; 1
    365c:	8d 83       	std	Y+5, r24	; 0x05
    365e:	9e 83       	std	Y+6, r25	; 0x06
    3660:	ae 01       	movw	r20, r28
    3662:	44 5e       	subi	r20, 0xE4	; 228
    3664:	5f 4f       	sbci	r21, 0xFF	; 255
    3666:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3668:	7b 8d       	ldd	r23, Y+27	; 0x1b
    366a:	ce 01       	movw	r24, r28
    366c:	01 96       	adiw	r24, 0x01	; 1
    366e:	16 d0       	rcall	.+44     	; 0x369c <vfprintf>
    3670:	4d 81       	ldd	r20, Y+5	; 0x05
    3672:	5e 81       	ldd	r21, Y+6	; 0x06
    3674:	57 fd       	sbrc	r21, 7
    3676:	0a c0       	rjmp	.+20     	; 0x368c <snprintf+0x5c>
    3678:	2f 81       	ldd	r18, Y+7	; 0x07
    367a:	38 85       	ldd	r19, Y+8	; 0x08
    367c:	42 17       	cp	r20, r18
    367e:	53 07       	cpc	r21, r19
    3680:	0c f4       	brge	.+2      	; 0x3684 <snprintf+0x54>
    3682:	9a 01       	movw	r18, r20
    3684:	f8 01       	movw	r30, r16
    3686:	e2 0f       	add	r30, r18
    3688:	f3 1f       	adc	r31, r19
    368a:	10 82       	st	Z, r1
    368c:	2e 96       	adiw	r28, 0x0e	; 14
    368e:	cd bf       	out	0x3d, r28	; 61
    3690:	de bf       	out	0x3e, r29	; 62
    3692:	df 91       	pop	r29
    3694:	cf 91       	pop	r28
    3696:	1f 91       	pop	r17
    3698:	0f 91       	pop	r16
    369a:	08 95       	ret

0000369c <vfprintf>:
    369c:	2f 92       	push	r2
    369e:	3f 92       	push	r3
    36a0:	4f 92       	push	r4
    36a2:	5f 92       	push	r5
    36a4:	6f 92       	push	r6
    36a6:	7f 92       	push	r7
    36a8:	8f 92       	push	r8
    36aa:	9f 92       	push	r9
    36ac:	af 92       	push	r10
    36ae:	bf 92       	push	r11
    36b0:	cf 92       	push	r12
    36b2:	df 92       	push	r13
    36b4:	ef 92       	push	r14
    36b6:	ff 92       	push	r15
    36b8:	0f 93       	push	r16
    36ba:	1f 93       	push	r17
    36bc:	cf 93       	push	r28
    36be:	df 93       	push	r29
    36c0:	cd b7       	in	r28, 0x3d	; 61
    36c2:	de b7       	in	r29, 0x3e	; 62
    36c4:	2c 97       	sbiw	r28, 0x0c	; 12
    36c6:	cd bf       	out	0x3d, r28	; 61
    36c8:	de bf       	out	0x3e, r29	; 62
    36ca:	7c 01       	movw	r14, r24
    36cc:	6b 01       	movw	r12, r22
    36ce:	8a 01       	movw	r16, r20
    36d0:	fc 01       	movw	r30, r24
    36d2:	16 82       	std	Z+6, r1	; 0x06
    36d4:	17 82       	std	Z+7, r1	; 0x07
    36d6:	83 81       	ldd	r24, Z+3	; 0x03
    36d8:	81 ff       	sbrs	r24, 1
    36da:	b0 c1       	rjmp	.+864    	; 0x3a3c <vfprintf+0x3a0>
    36dc:	ce 01       	movw	r24, r28
    36de:	01 96       	adiw	r24, 0x01	; 1
    36e0:	4c 01       	movw	r8, r24
    36e2:	f7 01       	movw	r30, r14
    36e4:	93 81       	ldd	r25, Z+3	; 0x03
    36e6:	f6 01       	movw	r30, r12
    36e8:	93 fd       	sbrc	r25, 3
    36ea:	85 91       	lpm	r24, Z+
    36ec:	93 ff       	sbrs	r25, 3
    36ee:	81 91       	ld	r24, Z+
    36f0:	6f 01       	movw	r12, r30
    36f2:	88 23       	and	r24, r24
    36f4:	09 f4       	brne	.+2      	; 0x36f8 <vfprintf+0x5c>
    36f6:	9e c1       	rjmp	.+828    	; 0x3a34 <vfprintf+0x398>
    36f8:	85 32       	cpi	r24, 0x25	; 37
    36fa:	39 f4       	brne	.+14     	; 0x370a <vfprintf+0x6e>
    36fc:	93 fd       	sbrc	r25, 3
    36fe:	85 91       	lpm	r24, Z+
    3700:	93 ff       	sbrs	r25, 3
    3702:	81 91       	ld	r24, Z+
    3704:	6f 01       	movw	r12, r30
    3706:	85 32       	cpi	r24, 0x25	; 37
    3708:	21 f4       	brne	.+8      	; 0x3712 <vfprintf+0x76>
    370a:	b7 01       	movw	r22, r14
    370c:	90 e0       	ldi	r25, 0x00	; 0
    370e:	c4 d1       	rcall	.+904    	; 0x3a98 <fputc>
    3710:	e8 cf       	rjmp	.-48     	; 0x36e2 <vfprintf+0x46>
    3712:	51 2c       	mov	r5, r1
    3714:	31 2c       	mov	r3, r1
    3716:	20 e0       	ldi	r18, 0x00	; 0
    3718:	20 32       	cpi	r18, 0x20	; 32
    371a:	a0 f4       	brcc	.+40     	; 0x3744 <vfprintf+0xa8>
    371c:	8b 32       	cpi	r24, 0x2B	; 43
    371e:	69 f0       	breq	.+26     	; 0x373a <vfprintf+0x9e>
    3720:	30 f4       	brcc	.+12     	; 0x372e <vfprintf+0x92>
    3722:	80 32       	cpi	r24, 0x20	; 32
    3724:	59 f0       	breq	.+22     	; 0x373c <vfprintf+0xa0>
    3726:	83 32       	cpi	r24, 0x23	; 35
    3728:	69 f4       	brne	.+26     	; 0x3744 <vfprintf+0xa8>
    372a:	20 61       	ori	r18, 0x10	; 16
    372c:	2c c0       	rjmp	.+88     	; 0x3786 <vfprintf+0xea>
    372e:	8d 32       	cpi	r24, 0x2D	; 45
    3730:	39 f0       	breq	.+14     	; 0x3740 <vfprintf+0xa4>
    3732:	80 33       	cpi	r24, 0x30	; 48
    3734:	39 f4       	brne	.+14     	; 0x3744 <vfprintf+0xa8>
    3736:	21 60       	ori	r18, 0x01	; 1
    3738:	26 c0       	rjmp	.+76     	; 0x3786 <vfprintf+0xea>
    373a:	22 60       	ori	r18, 0x02	; 2
    373c:	24 60       	ori	r18, 0x04	; 4
    373e:	23 c0       	rjmp	.+70     	; 0x3786 <vfprintf+0xea>
    3740:	28 60       	ori	r18, 0x08	; 8
    3742:	21 c0       	rjmp	.+66     	; 0x3786 <vfprintf+0xea>
    3744:	27 fd       	sbrc	r18, 7
    3746:	27 c0       	rjmp	.+78     	; 0x3796 <vfprintf+0xfa>
    3748:	30 ed       	ldi	r19, 0xD0	; 208
    374a:	38 0f       	add	r19, r24
    374c:	3a 30       	cpi	r19, 0x0A	; 10
    374e:	78 f4       	brcc	.+30     	; 0x376e <vfprintf+0xd2>
    3750:	26 ff       	sbrs	r18, 6
    3752:	06 c0       	rjmp	.+12     	; 0x3760 <vfprintf+0xc4>
    3754:	fa e0       	ldi	r31, 0x0A	; 10
    3756:	5f 9e       	mul	r5, r31
    3758:	30 0d       	add	r19, r0
    375a:	11 24       	eor	r1, r1
    375c:	53 2e       	mov	r5, r19
    375e:	13 c0       	rjmp	.+38     	; 0x3786 <vfprintf+0xea>
    3760:	8a e0       	ldi	r24, 0x0A	; 10
    3762:	38 9e       	mul	r3, r24
    3764:	30 0d       	add	r19, r0
    3766:	11 24       	eor	r1, r1
    3768:	33 2e       	mov	r3, r19
    376a:	20 62       	ori	r18, 0x20	; 32
    376c:	0c c0       	rjmp	.+24     	; 0x3786 <vfprintf+0xea>
    376e:	8e 32       	cpi	r24, 0x2E	; 46
    3770:	21 f4       	brne	.+8      	; 0x377a <vfprintf+0xde>
    3772:	26 fd       	sbrc	r18, 6
    3774:	5f c1       	rjmp	.+702    	; 0x3a34 <vfprintf+0x398>
    3776:	20 64       	ori	r18, 0x40	; 64
    3778:	06 c0       	rjmp	.+12     	; 0x3786 <vfprintf+0xea>
    377a:	8c 36       	cpi	r24, 0x6C	; 108
    377c:	11 f4       	brne	.+4      	; 0x3782 <vfprintf+0xe6>
    377e:	20 68       	ori	r18, 0x80	; 128
    3780:	02 c0       	rjmp	.+4      	; 0x3786 <vfprintf+0xea>
    3782:	88 36       	cpi	r24, 0x68	; 104
    3784:	41 f4       	brne	.+16     	; 0x3796 <vfprintf+0xfa>
    3786:	f6 01       	movw	r30, r12
    3788:	93 fd       	sbrc	r25, 3
    378a:	85 91       	lpm	r24, Z+
    378c:	93 ff       	sbrs	r25, 3
    378e:	81 91       	ld	r24, Z+
    3790:	6f 01       	movw	r12, r30
    3792:	81 11       	cpse	r24, r1
    3794:	c1 cf       	rjmp	.-126    	; 0x3718 <vfprintf+0x7c>
    3796:	98 2f       	mov	r25, r24
    3798:	9f 7d       	andi	r25, 0xDF	; 223
    379a:	95 54       	subi	r25, 0x45	; 69
    379c:	93 30       	cpi	r25, 0x03	; 3
    379e:	28 f4       	brcc	.+10     	; 0x37aa <vfprintf+0x10e>
    37a0:	0c 5f       	subi	r16, 0xFC	; 252
    37a2:	1f 4f       	sbci	r17, 0xFF	; 255
    37a4:	ff e3       	ldi	r31, 0x3F	; 63
    37a6:	f9 83       	std	Y+1, r31	; 0x01
    37a8:	0d c0       	rjmp	.+26     	; 0x37c4 <vfprintf+0x128>
    37aa:	83 36       	cpi	r24, 0x63	; 99
    37ac:	31 f0       	breq	.+12     	; 0x37ba <vfprintf+0x11e>
    37ae:	83 37       	cpi	r24, 0x73	; 115
    37b0:	71 f0       	breq	.+28     	; 0x37ce <vfprintf+0x132>
    37b2:	83 35       	cpi	r24, 0x53	; 83
    37b4:	09 f0       	breq	.+2      	; 0x37b8 <vfprintf+0x11c>
    37b6:	57 c0       	rjmp	.+174    	; 0x3866 <vfprintf+0x1ca>
    37b8:	21 c0       	rjmp	.+66     	; 0x37fc <vfprintf+0x160>
    37ba:	f8 01       	movw	r30, r16
    37bc:	80 81       	ld	r24, Z
    37be:	89 83       	std	Y+1, r24	; 0x01
    37c0:	0e 5f       	subi	r16, 0xFE	; 254
    37c2:	1f 4f       	sbci	r17, 0xFF	; 255
    37c4:	44 24       	eor	r4, r4
    37c6:	43 94       	inc	r4
    37c8:	51 2c       	mov	r5, r1
    37ca:	54 01       	movw	r10, r8
    37cc:	14 c0       	rjmp	.+40     	; 0x37f6 <vfprintf+0x15a>
    37ce:	38 01       	movw	r6, r16
    37d0:	f2 e0       	ldi	r31, 0x02	; 2
    37d2:	6f 0e       	add	r6, r31
    37d4:	71 1c       	adc	r7, r1
    37d6:	f8 01       	movw	r30, r16
    37d8:	a0 80       	ld	r10, Z
    37da:	b1 80       	ldd	r11, Z+1	; 0x01
    37dc:	26 ff       	sbrs	r18, 6
    37de:	03 c0       	rjmp	.+6      	; 0x37e6 <vfprintf+0x14a>
    37e0:	65 2d       	mov	r22, r5
    37e2:	70 e0       	ldi	r23, 0x00	; 0
    37e4:	02 c0       	rjmp	.+4      	; 0x37ea <vfprintf+0x14e>
    37e6:	6f ef       	ldi	r22, 0xFF	; 255
    37e8:	7f ef       	ldi	r23, 0xFF	; 255
    37ea:	c5 01       	movw	r24, r10
    37ec:	2c 87       	std	Y+12, r18	; 0x0c
    37ee:	49 d1       	rcall	.+658    	; 0x3a82 <strnlen>
    37f0:	2c 01       	movw	r4, r24
    37f2:	83 01       	movw	r16, r6
    37f4:	2c 85       	ldd	r18, Y+12	; 0x0c
    37f6:	2f 77       	andi	r18, 0x7F	; 127
    37f8:	22 2e       	mov	r2, r18
    37fa:	16 c0       	rjmp	.+44     	; 0x3828 <vfprintf+0x18c>
    37fc:	38 01       	movw	r6, r16
    37fe:	f2 e0       	ldi	r31, 0x02	; 2
    3800:	6f 0e       	add	r6, r31
    3802:	71 1c       	adc	r7, r1
    3804:	f8 01       	movw	r30, r16
    3806:	a0 80       	ld	r10, Z
    3808:	b1 80       	ldd	r11, Z+1	; 0x01
    380a:	26 ff       	sbrs	r18, 6
    380c:	03 c0       	rjmp	.+6      	; 0x3814 <vfprintf+0x178>
    380e:	65 2d       	mov	r22, r5
    3810:	70 e0       	ldi	r23, 0x00	; 0
    3812:	02 c0       	rjmp	.+4      	; 0x3818 <vfprintf+0x17c>
    3814:	6f ef       	ldi	r22, 0xFF	; 255
    3816:	7f ef       	ldi	r23, 0xFF	; 255
    3818:	c5 01       	movw	r24, r10
    381a:	2c 87       	std	Y+12, r18	; 0x0c
    381c:	27 d1       	rcall	.+590    	; 0x3a6c <strnlen_P>
    381e:	2c 01       	movw	r4, r24
    3820:	2c 85       	ldd	r18, Y+12	; 0x0c
    3822:	20 68       	ori	r18, 0x80	; 128
    3824:	22 2e       	mov	r2, r18
    3826:	83 01       	movw	r16, r6
    3828:	23 fc       	sbrc	r2, 3
    382a:	19 c0       	rjmp	.+50     	; 0x385e <vfprintf+0x1c2>
    382c:	83 2d       	mov	r24, r3
    382e:	90 e0       	ldi	r25, 0x00	; 0
    3830:	48 16       	cp	r4, r24
    3832:	59 06       	cpc	r5, r25
    3834:	a0 f4       	brcc	.+40     	; 0x385e <vfprintf+0x1c2>
    3836:	b7 01       	movw	r22, r14
    3838:	80 e2       	ldi	r24, 0x20	; 32
    383a:	90 e0       	ldi	r25, 0x00	; 0
    383c:	2d d1       	rcall	.+602    	; 0x3a98 <fputc>
    383e:	3a 94       	dec	r3
    3840:	f5 cf       	rjmp	.-22     	; 0x382c <vfprintf+0x190>
    3842:	f5 01       	movw	r30, r10
    3844:	27 fc       	sbrc	r2, 7
    3846:	85 91       	lpm	r24, Z+
    3848:	27 fe       	sbrs	r2, 7
    384a:	81 91       	ld	r24, Z+
    384c:	5f 01       	movw	r10, r30
    384e:	b7 01       	movw	r22, r14
    3850:	90 e0       	ldi	r25, 0x00	; 0
    3852:	22 d1       	rcall	.+580    	; 0x3a98 <fputc>
    3854:	31 10       	cpse	r3, r1
    3856:	3a 94       	dec	r3
    3858:	f1 e0       	ldi	r31, 0x01	; 1
    385a:	4f 1a       	sub	r4, r31
    385c:	51 08       	sbc	r5, r1
    385e:	41 14       	cp	r4, r1
    3860:	51 04       	cpc	r5, r1
    3862:	79 f7       	brne	.-34     	; 0x3842 <vfprintf+0x1a6>
    3864:	de c0       	rjmp	.+444    	; 0x3a22 <vfprintf+0x386>
    3866:	84 36       	cpi	r24, 0x64	; 100
    3868:	11 f0       	breq	.+4      	; 0x386e <vfprintf+0x1d2>
    386a:	89 36       	cpi	r24, 0x69	; 105
    386c:	31 f5       	brne	.+76     	; 0x38ba <vfprintf+0x21e>
    386e:	f8 01       	movw	r30, r16
    3870:	27 ff       	sbrs	r18, 7
    3872:	07 c0       	rjmp	.+14     	; 0x3882 <vfprintf+0x1e6>
    3874:	60 81       	ld	r22, Z
    3876:	71 81       	ldd	r23, Z+1	; 0x01
    3878:	82 81       	ldd	r24, Z+2	; 0x02
    387a:	93 81       	ldd	r25, Z+3	; 0x03
    387c:	0c 5f       	subi	r16, 0xFC	; 252
    387e:	1f 4f       	sbci	r17, 0xFF	; 255
    3880:	08 c0       	rjmp	.+16     	; 0x3892 <vfprintf+0x1f6>
    3882:	60 81       	ld	r22, Z
    3884:	71 81       	ldd	r23, Z+1	; 0x01
    3886:	88 27       	eor	r24, r24
    3888:	77 fd       	sbrc	r23, 7
    388a:	80 95       	com	r24
    388c:	98 2f       	mov	r25, r24
    388e:	0e 5f       	subi	r16, 0xFE	; 254
    3890:	1f 4f       	sbci	r17, 0xFF	; 255
    3892:	2f 76       	andi	r18, 0x6F	; 111
    3894:	b2 2e       	mov	r11, r18
    3896:	97 ff       	sbrs	r25, 7
    3898:	09 c0       	rjmp	.+18     	; 0x38ac <vfprintf+0x210>
    389a:	90 95       	com	r25
    389c:	80 95       	com	r24
    389e:	70 95       	com	r23
    38a0:	61 95       	neg	r22
    38a2:	7f 4f       	sbci	r23, 0xFF	; 255
    38a4:	8f 4f       	sbci	r24, 0xFF	; 255
    38a6:	9f 4f       	sbci	r25, 0xFF	; 255
    38a8:	20 68       	ori	r18, 0x80	; 128
    38aa:	b2 2e       	mov	r11, r18
    38ac:	2a e0       	ldi	r18, 0x0A	; 10
    38ae:	30 e0       	ldi	r19, 0x00	; 0
    38b0:	a4 01       	movw	r20, r8
    38b2:	24 d1       	rcall	.+584    	; 0x3afc <__ultoa_invert>
    38b4:	a8 2e       	mov	r10, r24
    38b6:	a8 18       	sub	r10, r8
    38b8:	43 c0       	rjmp	.+134    	; 0x3940 <vfprintf+0x2a4>
    38ba:	85 37       	cpi	r24, 0x75	; 117
    38bc:	29 f4       	brne	.+10     	; 0x38c8 <vfprintf+0x22c>
    38be:	2f 7e       	andi	r18, 0xEF	; 239
    38c0:	b2 2e       	mov	r11, r18
    38c2:	2a e0       	ldi	r18, 0x0A	; 10
    38c4:	30 e0       	ldi	r19, 0x00	; 0
    38c6:	25 c0       	rjmp	.+74     	; 0x3912 <vfprintf+0x276>
    38c8:	f2 2f       	mov	r31, r18
    38ca:	f9 7f       	andi	r31, 0xF9	; 249
    38cc:	bf 2e       	mov	r11, r31
    38ce:	8f 36       	cpi	r24, 0x6F	; 111
    38d0:	c1 f0       	breq	.+48     	; 0x3902 <vfprintf+0x266>
    38d2:	18 f4       	brcc	.+6      	; 0x38da <vfprintf+0x23e>
    38d4:	88 35       	cpi	r24, 0x58	; 88
    38d6:	79 f0       	breq	.+30     	; 0x38f6 <vfprintf+0x25a>
    38d8:	ad c0       	rjmp	.+346    	; 0x3a34 <vfprintf+0x398>
    38da:	80 37       	cpi	r24, 0x70	; 112
    38dc:	19 f0       	breq	.+6      	; 0x38e4 <vfprintf+0x248>
    38de:	88 37       	cpi	r24, 0x78	; 120
    38e0:	21 f0       	breq	.+8      	; 0x38ea <vfprintf+0x24e>
    38e2:	a8 c0       	rjmp	.+336    	; 0x3a34 <vfprintf+0x398>
    38e4:	2f 2f       	mov	r18, r31
    38e6:	20 61       	ori	r18, 0x10	; 16
    38e8:	b2 2e       	mov	r11, r18
    38ea:	b4 fe       	sbrs	r11, 4
    38ec:	0d c0       	rjmp	.+26     	; 0x3908 <vfprintf+0x26c>
    38ee:	8b 2d       	mov	r24, r11
    38f0:	84 60       	ori	r24, 0x04	; 4
    38f2:	b8 2e       	mov	r11, r24
    38f4:	09 c0       	rjmp	.+18     	; 0x3908 <vfprintf+0x26c>
    38f6:	24 ff       	sbrs	r18, 4
    38f8:	0a c0       	rjmp	.+20     	; 0x390e <vfprintf+0x272>
    38fa:	9f 2f       	mov	r25, r31
    38fc:	96 60       	ori	r25, 0x06	; 6
    38fe:	b9 2e       	mov	r11, r25
    3900:	06 c0       	rjmp	.+12     	; 0x390e <vfprintf+0x272>
    3902:	28 e0       	ldi	r18, 0x08	; 8
    3904:	30 e0       	ldi	r19, 0x00	; 0
    3906:	05 c0       	rjmp	.+10     	; 0x3912 <vfprintf+0x276>
    3908:	20 e1       	ldi	r18, 0x10	; 16
    390a:	30 e0       	ldi	r19, 0x00	; 0
    390c:	02 c0       	rjmp	.+4      	; 0x3912 <vfprintf+0x276>
    390e:	20 e1       	ldi	r18, 0x10	; 16
    3910:	32 e0       	ldi	r19, 0x02	; 2
    3912:	f8 01       	movw	r30, r16
    3914:	b7 fe       	sbrs	r11, 7
    3916:	07 c0       	rjmp	.+14     	; 0x3926 <vfprintf+0x28a>
    3918:	60 81       	ld	r22, Z
    391a:	71 81       	ldd	r23, Z+1	; 0x01
    391c:	82 81       	ldd	r24, Z+2	; 0x02
    391e:	93 81       	ldd	r25, Z+3	; 0x03
    3920:	0c 5f       	subi	r16, 0xFC	; 252
    3922:	1f 4f       	sbci	r17, 0xFF	; 255
    3924:	06 c0       	rjmp	.+12     	; 0x3932 <vfprintf+0x296>
    3926:	60 81       	ld	r22, Z
    3928:	71 81       	ldd	r23, Z+1	; 0x01
    392a:	80 e0       	ldi	r24, 0x00	; 0
    392c:	90 e0       	ldi	r25, 0x00	; 0
    392e:	0e 5f       	subi	r16, 0xFE	; 254
    3930:	1f 4f       	sbci	r17, 0xFF	; 255
    3932:	a4 01       	movw	r20, r8
    3934:	e3 d0       	rcall	.+454    	; 0x3afc <__ultoa_invert>
    3936:	a8 2e       	mov	r10, r24
    3938:	a8 18       	sub	r10, r8
    393a:	fb 2d       	mov	r31, r11
    393c:	ff 77       	andi	r31, 0x7F	; 127
    393e:	bf 2e       	mov	r11, r31
    3940:	b6 fe       	sbrs	r11, 6
    3942:	0b c0       	rjmp	.+22     	; 0x395a <vfprintf+0x2be>
    3944:	2b 2d       	mov	r18, r11
    3946:	2e 7f       	andi	r18, 0xFE	; 254
    3948:	a5 14       	cp	r10, r5
    394a:	50 f4       	brcc	.+20     	; 0x3960 <vfprintf+0x2c4>
    394c:	b4 fe       	sbrs	r11, 4
    394e:	0a c0       	rjmp	.+20     	; 0x3964 <vfprintf+0x2c8>
    3950:	b2 fc       	sbrc	r11, 2
    3952:	08 c0       	rjmp	.+16     	; 0x3964 <vfprintf+0x2c8>
    3954:	2b 2d       	mov	r18, r11
    3956:	2e 7e       	andi	r18, 0xEE	; 238
    3958:	05 c0       	rjmp	.+10     	; 0x3964 <vfprintf+0x2c8>
    395a:	7a 2c       	mov	r7, r10
    395c:	2b 2d       	mov	r18, r11
    395e:	03 c0       	rjmp	.+6      	; 0x3966 <vfprintf+0x2ca>
    3960:	7a 2c       	mov	r7, r10
    3962:	01 c0       	rjmp	.+2      	; 0x3966 <vfprintf+0x2ca>
    3964:	75 2c       	mov	r7, r5
    3966:	24 ff       	sbrs	r18, 4
    3968:	0d c0       	rjmp	.+26     	; 0x3984 <vfprintf+0x2e8>
    396a:	fe 01       	movw	r30, r28
    396c:	ea 0d       	add	r30, r10
    396e:	f1 1d       	adc	r31, r1
    3970:	80 81       	ld	r24, Z
    3972:	80 33       	cpi	r24, 0x30	; 48
    3974:	11 f4       	brne	.+4      	; 0x397a <vfprintf+0x2de>
    3976:	29 7e       	andi	r18, 0xE9	; 233
    3978:	09 c0       	rjmp	.+18     	; 0x398c <vfprintf+0x2f0>
    397a:	22 ff       	sbrs	r18, 2
    397c:	06 c0       	rjmp	.+12     	; 0x398a <vfprintf+0x2ee>
    397e:	73 94       	inc	r7
    3980:	73 94       	inc	r7
    3982:	04 c0       	rjmp	.+8      	; 0x398c <vfprintf+0x2f0>
    3984:	82 2f       	mov	r24, r18
    3986:	86 78       	andi	r24, 0x86	; 134
    3988:	09 f0       	breq	.+2      	; 0x398c <vfprintf+0x2f0>
    398a:	73 94       	inc	r7
    398c:	23 fd       	sbrc	r18, 3
    398e:	12 c0       	rjmp	.+36     	; 0x39b4 <vfprintf+0x318>
    3990:	20 ff       	sbrs	r18, 0
    3992:	06 c0       	rjmp	.+12     	; 0x39a0 <vfprintf+0x304>
    3994:	5a 2c       	mov	r5, r10
    3996:	73 14       	cp	r7, r3
    3998:	18 f4       	brcc	.+6      	; 0x39a0 <vfprintf+0x304>
    399a:	53 0c       	add	r5, r3
    399c:	57 18       	sub	r5, r7
    399e:	73 2c       	mov	r7, r3
    39a0:	73 14       	cp	r7, r3
    39a2:	60 f4       	brcc	.+24     	; 0x39bc <vfprintf+0x320>
    39a4:	b7 01       	movw	r22, r14
    39a6:	80 e2       	ldi	r24, 0x20	; 32
    39a8:	90 e0       	ldi	r25, 0x00	; 0
    39aa:	2c 87       	std	Y+12, r18	; 0x0c
    39ac:	75 d0       	rcall	.+234    	; 0x3a98 <fputc>
    39ae:	73 94       	inc	r7
    39b0:	2c 85       	ldd	r18, Y+12	; 0x0c
    39b2:	f6 cf       	rjmp	.-20     	; 0x39a0 <vfprintf+0x304>
    39b4:	73 14       	cp	r7, r3
    39b6:	10 f4       	brcc	.+4      	; 0x39bc <vfprintf+0x320>
    39b8:	37 18       	sub	r3, r7
    39ba:	01 c0       	rjmp	.+2      	; 0x39be <vfprintf+0x322>
    39bc:	31 2c       	mov	r3, r1
    39be:	24 ff       	sbrs	r18, 4
    39c0:	11 c0       	rjmp	.+34     	; 0x39e4 <vfprintf+0x348>
    39c2:	b7 01       	movw	r22, r14
    39c4:	80 e3       	ldi	r24, 0x30	; 48
    39c6:	90 e0       	ldi	r25, 0x00	; 0
    39c8:	2c 87       	std	Y+12, r18	; 0x0c
    39ca:	66 d0       	rcall	.+204    	; 0x3a98 <fputc>
    39cc:	2c 85       	ldd	r18, Y+12	; 0x0c
    39ce:	22 ff       	sbrs	r18, 2
    39d0:	16 c0       	rjmp	.+44     	; 0x39fe <vfprintf+0x362>
    39d2:	21 ff       	sbrs	r18, 1
    39d4:	03 c0       	rjmp	.+6      	; 0x39dc <vfprintf+0x340>
    39d6:	88 e5       	ldi	r24, 0x58	; 88
    39d8:	90 e0       	ldi	r25, 0x00	; 0
    39da:	02 c0       	rjmp	.+4      	; 0x39e0 <vfprintf+0x344>
    39dc:	88 e7       	ldi	r24, 0x78	; 120
    39de:	90 e0       	ldi	r25, 0x00	; 0
    39e0:	b7 01       	movw	r22, r14
    39e2:	0c c0       	rjmp	.+24     	; 0x39fc <vfprintf+0x360>
    39e4:	82 2f       	mov	r24, r18
    39e6:	86 78       	andi	r24, 0x86	; 134
    39e8:	51 f0       	breq	.+20     	; 0x39fe <vfprintf+0x362>
    39ea:	21 fd       	sbrc	r18, 1
    39ec:	02 c0       	rjmp	.+4      	; 0x39f2 <vfprintf+0x356>
    39ee:	80 e2       	ldi	r24, 0x20	; 32
    39f0:	01 c0       	rjmp	.+2      	; 0x39f4 <vfprintf+0x358>
    39f2:	8b e2       	ldi	r24, 0x2B	; 43
    39f4:	27 fd       	sbrc	r18, 7
    39f6:	8d e2       	ldi	r24, 0x2D	; 45
    39f8:	b7 01       	movw	r22, r14
    39fa:	90 e0       	ldi	r25, 0x00	; 0
    39fc:	4d d0       	rcall	.+154    	; 0x3a98 <fputc>
    39fe:	a5 14       	cp	r10, r5
    3a00:	30 f4       	brcc	.+12     	; 0x3a0e <vfprintf+0x372>
    3a02:	b7 01       	movw	r22, r14
    3a04:	80 e3       	ldi	r24, 0x30	; 48
    3a06:	90 e0       	ldi	r25, 0x00	; 0
    3a08:	47 d0       	rcall	.+142    	; 0x3a98 <fputc>
    3a0a:	5a 94       	dec	r5
    3a0c:	f8 cf       	rjmp	.-16     	; 0x39fe <vfprintf+0x362>
    3a0e:	aa 94       	dec	r10
    3a10:	f4 01       	movw	r30, r8
    3a12:	ea 0d       	add	r30, r10
    3a14:	f1 1d       	adc	r31, r1
    3a16:	80 81       	ld	r24, Z
    3a18:	b7 01       	movw	r22, r14
    3a1a:	90 e0       	ldi	r25, 0x00	; 0
    3a1c:	3d d0       	rcall	.+122    	; 0x3a98 <fputc>
    3a1e:	a1 10       	cpse	r10, r1
    3a20:	f6 cf       	rjmp	.-20     	; 0x3a0e <vfprintf+0x372>
    3a22:	33 20       	and	r3, r3
    3a24:	09 f4       	brne	.+2      	; 0x3a28 <vfprintf+0x38c>
    3a26:	5d ce       	rjmp	.-838    	; 0x36e2 <vfprintf+0x46>
    3a28:	b7 01       	movw	r22, r14
    3a2a:	80 e2       	ldi	r24, 0x20	; 32
    3a2c:	90 e0       	ldi	r25, 0x00	; 0
    3a2e:	34 d0       	rcall	.+104    	; 0x3a98 <fputc>
    3a30:	3a 94       	dec	r3
    3a32:	f7 cf       	rjmp	.-18     	; 0x3a22 <vfprintf+0x386>
    3a34:	f7 01       	movw	r30, r14
    3a36:	86 81       	ldd	r24, Z+6	; 0x06
    3a38:	97 81       	ldd	r25, Z+7	; 0x07
    3a3a:	02 c0       	rjmp	.+4      	; 0x3a40 <vfprintf+0x3a4>
    3a3c:	8f ef       	ldi	r24, 0xFF	; 255
    3a3e:	9f ef       	ldi	r25, 0xFF	; 255
    3a40:	2c 96       	adiw	r28, 0x0c	; 12
    3a42:	cd bf       	out	0x3d, r28	; 61
    3a44:	de bf       	out	0x3e, r29	; 62
    3a46:	df 91       	pop	r29
    3a48:	cf 91       	pop	r28
    3a4a:	1f 91       	pop	r17
    3a4c:	0f 91       	pop	r16
    3a4e:	ff 90       	pop	r15
    3a50:	ef 90       	pop	r14
    3a52:	df 90       	pop	r13
    3a54:	cf 90       	pop	r12
    3a56:	bf 90       	pop	r11
    3a58:	af 90       	pop	r10
    3a5a:	9f 90       	pop	r9
    3a5c:	8f 90       	pop	r8
    3a5e:	7f 90       	pop	r7
    3a60:	6f 90       	pop	r6
    3a62:	5f 90       	pop	r5
    3a64:	4f 90       	pop	r4
    3a66:	3f 90       	pop	r3
    3a68:	2f 90       	pop	r2
    3a6a:	08 95       	ret

00003a6c <strnlen_P>:
    3a6c:	fc 01       	movw	r30, r24
    3a6e:	05 90       	lpm	r0, Z+
    3a70:	61 50       	subi	r22, 0x01	; 1
    3a72:	70 40       	sbci	r23, 0x00	; 0
    3a74:	01 10       	cpse	r0, r1
    3a76:	d8 f7       	brcc	.-10     	; 0x3a6e <strnlen_P+0x2>
    3a78:	80 95       	com	r24
    3a7a:	90 95       	com	r25
    3a7c:	8e 0f       	add	r24, r30
    3a7e:	9f 1f       	adc	r25, r31
    3a80:	08 95       	ret

00003a82 <strnlen>:
    3a82:	fc 01       	movw	r30, r24
    3a84:	61 50       	subi	r22, 0x01	; 1
    3a86:	70 40       	sbci	r23, 0x00	; 0
    3a88:	01 90       	ld	r0, Z+
    3a8a:	01 10       	cpse	r0, r1
    3a8c:	d8 f7       	brcc	.-10     	; 0x3a84 <strnlen+0x2>
    3a8e:	80 95       	com	r24
    3a90:	90 95       	com	r25
    3a92:	8e 0f       	add	r24, r30
    3a94:	9f 1f       	adc	r25, r31
    3a96:	08 95       	ret

00003a98 <fputc>:
    3a98:	0f 93       	push	r16
    3a9a:	1f 93       	push	r17
    3a9c:	cf 93       	push	r28
    3a9e:	df 93       	push	r29
    3aa0:	18 2f       	mov	r17, r24
    3aa2:	09 2f       	mov	r16, r25
    3aa4:	eb 01       	movw	r28, r22
    3aa6:	8b 81       	ldd	r24, Y+3	; 0x03
    3aa8:	81 fd       	sbrc	r24, 1
    3aaa:	03 c0       	rjmp	.+6      	; 0x3ab2 <fputc+0x1a>
    3aac:	8f ef       	ldi	r24, 0xFF	; 255
    3aae:	9f ef       	ldi	r25, 0xFF	; 255
    3ab0:	20 c0       	rjmp	.+64     	; 0x3af2 <fputc+0x5a>
    3ab2:	82 ff       	sbrs	r24, 2
    3ab4:	10 c0       	rjmp	.+32     	; 0x3ad6 <fputc+0x3e>
    3ab6:	4e 81       	ldd	r20, Y+6	; 0x06
    3ab8:	5f 81       	ldd	r21, Y+7	; 0x07
    3aba:	2c 81       	ldd	r18, Y+4	; 0x04
    3abc:	3d 81       	ldd	r19, Y+5	; 0x05
    3abe:	42 17       	cp	r20, r18
    3ac0:	53 07       	cpc	r21, r19
    3ac2:	7c f4       	brge	.+30     	; 0x3ae2 <fputc+0x4a>
    3ac4:	e8 81       	ld	r30, Y
    3ac6:	f9 81       	ldd	r31, Y+1	; 0x01
    3ac8:	9f 01       	movw	r18, r30
    3aca:	2f 5f       	subi	r18, 0xFF	; 255
    3acc:	3f 4f       	sbci	r19, 0xFF	; 255
    3ace:	28 83       	st	Y, r18
    3ad0:	39 83       	std	Y+1, r19	; 0x01
    3ad2:	10 83       	st	Z, r17
    3ad4:	06 c0       	rjmp	.+12     	; 0x3ae2 <fputc+0x4a>
    3ad6:	e8 85       	ldd	r30, Y+8	; 0x08
    3ad8:	f9 85       	ldd	r31, Y+9	; 0x09
    3ada:	81 2f       	mov	r24, r17
    3adc:	19 95       	eicall
    3ade:	89 2b       	or	r24, r25
    3ae0:	29 f7       	brne	.-54     	; 0x3aac <fputc+0x14>
    3ae2:	2e 81       	ldd	r18, Y+6	; 0x06
    3ae4:	3f 81       	ldd	r19, Y+7	; 0x07
    3ae6:	2f 5f       	subi	r18, 0xFF	; 255
    3ae8:	3f 4f       	sbci	r19, 0xFF	; 255
    3aea:	2e 83       	std	Y+6, r18	; 0x06
    3aec:	3f 83       	std	Y+7, r19	; 0x07
    3aee:	81 2f       	mov	r24, r17
    3af0:	90 2f       	mov	r25, r16
    3af2:	df 91       	pop	r29
    3af4:	cf 91       	pop	r28
    3af6:	1f 91       	pop	r17
    3af8:	0f 91       	pop	r16
    3afa:	08 95       	ret

00003afc <__ultoa_invert>:
    3afc:	fa 01       	movw	r30, r20
    3afe:	aa 27       	eor	r26, r26
    3b00:	28 30       	cpi	r18, 0x08	; 8
    3b02:	51 f1       	breq	.+84     	; 0x3b58 <__ultoa_invert+0x5c>
    3b04:	20 31       	cpi	r18, 0x10	; 16
    3b06:	81 f1       	breq	.+96     	; 0x3b68 <__ultoa_invert+0x6c>
    3b08:	e8 94       	clt
    3b0a:	6f 93       	push	r22
    3b0c:	6e 7f       	andi	r22, 0xFE	; 254
    3b0e:	6e 5f       	subi	r22, 0xFE	; 254
    3b10:	7f 4f       	sbci	r23, 0xFF	; 255
    3b12:	8f 4f       	sbci	r24, 0xFF	; 255
    3b14:	9f 4f       	sbci	r25, 0xFF	; 255
    3b16:	af 4f       	sbci	r26, 0xFF	; 255
    3b18:	b1 e0       	ldi	r27, 0x01	; 1
    3b1a:	3e d0       	rcall	.+124    	; 0x3b98 <__ultoa_invert+0x9c>
    3b1c:	b4 e0       	ldi	r27, 0x04	; 4
    3b1e:	3c d0       	rcall	.+120    	; 0x3b98 <__ultoa_invert+0x9c>
    3b20:	67 0f       	add	r22, r23
    3b22:	78 1f       	adc	r23, r24
    3b24:	89 1f       	adc	r24, r25
    3b26:	9a 1f       	adc	r25, r26
    3b28:	a1 1d       	adc	r26, r1
    3b2a:	68 0f       	add	r22, r24
    3b2c:	79 1f       	adc	r23, r25
    3b2e:	8a 1f       	adc	r24, r26
    3b30:	91 1d       	adc	r25, r1
    3b32:	a1 1d       	adc	r26, r1
    3b34:	6a 0f       	add	r22, r26
    3b36:	71 1d       	adc	r23, r1
    3b38:	81 1d       	adc	r24, r1
    3b3a:	91 1d       	adc	r25, r1
    3b3c:	a1 1d       	adc	r26, r1
    3b3e:	20 d0       	rcall	.+64     	; 0x3b80 <__ultoa_invert+0x84>
    3b40:	09 f4       	brne	.+2      	; 0x3b44 <__ultoa_invert+0x48>
    3b42:	68 94       	set
    3b44:	3f 91       	pop	r19
    3b46:	2a e0       	ldi	r18, 0x0A	; 10
    3b48:	26 9f       	mul	r18, r22
    3b4a:	11 24       	eor	r1, r1
    3b4c:	30 19       	sub	r19, r0
    3b4e:	30 5d       	subi	r19, 0xD0	; 208
    3b50:	31 93       	st	Z+, r19
    3b52:	de f6       	brtc	.-74     	; 0x3b0a <__ultoa_invert+0xe>
    3b54:	cf 01       	movw	r24, r30
    3b56:	08 95       	ret
    3b58:	46 2f       	mov	r20, r22
    3b5a:	47 70       	andi	r20, 0x07	; 7
    3b5c:	40 5d       	subi	r20, 0xD0	; 208
    3b5e:	41 93       	st	Z+, r20
    3b60:	b3 e0       	ldi	r27, 0x03	; 3
    3b62:	0f d0       	rcall	.+30     	; 0x3b82 <__ultoa_invert+0x86>
    3b64:	c9 f7       	brne	.-14     	; 0x3b58 <__ultoa_invert+0x5c>
    3b66:	f6 cf       	rjmp	.-20     	; 0x3b54 <__ultoa_invert+0x58>
    3b68:	46 2f       	mov	r20, r22
    3b6a:	4f 70       	andi	r20, 0x0F	; 15
    3b6c:	40 5d       	subi	r20, 0xD0	; 208
    3b6e:	4a 33       	cpi	r20, 0x3A	; 58
    3b70:	18 f0       	brcs	.+6      	; 0x3b78 <__ultoa_invert+0x7c>
    3b72:	49 5d       	subi	r20, 0xD9	; 217
    3b74:	31 fd       	sbrc	r19, 1
    3b76:	40 52       	subi	r20, 0x20	; 32
    3b78:	41 93       	st	Z+, r20
    3b7a:	02 d0       	rcall	.+4      	; 0x3b80 <__ultoa_invert+0x84>
    3b7c:	a9 f7       	brne	.-22     	; 0x3b68 <__ultoa_invert+0x6c>
    3b7e:	ea cf       	rjmp	.-44     	; 0x3b54 <__ultoa_invert+0x58>
    3b80:	b4 e0       	ldi	r27, 0x04	; 4
    3b82:	a6 95       	lsr	r26
    3b84:	97 95       	ror	r25
    3b86:	87 95       	ror	r24
    3b88:	77 95       	ror	r23
    3b8a:	67 95       	ror	r22
    3b8c:	ba 95       	dec	r27
    3b8e:	c9 f7       	brne	.-14     	; 0x3b82 <__ultoa_invert+0x86>
    3b90:	00 97       	sbiw	r24, 0x00	; 0
    3b92:	61 05       	cpc	r22, r1
    3b94:	71 05       	cpc	r23, r1
    3b96:	08 95       	ret
    3b98:	9b 01       	movw	r18, r22
    3b9a:	ac 01       	movw	r20, r24
    3b9c:	0a 2e       	mov	r0, r26
    3b9e:	06 94       	lsr	r0
    3ba0:	57 95       	ror	r21
    3ba2:	47 95       	ror	r20
    3ba4:	37 95       	ror	r19
    3ba6:	27 95       	ror	r18
    3ba8:	ba 95       	dec	r27
    3baa:	c9 f7       	brne	.-14     	; 0x3b9e <__ultoa_invert+0xa2>
    3bac:	62 0f       	add	r22, r18
    3bae:	73 1f       	adc	r23, r19
    3bb0:	84 1f       	adc	r24, r20
    3bb2:	95 1f       	adc	r25, r21
    3bb4:	a0 1d       	adc	r26, r0
    3bb6:	08 95       	ret

00003bb8 <_exit>:
    3bb8:	f8 94       	cli

00003bba <__stop_program>:
    3bba:	ff cf       	rjmp	.-2      	; 0x3bba <__stop_program>
